<Type Name="MemoryMappedFile" FullName="System.IO.MemoryMappedFiles.MemoryMappedFile">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a66a5dd4c90728e89b0d27733b7685923d2e2f64" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298822" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MemoryMappedFile : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryMappedFile extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryMappedFile&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryMappedFile : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un archivo asignado a la memoria.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un archivo asignado a memoria asigna el contenido de un archivo al espacio de direcciones lógico de una aplicación. Archivos asignados a memoria permiten a los programadores trabajar con archivos muy grandes porque memoria puede administrarse de forma simultánea y permiten el acceso completo y aleatorio a un archivo sin necesidad de operaciones de búsqueda. Archivos asignados a memoria también se pueden compartir entre varios procesos.  
  
 El <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> métodos crean un archivo asignado a memoria desde una ruta de acceso especificada o un <xref:System.IO.FileStream> de un archivo existente en el disco. Cambios se propagan automáticamente en el disco cuando no se ha asignado el archivo.  
  
 El <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> métodos crean un archivo asignado a memoria que no está asignado a un archivo existente en el disco; y son idóneos para crear memoria compartida para la comunicación entre procesos (IPC).  
  
 Un archivo asignado a memoria puede asociarse con un nombre opcional que permite que el archivo asignado a la memoria que puede compartirse con otros procesos. 
  
 Puede crear varias vistas del archivo asignado a memoria, incluidas las vistas de partes del archivo. Puede asignar la misma parte de un archivo a más de una dirección para crear memoria simultáneas. Para que dos vistas sigan siendo simultáneas, tienen que crearse a partir del mismo archivo asignado a memoria. Creación de dos asignaciones del mismo archivo con dos vistas no proporciona simultaneidad.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una vista asignada a memoria de una parte de un archivo muy grande y se manipula una parte de él.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromFile">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un archivo asignado a la memoria a partir de un archivo existente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo que se va asignar.</param>
        <summary>Crea un archivo asignado a la memoria a partir de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%2A> método para crear un archivo asignado a memoria y, a continuación, crea una vista asignada a la memoria a una parte de un archivo muy grande.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#1)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía, que solo contiene espacios en blanco, o bien, contiene uno o varios de los caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  -o bien- <paramref name="path" /> hace referencia a un dispositivo no válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene los permisos necesarios para el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo que se va asignar.</param>
        <param name="mode">Modo de acceso; debe ser <see cref="F:System.IO.FileMode.Open" />.</param>
        <summary>Crea un archivo asignado a la memoria que tiene el modo de acceso especificado de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria con el modo de acceso especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro pertenece al archivo de origen en el disco. Puede utilizar solo el <xref:System.IO.FileMode.Open> valor de enumeración para crear el archivo asignado a la memoria desde el archivo de origen en el disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía, que solo contiene espacios en blanco, o bien, contiene uno o varios de los caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  -o bien- <paramref name="path" /> hace referencia a un dispositivo no válido.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> o <see cref="F:System.IO.FileMode.Truncate" />.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.OpenOrCreate" /> y el archivo del disco no existe.  -o bien- Error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene los permisos necesarios para el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo que se va asignar.</param>
        <param name="mode">Modo de acceso; debe ser <see cref="F:System.IO.FileMode.Open" />.</param>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <summary>Crea un archivo asignado a la memoria que tiene el modo de acceso y el nombre especificados de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria con el nombre y el modo de acceso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro pertenece al archivo de origen en el disco. Puede utilizar solo el <xref:System.IO.FileMode.Open> valor de enumeración para crear el archivo asignado a la memoria desde el archivo de origen en el disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía, que solo contiene espacios en blanco, o bien, contiene uno o varios de los caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  -o bien- <paramref name="path" /> hace referencia a un dispositivo no válido.  -o bien- <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" /> o <see cref="F:System.IO.FileMode.Truncate" />.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.OpenOrCreate" /> y el archivo del disco no existe.  -o bien- Error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene los permisos necesarios para el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo que se va asignar.</param>
        <param name="mode">Modo de acceso: puede ser cualquiera de los valores de enumeración <see cref="T:System.IO.FileMode" /> excepto <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria. Especifique 0 para establecer la capacidad en el tamaño del archivo de disco.</param>
        <summary>Crea un archivo asignado a la memoria que tiene el modo de acceso, el nombre y la capacidad especificados de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro pertenece al archivo de origen en el disco.  
  
 Si `capacity` es mayor que el tamaño del archivo en disco, el archivo en disco aumenta para coincidir con la capacidad especificada aun cuando no se escriben datos en el archivo asignado a la memoria. Para evitar que esto suceda, especifique 0 (cero) para la capacidad de manera predeterminada, que establecerá internamente `capacity` al tamaño del archivo en disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> es una cadena vacía, que solo contiene espacios en blanco, o bien, contiene uno o varios de los caracteres no válidos definidos por el método <see cref="M:System.IO.Path.GetInvalidFileNameChars" />.  -o bien- <paramref name="path" /> hace referencia a un dispositivo no válido.  -o bien- <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor que cero.  -o bien- <paramref name="capacity" /> es menor que el tamaño de archivo (pero no es cero).  -o bien- <paramref name="capacity" /> es cero y el tamaño del archivo en disco también es cero.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene los permisos necesarios para el archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (string path, System.IO.FileMode mode, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(string path, valuetype System.IO.FileMode mode, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateFromFile (path As String, mode As FileMode, mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::String ^ path, System::IO::FileMode mode, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso al archivo que se va asignar.</param>
        <param name="mode">Modo de acceso: puede ser cualquiera de los valores de enumeración <see cref="T:System.IO.FileMode" /> excepto <see cref="F:System.IO.FileMode.Append" />.</param>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria. Especifique 0 para establecer la capacidad en el tamaño del archivo de disco.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria.</param>
        <summary>Crea un archivo asignado a la memoria que tiene el modo de acceso, el nombre, la capacidad y el tipo de acceso especificados de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro pertenece al archivo de origen en el disco.  
  
 Si `capacity` es mayor que el tamaño del archivo en disco, el archivo en disco aumenta para coincidir con la capacidad especificada aun cuando no se escriben datos en el archivo asignado a la memoria. Para evitar que esto suceda, especifique 0 (cero) para la capacidad de manera predeterminada, que establecerá internamente `capacity` al tamaño del archivo en disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> no es un valor permitido.  -o bien- <paramref name="path" /> especifica un archivo vacío.  -o bien- <paramref name="access" /> se ha especificado como <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> y la capacidad es mayor que el tamaño del archivo que indica <paramref name="path" />.  -o bien- <paramref name="mode" /> es <see cref="F:System.IO.FileMode.Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor que cero.  -o bien- <paramref name="capacity" /> es menor que el tamaño de archivo (pero no es cero).  -o bien- <paramref name="capacity" /> es cero y el tamaño del archivo en disco también es cero.  -o bien- <paramref name="access" /> no es un valor <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> definido.  -o bien- El tamaño del archivo que indica <paramref name="path" /> es mayor que <paramref name="capacity" />.</exception>
        <exception cref="T:System.IO.IOException">-o bien- Error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> supera la longitud máxima definida por el sistema operativo.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene los permisos necesarios para el archivo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">Secuencia de archivo del archivo existente.</param>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria. Especifique 0 para establecer la capacidad en el tamaño de <c>filestream</c>.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria.  Este parámetro no puede establecerse en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="inheritability">Uno de los valores de enumeración que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">Valor que indica si se va a cerrar la secuencia del archivo de origen cuando se elimine <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</param>
        <summary>Crea un archivo asignado a la memoria a partir de un archivo existente con el modo de acceso, el nombre, la herencia y la capacidad especificados.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es <see langword="null" /> o una cadena vacía.  -o bien- <paramref name="capacity" /> y la longitud del archivo son cero.  -o bien- <paramref name="access" /> se ha establecido en el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, que no está permitido.  -o bien- <paramref name="access" /> se ha establecido en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> y <paramref name="capacity" /> es mayor que la longitud de <see langword="filestream" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.  -o bien- <paramref name="capacity" /> es menor que el tamaño de archivo.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromFile">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile (System.IO.FileStream fileStream, string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(class System.IO.FileStream fileStream, string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateFromFile(System::IO::FileStream ^ fileStream, System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability, bool leaveOpen);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileStream" Type="System.IO.FileStream" />
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileStream">
          <c>fileStream</c> al archivo que se va a asignar.</param>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria. Especifique 0 para establecer la capacidad en el tamaño del archivo de disco.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria.  Este parámetro no puede establecerse en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</param>
        <param name="memoryMappedFileSecurity">Permisos que se pueden conceder para el acceso a archivos y las operaciones en los archivos asignados a la memoria.  Este parámetro puede ser <see langword="null" />.</param>
        <param name="inheritability">Uno de los valores de enumeración que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <param name="leaveOpen">
          <see langword="true" /> para no eliminar <c>fileStream</c> después de que se cierre <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />; <see langword="false" /> para eliminar <c>fileStream</c>.</param>
        <summary>Crea un archivo asignado a la memoria con el nombre, la capacidad, el tipo de acceso, los permisos de seguridad, la herencia y el requisito de eliminación especificados de un archivo de disco.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `capacity` es mayor que el tamaño del archivo en disco, el archivo en disco aumenta para coincidir con la capacidad especificada aun cuando no se escriben datos en el archivo asignado a la memoria. Para evitar que esto suceda, especifique 0 (cero) para la capacidad de manera predeterminada, que establecerá internamente `capacity` al tamaño del archivo en disco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="capacity" /> y la longitud del archivo son cero.  -o bien- <paramref name="access" /> se ha establecido en el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />, que no está permitido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileStream" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor que cero.  -o bien- <paramref name="capacity" /> es menor que el tamaño de archivo.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <exception cref="T:System.ObjectDisposedException">Se cerró <paramref name="fileStream" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> se establece en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> cuando el acceso de <paramref name="fileStream" /> se establece en <see cref="F:System.IO.FileAccess.Read" /> o <see cref="F:System.IO.FileAccess.Write" />.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="mapName" /> ya existe.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNew">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un archivo asignado a la memoria en la memoria del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <summary>Crea un archivo asignado a la memoria con la capacidad especificada en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria con el nombre y la capacidad especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
   
  
## Examples  
 En el siguiente ejemplo se compone de tres procesos independientes (aplicaciones de consola) que escriben `Boolean` valores en un archivo asignado a la memoria. Se produce la siguiente secuencia de acciones:  
  
1.  Proceso A crea el archivo asignado a memoria y escribe un valor en él.  
  
2.  Proceso B abre el archivo asignado a memoria y escribe un valor en él.  
  
3.  Proceso C abre el archivo asignado a memoria y escribe un valor en él.  
  
4.  Proceso A lee y muestra los valores del archivo asignado a la memoria.  
  
5.  Después de finaliza un proceso con el archivo asignado a la memoria, el archivo inmediatamente sea reclamado por la recolección.  
  
 Para ejecutar este ejemplo, haga lo siguiente:  
  
1.  Compile las aplicaciones y abra tres ventanas de comandos.  
  
2.  En la primera ventana de comandos, ejecute A. de proceso  
  
3.  En la segunda ventana de comandos, ejecute el proceso B.  
  
4.  Vuelva al proceso A y presione ENTRAR.  
  
5.  En la tercera ventana de comandos, ejecute el proceso C.  
  
6.  Vuelva al proceso A y presione ENTRAR.  
  
 La salida de un proceso es el siguiente:  
  
```  
Start Process B and press ENTER to continue.  
Start Process C and press ENTER to continue.  
Process A says: True  
Process B says: False  
Process C says: True  
```  
  
 **Process A**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#1)]  
  
 **Process B**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_A#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_a/vb/program.vb#1)]  
  
 **Process C**  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/cs/program.cs#1)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_B#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_b/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea un archivo asignado a la memoria con la capacidad y el tipo de acceso especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateNew (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinación bit a bit de valores de enumeración que especifica las opciones de asignación de memoria para el archivo asignado a la memoria.</param>
        <param name="inheritability">Valor que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un archivo asignado a la memoria con el nombre, la capacidad, el tipo de acceso, las opciones de asignación de memoria y la herencia especificados.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNew">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateNew(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre para asignar al archivo asignado a la memoria o <see langword="null" /> para un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> que no tiene intención de compartir entre procesos.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinación bit a bit de valores de enumeración que especifica las opciones de asignación de memoria para el archivo asignado a la memoria.</param>
        <param name="memoryMappedFileSecurity">Permisos que se pueden conceder para el acceso a archivos y las operaciones en los archivos asignados a la memoria.  Este parámetro puede ser <see langword="null" />.</param>
        <param name="inheritability">Uno de los valores de enumeración que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un archivo asignado a la memoria con la capacidad, el tipo de acceso, la asignación de memoria, los permisos de seguridad y la herencia especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateOrOpen">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea o abre un archivo asignado a la memoria en la memoria del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <summary>Crea o abre un archivo asignado a la memoria con el nombre y la capacidad especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene el nombre y el tamaño especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear o abrir un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor o igual que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea o abre un archivo asignado a la memoria con el nombre, la capacidad y el tipo de acceso especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear o abrir un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo denegó el acceso especificado al archivo; por ejemplo, el acceso está establecido en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, pero el archivo o el directorio es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateOrOpen (mapName As String, capacity As Long, access As MemoryMappedFileAccess, options As MemoryMappedFileOptions, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinación bit a bit de valores que indican las opciones de asignación de memoria que se aplican al archivo.</param>
        <param name="inheritability">Valor que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea un archivo asignado a la memoria vacío o abre un archivo existente asignado a la memoria si ya existe uno con el mismo nombre. Si se abre un archivo existente, se omiten la capacidad, las opciones y los argumentos de memoria.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo denegó el acceso especificado al archivo; por ejemplo, el acceso está establecido en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, pero el archivo o el directorio es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateOrOpen">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen (string mapName, long capacity, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(string mapName, int64 capacity, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileOptions options, class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.MemoryMappedFiles.MemoryMappedFileSecurity,System.IO.HandleInheritability)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ CreateOrOpen(System::String ^ mapName, long capacity, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access, System::IO::MemoryMappedFiles::MemoryMappedFileOptions options, System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
        <Parameter Name="options" Type="System.IO.MemoryMappedFiles.MemoryMappedFileOptions" />
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria.</param>
        <param name="capacity">Tamaño máximo, en bytes, que se va a asignar al archivo asignado a la memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <param name="options">Combinación bit a bit de valores de enumeración que especifica las opciones de asignación de memoria para el archivo asignado a la memoria.</param>
        <param name="memoryMappedFileSecurity">Permisos que se pueden conceder para el acceso a archivos y las operaciones en los archivos asignados a la memoria.  Este parámetro puede ser <see langword="null" />.</param>
        <param name="inheritability">Uno de los valores de enumeración que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Crea o abre un archivo asignado a la memoria con el nombre, la capacidad, el tipo de acceso, la asignación de memoria, los permisos de seguridad y la herencia especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este método para crear o abrir un archivo asignado a memoria que no es persistente (es decir, no asociado con un archivo en disco), que puede usar para compartir datos entre procesos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.  -o bien- <paramref name="access" /> se ha establecido como de solo escritura con el valor de enumeración <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> es mayor que el tamaño del espacio de direcciones lógico.  -o bien- <paramref name="capacity" /> es menor o igual que cero.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El sistema operativo denegó <paramref name="access" /> especificado al archivo; por ejemplo, <paramref name="access" /> está establecido en <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> o <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, pero el archivo o el directorio es de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewAccessor">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> que se asigna a una vista del archivo asignado a la memoria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor () As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> que se asigna a una vista del archivo asignado a la memoria.</summary>
        <returns>Bloque de memoria de acceso aleatorio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la vista devuelta por este método para obtener acceso aleatorio a un archivo asignado a la memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">No se autoriza el acceso al archivo asignado a la memoria.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Byte en el que va a comenzar la vista.</param>
        <param name="size">Tamaño de la vista. Especifique 0 (cero) para crear una vista que empiece en <c>offset</c> y termine aproximadamente al final del archivo asignado en memoria.</param>
        <summary>Crea un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> que se asigna a una vista del archivo asignado a la memoria y que tiene el desplazamiento y el tamaño especificados.</summary>
        <returns>Bloque de memoria de acceso aleatorio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la vista devuelta por este método para obtener acceso aleatorio a un archivo asignado a la memoria.  
  
 Para crear una vista completa del archivo asignado a memoria, especifique 0 (cero) para el `size` parámetro. Si lo hace, el tamaño de la vista puede ser menor o mayor que el tamaño del archivo de origen en el disco. Esto es porque se proporcionan vistas en unidades de páginas del sistema y el tamaño de la vista se redondea al siguiente tamaño de página del sistema.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una vista de un archivo asignado a memoria y lo edita. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> clase.  
  
 [!code-csharp[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/cs/program.cs#2)]
 [!code-vb[MemoryMappedFiles.MemoryMappedFile.CreateFromFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.createfromfile/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="offset" /> o <paramref name="size" /> es negativo.  -o bien- <paramref name="size" /> es mayor que el espacio de direcciones lógico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">No se autoriza el acceso al archivo asignado a la memoria.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewAccessor">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewAccessor (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewAccessor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewAccessor ^ CreateViewAccessor(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewAccessor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Byte en el que va a comenzar la vista.</param>
        <param name="size">Tamaño de la vista. Especifique 0 (cero) para crear una vista que empiece en <c>offset</c> y termine aproximadamente al final del archivo asignado en memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea un <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> que se asigna a una vista del archivo asignado a la memoria y que tiene el desplazamiento, el tamaño y las restricciones de acceso especificados.</summary>
        <returns>Bloque de memoria de acceso aleatorio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la vista devuelta por este método para obtener acceso aleatorio a un archivo asignado a la memoria.  
  
 Para crear una vista completa del archivo asignado a memoria, especifique 0 (cero) para el `size` parámetro. Si lo hace, el tamaño de la vista puede ser menor o mayor que el tamaño del archivo de origen en el disco. Esto es porque se proporcionan vistas en unidades de páginas del sistema y el tamaño de la vista se redondea al siguiente tamaño de página del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="offset" /> o <paramref name="size" /> es negativo.  -o bien- <paramref name="size" /> es mayor que el espacio de direcciones lógico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> no es válido para el archivo asignado por memoria.</exception>
        <exception cref="T:System.IO.IOException">Error de E/S.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateViewStream">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una secuencia que se asigna a una vista del archivo asignado a la memoria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream () As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una secuencia que se asigna a una vista del archivo asignado a la memoria.</summary>
        <returns>Secuencia de memoria.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la secuencia devuelta por este método para el acceso secuencial a un archivo asignado a la memoria, como para las comunicaciones entre procesos.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una secuencia y escribe un valor en él. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%2A> método.  
  
 [!code-csharp[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/cs/program.cs#2)]
 [!code-vb[System.IO.MemoryMappedFiles_IPC_X#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.memorymappedfiles_ipc_x/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">No se autoriza el acceso al archivo asignado a la memoria.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="offset">Byte en el que va a comenzar la vista.</param>
        <param name="size">Tamaño de la vista. Especifique 0 (cero) para crear una vista que empiece en <c>offset</c> y termine aproximadamente al final del archivo asignado en memoria.</param>
        <summary>Crea una secuencia que se asigna a una vista del archivo asignado a la memoria y que tiene el desplazamiento y el tamaño especificados.</summary>
        <returns>Secuencia de memoria con el desplazamiento y el tamaño especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la secuencia devuelta por este método para el acceso secuencial a un archivo asignado a la memoria, como para las comunicaciones entre procesos.  
  
 Para crear una vista completa del archivo asignado a memoria, especifique 0 (cero) para el `size` parámetro. Si lo hace, el tamaño de la vista puede ser menor o mayor que el tamaño del archivo de origen en el disco. Esto es porque se proporcionan vistas en unidades de páginas del sistema y el tamaño de la vista se redondea al siguiente tamaño de página del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="offset" /> o <paramref name="size" /> es negativo.  -o bien- <paramref name="size" /> es mayor que el espacio de direcciones lógico.</exception>
        <exception cref="T:System.UnauthorizedAccessException">No se autoriza el acceso al archivo asignado a la memoria.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> es mayor que la memoria virtual total.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateViewStream">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream (long offset, long size, System.IO.MemoryMappedFiles.MemoryMappedFileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(int64 offset, int64 size, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateViewStream (offset As Long, size As Long, access As MemoryMappedFileAccess) As MemoryMappedViewStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedViewStream ^ CreateViewStream(long offset, long size, System::IO::MemoryMappedFiles::MemoryMappedFileAccess access);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedViewStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
        <Parameter Name="access" Type="System.IO.MemoryMappedFiles.MemoryMappedFileAccess" />
      </Parameters>
      <Docs>
        <param name="offset">Byte en el que va a comenzar la vista.</param>
        <param name="size">Tamaño de la vista. Especifique 0 (cero) para crear una vista que empiece en <c>offset</c> y termine aproximadamente al final del archivo asignado en memoria.</param>
        <param name="access">Uno de los valores de enumeración que especifica el tipo de acceso permitido para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
        <summary>Crea una secuencia que se asigna a una vista del archivo asignado a la memoria y que tiene el desplazamiento, el tamaño y el tipo de acceso especificados.</summary>
        <returns>Secuencia de memoria con las características especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar la secuencia devuelta por este método para el acceso secuencial a un archivo asignado a la memoria, como para las comunicaciones entre procesos.  
  
 Para crear una vista completa del archivo asignado a memoria, especifique 0 (cero) para el `size` parámetro. Si lo hace, el tamaño de la vista puede ser menor o mayor que el tamaño del archivo de origen en el disco. Esto es porque se proporcionan vistas en unidades de páginas del sistema y el tamaño de la vista se redondea al siguiente tamaño de página del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="offset" /> o <paramref name="size" /> es negativo.  -o bien- <paramref name="size" /> es mayor que el espacio de direcciones lógico.  -o bien- <paramref name="access" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="access" /> no es válido para el archivo asignado por memoria.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="size" /> es mayor que la memoria virtual total.  -o bien- <paramref name="access" /> no es válido para el archivo asignado a la memoria.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MemoryMappedFileSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ GetAccessControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el control de acceso al recurso de archivo asignado a la memoria.</summary>
        <returns>Permisos que se pueden conceder para el acceso a archivos y las operaciones en los archivos asignados a la memoria.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.</exception>
        <exception cref="T:System.NotSupportedException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.</exception>
        <exception cref="T:System.ObjectDisposedException">El archivo asignado a memoria está cerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">La plataforma actual es Windows 98 o anterior.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.  -o bien- El archivo asignado a la memoria se abrió como <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> únicamente.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un archivo asignado a la memoria con nombre existente en la memoria del sistema.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria.</param>
        <summary>Abre un archivo asignado a la memoria existente que tiene el nombre especificado en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene el nombre especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El archivo asignado a la memoria puede ser un persistente asignado a la memoria archivo (asociado a un archivo en disco) o no persistente.  
  
   
  
## Examples  
 **Abrir un archivo asignado a memoria persistente**  
  
 En el ejemplo siguiente se abre un archivo asignado a memoria denominado `ImgA` que ya se ha creado desde un archivo en disco (como se muestra en el ejemplo de la <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile%28System.String%29> método).  
  
 [!code-csharp[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/csharp/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/cs/program.cs#1)]
 [!code-vb[memorymappedfiles.memorymappedfile.openexisting#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/memorymappedfiles.memorymappedfile.openexisting/vb/program.vb#1)]  
  
 **Abrir un archivo asignado a memoria no persistentes**  
  
 En el ejemplo siguiente se abre un archivo asignado a memoria que se utiliza para la comunicación entre procesos. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew%28System.String%2CSystem.Int64%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo especificado para <paramref name="mapName" /> no existe.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria que se va a abrir.</param>
        <param name="desiredAccessRights">Uno de los valores de enumeración que especifica los derechos de acceso que se van a aplicar al archivo asignado a la memoria.</param>
        <summary>Abre un archivo asignado a la memoria existente que tiene el nombre y los permisos de acceso especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> válido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo especificado para <paramref name="mapName" /> no existe.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting (string mapName, System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, System.IO.HandleInheritability inheritability);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(string mapName, valuetype System.IO.MemoryMappedFiles.MemoryMappedFileRights desiredAccessRights, valuetype System.IO.HandleInheritability inheritability) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (mapName As String, desiredAccessRights As MemoryMappedFileRights, inheritability As HandleInheritability) As MemoryMappedFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::MemoryMappedFiles::MemoryMappedFile ^ OpenExisting(System::String ^ mapName, System::IO::MemoryMappedFiles::MemoryMappedFileRights desiredAccessRights, System::IO::HandleInheritability inheritability);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.MemoryMappedFiles.MemoryMappedFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mapName" Type="System.String" />
        <Parameter Name="desiredAccessRights" Type="System.IO.MemoryMappedFiles.MemoryMappedFileRights" />
        <Parameter Name="inheritability" Type="System.IO.HandleInheritability" />
      </Parameters>
      <Docs>
        <param name="mapName">Nombre del archivo asignado a la memoria que se va a abrir.</param>
        <param name="desiredAccessRights">Uno de los valores de enumeración que especifica los derechos de acceso que se van a aplicar al archivo asignado a la memoria.</param>
        <param name="inheritability">Uno de los valores de enumeración que especifica si un proceso secundario puede heredar un identificador para el archivo asignado a la memoria. El valor predeterminado es <see cref="F:System.IO.HandleInheritability.None" />.</param>
        <summary>Abre un archivo asignado a la memoria existente que tiene el nombre, los permisos de acceso y la herencia especificados en la memoria del sistema.</summary>
        <returns>Archivo asignado a la memoria que tiene las características especificadas.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="mapName" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mapName" /> es una cadena vacía.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="desiredAccessRights" /> no es un valor de enumeración <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> válido.  -o bien- <paramref name="inheritability" /> no es un valor de enumeración <see cref="T:System.IO.HandleInheritability" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El acceso solicitado no es válido para el archivo asignado a memoria.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo especificado para <paramref name="mapName" /> no existe.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeMemoryMappedFileHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.MemoryMappedFiles.MemoryMappedFile.SafeMemoryMappedFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeMemoryMappedFileHandle As SafeMemoryMappedFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ SafeMemoryMappedFileHandle { Microsoft::Win32::SafeHandles::SafeMemoryMappedFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.MemoryMappedFiles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador de un archivo asignado a la memoria.</summary>
        <value>Identificador para el archivo asignado a la memoria.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.IO.MemoryMappedFiles.MemoryMappedFileSecurity memoryMappedFileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.MemoryMappedFiles.MemoryMappedFile.SetAccessControl(System.IO.MemoryMappedFiles.MemoryMappedFileSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::IO::MemoryMappedFiles::MemoryMappedFileSecurity ^ memoryMappedFileSecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memoryMappedFileSecurity" Type="System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" />
      </Parameters>
      <Docs>
        <param name="memoryMappedFileSecurity">Permisos que se pueden conceder para el acceso a archivos y las operaciones en los archivos asignados a la memoria.</param>
        <summary>Establece el control de acceso al recurso de archivo asignado a la memoria.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="memoryMappedFileSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.</exception>
        <exception cref="T:System.NotSupportedException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Se ha producido un error en una llamada subyacente para establecer la información de seguridad.</exception>
      </Docs>
    </Member>
  </Members>
</Type>