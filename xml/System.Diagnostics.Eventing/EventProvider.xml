<Type Name="EventProvider" FullName="System.Diagnostics.Eventing.EventProvider">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="444c8c7687180dcc9bbce821804e821244aedd0e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52207610" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventProvider : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventProvider extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.EventProvider" />
  <TypeSignature Language="VB.NET" Value="Public Class EventProvider&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventProvider : IDisposable" />
  <TypeSignature Language="F#" Value="type EventProvider = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Utilice esta clase para escribir eventos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para consumir eventos escritos con la <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A> y <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> métodos, los eventos deben definirse en un manifiesto; eventos escritos con la <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A> método no requiere un manifiesto.  
  
 Los eventos pueden contener los siguientes tipos de datos administrados:  
  
-   bool  
  
-   Booleano  
  
-   byte  
  
-   char  
  
-   decimal  
  
-   double  
  
-   float  
  
-   GUID  
  
-   int  
  
-   IntPtr  
  
-   long  
  
-   sbyte  
  
-   short  
  
-   cadena  
  
-   uint  
  
-   UInt64  
  
 Si usa un evento en el manifiesto de la `Boolean` en tipo, no se puede escribir el elemento de datos mediante un `Boolean` tipo de datos en el código administrado. El `Boolean` de tipo en el manifiesto espera un valor de 4 bytes y un `Boolean` tipo de datos en código administrado es de 1 byte. En su lugar, debe usar un `int` tipo de datos para escribir el valor. Si desea registrar un `Boolean` valor, use el tipo de manifiesto de UInt8.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventProvider (Guid providerGuid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Guid providerGuid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.#ctor(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (providerGuid As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventProvider(Guid providerGuid);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.EventProvider : Guid -&gt; System.Diagnostics.Eventing.EventProvider" Usage="new System.Diagnostics.Eventing.EventProvider providerGuid" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="providerGuid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="providerGuid">Guid que identifica de forma única al proveedor.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Registra el proveedor. Para quitar el registro cuando termine, llame a la <xref:System.Diagnostics.Eventing.EventProvider.Close%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientMemoryException">No hay suficiente memoria para completar la operación.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Las clases del espacio de nombres <see cref="N:System.Diagnostics.Eventing" /> sólo funcionan en Windows Vista.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="providerGuid" /> no puede ser null.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Error devuelto por el subsistema ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="eventProvider.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita el registro del proveedor del subsistema ETW y libera todos los recursos no administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a este método cuando acabe en lugar de esperar el sistema para deshacerse de los recursos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Error devuelto por el subsistema ETW.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateActivityId">
      <MemberSignature Language="C#" Value="public static Guid CreateActivityId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid CreateActivityId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateActivityId () As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid CreateActivityId();" />
      <MemberSignature Language="F#" Value="static member CreateActivityId : unit -&gt; Guid" Usage="System.Diagnostics.Eventing.EventProvider.CreateActivityId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un identificador de actividad único para el proveedor.</summary>
        <returns>Guid único que se utiliza al llamar al método <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> para establecer el identificador de actividad para el proveedor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método estático.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventProvider.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos utilizados por este objeto <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventProvider.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Este método omite este parámetro porque no hay recursos no administrados.</param>
        <summary>Libera los recursos utilizados por este objeto <see cref="T:System.Diagnostics.Eventing.EventProvider" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~EventProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!EventProvider ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="eventProvider.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera recursos y realiza la limpieza interna antes de que recopilación de elementos no utilizados reclame la instancia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteEventError">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode GetLastWriteEventError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Diagnostics.Eventing.EventProvider/WriteEventErrorCode GetLastWriteEventError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLastWriteEventError () As EventProvider.WriteEventErrorCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Eventing::EventProvider::WriteEventErrorCode GetLastWriteEventError();" />
      <MemberSignature Language="F#" Value="static member GetLastWriteEventError : unit -&gt; System.Diagnostics.Eventing.EventProvider.WriteEventErrorCode" Usage="System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.EventProvider+WriteEventErrorCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el último error asociado a un error de escritura de evento.</summary>
        <returns>Utilice el valor para determinar la causa de un error de escritura de evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Diagnostics.Eventing.EventProvider.WriteEvent%2A>, <xref:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent%2A>, y <xref:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent%2A> métodos establecen este valor si se produce un error al escribir el evento.  
  
 Se trata de un método estático.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsEnabled">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina si una sesión habilitó el proveedor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled();" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : unit -&gt; bool" Usage="eventProvider.IsEnabled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina si alguna sesión habilitó el proveedor, sin tener en cuenta los valores de nivel y palabra clave utilizados para habilitar el proveedor.</summary>
        <returns>Es <see langword="true" /> si el proveedor se habilitó en alguna sesión; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, un proveedor no llama a este método para determinar si el proveedor se ha habilitado una sesión; el proveedor simplemente escribe el evento y ETW determina si el evento se registra en la sesión. Un proveedor puede llamar a esta función si el proveedor necesita para realizar trabajo adicional para generar el evento. En este caso, una llamada a esta función primero puede ahorrar tiempo y recursos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled (byte level, long keywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsEnabled(unsigned int8 level, int64 keywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.IsEnabled(System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsEnabled (level As Byte, keywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsEnabled(System::Byte level, long keywords);" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : byte * int64 -&gt; bool" Usage="eventProvider.IsEnabled (level, keywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Byte" />
        <Parameter Name="keywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="level">Nivel de detalle que se incluye en el evento.</param>
        <param name="keywords">Máscara de bits que especifica la categoría de evento. Esta máscara debe ser la misma máscara de palabra clave definida en el manifiesto para el evento.</param>
        <summary>Determina si alguna sesión está solicitando el evento especificado del proveedor.</summary>
        <returns>Es <see langword="true" /> si alguna sesión está solicitando el evento especificado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, un proveedor no llama a este método para determinar si una sesión solicitó el evento especificado; el proveedor simplemente escribe el evento y ETW determina si el evento se registra en una sesión. Un proveedor puede llamar a esta función si el proveedor necesita para realizar trabajo adicional para generar el evento. En este caso, una llamada a esta función primero para determinar si una sesión solicitó el evento o no, puede ahorrar tiempo y recursos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetActivityId">
      <MemberSignature Language="C#" Value="public static void SetActivityId (ref Guid id);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetActivityId(valuetype System.Guid&amp; id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetActivityId (ByRef id As Guid)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetActivityId(Guid % id);" />
      <MemberSignature Language="F#" Value="static member SetActivityId :  -&gt; unit" Usage="System.Diagnostics.Eventing.EventProvider.SetActivityId id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.Guid" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="id">Identificador de la actividad único devuelto por el método <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" />.</param>
        <summary>Establece el identificador de actividad actual utilizado por los métodos <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El identificador se almacena en el contexto del subproceso.  
  
 Tenga en cuenta que en la versión 3.5 de .NET framework, tenía que establecer el `id` parámetro de este método y el <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> valor de propiedad en el mismo valor de identificador. Sin embargo, en la versión 4.0 de framework, el <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método establece automáticamente el identificador de actividad de correlación para usted.  
  
 Se trata de un método estático.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe un evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice estos métodos si utiliza un manifiesto para definir los eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * obj[] -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instancia de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> que identifica el evento que se va a escribir.</param>
        <param name="eventPayload">Matriz de objetos que contiene los datos del evento que se va a escribir. El objeto debe estar en el orden especificado en el manifiesto. La matriz se limita a 32 objetos, de los que sólo ocho pueden ser cadenas. El tamaño de datos máximo del evento se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.  
  
Este parámetro puede ser NULL.</param>
        <summary>Escribe un evento. Los datos de evento se especifican como una matriz de objetos.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método para especificar un identificador de actividad para el evento, este método recupera el identificador del contexto del subproceso y lo incluye con el evento.  
  
 Si no se admite el tipo de objeto, el método escribe el valor del objeto <xref:System.Object.ToString%2A?displayProperty=nameWithType> método en la carga. Para obtener una lista de tipos de objetos admitidos, vea los comentarios sobre el <xref:System.Diagnostics.Eventing.EventProvider> clase.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
enum Keyword  
{  
    Read = 0x1,  
    Write = 0x2,  
    Local = 0x4,  
    Remote = 0x8  
}  
  
enum Level  
{  
    Critical = 1,  
    Error,  
    Warning,  
    Information,  
    Verbose  
}  
  
    EventProvider provider = new EventProvider(providerId);  
    EventDescriptor readEvent;  
    string path = @"<PATHGOESHERE>";  
    UInt64 bytesRead = <ASSIGNVALUE>;  
  
    if (provider.IsEnabled(Level.Information, (long)Keyword.Read))  
    {  
        unchecked  
        {  
            readEvent = new EventDescriptor(0x1, 0x0, 0x10, 0x4, 0x0, 0x0, (long)0x8000000000000005);  
        }  
  
        if (!provider.WriteEvent(ref readEvent, new object[] { path, bytesRead }))  
            Console.WriteLine(EventProvider.GetLastWriteEventError());  
    }  
  
    provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="eventPayload" /> contiene demasiados objetos o cadenas.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteEvent (ByRef eventDescriptor As EventDescriptor, data As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, System::String ^ data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * string -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instancia de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> que identifica el evento que se va a escribir.</param>
        <param name="data">Cadena que se va a escribir como los datos del evento.</param>
        <summary>Escribe un evento. Los datos del evento se especifican como una cadena.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método para especificar un identificador de actividad para el evento, este método recupera el identificador del contexto del subproceso y lo incluye con el evento.  
  
 La longitud máxima de cadena se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.  
  
   
  
## Examples  
  
```csharp  
private static Guid providerId = new Guid("{FB33FDA8-45FB-4df0-8A55-EEB4BA88E7E7}");  
  
EventProvider provider = new EventProvider(providerId);  
EventDescriptor writeEvent;  
  
if (provider.IsEnabled())  
{  
     unchecked  
     {  
          writeEvent = new EventDescriptor(0x2, 0x0, 0x10, 0x3, 0x0, 0x0, (long)0x8000000000000006);  
     }  
  
     if (!provider.WriteEvent(ref writeEvent, "Write event."))  
          Console.WriteLine(EventProvider.GetLastWriteEventError());  
}  
  
provider.Close();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="data" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="protected bool WriteEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteEvent (ByRef eventDescriptor As EventDescriptor, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent :  * int * nativeint -&gt; bool" Usage="eventProvider.WriteEvent (eventDescriptor, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instancia de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> que identifica el evento que se va a escribir.</param>
        <param name="dataCount">Tamaño de los datos del evento a los que apunta el parámetro <paramref name="data" />. El tamaño de datos máximo del evento se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.</param>
        <param name="data">Puntero a los datos del evento que se va escribir.</param>
        <summary>Escribe un evento. Los datos del evento se especifican como un bloque de memoria.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a la <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método para especificar un identificador de actividad para el evento, este método recupera el identificador del contexto del subproceso y lo incluye con el evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteMessageEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe un evento que contiene una cadena como datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estos métodos no requieren un manifiesto para consumir el evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string -&gt; bool" Usage="eventProvider.WriteMessageEvent eventMessage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Cadena que se va a escribir como los datos del evento.</param>
        <summary>Escribe un evento que contiene una cadena como datos.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud máxima de cadena se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.  
  
   
  
## Examples  
  
```csharp  
if (!provider.WriteMessageEvent("Event string."))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventMessage" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteMessageEvent">
      <MemberSignature Language="C#" Value="public bool WriteMessageEvent (string eventMessage, byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteMessageEvent(string eventMessage, unsigned int8 eventLevel, int64 eventKeywords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteMessageEvent(System.String,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteMessageEvent (eventMessage As String, eventLevel As Byte, eventKeywords As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteMessageEvent(System::String ^ eventMessage, System::Byte eventLevel, long eventKeywords);" />
      <MemberSignature Language="F#" Value="member this.WriteMessageEvent : string * byte * int64 -&gt; bool" Usage="eventProvider.WriteMessageEvent (eventMessage, eventLevel, eventKeywords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventMessage" Type="System.String" />
        <Parameter Name="eventLevel" Type="System.Byte" />
        <Parameter Name="eventKeywords" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="eventMessage">Cadena que se va a escribir como los datos del evento.</param>
        <param name="eventLevel">Nivel de detalle que se incluye en el evento. Si el proveedor utiliza un manifiesto para definir el evento, establezca este valor en el mismo nivel definido en el manifiesto.</param>
        <param name="eventKeywords">Máscara de bits que especifica la categoría de evento. Si el proveedor utiliza un manifiesto para definir el evento, establezca este valor en la misma máscara de palabra clave definida en el manifiesto.</param>
        <summary>Escribe un evento que contiene una cadena como datos si el valor de nivel y palabra clave coinciden con los eventos solicitados por la sesión.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud máxima de cadena se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.  
  
   
  
## Examples  
  
```csharp  
// Calling this method with level and keyword set to zero is the same  
// as calling WriteMessageEvent(string); the event is always written.  
if (!provider.WriteMessageEvent("Event string.", 0, 0))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
  
// Event is written if the level value of the session is less than or equal to 3, and bit 1 of the session  
// keyword bit-mask is set.  
if (!provider.WriteMessageEvent("Event string.", 3, 2))  
    Console.WriteLine(EventProvider.GetLastWriteEventError());  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventMessage" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteTransferEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vincula eventos al seguir la traza de eventos en un escenario completo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="public bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, params object[] eventPayload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, object[] eventPayload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, ParamArray eventPayload As Object()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, ... cli::array &lt;System::Object ^&gt; ^ eventPayload);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * obj[] -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, eventPayload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="eventPayload" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instancia de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> que identifica el evento que se va a escribir.</param>
        <param name="relatedActivityId">Identificador de actividad del componente anterior. Utilice este parámetro para vincular los eventos del componente con los eventos del componente anterior.</param>
        <param name="eventPayload">Matriz de objetos que contiene los datos del evento que se va a escribir. Los datos deben estar en el orden especificado en el manifiesto. La matriz se limita a 32 objetos, de los que sólo ocho pueden ser cadenas. El tamaño de datos máximo del evento se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.</param>
        <summary>Vincula eventos al seguir la traza de eventos en un escenario completo. Los datos de evento se especifican como una matriz de objetos.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método usa el identificador de actividad establecido en el contexto del subproceso para identificar este componente. Para establecer el identificador de actividad, llame a la <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método.  
  
 Si usas el <xref:System.Diagnostics.Trace> (clase), no use el <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método para especificar el identificador de actividad. En su lugar, tener acceso a la <xref:System.Diagnostics.Trace.CorrelationManager%2A> propiedad va a obtener el <xref:System.Diagnostics.CorrelationManager> objeto. A continuación, establezca el <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> propiedad para el identificador de actividad. También debe establecer el `relatedActivityId` a un <xref:System.Diagnostics.CorrelationManager.ActivityId%2A> valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Si <paramref name="eventPayload" /> contiene demasiados objetos o cadenas.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTransferEvent">
      <MemberSignature Language="C#" Value="protected bool WriteTransferEvent (ref System.Diagnostics.Eventing.EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool WriteTransferEvent(valuetype System.Diagnostics.Eventing.EventDescriptor&amp; eventDescriptor, valuetype System.Guid relatedActivityId, int32 dataCount, native int data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.EventProvider.WriteTransferEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Guid,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Function WriteTransferEvent (ByRef eventDescriptor As EventDescriptor, relatedActivityId As Guid, dataCount As Integer, data As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool WriteTransferEvent(System::Diagnostics::Eventing::EventDescriptor % eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data);" />
      <MemberSignature Language="F#" Value="member this.WriteTransferEvent :  * Guid * int * nativeint -&gt; bool" Usage="eventProvider.WriteTransferEvent (eventDescriptor, relatedActivityId, dataCount, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventDescriptor" Type="System.Diagnostics.Eventing.EventDescriptor" RefType="ref" />
        <Parameter Name="relatedActivityId" Type="System.Guid" />
        <Parameter Name="dataCount" Type="System.Int32" />
        <Parameter Name="data" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="eventDescriptor">Instancia de <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> que identifica el evento que se va a escribir.</param>
        <param name="relatedActivityId">Identificador de actividad del componente anterior. Utilice este parámetro para vincular los eventos del componente con los eventos del componente anterior.</param>
        <param name="dataCount">Tamaño de los datos del evento a los que apunta el parámetro <paramref name="data" />. El tamaño de datos máximo del evento se limita a 64 KB menos el tamaño de los encabezados de evento. El tamaño del evento será menor si el tamaño de búfer de la sesión es menor y la sesión incluye elementos de datos extendidos con el evento.</param>
        <param name="data">Puntero a los datos del evento que se va escribir.</param>
        <summary>Vincula eventos al seguir la traza de eventos en un escenario completo. Los datos del evento se especifican como un bloque de memoria.</summary>
        <returns>Es <see langword="true" /> si se escribe el evento; de lo contrario, es <see langword="false" />. Si su valor es false, llame al método <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> para determinar la causa del error.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método usa el identificador de actividad establecido en el contexto del subproceso para identificar este componente. Para establecer el identificador de actividad, llame a la <xref:System.Diagnostics.Eventing.EventProvider.SetActivityId%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>