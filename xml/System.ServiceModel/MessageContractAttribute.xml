<Type Name="MessageContractAttribute" FullName="System.ServiceModel.MessageContractAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9c523f6be030722faee7873be463828de81cd09a" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52907780" /></Metadata><TypeSignature Language="C#" Value="public sealed class MessageContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MessageContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.MessageContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MessageContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type MessageContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;dotnet-plat-ext-2.2">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple=false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define una clase fuertemente tipada que corresponde a un mensaje SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el atributo <xref:System.ServiceModel.MessageContractAttribute> para especificar la estructura del sobre de SOAP para un mensaje determinado. Su servicio puede utilizar a continuación el mensaje como un parámetro o tipo de valor devuelto en operaciones del servicio. Para obtener información acerca de cómo controlar la serialización del contenido de un cuerpo SOAP sin modificar el propio sobre SOAP predeterminado, consulte <xref:System.Runtime.Serialization.DataContractAttribute?displayProperty=nameWithType>, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md), y [Using Los contratos de datos](~/docs/framework/wcf/feature-details/using-data-contracts.md).  
  
> [!NOTE]
>  No puede utilizar tipos de mensaje personalizados en su operación del servicio con parámetros serializables normales. Utilice tipos de mensaje personalizados o parámetros serializables que no sean objetos <xref:System.ServiceModel.Channels.Message>. Para obtener más información, vea, [Specifying Data Transfer in Service Contracts](~/docs/framework/wcf/feature-details/specifying-data-transfer-in-service-contracts.md).  
  
 Para implementar un contrato del mensaje para un tipo, anótelo con <xref:System.ServiceModel.MessageContractAttribute> y anote uno o más de los campos o propiedades de clase con <xref:System.ServiceModel.MessageBodyMemberAttribute>, <xref:System.ServiceModel.MessageHeaderAttribute> o <xref:System.ServiceModel.MessageHeaderArrayAttribute>.  
  
> [!NOTE]
>  <xref:System.ServiceModel.MessageParameterAttribute?displayProperty=nameWithType> no es un atributo de contrato de mensaje y no se utiliza junto con <xref:System.ServiceModel.MessageContractAttribute>.  
  
 Utilice las propiedades <xref:System.ServiceModel.OperationContractAttribute.Action%2A> y <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> para especificar el valor del elemento `<Action>` en el mensaje SOAP.  
  
-   Utilice las propiedades <xref:System.ServiceModel.MessageContractAttribute.HasProtectionLevel%2A> y <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A> para indicar si el tipo de mensaje SOAP tiene un nivel de protección y, en ese caso, cuál es.  
  
-   Utilice la propiedad <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> para indicar si el cuerpo del mensaje tiene un elemento contenedor y, en ese caso, utilice las propiedades <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> y <xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A> para especificar el nombre y espacio de nombres, respectivamente, del elemento de ajuste.  
  
 Para obtener más información, consulte [Using Message Contracts](~/docs/framework/wcf/feature-details/using-message-contracts.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra el uso de <xref:System.ServiceModel.MessageContractAttribute> para controlar la estructura de envoltura SOAP para el mensaje de solicitud y el mensaje de respuesta, y el uso de <xref:System.ServiceModel.MessageHeaderAttribute> (para crear un encabezado SOAP para el mensaje de respuesta) y <xref:System.ServiceModel.MessageBodyMemberAttribute> (para especificar los cuerpos del mensaje de solicitud y respuesta). El ejemplo de código contiene un ejemplo de cada mensaje cuando se envía.  
  
 [!code-csharp[MessageHeaderAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/messageheaderattribute/cs/services.cs#1)]
 [!code-vb[MessageHeaderAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/messageheaderattribute/vb/services.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.MessageContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.MessageContractAttribute" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.MessageContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el mensaje tiene un nivel de protección.</summary>
        <value><see langword="true" /> si se debe cifrar el mensaje, firmarlo o las dos cosas; de lo contrario <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este valor es `true`, el nivel de protección para el mensaje es el valor de <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A>. Para obtener más información acerca de los niveles de protección y sus suposiciones y ámbitos, consulte [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWrapped">
      <MemberSignature Language="C#" Value="public bool IsWrapped { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWrapped" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractAttribute.IsWrapped" />
      <MemberSignature Language="VB.NET" Value="Public Property IsWrapped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWrapped { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsWrapped : bool with get, set" Usage="System.ServiceModel.MessageContractAttribute.IsWrapped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si el cuerpo del mensaje tiene un elemento contenedor.</summary>
        <value><see langword="true" /> si el cuerpo del mensaje tiene un elemento contenedor; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca el valor de <xref:System.ServiceModel.MessageContractAttribute.IsWrapped%2A> como `false` para suprimir el elemento contenedor en el que se serializa el cuerpo del mensaje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.MessageContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si los mensajes deben cifrarse, firmarse o las dos cosas.</summary>
        <value>Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />. El valor predeterminado es <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de los niveles de protección y sus suposiciones y ámbitos, consulte [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Valor pasado a la propiedad cuando el valor no es uno de los valores <see cref="T:System.Net.Security.ProtectionLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WrapperName">
      <MemberSignature Language="C#" Value="public string WrapperName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WrapperName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractAttribute.WrapperName" />
      <MemberSignature Language="VB.NET" Value="Public Property WrapperName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WrapperName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WrapperName : string with get, set" Usage="System.ServiceModel.MessageContractAttribute.WrapperName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del elemento contenedor del cuerpo del mensaje.</summary>
        <value>El nombre del elemento contenedor en el cuerpo del mensaje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.MessageContractAttribute.WrapperName%2A> para establecer el nombre del elemento contenedor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="WrapperNamespace">
      <MemberSignature Language="C#" Value="public string WrapperNamespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WrapperNamespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.MessageContractAttribute.WrapperNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Property WrapperNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WrapperNamespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WrapperNamespace : string with get, set" Usage="System.ServiceModel.MessageContractAttribute.WrapperNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el espacio de nombres del elemento contenedor del cuerpo del mensaje.</summary>
        <value>El espacio de nombres del elemento contenedor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.MessageContractAttribute.WrapperNamespace%2A> para establecer el espacio de nombres del elemento contenedor.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra el uso de <xref:System.ServiceModel.MessageContractAttribute> para controlar la estructura de envoltura SOAP para el mensaje de solicitud y el mensaje de respuesta, y el uso de <xref:System.ServiceModel.MessageHeaderAttribute> (para crear un encabezado SOAP para el mensaje de respuesta) y <xref:System.ServiceModel.MessageBodyMemberAttribute> (para especificar los cuerpos del mensaje de solicitud y respuesta). El ejemplo de código contiene un ejemplo de cada mensaje cuando se envía.  
  
 [!code-csharp[MessageHeaderAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/messageheaderattribute/cs/services.cs#1)]
 [!code-vb[MessageHeaderAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/messageheaderattribute/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>