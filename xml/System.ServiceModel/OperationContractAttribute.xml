<Type Name="OperationContractAttribute" FullName="System.ServiceModel.OperationContractAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a0808c4424298333da5de1382e073e19dd8b1592" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37612476" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class OperationContractAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit OperationContractAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.OperationContractAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class OperationContractAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class OperationContractAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type OperationContractAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Indicates that a method defines an operation that is part of a service contract in a Windows Communication Foundation (WCF) application.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplique <xref:System.ServiceModel.OperationContractAttribute> a un método para indicar que el método implementa una operación de servicio como parte de un contrato de servicio (especificado por un atributo <xref:System.ServiceModel.ServiceContractAttribute>).  
  
 Use las propiedades <xref:System.ServiceModel.OperationContractAttribute> para controlar la estructura de la operación y los valores expresados en metadatos:  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.Action%2A> especifica la acción que identifica de forma unívoca esta operación. WCF envía mensajes de solicitud a los métodos basados en su acción.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> indica que la operación se implementa o se puede llamar de forma asincrónica utilizando un par de métodos Begin/End.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> indica si se ha definido de forma explícita la propiedad <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A>.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> indica que la operación solo consiste en un mensaje de entrada. La operación no tiene ningún mensaje de salida asociado.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> especifica si esta operación puede ser la operación inicial en una sesión.  
  
-   El <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> propiedad especifica si los intentos de WCF finalizar la sesión actual una vez completada la operación.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> especifica la seguridad del nivel de mensaje que una operación necesita en el tiempo de ejecución.  
  
-   La propiedad <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> especifica la acción del mensaje de respuesta para la operación.  
  
 El atributo <xref:System.ServiceModel.OperationContractAttribute> declara que un método es una operación en un contrato de servicio. Solo los métodos atribuidos a <xref:System.ServiceModel.OperationContractAttribute> se exponen como operaciones de servicio. Un contrato de servicio sin métodos marcado con <xref:System.ServiceModel.OperationContractAttribute> no expone ninguna operación.  
  
 El <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> propiedad indica que un par de `Begin` \< *methodName*> y `End` \< *methodName*> métodos forman un único operación que implementa de forma asincrónica (ya sea en el cliente o el servicio). La capacidad de un servicio de implementar operaciones de forma asincrónica es un detalle de implementación de servicio y no está expuesto en metadatos (como el Lenguaje de descripción de servicios Web [WSDL]).  
  
 De igual forma, los clientes pueden decidir invocar de forma asincrónica las operaciones independientemente de cómo se implemente el método de servicio. Se recomienda llamar a las operaciones de servicio asincrónicas en el cliente cuando un método de servicio tarda algo de tiempo pero debe devolver la información directamente al cliente. Para obtener información detallada, vea <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>.  
  
 La propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> indica que un método no devuelve ningún valor en absoluto, incluido un mensaje de respuesta subyacente vacío. Este tipo de método es útil para notificaciones o comunicaciones con estilo de eventos. Los métodos de este tipo no pueden devolver un mensaje de respuesta de manera que la declaración del método debe devolver el valor `void`.  
  
> [!IMPORTANT]
>  Cuando se recuperan mediante programación el almacén de información en este atributo, utilice el <xref:System.ServiceModel.Description.ContractDescription> clase en lugar de reflexión.  
  
> [!NOTE]
>  Si la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> está establecida en `false` (el valor predeterminado), incluso los métodos que devuelven el valor `void` son métodos bidireccionales en el nivel de mensaje subyacente. En este caso, la infraestructura crea y envía un mensaje vacío para indicar al autor de la llamada que se ha devuelto el método. Utilizar este enfoque permite a la aplicación y a la infraestructura devolver información de error (como error de SOAP) al cliente. Establecer <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> en `true` es la única manera de evitar la creación y distribución de un mensaje de respuesta. Para obtener más información, consulte [servicios unidireccional](~/docs/framework/wcf/feature-details/one-way-services.md).  
  
 Se pueden usar las propiedades <xref:System.ServiceModel.OperationContractAttribute.Action%2A> y <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> no solo para modificar la acción predeterminada de mensajes SOAP sino también para crear controladores para mensajes desconocidos o deshabilitar la adición de acciones para la programación directa del mensaje. Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> para evitar que los clientes llamen a una operación de servicio determinada antes de otras operaciones. Use el <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> propiedad tenga WCF se cierre el canal después de que los clientes llamar a una operación de servicio determinada. Para obtener más información, consulte [mediante sesiones](~/docs/framework/wcf/using-sessions.md).  
  
 La propiedad <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> le permite especificar en el contrato de la operación si los mensajes de la operación están firmados, cifrados, o firmados y cifrados. Si un enlace no puede proporcionar el nivel de seguridad exigido por el contrato, se producirá una excepción en el tiempo de ejecución. Para obtener más información, consulte <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> y [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra un contrato de servicio simple con una operación.  
  
 [!code-csharp[OperationContractAttribute#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute/vb/services.vb#1)]  
  
 El ejemplo siguiente es un servicio que implementa un contrato de servicio implícito que especifica tres operaciones. Dos de las operaciones son bidireccionales, que devuelven mensajes de respuesta subyacentes al autor de la llamada sin tener en cuenta el valor devuelto. La tercera operación recibe una llamada, un mensaje entrante subyacente, pero no devuelve ningún mensaje de respuesta subyacente.  
  
```csharp  
[ServiceContractAttribute]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContractAttribute]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContractAttribute]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is dispatched to the service; no response  
  // message is generated or sent from the service.  
  [OperationContractAttribute(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public OperationContractAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.OperationContractAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; OperationContractAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.ServiceModel.OperationContractAttribute" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Action">
      <MemberSignature Language="C#" Value="public string Action { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Action" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Action" />
      <MemberSignature Language="VB.NET" Value="Public Property Action As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Action { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Action : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Action" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the WS-Addressing action of the request message.</summary>
        <value>La acción que utilizar al generar el encabezado de la acción WS-Addressing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el <xref:System.ServiceModel.OperationContractAttribute.Action%2A> mensaje de entrada de propiedad para controlar la acción del método. Dado que WCF usa esta acción para enviar un mensaje entrante para el método adecuado, los mensajes utilizados dentro de una operación de contrato deben tener acciones únicas. El valor de la acción predeterminada es una combinación del espacio de nombres de contrato (el valor predeterminado es "http://tempuri.org/"), el nombre de contrato (nombre de la interfaz o el nombre de clase, si no se usa ninguna interfaz de servicio explícita), el nombre de la operación y una cadena adicional ("respuesta") si el mensaje es una respuesta asociada. Puede invalidar este valor predeterminado con la propiedad <xref:System.ServiceModel.OperationContractAttribute.Action%2A>.  
  
 Para indicar que una operación de servicio administra todos los mensajes que el servicio recibe pero que no se pueden dirigir a una operación de servicio, especifique el valor "*" (un asterisco). Este tipo de operación, denominada "controlador de mensajes que no coinciden", debe tener una de las siguientes firmas de método, si no se iniciará <xref:System.InvalidOperationException>:  
  
-   La operación de servicio solo puede tomar un objeto <xref:System.ServiceModel.Channels.Message> y devolver un objeto <xref:System.ServiceModel.Channels.Message>.  
  
-   La operación de servicio puede tomar sólo un objeto <xref:System.ServiceModel.Channels.Message> y no devolver nada (es decir, devolver el valor `void`).  
  
> [!NOTE]
>  Un contrato de servicio sólo puede contar con una operación de servicio con la propiedad <xref:System.ServiceModel.OperationContractAttribute.Action%2A> establecida en "*." Cualquier grupo de contratos de servicios hospedados en el mismo listenUri que una clase de servicio implementa puede tener muchas operaciones de servicio con el <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propiedad establecida en "\*" cuando el <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propiedad está establecida en `false`. Sin embargo, solo una de estas operaciones de servicio puede tener la <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propiedad establecida en "\*" y el <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propiedad establecida en true. Para obtener más información, vea <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente es un servicio que utiliza las propiedades <xref:System.ServiceModel.OperationContractAttribute.Action%2A> y <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> para controlar explícitamente las acciones SOAP de los mensajes de entrada y salida (o respuesta), y la propiedad <xref:System.ServiceModel.OperationContractAttribute.Name%2A> para controlar el nombre de la operación en los metadatos. Finalmente, la aplicación también utiliza un valor <xref:System.ServiceModel.OperationContractAttribute.Action%2A> de "*" para indicar un método que administra los mensajes desconocidos.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 Un servicio que implementa este contrato envía mensajes que se parecen al ejemplo siguiente:  
  
 [!code-csharp[OperationContractAttribute_Properties#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The value is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncPattern">
      <MemberSignature Language="C#" Value="public bool AsyncPattern { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncPattern" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPattern As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AsyncPattern { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPattern : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.AsyncPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates that an operation is implemented asynchronously using a <see langword="Begin" />&lt;*methodName*&gt; and <see langword="End" />&lt;*methodName*&gt; method pair in a service contract.</summary>
        <value>
          <see langword="true" /> Si el <see langword="Begin" /> &lt;* methodName *&gt;método coincide con un <see langword="End" /> &lt;* methodName *&gt; método y se puede tratar la infraestructura como una operación que se implementa como una asincrónica par de métodos en la interfaz de servicio; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> para crear operaciones de servicio a las que se pueden llamar de forma asincrónica en el servidor, el cliente o ambos. La propiedad <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> informa al tiempo de ejecución que un método `Begin` tiene un método `End` con el que coincide y que se ajusta al patrón de diseño de método asincrónico de .NET Framework. Crear métodos asincrónicos de servidor que implementan una operación de servicio aumentan la escalabilidad del servidor y el rendimiento sin afectar a los clientes del servicio. Se recomiendan cuando una operación de servicio debe devolver algo al cliente después de realizar una operación larga que se puede realizar de forma asincrónica.  
  
 A los clientes no les afecta porque el par de métodos asincrónicos en el servidor es un detalle de implementación que no afecta a la descripción del lenguaje de descripción de servicios Web (WSDL) subyacente de la operación. Tales métodos aparecen en los clientes como una operación única con `<input>` y correlacionados `<output>` mensajes. WCF enruta automáticamente los mensajes entrantes a la `Begin` \< *methodName*> método y enruta los resultados de la `End` \< *methodName*> llamar a en el mensaje de salida. Por consiguiente, los canales del cliente pueden representar el par de método como una operación sincrónica o como un par de operaciones asincrónicas. En ningún caso la representación del cliente afecta a la implementación asincrónica en el servidor.  
  
 Los contratos del cliente pueden utilizar la propiedad <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A> para indicar un par de métodos asincrónicos que el cliente puede utilizar para invocar de forma asincrónica la operación. Normalmente, las aplicaciones cliente utilizan la [ServiceModel Metadata Utility Tool (Svcutil.exe)](~/docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) herramienta y el `/async` opción para generar un `Begin` \< *methodName*> y `End` \< *methodName*> par de métodos que el cliente puede utilizar para invocar la operación de forma asincrónica.  
  
> [!NOTE]
>  Si una operación de servicio tiene una versión asincrónica y otra sincrónica, el comportamiento predeterminado en el servicio será invocar la versión sincrónica.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra un canal de cliente a un contrato de servicio que incluye tanto una versión sincrónica de `Add` como una asincrónica. Si la interfaz de contrato se utiliza en el cliente, tanto la operación `BeginAdd` como la operación `Add` invocan un método en el servidor que puede ser o no ser sincrónico. Si el contrato se utiliza para implementar el servicio, el valor predeterminado es que las solicitudes entrantes se envían al método sincrónico.  
  
```csharp  
[ServiceContract]  
public interface IAddTwoNumbers  
{  
    // If the asynchronous method pair  
    // appears on the client channel, the client can call   
    // them asynchronously to prevent blocking.  
    [OperationContract (AsyncPattern=true)]  
    IAsyncResult BeginAdd(int a, int b, AsyncCallback cb, AsyncState s);  
  
    [OperationContract]  
    int EndAdd(IAsyncResult r);  
  
    // This is a synchronous version of the BeginAdd/EndAdd pair.  
    // It appears in the client channel code by default.   
    [OperationContract]  
    int Add(int a, int b);  
   }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasProtectionLevel">
      <MemberSignature Language="C#" Value="public bool HasProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasProtectionLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasProtectionLevel { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasProtectionLevel : bool" Usage="System.ServiceModel.OperationContractAttribute.HasProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the messages for this operation must be encrypted, signed, or both.</summary>
        <value>
          <see langword="true" /> si se define la propiedad <see cref="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" /> en un valor distinto de <see cref="F:System.Net.Security.ProtectionLevel.None" />; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.HasProtectionLevel%2A> para determinar si los mensajes de esta operación necesitan un nivel de protección concreto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitiating">
      <MemberSignature Language="C#" Value="public bool IsInitiating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitiating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInitiating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitiating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsInitiating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsInitiating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the method implements an operation that can initiate a session on the server (if such a session exists).</summary>
        <value>
          <see langword="true" /> si se permite a la operación iniciar una sesión en el servidor, de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> controla si una operación puede ser la primera operación a la que se llama cuando se crea una sesión.  
  
> [!NOTE]
>  El valor de <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType> debe ser <xref:System.ServiceModel.SessionMode.Allowed> o <xref:System.ServiceModel.SessionMode.Required> y el enlace utilizado debe requerir o permitir las sesiones para que la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> funcione correctamente.  
  
 El valor predeterminado es `true`, lo que significa que una operación puede ser la primera a la que se llame en un canal. Las siguientes llamadas al método de inicio no tienen otro efecto que llamar al método. No se crea ninguna otra sesión. Si el contrato no utiliza una sesión, se omitirá la definición de <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> en `false`.  
  
 Normalmente, define <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> en `false` para obligar a los clientes a llamar a otro método en el servicio antes de poder invocar a este. Por ejemplo, si su servicio tiene una serie de operaciones que dependen de un número de identificador de orden, puede establecer <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> en `true` para una operación de servicio `GetOrderId` y establecer todas las operaciones de servicio restantes en `false`. Esto garantiza que cada nuevo cliente obtiene un identificador de orden antes de utilizar los otros métodos expuestos por el servicio.  
  
> [!NOTE]
>  Hay una interacción entre <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> y la propiedad <xref:System.ServiceModel.OperationContractAttribute.Action%2A>. Un contrato de servicio sólo puede contar con una operación de servicio con la propiedad <xref:System.ServiceModel.OperationContractAttribute.Action%2A> establecida en "*." Cualquier grupo de contratos de servicios hospedados en el mismo ListenUri que una clase de servicio implementa puede tener muchas operaciones de servicio con el <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propiedad establecida en "\*" cuando el <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propiedad está establecida en `false`. Sin embargo, sólo uno de estos métodos de servicio puede tener la <xref:System.ServiceModel.OperationContractAttribute.Action%2A> propiedad establecida en "\*" y la <xref:System.ServiceModel.OperationContractAttribute.IsInitiating%2A> propiedad establecida en `true`.  
  
 Si un servicio recibe un mensaje para una operación que no se inicia, el servicio devuelve un error de SOAP ActionNotSupported. El cliente experimenta este hecho como <xref:System.ServiceModel.FaultException>. Si un cliente llama primero a una operación que no se inicia, el tiempo de ejecución del cliente inicia <xref:System.InvalidOperationException?displayProperty=nameWithType>.  
  
 Para obtener más información, consulte [mediante sesiones](~/docs/framework/wcf/using-sessions.md).  
  
   
  
## Examples  
 El ejemplo siguiente es un servicio que implementa un contrato de servicio que especifica tres métodos. El servicio requiere una sesión. Si la primera llamada de un autor de la llamada es a cualquier operación distinta de `MethodOne`, se rechaza el canal y se produce una excepción. Cuando un autor de la llamada inicia una sesión llamando a `MethodOne`, ese autor de la llamada puede terminar la sesión de comunicación en cualquier momento llamando a `MethodThree`. Se puede llamar a `MethodTwo` las veces que se quiera durante una sesión.  
  
```csharp  
[ServiceContract(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false,  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOneWay">
      <MemberSignature Language="C#" Value="public bool IsOneWay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOneWay" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOneWay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOneWay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOneWay : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsOneWay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether an operation returns a reply message.</summary>
        <value>
          <see langword="true" /> si este método recibe un mensaje de solicitud y no devuelve ningún mensaje de respuesta; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> para indicar que una operación no devuelve un mensaje de respuesta. Este tipo de operación es útil para notificaciones o comunicaciones de estilo del evento, sobre todo en comunicaciones bidireccionales. Sin esperar a un mensaje de respuesta subyacente, los autores de la llamada de operaciones unidireccionales no tienen ninguna manera directa de detectar un error al procesar el mensaje de solicitud. (Las aplicaciones de servicio que utilizan canales confiables y las operaciones unidireccionales pueden detectar un error en la entrega del mensaje en el nivel del canal. Para obtener más información, consulte [información general de las sesiones confiables](~/docs/framework/wcf/feature-details/reliable-sessions-overview.md).)  
  
 En aplicaciones orientadas a servicios dúplex (o bidireccionales) en que el cliente y el servidor se comunican entre sí independientemente, un canal de cliente puede utilizar la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> en sus métodos para indicar que el servicio puede realizar las llamadas unidireccionales al cliente que el cliente puede tratar como eventos. No se genera ninguna llamada o mensaje de devolución porque el servicio no espera ningún mensaje de respuesta.  
  
 Si la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> se establece en `false` (el valor predeterminado), incluso los métodos que devuelven `void` tienen como resultado un mensaje de respuesta. En este caso, la infraestructura crea y envía un mensaje vacío para indicar al autor de la llamada que se ha devuelto el método. (Utilizar este enfoque permite a la infraestructura devolver los errores de SOAP al cliente.) Establecer <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A> en `true` es la única manera de cancelar la creación y expedición de un mensaje de respuesta.  
  
 Los métodos unidireccionales no deben devolver un valor o tener parámetros `ref` o `out`; de lo contrario, se producirá una excepción <xref:System.InvalidOperationException?displayProperty=nameWithType>.  
  
 Especificar que una operación es unidireccional significa que no hay ningún mensaje de respuesta. Es posible bloquear si no se puede realizar una conexión, si el mensaje saliente es muy grande o si el servicio no puede leer la información entrante con la rapidez necesaria. Si un cliente requiere una llamada que no sea de bloqueo, genere las operaciones <xref:System.ServiceModel.OperationContractAttribute.AsyncPattern%2A>. Para obtener más información, consulte [servicios unidireccional](~/docs/framework/wcf/feature-details/one-way-services.md) y [servicios de acceso mediante un cliente WCF](~/docs/framework/wcf/feature-details/accessing-services-using-a-client.md).  
  
   
  
## Examples  
 El ejemplo siguiente es un servicio que implementa un contrato de servicio que especifica tres operaciones. Dos de los métodos implementan operaciones bidireccionales, que devuelven mensajes de respuesta subyacentes al autor de la llamada sin tener en cuenta el valor devuelto. El tercer método implementa una operación que recibe una llamada (un mensaje entrante subyacente) pero no devuelve ningún mensaje de respuesta subyacente.  
  
```csharp  
[ServiceContract]  
public class OneAndTwoWay  
{  
  // The client waits until a response message appears.  
  [OperationContract]  
  public int MethodOne (int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  // The client waits until an empty response message appears.  
  [OperationContract]  
  public void MethodTwo (int x)  
  {  
    return;  
  }  
  
  // The client returns as soon as an outbound message  
  // is queued for dispatch to the service; no response  
  // message is generated or sent.  
  [OperationContract(IsOneWay=true)]  
  public void MethodThree (int x)  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTerminating">
      <MemberSignature Language="C#" Value="public bool IsTerminating { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTerminating" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberSignature Language="VB.NET" Value="Public Property IsTerminating As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTerminating { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsTerminating : bool with get, set" Usage="System.ServiceModel.OperationContractAttribute.IsTerminating" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the service operation causes the server to close the session after the reply message, if any, is sent.</summary>
        <value>
          <see langword="true" /> si la operación provoca que el servidor cierre la sesión, de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> para indicar que al llamar a una operación de servicio, se finaliza la sesión de comunicación.  
  
 En una aplicación cliente, un valor de <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A> establecido en `true` indica a WCF que se cierre el canal después de que llegue la respuesta.  
  
 En un servicio, se establece un temporizador y el canal anula si el cliente no cierra el canal dentro de ese período.  
  
 Para obtener más información sobre el uso de esta propiedad con sesiones, vea [mediante sesiones](~/docs/framework/wcf/using-sessions.md).  
  
> [!NOTE]
>  Si el autor de la llamada está escuchando el evento <xref:System.ServiceModel.OperationContext.OperationCompleted?displayProperty=nameWithType> para una operación <xref:System.ServiceModel.OperationContractAttribute.IsTerminating%2A?displayProperty=nameWithType>, es posible bloquear cuando se reciba la respuesta. La manera adecuada de gestionar esto es programar el trabajo en otro subproceso cuando se llega a <xref:System.ServiceModel.OperationContext.OperationCompleted> y entonces devolver inmediatamente desde ese controlador de eventos.  
  
   
  
## Examples  
 El ejemplo siguiente es un servicio que implementa un contrato de servicio que especifica tres operaciones. El servicio requiere una conexión con estado. Si la primera llamada de un autor de la llamada es a cualquier operación distinta de `MethodOne`, se rechaza el canal y se produce una excepción. Cuando un autor de la llamada inicia una sesión llamando a `MethodOne`, ese autor de la llamada puede terminar la sesión de comunicación en cualquier momento llamando a `MethodThree`. Se puede llamar a `MethodTwo` las veces que se quiera durante una sesión.  
  
```csharp  
[ServiceContractAttribute(SessionMode=SessionMode.Required)]  
public class InitializeAndTerminateService  
{  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=true,  
    IsTerminating=false  
  )]  
  public void MethodOne()  
  {  
    return;  
  }  
  
  [OperationContract(  
    IsInitiating=false,  
    IsTerminating=false  
  )]  
  public int MethodTwo(int x, out int y)  
  {  
    y = 34;  
    return 0;  
  }  
  
  [OperationContract(  
    IsOneWay=true,  
    IsInitiating=false  
    IsTerminating=true  
  )]  
  public void MethodThree()  
  {  
    return;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the name of the operation.</summary>
        <value>Nombre de la operación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.ServiceModel.OperationContractAttribute.Name%2A> propiedad para reemplazar el <`operation`> nombre de elemento en WSDL. El nombre de la operación predeterminada es el nombre del método de implementación.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza la propiedad <xref:System.ServiceModel.OperationContractAttribute.Name%2A> para declarar el nombre de la operación tal y como se ha expuesto en los metadatos.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.Name" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is an empty string.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); void set(System::Net::Security::ProtectionLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel with get, set" Usage="System.ServiceModel.OperationContractAttribute.ProtectionLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether the messages of an operation must be encrypted, signed, or both.</summary>
        <value>Uno de los valores de <see cref="T:System.Net.Security.ProtectionLevel" />. De manera predeterminada, es <see cref="F:System.Net.Security.ProtectionLevel.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> para controlar si los mensajes de una operación deben cifrarse, firmarse o ambas cosas. El valor establecido aquí es el valor predeterminado para todos los mensajes especificados de esta operación, salvo que un ámbito más restringido lo invalide.  
  
 Es importante recordar que el comportamiento de protección en el tiempo de ejecución es la combinación de los valores de nivel de protección definidos en las propiedades siguientes. Estas propiedades tienen una estructura jerárquica. Al establecer el valor punto de conexión, se establece la configuración predeterminada para todos los ámbitos más restringidos a menos que se establezca un valor diferente para un ámbito más restringido explícitamente. En este caso, el valor externo sigue siendo el predeterminado para todos los ámbitos más restringidos con la excepción del definido específicamente.  
  
 Por ejemplo, si <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType> está establecido en <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType> y ningún otro ámbito más restringido tiene valores de nivel de protección, se cifrarán y firmarán todos los mensajes en un contrato de la operación. Si, sin embargo, una de esas operaciones tiene <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A> definido en <xref:System.Net.Security.ProtectionLevel.Sign?displayProperty=nameWithType>, se firmarán los mensajes para esa operación pero se cifrarán y firmarán todos los demás mensajes en el contrato.  
  
 Para obtener más información acerca de los niveles de protección y sus suposiciones y ámbitos, consulte [Understanding Protection Level](~/docs/framework/wcf/understanding-protection-level.md).  
  
 Los ámbitos en los que se establecen estos valores son:  
  
 <xref:System.ServiceModel.ServiceContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.OperationContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.FaultContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 <xref:System.ServiceModel.MessageContractAttribute.ProtectionLevel%2A?displayProperty=nameWithType>  
  
 La propiedad <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> en <xref:System.ServiceModel.MessageHeaderAttribute?displayProperty=nameWithType>.  
  
 La propiedad <xref:System.ServiceModel.MessageContractMemberAttribute.ProtectionLevel%2A?displayProperty=nameWithType> en <xref:System.ServiceModel.MessageBodyMemberAttribute?displayProperty=nameWithType>.  
  
 Cuando no se haya especificado de manera concreta ningún nivel de protección en el contrato y el enlace subyacente admita la seguridad (ya sea en el nivel de transporte o de mensaje), el nivel de protección efectivo para todo el contrato será <xref:System.Net.Security.ProtectionLevel.EncryptAndSign?displayProperty=nameWithType>. Si el enlace no admite la seguridad (como <xref:System.ServiceModel.BasicHttpBinding>), el <xref:System.Net.Security.ProtectionLevel?displayProperty=nameWithType> eficaz será <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType> para todo el contrato. El resultado será (en función del enlace del extremo) que los clientes pueden exigir una protección de nivel de seguridad diferente para los mensajes o el transporte aun cuando el contrato especifique <xref:System.Net.Security.ProtectionLevel.None?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The value is not one of the <see cref="T:System.Net.Security.ProtectionLevel" /> values.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReplyAction">
      <MemberSignature Language="C#" Value="public string ReplyAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ReplyAction" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberSignature Language="VB.NET" Value="Public Property ReplyAction As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ReplyAction { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReplyAction : string with get, set" Usage="System.ServiceModel.OperationContractAttribute.ReplyAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the SOAP action for the reply message of the operation.</summary>
        <value>El valor de la acción de SOAP para el mensaje de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de especificar un valor en concreto para el encabezado de la acción del mensaje de respuesta, también puede especificar la cadena "*" (un asterisco). Especificar un asterisco en el servicio indica a WCF no para agregar una acción de respuesta al mensaje, lo que resulta útil si está programando directamente contra los mensajes. Especificar un asterisco en una aplicación cliente indica a WCF no para validar la acción de respuesta.  
  
   
  
## Examples  
 El ejemplo siguiente es un servicio que utiliza las propiedades <xref:System.ServiceModel.OperationContractAttribute.Action%2A> y <xref:System.ServiceModel.OperationContractAttribute.ReplyAction%2A> para controlar de manera explícita las acciones de SOAP de los mensajes entrantes y salientes (o de respuesta). También utiliza la propiedad <xref:System.ServiceModel.OperationContractAttribute.Name%2A> para declarar el nombre de la operación tal y como se ha expuesto en los metadatos.  
  
 [!code-csharp[OperationContractAttribute_Properties#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationcontractattribute_properties/cs/services.cs#1)]
 [!code-vb[OperationContractAttribute_Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationcontractattribute_properties/vb/services.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.ServiceModel.OperationContractAttribute.ReplyAction" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>