<Type Name="NetTcpBinding" FullName="System.ServiceModel.NetTcpBinding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e3e6c4f9479d92697c2efbcd29dcb045d6d17253" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37452822" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class NetTcpBinding : System.ServiceModel.Channels.Binding, System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit NetTcpBinding extends System.ServiceModel.Channels.Binding implements class System.ServiceModel.Channels.IBindingRuntimePreferences" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.NetTcpBinding" />
  <TypeSignature Language="VB.NET" Value="Public Class NetTcpBinding&#xA;Inherits Binding&#xA;Implements IBindingRuntimePreferences" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetTcpBinding : System::ServiceModel::Channels::Binding, System::ServiceModel::Channels::IBindingRuntimePreferences" />
  <TypeSignature Language="F#" Value="type NetTcpBinding = class&#xA;    inherit Binding&#xA;    interface IBindingRuntimePreferences" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.Binding</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Channels.IBindingRuntimePreferences</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Un enlace seguro y confiable adecuado para la comunicación entre equipos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.NetTcpBinding> genera de forma predeterminada una pila de comunicación en tiempo de ejecución que utiliza la seguridad de transporte, TCP para la entrega del mensaje, y una codificación de mensajes binaria. Este enlace es una opción adecuada de proporcionado por el sistema de Windows Communication Foundation (WCF) para comunicarse a través de una Intranet.  
  
 La configuración predeterminada para el <xref:System.ServiceModel.NetTcpBinding> es más rápido que la configuración proporcionada por el <xref:System.ServiceModel.WSHttpBinding>, pero está pensada solo para la comunicación de WCF. El comportamiento de seguridad es configurable mediante el parámetro opcional `securityMode` en el constructor. El uso de WS-ReliableMessaging es configurable utilizando el parámetro `reliableSessionEnabled` opcional. Pero la mensajería de confianza está apagada de forma predeterminada. Más generalmente, los enlaces proporcionados por el sistema HTTP como <xref:System.ServiceModel.WSHttpBinding> y <xref:System.ServiceModel.BasicHttpBinding> se configuran para activar de forma predeterminada las cosas, mientras que el enlace <xref:System.ServiceModel.NetTcpBinding> desactiva de forma predeterminada las cosas para que tenga que inscribirse para obtener compatibilidad, por ejemplo, para una de las especificaciones de WS-*. Esto significa que la configuración predeterminada para TCP es más rápida en intercambiar los mensajes entre los extremos que la configurada de forma predeterminada para los enlaces HTTP.  
  
> [!WARNING]
>  El <xref:System.ServiceModel.NetTcpBinding> utiliza la agrupación de conexiones TCP en función del servicio de host nombre DNS y el servicio está escuchando en el número de puerto. Esto funciona bien cuando un cliente realiza llamadas a diferentes servicios en puertos diferentes o servicios se hospedan en un único proceso y compartan un puerto. Si un solo cliente llama a varios servicios de uso compartido de un puerto que se hospedan en procesos diferentes, o que son WAS / IIS hospedada, la agrupación del lado cliente puede dar lugar a problemas donde se reutiliza una conexión a un servicio para el servicio B, lo que produce una excepción , la conexión anulada y un nuevo canal creado. Para evitar este problema, utilice un enlace CustomBinding y especifique un ConnectionPoolSettings.GroupName diferente para cada servicio que el cliente se comunica con.  
  
   
  
## Examples  
 En este ejemplo se cómo crear <xref:System.ServiceModel.NetTcpBinding> estableciendo el modo de seguridad y el tipo de credencial de transporte.  
  
 [!code-csharp[S_UENetTcpBinding#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.NetTcpBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de seguridad es configurable mediante el parámetro opcional `securityMode` en el constructor. El uso de WS-ReliableMessaging es configurable utilizando el parámetro `reliableSessionEnabled` opcional.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.NetTcpBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, la seguridad de transporte se utiliza para proteger la comunicación (es decir, el valor de <xref:System.ServiceModel.SecurityMode> se establece en <xref:System.ServiceModel.SecurityMode.Transport>) y las sesiones confiables están deshabilitadas (es decir, <xref:System.ServiceModel.OptionalReliableSession.Enabled%2A> es `false`).  
  
   
  
## Examples  
 En este ejemplo se cómo crear <xref:System.ServiceModel.NetTcpBinding> estableciendo el modo de seguridad y el tipo de credencial de transporte.  
  
 [!code-csharp[S_UENETTCPBINDING#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (System.ServiceModel.SecurityMode securityMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.SecurityMode securityMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.ServiceModel.SecurityMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::ServiceModel::SecurityMode securityMode);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : System.ServiceModel.SecurityMode -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding securityMode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.SecurityMode" />
      </Parameters>
      <Docs>
        <param name="securityMode">Valor <see cref="T:System.ServiceModel.SecurityMode" /> que especifica el tipo de seguridad utilizado con el enlace.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.ServiceModel.NetTcpBinding" /> con el tipo de seguridad utilizado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor cuando desee configurar la seguridad. Si desea configurar la seguridad y habilitar las sesiones confiables, utilice <xref:System.ServiceModel.NetTcpBinding.%23ctor%28System.ServiceModel.SecurityMode%2CSystem.Boolean%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Este ejemplo muestra cómo crear <xref:System.ServiceModel.NetTcpBinding> mediante el parámetro de modo de seguridad.  
  
 [!code-csharp[S_UENETTCPBINDING#3](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (string configurationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string configurationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (configurationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::String ^ configurationName);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : string -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding configurationName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="configurationName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="configurationName">Nombre de configuración del enlace para <see cref="T:System.ServiceModel.NetTcpBinding" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.ServiceModel.NetTcpBinding" /> con el nombre de configuración especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si desea inicializar los valores de enlace desde la configuración.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo crear un <xref:System.ServiceModel.NetTcpBinding> mediante el parámetro `configurationName`.  
  
 [!code-csharp[S_UENETTCPBINDING#4](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetTcpBinding (System.ServiceModel.SecurityMode securityMode, bool reliableSessionEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ServiceModel.SecurityMode securityMode, bool reliableSessionEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.#ctor(System.ServiceModel.SecurityMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetTcpBinding(System::ServiceModel::SecurityMode securityMode, bool reliableSessionEnabled);" />
      <MemberSignature Language="F#" Value="new System.ServiceModel.NetTcpBinding : System.ServiceModel.SecurityMode * bool -&gt; System.ServiceModel.NetTcpBinding" Usage="new System.ServiceModel.NetTcpBinding (securityMode, reliableSessionEnabled)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityMode" Type="System.ServiceModel.SecurityMode" />
        <Parameter Name="reliableSessionEnabled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="securityMode">Valor <see cref="T:System.ServiceModel.SecurityMode" /> que especifica el tipo de seguridad utilizado con el enlace.</param>
        <param name="reliableSessionEnabled">
          <see langword="true" /> si se habilitan sesiones de confianza; de lo contrario, <see langword="false" />.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.ServiceModel.NetTcpBinding" /> con el tipo de seguridad utilizado especificado, y con un valor que indica si se habilitan explícitamente las sesiones de confianza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor si desea configurar la seguridad y habilitar las sesiones de confianza.  
  
   
  
## Examples  
 Este ejemplo muestra cómo crear <xref:System.ServiceModel.NetTcpBinding> mediante los parámetros `securityMode` y `reliableSessionEnabled`.  
  
 [!code-csharp[S_UENETTCPBINDING#5](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateBindingElements">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElementCollection CreateBindingElements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElementCollection CreateBindingElements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.CreateBindingElements" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateBindingElements () As BindingElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ServiceModel::Channels::BindingElementCollection ^ CreateBindingElements();" />
      <MemberSignature Language="F#" Value="override this.CreateBindingElements : unit -&gt; System.ServiceModel.Channels.BindingElementCollection" Usage="netTcpBinding.CreateBindingElements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElementCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una colección con los elementos de enlace para el enlace.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.ICollection`1" /> de tipo <see cref="T:System.ServiceModel.Channels.BindingElement" /> que constituye el enlace.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo muestra cómo utilizar el método <xref:System.ServiceModel.NetTcpBinding.CreateBindingElements%2A> para crear una colección con los elementos de enlace para el enlace.  
  
 [!code-csharp[S_UENetTcpBinding#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnvelopeVersion">
      <MemberSignature Language="C#" Value="public System.ServiceModel.EnvelopeVersion EnvelopeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.EnvelopeVersion EnvelopeVersion" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.EnvelopeVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EnvelopeVersion As EnvelopeVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::EnvelopeVersion ^ EnvelopeVersion { System::ServiceModel::EnvelopeVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnvelopeVersion : System.ServiceModel.EnvelopeVersion" Usage="System.ServiceModel.NetTcpBinding.EnvelopeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.EnvelopeVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la versión de SOAP que se utiliza para los mensajes procesados por este enlace.</summary>
        <value>El valor de <see cref="T:System.ServiceModel.EnvelopeVersion" /> que se utiliza con este enlace. El valor es SOAP 1.2.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad devuelve siempre SOAP 1.2. Este valor no puede modificarse.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.EnvelopeVersion%2A>.  
  
 [!code-csharp[S_UENETTCPBINDING#6](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HostNameComparisonMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.HostNameComparisonMode HostNameComparisonMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.HostNameComparisonMode HostNameComparisonMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.HostNameComparisonMode" />
      <MemberSignature Language="VB.NET" Value="Public Property HostNameComparisonMode As HostNameComparisonMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::HostNameComparisonMode HostNameComparisonMode { System::ServiceModel::HostNameComparisonMode get(); void set(System::ServiceModel::HostNameComparisonMode value); };" />
      <MemberSignature Language="F#" Value="member this.HostNameComparisonMode : System.ServiceModel.HostNameComparisonMode with get, set" Usage="System.ServiceModel.NetTcpBinding.HostNameComparisonMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.HostNameComparisonMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el nombre del host se usa para alcanzar el servicio al coincidir con el URI.</summary>
        <value>Uno de los valores <see cref="P:System.ServiceModel.Configuration.WSDualHttpBindingElement.HostNameComparisonMode" /> que indica si el nombre del host se utiliza para alcanzar el servicio cuando coincide con el URI. El valor predeterminado es <see cref="F:System.ServiceModel.HostNameComparisonMode.StrongWildcard" />, que omite el nombre del host en la coincidencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.HostNameComparisonMode%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#7](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListenBacklog">
      <MemberSignature Language="C#" Value="public int ListenBacklog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ListenBacklog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Property ListenBacklog As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ListenBacklog { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ListenBacklog : int with get, set" Usage="System.ServiceModel.NetTcpBinding.ListenBacklog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de solicitudes de conexión en cola que pueden estar pendientes.</summary>
        <value>Devuelve el número máximo de solicitudes de conexión en cola pendientes. El valor predeterminado es 10.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.Channels.TcpTransportBindingElement.ListenBacklog%2A> es una propiedad del nivel del socket que describe el número de solicitudes "pendientes de aceptación" que se van a poner en cola. Si la cola de trabajos pendientes de escucha se llena, las nuevas solicitudes de socket se rechazarán.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.ListenBacklog%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#8](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no puede ser menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferPoolSize">
      <MemberSignature Language="C#" Value="public long MaxBufferPoolSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxBufferPoolSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxBufferPoolSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferPoolSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxBufferPoolSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferPoolSize : int64 with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxBufferPoolSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo permitido, en bytes, para un grupo de búferes que almacena mensajes TCP procesados por el enlace.</summary>
        <value>Tamaño máximo permitido para un grupo de búferes que almacena mensajes TCP procesados por el enlace. El valor predeterminado es 524.288 bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si recibe más datos de los que puede almacenar en búfer, los datos que superan el tamaño del búfer se quedan en el socket subyacente hasta que su búfer tenga sitio para el resto de los datos.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.MaxBufferPoolSize%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#9](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxBufferSize">
      <MemberSignature Language="C#" Value="public int MaxBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxBufferSize : int with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica el tamaño máximo, en bytes, del búfer usado para almacenar los mensajes en memoria.</summary>
        <value>El tamaño máximo (en bytes) del búfer usado para almacenar mensajes en memoria. El valor predeterminado es 65.536 bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si recibe más datos de los que puede almacenar en búfer, los datos que superan el tamaño del búfer se quedan en el socket subyacente hasta que su búfer tenga sitio para el resto de los datos.  
  
   
  
## Examples  
 Este ejemplo muestra cómo obtener el valor de <xref:System.ServiceModel.NetTcpBinding.MaxBufferSize%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#10](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxConnections">
      <MemberSignature Language="C#" Value="public int MaxConnections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxConnections" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxConnections" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxConnections As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxConnections { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxConnections : int with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que controla el número máximo de conexiones que se van a agrupar para su reutilización subsiguiente en el cliente y el número máximo de conexiones que pueden estar pendientes de envío en el servidor.</summary>
        <value>En el cliente, el número máximo de conexiones que se van a agrupar para su reutilización subsiguiente; en el servidor, el número máximo de conexiones que pueden estar pendientes de envío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor predeterminado es 10.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.MaxConnections%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#11](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxReceivedMessageSize">
      <MemberSignature Language="C#" Value="public long MaxReceivedMessageSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxReceivedMessageSize" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxReceivedMessageSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxReceivedMessageSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxReceivedMessageSize : int64 with get, set" Usage="System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tamaño máximo, en bytes, para un mensaje recibido que el enlace procesa.</summary>
        <value>El tamaño máximo, en bytes, para un mensaje recibido que el enlace procesa. El valor predeterminado es 65.536 bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortSharingEnabled">
      <MemberSignature Language="C#" Value="public bool PortSharingEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PortSharingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.PortSharingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PortSharingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PortSharingEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PortSharingEnabled : bool with get, set" Usage="System.ServiceModel.NetTcpBinding.PortSharingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el uso compartido de puerto TCP está habilitado para la conexión configurada con este enlace.</summary>
        <value>
          <see langword="true" /> si está habilitado el uso compartido de puerto TCP; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con esta configuración requiere la habilitación del servicio de uso compartido de puerto TCP de Windows Communication Foundation (WCF), cambiando su tipo de inicio a Manual o automático.  
  
 Para obtener más información sobre el agente de escucha TCP y cómo iniciarlo, vea <xref:System.Net.Sockets.TcpListener>.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.PortSharingEnabled%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReaderQuotas">
      <MemberSignature Language="C#" Value="public System.Xml.XmlDictionaryReaderQuotas ReaderQuotas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDictionaryReaderQuotas ReaderQuotas" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Property ReaderQuotas As XmlDictionaryReaderQuotas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlDictionaryReaderQuotas ^ ReaderQuotas { System::Xml::XmlDictionaryReaderQuotas ^ get(); void set(System::Xml::XmlDictionaryReaderQuotas ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReaderQuotas : System.Xml.XmlDictionaryReaderQuotas with get, set" Usage="System.ServiceModel.NetTcpBinding.ReaderQuotas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDictionaryReaderQuotas</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece restricciones en la complejidad de mensajes SOAP que pueden ser procesados por puntos de conexión configurados con este enlace.</summary>
        <value>
          <see cref="T:System.Xml.XmlDictionaryReaderQuotas" /> que especifica las restricciones de complejidad en los mensajes SOAP intercambiados. Los valores predeterminados para estas restricciones se proporcionan en la sección Notas siguiente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las restricciones de complejidad protegen contra una clase de ataques por denegación de servicio (DOS) que intentan usar la complejidad de los mensajes para congestionar los recursos de procesamiento de los puntos de conexión. Las propiedades que expresan estas restricciones y sus valores predeterminados son las siguientes:  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> = 32  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> = 8192  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> = 16384  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> = 4096  
  
-   <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A> = 16384  
  
   
  
## Examples  
 En el siguiente ejemplo de código se muestra cómo obtener el objeto <xref:System.ServiceModel.NetTcpBinding.ReaderQuotas%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReliableSession">
      <MemberSignature Language="C#" Value="public System.ServiceModel.OptionalReliableSession ReliableSession { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.OptionalReliableSession ReliableSession" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.ReliableSession" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReliableSession As OptionalReliableSession" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::OptionalReliableSession ^ ReliableSession { System::ServiceModel::OptionalReliableSession ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReliableSession : System.ServiceModel.OptionalReliableSession" Usage="System.ServiceModel.NetTcpBinding.ReliableSession" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.OptionalReliableSession</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que indica si se establece una sesión confiable entre los puntos de conexión del canal.</summary>
        <value>
          <see cref="T:System.ServiceModel.OptionalReliableSession" /> que indica si se establece una sesión confiable WS-RM entre los extremos del canal. El valor predeterminado de <see cref="P:System.ServiceModel.OptionalReliableSession.Enabled" /> es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.ReliableSession%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public override string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Scheme : string" Usage="System.ServiceModel.NetTcpBinding.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve el esquema URI para el transporte.</summary>
        <value>Esquema del URI para el transporte, que es "net.tcp."</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La propiedad se proporciona para validar los enlaces contra las direcciones base.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.Scheme%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Security">
      <MemberSignature Language="C#" Value="public System.ServiceModel.NetTcpSecurity Security { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.NetTcpSecurity Security" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.Security" />
      <MemberSignature Language="VB.NET" Value="Public Property Security As NetTcpSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::NetTcpSecurity ^ Security { System::ServiceModel::NetTcpSecurity ^ get(); void set(System::ServiceModel::NetTcpSecurity ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Security : System.ServiceModel.NetTcpSecurity with get, set" Usage="System.ServiceModel.NetTcpBinding.Security" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.NetTcpSecurity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que especifica el tipo de seguridad utilizado con servicios configurados con este enlace.</summary>
        <value>
          <see cref="T:System.ServiceModel.NetTcpSecurity" /> que contiene los tipos de seguridad utilizados con este enlace. El modo de seguridad predeterminado para el enlace <see langword="NetTCPBinding" /> es <see cref="F:System.ServiceModel.SecurityMode.Transport" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceModel.NetTcpSecurity> proporciona los tipos de seguridad y valores disponibles para <xref:System.ServiceModel.NetTcpBinding>.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.Security%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeListenBacklog">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeListenBacklog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeListenBacklog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeListenBacklog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeListenBacklog () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeListenBacklog();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeListenBacklog : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeListenBacklog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ListenBacklog" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ListenBacklog" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeMaxConnections">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeMaxConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeMaxConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeMaxConnections" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeMaxConnections () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeMaxConnections();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeMaxConnections : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeMaxConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.MaxConnections" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.MaxConnections" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReaderQuotas">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReaderQuotas ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReaderQuotas() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeReaderQuotas" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReaderQuotas () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReaderQuotas();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReaderQuotas : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeReaderQuotas " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ReaderQuotas" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReliableSession">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReliableSession ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReliableSession() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeReliableSession" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReliableSession () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReliableSession();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReliableSession : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeReliableSession " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ReliableSession" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.ReliableSession" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSecurity">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeSecurity" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeSecurity () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeSecurity();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSecurity : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeSecurity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.Security" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.Security" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionProtocol">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionProtocol ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionProtocol() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.NetTcpBinding.ShouldSerializeTransactionProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionProtocol () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionProtocol();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionProtocol : unit -&gt; bool" Usage="netTcpBinding.ShouldSerializeTransactionProtocol " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously">
      <MemberSignature Language="C#" Value="bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.System#ServiceModel#Channels#IBindingRuntimePreferences#ReceiveSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ReceiveSynchronously As Boolean Implements IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ServiceModel.NetTcpBinding.System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.Channels.IBindingRuntimePreferences.ReceiveSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si las solicitudes de entrada se administran de forma sincrónica o asincrónica.</summary>
        <value>
          <see langword="true" /> si se administran las solicitudes entrantes sincrónicamente; <see langword="false" /> si se administran las solicitudes entrantes de forma asincrónica. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comportamiento en tiempo de ejecución para recibir los mensajes en un servicio o aplicación cliente puede cambiarse con [ &lt;synchronousReceive&gt;](~/docs/framework/configure-apps/file-schema/wcf/synchronousreceive-element.md).  
  
   
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.TransferMode%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionFlow">
      <MemberSignature Language="C#" Value="public bool TransactionFlow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionFlow" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransactionFlow" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionFlow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionFlow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionFlow : bool with get, set" Usage="System.ServiceModel.NetTcpBinding.TransactionFlow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que determina si se ha habilitado el flujo de transacciones.</summary>
        <value>
          <see langword="true" /> si el flujo de transacciones está habilitado; de lo contrario <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.TransactionFlow%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionProtocol">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransactionProtocol TransactionProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.TransactionProtocol TransactionProtocol" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransactionProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionProtocol As TransactionProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransactionProtocol ^ TransactionProtocol { System::ServiceModel::TransactionProtocol ^ get(); void set(System::ServiceModel::TransactionProtocol ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionProtocol : System.ServiceModel.TransactionProtocol with get, set" Usage="System.ServiceModel.NetTcpBinding.TransactionProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransactionProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el protocolo de transacciones utilizado por el servicio para el flujo de transacciones.</summary>
        <value>El <see cref="T:System.ServiceModel.TransactionProtocol" /> utilizado por el servicio para el flujo de transacciones.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.TransactionProtocol%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransferMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.TransferMode TransferMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.TransferMode TransferMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.NetTcpBinding.TransferMode" />
      <MemberSignature Language="VB.NET" Value="Public Property TransferMode As TransferMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::TransferMode TransferMode { System::ServiceModel::TransferMode get(); void set(System::ServiceModel::TransferMode value); };" />
      <MemberSignature Language="F#" Value="member this.TransferMode : System.ServiceModel.TransferMode with get, set" Usage="System.ServiceModel.NetTcpBinding.TransferMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.NetTcp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.TransferMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor  que indica si el servicio configurado con el enlace utiliza modos de transmisión o de almacenamiento en búfer (o ambos) para transferir los mensajes.</summary>
        <value>Valor de <see cref="T:System.ServiceModel.TransferMode" /> que indica si el servicio configurado con el enlace utiliza modos de transmisión o de almacenamiento en búfer (o ambos) para la transferencia de los mensajes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En este ejemplo se muestra cómo obtener el valor <xref:System.ServiceModel.NetTcpBinding.TransferMode%2A>.  
  
 [!code-csharp[S_UENetTcpBinding#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_uenettcpbinding/cs/source.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>