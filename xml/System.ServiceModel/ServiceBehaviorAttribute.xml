<Type Name="ServiceBehaviorAttribute" FullName="System.ServiceModel.ServiceBehaviorAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="520777697799b1acc1f55e252818e7067ccfb7a4" /><Meta Name="ms.sourcegitcommit" Value="93667418e6e77da6ba7109a407c61b8969cec4ec" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="07/05/2019" /><Meta Name="ms.locfileid" Value="67570940" /></Metadata><TypeSignature Language="C#" Value="public sealed class ServiceBehaviorAttribute : Attribute, System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ServiceBehaviorAttribute extends System.Attribute implements class System.ServiceModel.Description.IServiceBehavior" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceBehaviorAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ServiceBehaviorAttribute&#xA;Inherits Attribute&#xA;Implements IServiceBehavior" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBehaviorAttribute sealed : Attribute, System::ServiceModel::Description::IServiceBehavior" />
  <TypeSignature Language="F#" Value="type ServiceBehaviorAttribute = class&#xA;    inherit Attribute&#xA;    interface IServiceBehavior" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IServiceBehavior</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Especifica el comportamiento de ejecución interno de una implementación de contrato de servicio.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplique el atributo <xref:System.ServiceModel.ServiceBehaviorAttribute> a una implementación del servicio para especificar el comportamiento de ejecución de todo el servicio. (Para especificar el comportamiento de ejecución en el nivel de método, utilice el atributo <xref:System.ServiceModel.OperationBehaviorAttribute>.) Este atributo sólo se puede aplicar a las implementaciones de servicio. Para obtener ejemplos, vea el [Service: Ejemplos de comportamientos](https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)).  
  
 <xref:System.ServiceModel.ServiceBehaviorAttribute> las propiedades son una característica del modelo de programación de Windows Communication Foundation (WCF) que habilita características comunes que los desarrolladores en caso contrario, tienen que implementar. Para obtener más información sobre estos y otros comportamientos, vea [especificar el comportamiento de tiempo de ejecución de servicio](~/docs/framework/wcf/specifying-service-run-time-behavior.md). Para obtener más información acerca de las propiedades en tiempo de ejecución subyacente que algunas de las siguientes propiedades definidas, consulte el artículo [Extending ServiceHost y la capa del modelo de servicio](~/docs/framework/wcf/extending/extending-servicehost-and-the-service-model-layer.md).  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> especifica el tipo de filtro que el sistema del distribuidor utiliza para buscar el punto de conexión que administra las solicitudes.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> cierra automáticamente la sesión cuando se cierra el canal y el servicio ha acabado de procesar todos los mensajes restantes.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> controla el modelo de subprocesos interno, habilitando la compatibilidad para los servicios reentrantes o multiproceso.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> se utiliza para declarar un nombre para su utilización en el atributo `name` del elemento `<service>` en un archivo de configuración.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> permite que el tiempo de ejecución omita información de serialización adicional que no se exige para procesar el mensaje.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> especifica si las excepciones no controladas de un servicio se devuelven como errores SOAP. Esto se hace sólo con fines de depuración.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> especifica si los servicios y sus objetos de servicio serán reciclados durante un intercambio con un cliente y cuándo lo serán.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> para limitar el número de elementos en un gráfico de objetos que se serializan.  
  
-   Las propiedades <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> y <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> controlan el nombre y el espacio de nombres de la expresión WSDL del elemento de servicio.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> especifica si el objeto de servicio se recicla cuando se completa una transacción.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> especifica si se completan las transacciones pendientes cuando la sesión se cierra.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> especifica el nivel del aislamiento de transacción que el contrato admite.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> especifica el período de tiempo dentro del que una nueva transacción creada en el servicio debe completarse o se anula.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> indica si sincronizar automáticamente las llamadas al método entrantes con el subproceso de la interfaz de usuario.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> informa al sistema sobre si debe confirmar que los encabezados SOAP marcados como `MustUnderstand` han sido, de hecho, entendidos.  
  
 La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> también se puede establecer mediante un archivo de configuración de aplicación. Para obtener información detallada, vea <xref:System.ServiceModel.Description.ServiceDebugBehavior.IncludeExceptionDetailInFaults%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestran las propiedades <xref:System.ServiceModel.ServiceBehaviorAttribute>. La clase `BehaviorService` utiliza el atributo <xref:System.ServiceModel.ServiceBehaviorAttribute> para indicar que:  
  
-   Se recicla el objeto de servicio cuando se completa la transacción.  
  
-   Hay un objeto de servicio para cada sesión.  
  
-   La instancia del servicio es de subproceso único y no admite llamadas reentrantes.  
  
 Además, en el nivel de la operación, los valores <xref:System.ServiceModel.OperationBehaviorAttribute> indican que el método `TxWork` da de alta automáticamente las transacciones de flujo o crea una transacción nueva para hacer el trabajo y que se confirma la transacción automáticamente si no se produce una excepción no controlada.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 El enlace subyacente debe admitir transacciones de flujo para que el ejemplo de código siguiente se ejecute correctamente. Para admitir transacciones de flujo con <xref:System.ServiceModel.WSHttpBinding>, por ejemplo, establezca la propiedad <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> como `true` en el código o en un archivo de configuración de la aplicación. El ejemplo de código siguiente muestra el archivo de configuración para el ejemplo anterior:  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceModel.OperationBehaviorAttribute" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms751453(v=vs.90)">Servicio: Ejemplo de comportamientos</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBehaviorAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBehaviorAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.ServiceBehaviorAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores predeterminados de <xref:System.ServiceModel.ServiceBehaviorAttribute> son:  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode%2A> se establece como <xref:System.ServiceModel.AddressFilterMode.Exact>.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> es `true`.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> se establece como <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName%2A> es el nombre calificado con el espacio de nombres del tipo sin la información de ensamblado.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> es `false`.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> se establece como 64 KB.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.Name%2A> es el nombre del tipo de servicio sin espacio de nombres ni información de ensamblado.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.Namespace%2A> es `"http://tempuri.org"`.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> es `true`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> es `false`.  
  
-   <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> es `true`.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose%2A> es `false`.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel%2A> es <xref:System.Transactions.IsolationLevel.Unspecified>.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout%2A> se establece en <xref:System.TimeSpan.Zero>.  
  
-   La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> es `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddressFilterMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.AddressFilterMode AddressFilterMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.AddressFilterMode AddressFilterMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AddressFilterMode As AddressFilterMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::AddressFilterMode AddressFilterMode { System::ServiceModel::AddressFilterMode get(); void set(System::ServiceModel::AddressFilterMode value); };" />
      <MemberSignature Language="F#" Value="member this.AddressFilterMode : System.ServiceModel.AddressFilterMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AddressFilterMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.AddressFilterMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="T:System.ServiceModel.AddressFilterMode" /> utilizado por el distribuidor para enrutar los mensajes entrantes al punto final correcto.</summary>
        <value>El objeto <see cref="T:System.ServiceModel.AddressFilterMode" /> utilizado por el distribuidor para enrutar los mensajes entrantes al punto de conexión correcto.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no es uno de los valores de <see cref="T:System.ServiceModel.AddressFilterMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutomaticSessionShutdown">
      <MemberSignature Language="C#" Value="public bool AutomaticSessionShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutomaticSessionShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property AutomaticSessionShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutomaticSessionShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutomaticSessionShutdown : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica si cerrar automáticamente una sesión cuando un cliente cierra una sesión de salida.</summary>
        <value><see langword="true" /> si los servicios cierran automáticamente una sesión cuando el cliente cierra una sesión de salida; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De manera predeterminada, cuando un cliente cierra una sesión de salida y el servicio ha acabado de procesar todos los mensajes restantes, el servidor cierra la sesión. Al establecer <xref:System.ServiceModel.ServiceBehaviorAttribute.AutomaticSessionShutdown%2A> como `false` se evita que el servidor cierre automáticamente la sesión y habilita el control personalizado de la duración de la sesión.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcurrencyMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.ConcurrencyMode ConcurrencyMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.ConcurrencyMode ConcurrencyMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ConcurrencyMode As ConcurrencyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::ConcurrencyMode ConcurrencyMode { System::ServiceModel::ConcurrencyMode get(); void set(System::ServiceModel::ConcurrencyMode value); };" />
      <MemberSignature Language="F#" Value="member this.ConcurrencyMode : System.ServiceModel.ConcurrencyMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.ConcurrencyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece si un servicio admite un subproceso, varios subprocesos o llamadas reentrantes.</summary>
        <value>Uno de los valores de <see cref="T:System.ServiceModel.ConcurrencyMode" />; el valor predeterminado es <see cref="F:System.ServiceModel.ConcurrencyMode.Single" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica si una instancia de un servicio puede administrar un subproceso o varios subprocesos que se ejecutan de forma simultánea y, si es de un único subproceso, si se admite la reentrada.  
  
> [!NOTE]
>  La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> interactúa con algunos otros valores. Por ejemplo, si el valor <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> está establecido como <xref:System.ServiceModel.InstanceContextMode.Single>, el resultado será que su servicio sólo puede procesar un mensaje a la vez a menos que también establezca el valor de <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> como <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Esta propiedad también genera comportamiento en combinación con la propiedad <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Para obtener más información, consulte [sesiones, Instancing y simultaneidad](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 Al establecer <xref:System.ServiceModel.ConcurrencyMode> como <xref:System.ServiceModel.ConcurrencyMode.Single> se le indica al sistema que restrinja las instancias del servicio a un subproceso de ejecución de cada vez, lo que lo libera de problemas con los subprocesos. Un valor de <xref:System.ServiceModel.ConcurrencyMode.Multiple> indica que varios subprocesos pueden ejecutar los objetos de servicio en cualquier momento. En este caso, debe garantizar la seguridad para subprocesos.  
  
 <xref:System.ServiceModel.ConcurrencyMode.Reentrant> También restringe el acceso a un único subproceso cada vez; mientras la operación está procesando, ningún otro mensaje puede escribir la operación. Si durante la operación se va una llamada a otro servicio, el mensaje actual pierde el bloqueo en la operación, que es libre de procesar otros mensajes. Cuando la llamada del servicio regresa, se restablece el bloqueo y el mensaje original puede seguir procesándose hasta su conclusión o hasta que se produzca otra llamada fuera de la operación.  
  
> [!IMPORTANT]
>  Aunque <xref:System.ServiceModel.ConcurrencyMode.Single> restringe las instancias de servicio en un subproceso de ejecución a la vez, también debe establecer <xref:System.ServiceModel.Description.ServiceThrottlingBehavior.MaxConcurrentCalls%2A> en 1 para no garantizar ningún mensaje de desorden.  
>   
>  Además, es su responsabilidad dejar un estado de objetos coherente antes de las llamadas y debe confirmar que los datos locales de operación sean válidas después de las llamadas. Tenga en cuenta que la instancia del servicio solo se desbloquea llamando a otro servicio a través de un canal de WCF. En este caso, el servicio al que se ha llamado puede reentrar al primer servicio mediante una devolución de llamada. Si el primer servicio no es reentrante, la secuencia de llamadas resulta en un interbloqueo. Para obtener información detallada, vea <xref:System.ServiceModel.ConcurrencyMode>.  
  
 Durante cualquier llamada saliente de una operación del procesamiento, se pueden modificar los datos que no son locales de la operación. (Se garantiza que los datos de estado locales son válidos cuando el mensaje original reanuda el proceso.) Como resultado, antes de la llamada saliente debe garantizar que los datos no locales sean válidos para otras llamadas de entrada y volver a validar los datos no locales después de que regrese la llamada saliente.  
  
 El pseudocódigo siguiente muestra el modelo necesario para la compatibilidad reentrante correcta.  
  
```csharp  
public void MyMethod()  
{  
  this.SomeNonLocalDataState;  
  // Here you need to clean nonlocal state for other users  
  OutboundProxy proxy = new OutboundProxy();  
  int returnValue = proxy.CallOutOfOperation();  
  // Ensure that this.SomeNonLocalDataState is valid for continued use.  
  this.ModifyNonLocalState;  
  return returnValue;  
}  
  
```  
  
 Al utilizar el modelo de llamada asincrónica Begin/End para una llamada saliente cuando <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> es <xref:System.ServiceModel.ConcurrencyMode.Reentrant> se inicia una excepción. Las llamadas salientes asincrónicas requieren una operación en la que <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> es <xref:System.ServiceModel.ConcurrencyMode.Multiple>. En ese caso deberá administrar los problemas de sincronización.  
  
 Generalmente, si llega un mensaje para una instancia que infringe su modo de simultaneidad, el mensaje espera hasta que la instancia esté disponible, o hasta que expire.  
  
 Además, si <xref:System.ServiceModel.ConcurrencyMode> está establecido como <xref:System.ServiceModel.ConcurrencyMode.Single> y se bloquea una llamada reentrante esperando a que la instancia se libere, el sistema detecta el interbloqueo e inicia una excepción.  
  
> [!NOTE]
>  Se inicia una <xref:System.InvalidOperationException> en tiempo de ejecución si <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> es `true` cuando la propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> está establecida como <xref:System.ServiceModel.ConcurrencyMode.Single>.  
  
 Tenga en cuenta que debe establecer explícitamente <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> como `false` si hay una operación con <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> establecido como true y usted establece <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> como <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. De lo contrario se producirá una excepción de validación porque el valor predeterminado de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> es `true`.  
  
 Hay una interacción de <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> y otras propiedades que puede modificar el comportamiento en tiempo de ejecución. Para obtener una descripción completa de estas interacciones, vea [sesiones, Instancing y simultaneidad](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra la diferencia de uso entre <xref:System.ServiceModel.ConcurrencyMode.Single>, <xref:System.ServiceModel.ConcurrencyMode.Reentrant> y <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Este ejemplo no se compila sin una implementación real detrás de él, pero muestran el tipo de garantías que hace que Windows Communication Foundation (WCF) y lo que significa para el código de operación de subprocesamiento.  
  
 [!code-csharp[C_BestPractices-Concurrency#1](~/samples/snippets/csharp/VS_Snippets_CFX/c_bestpractices-concurrency/cs/reentrantandmultiple.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no es uno de los valores de <see cref="T:System.ServiceModel.ConcurrencyMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationName">
      <MemberSignature Language="C#" Value="public string ConfigurationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationName : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor utilizado para buscar el elemento de servicio en un archivo de configuración de la aplicación.</summary>
        <value>Valor que se busca en el archivo de configuración. El valor predeterminado es el nombre de tipo completo sin información de ensamblado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este valor para especificar un servicio determinado en el archivo de configuración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor es null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es una cadena vacía.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureOrderedDispatch">
      <MemberSignature Language="C#" Value="public bool EnsureOrderedDispatch { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnsureOrderedDispatch" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberSignature Language="VB.NET" Value="Public Property EnsureOrderedDispatch As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnsureOrderedDispatch { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnsureOrderedDispatch : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.EnsureOrderedDispatch" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se garantiza el envío solicitado de servicio.</summary>
        <value>Es <see langword="true" /> si se garantiza el envío de servicio solicitado; en caso contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public object GetWellKnownSingleton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetWellKnownSingleton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.GetWellKnownSingleton" />
      <MemberSignature Language="VB.NET" Value="Public Function GetWellKnownSingleton () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetWellKnownSingleton();" />
      <MemberSignature Language="F#" Value="member this.GetWellKnownSingleton : unit -&gt; obj" Usage="serviceBehaviorAttribute.GetWellKnownSingleton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera un objeto que implementa el servicio y que se utiliza como instancia singleton del servicio o <see langword="null" /> si no hay ninguna instancia singleton.</summary>
        <returns>Una implementación del servicio. El valor predeterminado es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor diferente de `null` proporciona la instancia de servicio a la que se enviarán todos los mensajes dirigidos al servicio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExtensionDataObject">
      <MemberSignature Language="C#" Value="public bool IgnoreExtensionDataObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreExtensionDataObject" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreExtensionDataObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreExtensionDataObject { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreExtensionDataObject : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si enviar o no datos de serialización desconocidos hacia la conexión.</summary>
        <value><see langword="true" /> si nunca se envían datos de serialización desconocidos; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un tipo implementa la <xref:System.Runtime.Serialization.IExtensibleDataObject> interfaz, almacena cualquier dato adicional que desconoce acerca de que lleguen a través del cable al deserializar en ese tipo. Por ejemplo, si un tipo `Person` tiene miembros `FirstName` y `LastName`, y entra un elemento llamado `PhoneNumber`, se almacena. Al serializar después el tipo, se remitirá `PhoneNumber`. El problema es que el esquema para `Person` exportado por ese servicio sólo tiene `FirstName` y `LastName`, por lo que Windows Communication Foundation (WCF) genera una instancia de esquema no válida. Si la compatibilidad del esquema estricta es importante, puede establecer <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> como `true` para desactivar este comportamiento de reemisión.  
  
 En cualquier caso <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> establecer, WCF siempre procesa los datos conocidos (de entrada y salida) y no inicia excepciones cuando entran datos adicionales. También puede establecer esta propiedad utilizando el [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elemento en un archivo de configuración de la aplicación.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra el uso de <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> y una implementación de <xref:System.Runtime.Serialization.IExtensibleDataObject>. En este ejemplo, con <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> establecido como `false`, los datos adicionales que el cliente conoce regresan al cliente después de un viaje de ida y vuelta (round trip).  
  
 [!code-csharp[DCAContainerNoValidation#1](~/samples/snippets/csharp/VS_Snippets_CFX/dcacontainernovalidation/cs/services.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeExceptionDetailInFaults">
      <MemberSignature Language="C#" Value="public bool IncludeExceptionDetailInFaults { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeExceptionDetailInFaults" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeExceptionDetailInFaults As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeExceptionDetailInFaults { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeExceptionDetailInFaults : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica que las excepciones de ejecución generales no controladas se convertirán en una <see cref="T:System.ServiceModel.FaultException`1" /> de tipo <see cref="T:System.ServiceModel.ExceptionDetail" />, y se enviarán como mensaje de error. Establezca este valor como <see langword="true" /> sólo durante el desarrollo para solucionar problemas de un servicio.</summary>
        <value><see langword="true" /> si las excepciones no controladas se devuelven como errores de SOAP; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establezca <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> como `true` para permitir que la información de excepción fluya a los clientes para fines de depuración. Esta propiedad requiere un enlace que admita tanto mensajería de solicitud-respuesta como dúplex.  
  
 En todas las aplicaciones administradas, los errores de procesamiento están representados mediante objetos <xref:System.Exception>. En las aplicaciones basadas en SOAP, como aplicaciones de WCF, los métodos que implementan las operaciones de servicio comunican información de error mediante mensajes de error SOAP. Dado que las aplicaciones WCF que se ejecutan en ambos tipos de sistemas de error, cualquier información de excepción administrada que debe enviarse al cliente debe convertirse de excepciones a errores SOAP. Para obtener más información, consulte [especificar y controlar errores en contratos y servicios](~/docs/framework/wcf/specifying-and-handling-faults-in-contracts-and-services.md).  
  
 Durante el desarrollo puede desear que su servicio devuelva también otras excepciones al cliente para ayudarle a depurar. Esto es una característica sólo del desarrollo y no debería emplearse en servicios implementados.  
  
 Para facilitar el desarrollo de la depuración, establezca el <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> a `true` en código o usando un archivo de configuración de la aplicación.  
  
 Cuando se habilita, el servicio devuelve automáticamente información de excepción más segura al autor de la llamada. Estos errores aparecen en el cliente como objetos <xref:System.ServiceModel.FaultException%601> del tipo <xref:System.ServiceModel.ExceptionDetail>.  
  
> [!IMPORTANT]
>  Establecer <xref:System.ServiceModel.ServiceBehaviorAttribute.IncludeExceptionDetailInFaults%2A> a `true` las excepciones de método de servicio permite que los clientes para obtener información sobre interno; sólo se recomienda como una manera de depurar temporalmente una aplicación de servicio. Además, el WSDL de un método que devuelve excepciones administradas no controladas de esta manera no contiene el contrato para la <xref:System.ServiceModel.FaultException%601> de tipo <xref:System.ServiceModel.ExceptionDetail>. Los clientes deben esperar la posibilidad de que se produzca un error de SOAP desconocido para obtener correctamente la información de depuración.  
  
 Establecer esta propiedad en `true` también puede realizarse mediante un archivo de configuración de aplicación y el [ &lt;serviceDebug&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicedebug.md) elemento, como muestra el ejemplo de código siguiente.  
  
 [!code-xml[OperationBehaviorAttribute1#10](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#10)]   
   
  
## Examples  
 En el ejemplo de código siguiente se muestran las propiedades <xref:System.ServiceModel.ServiceBehaviorAttribute>. La clase `BehaviorService` utiliza el atributo <xref:System.ServiceModel.ServiceBehaviorAttribute> para indicar que:  
  
-   Los métodos de implementación se invocan en el subproceso de la interfaz de usuario.  
  
-   Hay un objeto de servicio para cada sesión.  
  
-   La instancia del servicio es de subproceso único y no admite llamadas reentrantes.  
  
 Además, en el nivel de la operación, los valores <xref:System.ServiceModel.OperationBehaviorAttribute> indican que el método `TxWork` da de alta automáticamente las transacciones de flujo o crea una transacción nueva para hacer el trabajo y que se confirma la transacción automáticamente si no se produce una excepción no controlada.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 El enlace subyacente debe admitir transacciones de flujo para que el ejemplo de código siguiente se ejecute correctamente. Para admitir transacciones de flujo con <xref:System.ServiceModel.WSHttpBinding>, por ejemplo, establezca la propiedad <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> como `true` en el código o en un archivo de configuración de la aplicación. El ejemplo de código siguiente muestra el archivo de configuración para el ejemplo anterior:  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InstanceContextMode">
      <MemberSignature Language="C#" Value="public System.ServiceModel.InstanceContextMode InstanceContextMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ServiceModel.InstanceContextMode InstanceContextMode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberSignature Language="VB.NET" Value="Public Property InstanceContextMode As InstanceContextMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::InstanceContextMode InstanceContextMode { System::ServiceModel::InstanceContextMode get(); void set(System::ServiceModel::InstanceContextMode value); };" />
      <MemberSignature Language="F#" Value="member this.InstanceContextMode : System.ServiceModel.InstanceContextMode with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.InstanceContextMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor que indica cuándo se crean los nuevos objetos de servicio.</summary>
        <value>Uno de los valores <see cref="T:System.ServiceModel.InstanceContextMode" />; el valor predeterminado es <see cref="F:System.ServiceModel.InstanceContextMode.PerSession" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.InstanceContextMode> para especificar cuándo se crean los nuevos objetos de servicio. Dado que el objeto de servicio no está conectado directamente al canal de la comunicación, la duración de los objetos de servicio es independiente de la duración del canal entre un cliente y la aplicación de servicio. El valor predeterminado, <xref:System.ServiceModel.InstanceContextMode.PerSession>, indica a la aplicación de servicio que cree un nuevo objeto de servicio cuando se establezca una nueva sesión de comunicaciones entre un cliente y la aplicación de servicio. El mismo objeto administra las llamadas subsiguientes en la misma sesión.  
  
 <xref:System.ServiceModel.InstanceContextMode.PerSession> indica que cada objeto de servicio administra las solicitudes de un canal de cliente.  
  
> [!NOTE]
>  La propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> interactúa con algunos otros valores. Por ejemplo, si el valor <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> está establecido como <xref:System.ServiceModel.InstanceContextMode.Single>, el resultado será que su servicio sólo puede procesar un mensaje a la vez a menos que también establezca el valor de <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> como <xref:System.ServiceModel.ConcurrencyMode.Multiple>. Esta propiedad también genera comportamiento en combinación con la propiedad <xref:System.ServiceModel.ServiceContractAttribute.SessionMode%2A?displayProperty=nameWithType>. Para obtener más información, consulte [sesiones, Instancing y simultaneidad](~/docs/framework/wcf/feature-details/sessions-instancing-and-concurrency.md).  
  
 En el caso del comportamiento de duración de singleton (por ejemplo, si la aplicación host llama al constructor <xref:System.ServiceModel.ServiceHost.%23ctor%2A> y pasa un objeto que se utilice como el servicio), la clase del servicio debe establecer <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> como `Single` o se inicia una excepción en tiempo de ejecución.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestran las propiedades <xref:System.ServiceModel.ServiceBehaviorAttribute>. La clase `BehaviorService` utiliza el atributo <xref:System.ServiceModel.ServiceBehaviorAttribute> para indicar que:  
  
-   Los métodos de implementación se invocan en el subproceso de la interfaz de usuario.  
  
-   Hay un objeto de servicio para cada sesión.  
  
-   La instancia del servicio es de subproceso único y no admite llamadas reentrantes.  
  
 Además, en el nivel de la operación, los valores <xref:System.ServiceModel.OperationBehaviorAttribute> indican que el método `TxWork` da de alta automáticamente las transacciones de flujo o crea una transacción nueva para hacer el trabajo y que se confirma la transacción automáticamente si no se produce una excepción no controlada.  
  
 [!code-csharp[OperationBehaviorAttribute1#2](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/services.cs#2)]
 [!code-vb[OperationBehaviorAttribute1#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/operationbehaviorattribute1/vb/services.vb#2)]  
  
 El enlace subyacente debe admitir transacciones de flujo para que el ejemplo de código siguiente se ejecute correctamente. Para admitir transacciones de flujo con <xref:System.ServiceModel.WSHttpBinding>, por ejemplo, establezca la propiedad <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> como `true` en el código o en un archivo de configuración de la aplicación. El ejemplo de código siguiente muestra el archivo de configuración para el ejemplo anterior:  
  
 [!code-xml[OperationBehaviorAttribute1#1](~/samples/snippets/csharp/VS_Snippets_CFX/operationbehaviorattribute1/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no es uno de los valores de <see cref="T:System.ServiceModel.InstanceContextMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxItemsInObjectGraph">
      <MemberSignature Language="C#" Value="public int MaxItemsInObjectGraph { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxItemsInObjectGraph" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxItemsInObjectGraph As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxItemsInObjectGraph { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxItemsInObjectGraph : int with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.ComponentModel.DefaultValue(65536)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de elementos permitido en un objeto serializado.</summary>
        <value>Número máximo de elementos permitido en un objeto. El valor predeterminado es 65536 bytes (64 KB).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.MaxItemsInObjectGraph%2A> para limitar el número de elementos en un gráfico de objetos que se serializan. También puede establecer esta propiedad utilizando el [ &lt;dataContractSerializer&gt; ](~/docs/framework/configure-apps/file-schema/wcf/datacontractserializer-element.md) elemento en un archivo de configuración de la aplicación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del atributo de nombre del elemento de servicio en el lenguaje de descripción de servicios Web (WSDL).</summary>
        <value>El valor del atributo de nombre en el elemento <see langword="&lt;wsdl:service&gt;" /> cuando se exporta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del espacio de nombres de destino del servicio en el lenguaje de descripción de servicios Web (WSDL).</summary>
        <value>El valor del atributo <see langword="targetNamespace" /> del elemento <see langword="&lt;wsdl:definitions&gt;" /> que contiene el elemento <see langword="&lt;wsdl:service&gt;" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ReleaseServiceInstanceOnTransactionComplete { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Property ReleaseServiceInstanceOnTransactionComplete As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReleaseServiceInstanceOnTransactionComplete { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReleaseServiceInstanceOnTransactionComplete : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si se libera el objeto de servicio cuando se completa la transacción actual.</summary>
        <value><see langword="true" /> si el objeto de servicio se va a liberar; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que debe establecer explícitamente <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> como `false` si hay una operación con <xref:System.ServiceModel.OperationBehaviorAttribute.TransactionScopeRequired%2A?displayProperty=nameWithType> establecido como true y usted establece <xref:System.ServiceModel.ServiceBehaviorAttribute.ConcurrencyMode%2A> como <xref:System.ServiceModel.ConcurrencyMode.Reentrant>. De lo contrario se producirá una excepción de validación porque el valor predeterminado de <xref:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete%2A> es `true`.  
  
 Además, es importante comprender que si el servicio se crea pasando un objeto de servicio al constructor <xref:System.ServiceModel.ServiceHost.%23ctor%28System.Object%2CSystem.Uri%5B%5D%29?displayProperty=nameWithType>, el valor de esta propiedad se trata como si fuera `false`.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el nivel de aislamiento de transacción como <xref:System.Transactions.IsolationLevel.ReadCommitted>, deshabilita la compatibilidad con transacciones simultáneas, requiere una transacción de flujo de la llamada de operación y confirma automáticamente la transacción del servicio si no se produce ninguna excepción no controlada.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 El enlace subyacente debe admitir transacciones de flujo para que el ejemplo de código siguiente se ejecute correctamente. Para admitir transacciones de flujo con <xref:System.ServiceModel.WSHttpBinding>, por ejemplo, establezca la propiedad <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> como `true` en el código o en un archivo de configuración de la aplicación. El ejemplo de código siguiente muestra un archivo de configuración para el ejemplo anterior:  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetWellKnownSingleton">
      <MemberSignature Language="C#" Value="public void SetWellKnownSingleton (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetWellKnownSingleton(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetWellKnownSingleton (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetWellKnownSingleton(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetWellKnownSingleton : obj -&gt; unit" Usage="serviceBehaviorAttribute.SetWellKnownSingleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Instancia singleton del servicio.</param>
        <summary>Especifica un objeto que implementa el servicio y que se utiliza como instancia singleton del servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto proporciona la instancia de servicio a la que se enviarán todos los mensajes dirigidos al servicio.  
  
 Si <xref:System.ServiceModel.ServiceBehaviorAttribute.SetWellKnownSingleton%2A> se establece con un valor diferente de `null`, <xref:System.ServiceModel.ServiceBehaviorAttribute.InstanceContextMode%2A> debe establecerse como <xref:System.ServiceModel.InstanceContextMode.Single> o se iniciará <xref:System.InvalidOperationException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor establecido es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeConfigurationName">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeConfigurationName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeConfigurationName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeConfigurationName" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeConfigurationName () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeConfigurationName();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeConfigurationName : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeConfigurationName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ConfigurationName" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeReleaseServiceInstanceOnTransactionComplete">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeReleaseServiceInstanceOnTransactionComplete () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeReleaseServiceInstanceOnTransactionComplete();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeReleaseServiceInstanceOnTransactionComplete : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeReleaseServiceInstanceOnTransactionComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.ReleaseServiceInstanceOnTransactionComplete" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionAutoCompleteOnSessionClose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionAutoCompleteOnSessionClose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionAutoCompleteOnSessionClose () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionAutoCompleteOnSessionClose();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionAutoCompleteOnSessionClose : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionAutoCompleteOnSessionClose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionIsolationLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionIsolationLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionIsolationLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionIsolationLevel();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionIsolationLevel : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionIsolationLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTransactionTimeout">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTransactionTimeout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTransactionTimeout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.ShouldSerializeTransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTransactionTimeout () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTransactionTimeout();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTransactionTimeout : unit -&gt; bool" Usage="serviceBehaviorAttribute.ShouldSerializeTransactionTimeout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si la propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> ha cambiado respecto de su valor predeterminado y se debe serializar.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.AddBindingParameters">
      <MemberSignature Language="C#" Value="void IServiceBehavior.AddBindingParameters (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase, System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, System.ServiceModel.Channels.BindingParameterCollection parameters);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase, class System.Collections.ObjectModel.Collection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; endpoints, class System.ServiceModel.Channels.BindingParameterCollection parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase, System::Collections::ObjectModel::Collection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ endpoints, System::ServiceModel::Channels::BindingParameterCollection ^ parameters) = System::ServiceModel::Description::IServiceBehavior::AddBindingParameters;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase,System.Collections.ObjectModel.Collection{System.ServiceModel.Description.ServiceEndpoint},System.ServiceModel.Channels.BindingParameterCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
        <Parameter Name="endpoints" Type="System.Collections.ObjectModel.Collection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" />
        <Parameter Name="parameters" Type="System.ServiceModel.Channels.BindingParameterCollection" />
      </Parameters>
      <Docs>
        <param name="description">Descripción del servicio.</param>
        <param name="serviceHostBase">Host de servicio.</param>
        <param name="endpoints">puntos de conexión del servicio.</param>
        <param name="parameters">Los objetos de datos que los enlaces necesitan para admitir el comportamiento.</param>
        <summary>Pasa objetos de datos personalizados a los enlaces que admiten las propiedades de comportamiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior">
      <MemberSignature Language="C#" Value="void IServiceBehavior.ApplyDispatchBehavior (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::ApplyDispatchBehavior;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Descripción del servicio.</param>
        <param name="serviceHostBase">Host de servicio.</param>
        <summary>Personaliza el tiempo de ejecución del servicio para admitir las propiedades de comportamiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IServiceBehavior.Validate">
      <MemberSignature Language="C#" Value="void IServiceBehavior.Validate (System.ServiceModel.Description.ServiceDescription description, System.ServiceModel.ServiceHostBase serviceHostBase);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IServiceBehavior.Validate(class System.ServiceModel.Description.ServiceDescription description, class System.ServiceModel.ServiceHostBase serviceHostBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceBehaviorAttribute.System#ServiceModel#Description#IServiceBehavior#Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ServiceModel.Description.IServiceBehavior.Validate(System::ServiceModel::Description::ServiceDescription ^ description, System::ServiceModel::ServiceHostBase ^ serviceHostBase) = System::ServiceModel::Description::IServiceBehavior::Validate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ServiceModel.Description.IServiceBehavior.Validate(System.ServiceModel.Description.ServiceDescription,System.ServiceModel.ServiceHostBase)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="description" Type="System.ServiceModel.Description.ServiceDescription" />
        <Parameter Name="serviceHostBase" Type="System.ServiceModel.ServiceHostBase" />
      </Parameters>
      <Docs>
        <param name="description">Descripción del servicio.</param>
        <param name="serviceHostBase">Host de servicio.</param>
        <summary>Confirma que la descripción del servicio y el host de servicio son capaces de admitir el comportamiento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionAutoCompleteOnSessionClose">
      <MemberSignature Language="C#" Value="public bool TransactionAutoCompleteOnSessionClose { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionAutoCompleteOnSessionClose As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TransactionAutoCompleteOnSessionClose { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionAutoCompleteOnSessionClose : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionAutoCompleteOnSessionClose" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si se completan las transacciones pendientes cuando la sesión actual se cierra sin error.</summary>
        <value><see langword="true" /> si las transacciones pendientes serán completadas cuando la sesión actual se cierra sin error; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionIsolationLevel">
      <MemberSignature Language="C#" Value="public System.Transactions.IsolationLevel TransactionIsolationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Transactions.IsolationLevel TransactionIsolationLevel" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionIsolationLevel As IsolationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Transactions::IsolationLevel TransactionIsolationLevel { System::Transactions::IsolationLevel get(); void set(System::Transactions::IsolationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionIsolationLevel : System.Transactions.IsolationLevel with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionIsolationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Transactions.IsolationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica el nivel de aislamiento de transacción para las nuevas transacciones creadas dentro del servicio y las transacciones entrantes que han fluido desde un cliente.</summary>
        <value>Valor <see cref="T:System.Transactions.IsolationLevel" /> que especifica el nivel de aislamiento de la transacción. De manera predeterminada, es <see cref="F:System.Transactions.IsolationLevel.Unspecified" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El nivel de aislamiento en el que su transacción se ejecuta determina cómo se tratan los datos cuando se realizan modificaciones en otras transacciones y cuánto tiempo debe contener los bloqueos su transacción para protegerse contra estos cambios. Por ejemplo, el valor predeterminado, <xref:System.Transactions.IsolationLevel.Unspecified>, especifica que no se puede actualizar ni insertar hasta que la transacción haya finalizado.  
  
 Esta propiedad también se puede utilizar para restringir el nivel de aislamiento de transacciones entrantes que han fluido de un cliente.  
  
   
  
## Examples  
 El ejemplo de código siguiente establece el nivel de aislamiento de transacción como <xref:System.Transactions.IsolationLevel.ReadCommitted>, no admite transacciones simultáneas, requiere una transacción de flujo de la llamada al método y confirma automáticamente la transacción si no se produce ninguna excepción no controlada.  
  
 [!code-csharp[SBA.Transactions#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/services.cs#2)]
 [!code-vb[SBA.Transactions#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactions/vb/services.vb#2)]  
  
 El enlace subyacente debe admitir transacciones de flujo para que el ejemplo de código siguiente se ejecute correctamente. Para admitir transacciones de flujo con <xref:System.ServiceModel.WSHttpBinding>, por ejemplo, establezca la propiedad <xref:System.ServiceModel.WSHttpBindingBase.TransactionFlow%2A> como `true` en el código o en un archivo de configuración de la aplicación. El ejemplo de código siguiente muestra un archivo de configuración para el ejemplo anterior:  
  
 [!code-xml[SBA.Transactions#1](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactions/cs/hostapplication.exe.config#1)]   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor no es uno de los valores de <see cref="T:System.Transactions.IsolationLevel" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransactionTimeout">
      <MemberSignature Language="C#" Value="public string TransactionTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionTimeout As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionTimeout { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionTimeout : string with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.TransactionTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el período dentro del que una transacción se debe completar.</summary>
        <value>Un objeto <see cref="T:System.TimeSpan" /> que representa el tiempo en el cual se tienen que completar las transacciones o anularse automáticamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor establece la propiedad <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.TransactionTimeout%2A?displayProperty=nameWithType>. También puede establecer esta propiedad utilizando el [ &lt;serviceTimeouts&gt; ](~/docs/framework/configure-apps/file-schema/wcf/servicetimeouts.md) elemento en un archivo de configuración de la aplicación.  
  
   
  
## Examples  
 El archivo de configuración siguiente especifica un tiempo de espera de la transacción de tres minutos.  
  
 [!code-csharp[SBA.TransactionTimeout#2](~/samples/snippets/csharp/VS_Snippets_CFX/sba.transactiontimeout/cs/services.cs#2)]
 [!code-vb[SBA.TransactionTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/sba.transactiontimeout/vb/services.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor es NULL.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que <see cref="F:System.TimeSpan.Zero" /> o mayor que <see cref="F:System.TimeSpan.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseSynchronizationContext">
      <MemberSignature Language="C#" Value="public bool UseSynchronizationContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseSynchronizationContext" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Property UseSynchronizationContext As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseSynchronizationContext { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseSynchronizationContext : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si utilizar el contexto de sincronización actual para elegir el subproceso de ejecución.</summary>
        <value><see langword="true" /> si todas las llamadas al servicio deben ejecutarse en el subproceso especificado por el <see cref="T:System.Threading.SynchronizationContext" />; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para proporcionar la afinidad de subproceso de interfaz de usuario que algunas aplicaciones requieren. Por ejemplo, una aplicación de Windows Forms se puede registrar como un objeto de servicio singleton. En este caso, todas las llamadas al servicio se deben ejecutar en el subproceso Windows Forms. El caso predeterminado, en el que <xref:System.ServiceModel.ServiceBehaviorAttribute.UseSynchronizationContext%2A> está establecido como `true`, sincroniza todas las llamadas al servicio para ejecutarse en el subproceso capturado de <xref:System.Threading.SynchronizationContext?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateMustUnderstand">
      <MemberSignature Language="C#" Value="public bool ValidateMustUnderstand { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ValidateMustUnderstand" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberSignature Language="VB.NET" Value="Public Property ValidateMustUnderstand As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ValidateMustUnderstand { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ValidateMustUnderstand : bool with get, set" Usage="System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si el sistema o la aplicación exige el procesamiento de encabezados <see langword="MustUnderstand" /> de SOAP.</summary>
        <value><see langword="true" /> si el sistema debe realizar el procesamiento de encabezados <see langword="MustUnderstand" /> de SOAP; de lo contrario, <see langword="false" />, que indica que la aplicación realiza este procesamiento. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la propiedad <xref:System.ServiceModel.ServiceBehaviorAttribute.ValidateMustUnderstand%2A> para desactivar la validación obligatoria de los encabezados de mensajes de llegada. En ejecución normal, los encabezados de mensaje se comparan con la propiedad <xref:System.ServiceModel.Channels.MessageHeaders.UnderstoodHeaders%2A> para confirmar que el servicio administra explícitamente los encabezados de llegada. Establezca este valor como `false` para deshabilitar la comprobación. Si se establece como `false`, la aplicación debe comprobar si hay encabezados marcados con MustUnderstand="true" y devuelve un error si hay alguno que no se comprendió. Esto resulta útil cuando la aplicación debe acepta cualquier mensaje SOAP entrante (por ejemplo, al utilizar mensajes con o sin tipo) y realiza el procesamiento personalizado de los encabezados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>