<Type Name="ServiceHostBase" FullName="System.ServiceModel.ServiceHostBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9932eb18e66eca5ec8bc36f67e98864f715741ee" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57932707" /></Metadata><TypeSignature Language="C#" Value="public abstract class ServiceHostBase : System.ServiceModel.Channels.CommunicationObject, IDisposable, System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.ServiceHostBase&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ServiceHostBase extends System.ServiceModel.Channels.CommunicationObject implements class System.IDisposable, class System.ServiceModel.IExtensibleObject`1&lt;class System.ServiceModel.ServiceHostBase&gt;" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.ServiceHostBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ServiceHostBase&#xA;Inherits CommunicationObject&#xA;Implements IDisposable, IExtensibleObject(Of ServiceHostBase)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceHostBase abstract : System::ServiceModel::Channels::CommunicationObject, IDisposable, System::ServiceModel::IExtensibleObject&lt;System::ServiceModel::ServiceHostBase ^&gt;" />
  <TypeSignature Language="F#" Value="type ServiceHostBase = class&#xA;    inherit CommunicationObject&#xA;    interface IExtensibleObject&lt;ServiceHostBase&gt;&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.CommunicationObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ServiceModel.IExtensibleObject&lt;System.ServiceModel.ServiceHostBase&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Extienda la clase <see cref="T:System.ServiceModel.ServiceHostBase" /> para implementar hosts que exponen los modelos de programación personalizados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la clase <xref:System.ServiceModel.ServiceHostBase> para crear hosts que proporcionan un modelo de programación personalizado. El servicio de Windows Communication Foundation (WCF) utiliza del modelo de programación la <xref:System.ServiceModel.ServiceHost> clase.  
  
 Nota especial para los usuarios de C++ que deriven de esta clase:  
  
-   Coloque su código de limpieza en (On)(Begin)Close (y/o OnAbort), no en un destructor.  
  
-   Evite los destructores; hacen que el compilador genere automáticamente <xref:System.IDisposable>  
  
-   Evite los miembros sin referencia; pueden hacer que el compilador genere automáticamente <xref:System.IDisposable>.  
  
-   Evite los finalizadores; pero si incluye uno, debería suprimir la advertencia de creación y llamar a <xref:System.GC.SuppressFinalize%28System.Object%29> y al propio finalizador de (On)(Begin)Close (y/o OnAbort) para emular lo que habría sido el comportamiento de <xref:System.IDisposable> generado automáticamente.  
  
   
  
## Examples  
 Este ejemplo utiliza la clase <xref:System.ServiceModel.ServiceHost>, que se deriva de <xref:System.ServiceModel.ServiceHostBase>  
  
 [!code-csharp[S_SelfHost#1](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#1)]
 [!code-vb[S_SelfHost#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/s_selfhost/vb/wholeenchilada.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ServiceHostBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ServiceHostBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ServiceModel.ServiceHostBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#30](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddBaseAddress">
      <MemberSignature Language="C#" Value="protected void AddBaseAddress (Uri baseAddress);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddBaseAddress(class System.Uri baseAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddBaseAddress(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddBaseAddress (baseAddress As Uri)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddBaseAddress(Uri ^ baseAddress);" />
      <MemberSignature Language="F#" Value="member this.AddBaseAddress : Uri -&gt; unit" Usage="serviceHostBase.AddBaseAddress baseAddress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseAddress"><see cref="T:System.Uri" /> que contiene la dirección base para los servicios hospedados en el host actual.</param>
        <summary>Agrega una dirección base al host de servicio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad permite a los usuarios extender <xref:System.ServiceModel.ServiceHostBase> para proporcionar la dirección base una vez construido el host.  <xref:System.ServiceModel.ServiceHostBase.AddBaseAddress%28System.Uri%29> se puede utilizar para agregar las direcciones base a un host existente, pero esto iniciará una excepción si ya se ha inicializado la descripción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No es posible llamar a <paramref name="baseAddress" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddDefaultEndpoints">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ServiceModel.Description.ServiceEndpoint&gt; AddDefaultEndpoints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.ServiceModel.Description.ServiceEndpoint&gt; AddDefaultEndpoints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddDefaultEndpoints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddDefaultEndpoints () As ReadOnlyCollection(Of ServiceEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::ObjectModel::ReadOnlyCollection&lt;System::ServiceModel::Description::ServiceEndpoint ^&gt; ^ AddDefaultEndpoints();" />
      <MemberSignature Language="F#" Value="abstract member AddDefaultEndpoints : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;&#xA;override this.AddDefaultEndpoints : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;" Usage="serviceHostBase.AddDefaultEndpoints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.ServiceModel.Description.ServiceEndpoint&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Agrega puntos de conexión de servicio para todas las direcciones base en cada contrato encontrado en el host del servicio con el enlace predeterminado.</summary>
        <returns>Una colección de solo lectura de puntos de conexión predeterminados.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddServiceEndpoint">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega extremos de servicio al servicio hospedado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public virtual void AddServiceEndpoint (System.ServiceModel.Description.ServiceEndpoint endpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddServiceEndpoint(class System.ServiceModel.Description.ServiceEndpoint endpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddServiceEndpoint(System.ServiceModel.Description.ServiceEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddServiceEndpoint (endpoint As ServiceEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddServiceEndpoint(System::ServiceModel::Description::ServiceEndpoint ^ endpoint);" />
      <MemberSignature Language="F#" Value="abstract member AddServiceEndpoint : System.ServiceModel.Description.ServiceEndpoint -&gt; unit&#xA;override this.AddServiceEndpoint : System.ServiceModel.Description.ServiceEndpoint -&gt; unit" Usage="serviceHostBase.AddServiceEndpoint endpoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.ServiceModel.Description.ServiceEndpoint" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="endpoint">Extremo del servicio.</param>
        <summary>Agrega el extremo de servicio especificado al servicio hospedado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el método, el host de servicio realiza una validación de "nombre mediante la configuración" en la descripción del contrato. En otras palabras, el host comprueba que <xref:System.ServiceModel.Description.ContractDescription.ConfigurationName%2A> existe en la lista de nombres de configuración de los contratos de servicio implementados por el servicio. Si la validación es correcta, la descripción en el <xref:System.ServiceModel.Description.ServiceEndpoint> se usa como lo es, incluso si la <xref:System.ServiceModel.Description.ContractDescription> reflejado desde el servicio es diferente.  
  
 Por ejemplo, suponga que la descripción en el ServiceEndpoint y la descripción del contrato reflejado desde el servicio tienen el mismo nombre, pero los comportamientos de operación diferente. La implicación de validación de "nombre mediante la configuración de" sólo es que no hay ninguna validación en el que los comportamientos son los mismos y hay uno actualizaciones para una descripción debido a otra descripción.  
  
 Si `address` es un URI relativo, una de las direcciones base de <xref:System.ServiceModel.ServiceHost> (en función del protocolo de enlace) se utiliza como dirección base del punto de conexión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="Endpoint" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El host no está en un estado de creado o de abierto o no hay ningún <see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado.</exception>
        <exception cref="T:System.ArgumentException">La propiedad <paramref name="Address" />, <paramref name="Binding" /> o <paramref name="Contract" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (string implementedContract, System.ServiceModel.Channels.Binding binding, string address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(string implementedContract, class System.ServiceModel.Channels.Binding binding, string address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddServiceEndpoint(System.String,System.ServiceModel.Channels.Binding,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(System::String ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address);" />
      <MemberSignature Language="F#" Value="member this.AddServiceEndpoint : string * System.ServiceModel.Channels.Binding * string -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHostBase.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.String" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="implementedContract">El contrato implementado por el punto de conexión.</param>
        <param name="binding">El <see cref="T:System.ServiceModel.Channels.Binding" /> para el extremo agregado.</param>
        <param name="address">La dirección para el extremo agregado. Éste puede ser un URI absoluto o relativo. Si es un URI relativo, uno de la dirección base de <see cref="T:System.ServiceModel.ServiceHost" /> (en función del protocolo de enlace) se utiliza como dirección base del extremo.</param>
        <summary>Agrega un punto de conexión de servicio al servicio hospedado con un contrato especificado, un enlace y una dirección del punto de conexión.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> agregado al servicio hospedado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#40](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> o <paramref name="binding" /> o <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El host no está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Created" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o no hay <see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado, de modo que no se puede agregar un extremo o al enlace le falta un transporte de esquema de enlace.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (string implementedContract, System.ServiceModel.Channels.Binding binding, Uri address);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(string implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddServiceEndpoint(System.String,System.ServiceModel.Channels.Binding,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(System::String ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address);" />
      <MemberSignature Language="F#" Value="member this.AddServiceEndpoint : string * System.ServiceModel.Channels.Binding * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHostBase.AddServiceEndpoint (implementedContract, binding, address)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.String" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">El contrato implementado por el punto de conexión.</param>
        <param name="binding">El <see cref="T:System.ServiceModel.Channels.Binding" /> para el extremo agregado.</param>
        <param name="address"><see cref="T:System.Uri" /> que contiene la dirección del extremo agregado. Éste puede ser un URI absoluto o relativo. Si es un URI relativo, uno de la dirección base de <see cref="T:System.ServiceModel.ServiceHost" /> (en función del protocolo de enlace) se utiliza como dirección base del extremo.</param>
        <summary>Agrega un punto de conexión de servicio al servicio hospedado con un contrato especificado, un enlace y un URI que contiene la dirección del punto de conexión.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> agregado al servicio hospedado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> o <paramref name="binding" /> o <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El host no está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Created" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o no hay <see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado, de modo que no se puede agregar un extremo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (string implementedContract, System.ServiceModel.Channels.Binding binding, string address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(string implementedContract, class System.ServiceModel.Channels.Binding binding, string address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddServiceEndpoint(System.String,System.ServiceModel.Channels.Binding,System.String,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(System::String ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, System::String ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="member this.AddServiceEndpoint : string * System.ServiceModel.Channels.Binding * string * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHostBase.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.String" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.String" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">El contrato implementado por el punto de conexión.</param>
        <param name="binding">El <see cref="T:System.ServiceModel.Channels.Binding" /> para el extremo agregado.</param>
        <param name="address">La dirección para el extremo agregado. Esta dirección puede ser un URI absoluto o relativo. Si es un URI relativo, uno de la dirección base de <see cref="T:System.ServiceModel.ServiceHost" /> (en función del protocolo de enlace) se utiliza como dirección base del extremo.</param>
        <param name="listenUri"><see cref="T:System.Uri" /> que contiene la dirección en la que el extremo realiza escuchas para los mensajes entrantes. Este URI puede ser relativo o absoluto.</param>
        <summary>Agrega un punto de conexión de servicio al servicio hospedado con un contrato especificado, un enlace, una dirección del punto de conexión y un URI que contiene la dirección en la que realiza escuchas.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> agregado al servicio hospedado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `address` es un URI relativo, una de las direcciones base de <xref:System.ServiceModel.ServiceHost> (en función del protocolo de enlace) se utiliza como dirección base del punto de conexión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> o <paramref name="binding" /> o <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El host no está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Created" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o no hay <see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado, de modo que no se puede agregar un extremo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddServiceEndpoint">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint (string implementedContract, System.ServiceModel.Channels.Binding binding, Uri address, Uri listenUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ServiceModel.Description.ServiceEndpoint AddServiceEndpoint(string implementedContract, class System.ServiceModel.Channels.Binding binding, class System.Uri address, class System.Uri listenUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.AddServiceEndpoint(System.String,System.ServiceModel.Channels.Binding,System.Uri,System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ServiceModel::Description::ServiceEndpoint ^ AddServiceEndpoint(System::String ^ implementedContract, System::ServiceModel::Channels::Binding ^ binding, Uri ^ address, Uri ^ listenUri);" />
      <MemberSignature Language="F#" Value="member this.AddServiceEndpoint : string * System.ServiceModel.Channels.Binding * Uri * Uri -&gt; System.ServiceModel.Description.ServiceEndpoint" Usage="serviceHostBase.AddServiceEndpoint (implementedContract, binding, address, listenUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceEndpoint</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContract" Type="System.String" />
        <Parameter Name="binding" Type="System.ServiceModel.Channels.Binding" />
        <Parameter Name="address" Type="System.Uri" />
        <Parameter Name="listenUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="implementedContract">El contrato implementado por el punto de conexión.</param>
        <param name="binding">El <see cref="T:System.ServiceModel.Channels.Binding" /> para el extremo agregado.</param>
        <param name="address"><see cref="T:System.Uri" /> que contiene la dirección del extremo agregado. Si es un URI relativo, uno de la dirección base de <see cref="T:System.ServiceModel.ServiceHost" /> (en función del protocolo de enlace) se utiliza como dirección base del extremo.</param>
        <param name="listenUri"><see cref="T:System.Uri" /> que contiene la dirección en la que el extremo realiza escuchas para los mensajes entrantes.</param>
        <summary>Agrega un punto de conexión de servicio al servicio hospedado con un contrato especificado, un enlace y URI que contienen la dirección del punto de conexión y la de escucha</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceEndpoint" /> agregado al servicio hospedado. Este URI puede ser absoluto o relativo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="implementedContract" /> o <paramref name="binding" /> o <paramref name="address" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">El host no está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Created" /> o <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o no hay <see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado, de modo que no se puede agregar un extremo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplyConfiguration">
      <MemberSignature Language="C#" Value="protected virtual void ApplyConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ApplyConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.ApplyConfiguration" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ApplyConfiguration ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ApplyConfiguration();" />
      <MemberSignature Language="F#" Value="abstract member ApplyConfiguration : unit -&gt; unit&#xA;override this.ApplyConfiguration : unit -&gt; unit" Usage="serviceHostBase.ApplyConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Carga la información de descripción de servicio del archivo de configuración y la aplica al tiempo de ejecución que se está construyendo.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La descripción del servicio hospedado es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authentication">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceAuthenticationBehavior Authentication { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Description.ServiceAuthenticationBehavior Authentication" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.Authentication" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authentication As ServiceAuthenticationBehavior" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::ServiceAuthenticationBehavior ^ Authentication { System::ServiceModel::Description::ServiceAuthenticationBehavior ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authentication : System.ServiceModel.Description.ServiceAuthenticationBehavior" Usage="System.ServiceModel.ServiceHostBase.Authentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceAuthenticationBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comportamiento de autenticación de servicio.</summary>
        <value>El comportamiento de autenticación de servicio.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Authorization">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceAuthorizationBehavior Authorization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Description.ServiceAuthorizationBehavior Authorization" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.Authorization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authorization As ServiceAuthorizationBehavior" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::ServiceAuthorizationBehavior ^ Authorization { System::ServiceModel::Description::ServiceAuthorizationBehavior ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Authorization : System.ServiceModel.Description.ServiceAuthorizationBehavior" Usage="System.ServiceModel.ServiceHostBase.Authorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceAuthorizationBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comportamiento de la autorización para el servicio hospedado.</summary>
        <value><see cref="T:System.ServiceModel.Description.ServiceAuthorizationBehavior" /> para el servicio hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#36](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#36)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseAddresses">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;Uri&gt; BaseAddresses { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Uri&gt; BaseAddresses" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.BaseAddresses" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseAddresses As ReadOnlyCollection(Of Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;Uri ^&gt; ^ BaseAddresses { System::Collections::ObjectModel::ReadOnlyCollection&lt;Uri ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseAddresses : System.Collections.ObjectModel.ReadOnlyCollection&lt;Uri&gt;" Usage="System.ServiceModel.ServiceHostBase.BaseAddresses" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las direcciones base utilizadas por el servicio hospedado.</summary>
        <value><see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de tipo <see cref="T:System.Uri" /> que contiene las direcciones base para el servicio hospedado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChannelDispatchers">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Dispatcher.ChannelDispatcherCollection ChannelDispatchers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Dispatcher.ChannelDispatcherCollection ChannelDispatchers" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.ChannelDispatchers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChannelDispatchers As ChannelDispatcherCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Dispatcher::ChannelDispatcherCollection ^ ChannelDispatchers { System::ServiceModel::Dispatcher::ChannelDispatcherCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChannelDispatchers : System.ServiceModel.Dispatcher.ChannelDispatcherCollection" Usage="System.ServiceModel.ServiceHostBase.ChannelDispatchers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Dispatcher.ChannelDispatcherCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de distribuidores del canal utilizados por el host del servicio.</summary>
        <value><see cref="T:System.ServiceModel.Dispatcher.ChannelDispatcherCollection" /> que contiene los distribuidores del canal utilizados por el host del servicio.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan CloseTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan CloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.CloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property CloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan CloseTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.CloseTimeout : TimeSpan with get, set" Usage="System.ServiceModel.ServiceHostBase.CloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el intervalo de tiempo permitido para que el host del servicio se cierre.</summary>
        <value><see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo permitido para que el host del servicio se cierre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#33](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor, en milisegundos, es el menor que cero o es mayor que <see cref="F:System.Int32.MaxValue" /> (2,147,483,647 o, en notación hexadecimal, 0X7FFFFFFF).</exception>
        <exception cref="T:System.InvalidOperationException">El host está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o <see cref="F:System.ServiceModel.CommunicationState.Closing" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El host está ya en un estado <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El host está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDescription">
      <MemberSignature Language="C#" Value="protected abstract System.ServiceModel.Description.ServiceDescription CreateDescription (out System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Description.ContractDescription&gt; implementedContracts);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.ServiceModel.Description.ServiceDescription CreateDescription([out] class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Description.ContractDescription&gt;&amp; implementedContracts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.CreateDescription(System.Collections.Generic.IDictionary{System.String,System.ServiceModel.Description.ContractDescription}@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateDescription (ByRef implementedContracts As IDictionary(Of String, ContractDescription)) As ServiceDescription" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::ServiceModel::Description::ServiceDescription ^ CreateDescription([Runtime::InteropServices::Out] System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ % implementedContracts);" />
      <MemberSignature Language="F#" Value="abstract member CreateDescription :  -&gt; System.ServiceModel.Description.ServiceDescription" Usage="serviceHostBase.CreateDescription implementedContracts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceDescription</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="implementedContracts" Type="System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Description.ContractDescription&gt;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="implementedContracts"><see cref="T:System.Collections.Generic.IDictionary`2" /> que contiene los objetos <see cref="T:System.ServiceModel.Description.ContractDescription" /> del servicio.</param>
        <summary>Cuando se implementa en una clase derivada, crea la descripción del servicio hospedado.</summary>
        <returns><see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#41](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceCredentials Credentials { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Description.ServiceCredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.Credentials" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Credentials As ServiceCredentials" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::ServiceCredentials ^ Credentials { System::ServiceModel::Description::ServiceCredentials ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Credentials : System.ServiceModel.Description.ServiceCredentials" Usage="System.ServiceModel.ServiceHostBase.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceCredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la credencial para el servicio hospedado.</summary>
        <value><see cref="T:System.ServiceModel.Description.ServiceCredentials" /> para el servicio hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#37](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#37)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCloseTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultCloseTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultCloseTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.DefaultCloseTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultCloseTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultCloseTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCloseTimeout : TimeSpan" Usage="System.ServiceModel.ServiceHostBase.DefaultCloseTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el intervalo de tiempo predeterminado permitido para que el host del servicio se cierre.</summary>
        <value><see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo predeterminado permitido para que el host del servicio se cierre.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultOpenTimeout">
      <MemberSignature Language="C#" Value="protected override TimeSpan DefaultOpenTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan DefaultOpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.DefaultOpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultOpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property TimeSpan DefaultOpenTimeout { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultOpenTimeout : TimeSpan" Usage="System.ServiceModel.ServiceHostBase.DefaultOpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el intervalo de tiempo predeterminado permitido para que el host del servicio se abra.</summary>
        <value><see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo predeterminado permitido para que el host del servicio se abra.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#35](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#35)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Description">
      <MemberSignature Language="C#" Value="public System.ServiceModel.Description.ServiceDescription Description { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.Description.ServiceDescription Description" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.Description" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Description As ServiceDescription" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::Description::ServiceDescription ^ Description { System::ServiceModel::Description::ServiceDescription ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Description : System.ServiceModel.Description.ServiceDescription" Usage="System.ServiceModel.ServiceHostBase.Description" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Description.ServiceDescription</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la descripción del servicio hospedado.</summary>
        <value><see cref="T:System.ServiceModel.Description.ServiceDescription" /> para el servicio hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[S_SelfHost#38](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#38)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.ServiceHostBase&gt; Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ServiceModel.IExtensionCollection`1&lt;class System.ServiceModel.ServiceHostBase&gt; Extensions" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As IExtensionCollection(Of ServiceHostBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::ServiceHostBase ^&gt; ^ Extensions { System::ServiceModel::IExtensionCollection&lt;System::ServiceModel::ServiceHostBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.ServiceHostBase&gt;" Usage="System.ServiceModel.ServiceHostBase.Extensions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ServiceModel.IExtensibleObject`1.Extensions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ServiceModel.IExtensionCollection&lt;System.ServiceModel.ServiceHostBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene las extensiones para el host del servicio actual especificado.</summary>
        <value>Interfaz <see cref="T:System.ServiceModel.IExtensionCollection`1" /> cuyo tipo es <see cref="T:System.ServiceModel.ServiceHostBase" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImplementedContracts">
      <MemberSignature Language="C#" Value="protected internal System.Collections.Generic.IDictionary&lt;string,System.ServiceModel.Description.ContractDescription&gt; ImplementedContracts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.ServiceModel.Description.ContractDescription&gt; ImplementedContracts" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.ImplementedContracts" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property ImplementedContracts As IDictionary(Of String, ContractDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ ImplementedContracts { System::Collections::Generic::IDictionary&lt;System::String ^, System::ServiceModel::Description::ContractDescription ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImplementedContracts : System.Collections.Generic.IDictionary&lt;string, System.ServiceModel.Description.ContractDescription&gt;" Usage="System.ServiceModel.ServiceHostBase.ImplementedContracts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.ServiceModel.Description.ContractDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera los contratos implementados por el servicio hospedado.</summary>
        <value><see cref="T:System.Collections.Generic.IDictionary`2" /> que contiene los objetos <see cref="T:System.ServiceModel.Description.ContractDescription" /> del servicio.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IncrementManualFlowControlLimit">
      <MemberSignature Language="C#" Value="public int IncrementManualFlowControlLimit (int incrementBy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IncrementManualFlowControlLimit(int32 incrementBy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.IncrementManualFlowControlLimit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IncrementManualFlowControlLimit (incrementBy As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IncrementManualFlowControlLimit(int incrementBy);" />
      <MemberSignature Language="F#" Value="member this.IncrementManualFlowControlLimit : int -&gt; int" Usage="serviceHostBase.IncrementManualFlowControlLimit incrementBy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="incrementBy" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="incrementBy">El número de mensajes en que aumentar el límite del control de flujo.</param>
        <summary>Aumenta el límite en la tasa de flujo de mensajes al servicio hospedado en un incremento especificado.</summary>
        <returns>El nuevo límite una vez agregado el incremento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se puede tener acceso a este límite utilizando la propiedad <xref:System.ServiceModel.ServiceHostBase.ManualFlowControlLimit%2A>.  
  
   
  
## Examples  
 [!code-csharp[S_SelfHost#42](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeDescription">
      <MemberSignature Language="C#" Value="protected void InitializeDescription (System.ServiceModel.UriSchemeKeyedCollection baseAddresses);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializeDescription(class System.ServiceModel.UriSchemeKeyedCollection baseAddresses) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.InitializeDescription(System.ServiceModel.UriSchemeKeyedCollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializeDescription (baseAddresses As UriSchemeKeyedCollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializeDescription(System::ServiceModel::UriSchemeKeyedCollection ^ baseAddresses);" />
      <MemberSignature Language="F#" Value="member this.InitializeDescription : System.ServiceModel.UriSchemeKeyedCollection -&gt; unit" Usage="serviceHostBase.InitializeDescription baseAddresses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseAddresses" Type="System.ServiceModel.UriSchemeKeyedCollection" />
      </Parameters>
      <Docs>
        <param name="baseAddresses"><see cref="T:System.ServiceModel.UriSchemeKeyedCollection" /> que contiene las direcciones base para el servicio hospedado.</param>
        <summary>Crea e inicializa el host del servicio con las descripciones de servicio y contrato.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeRuntime">
      <MemberSignature Language="C#" Value="protected virtual void InitializeRuntime ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeRuntime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.InitializeRuntime" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeRuntime ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeRuntime();" />
      <MemberSignature Language="F#" Value="abstract member InitializeRuntime : unit -&gt; unit&#xA;override this.InitializeRuntime : unit -&gt; unit" Usage="serviceHostBase.InitializeRuntime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa el tiempo de ejecución para el host del servicio.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La descripción del servicio hospedado es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadConfigurationSection">
      <MemberSignature Language="C#" Value="protected void LoadConfigurationSection (System.ServiceModel.Configuration.ServiceElement serviceSection);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void LoadConfigurationSection(class System.ServiceModel.Configuration.ServiceElement serviceSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.LoadConfigurationSection(System.ServiceModel.Configuration.ServiceElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub LoadConfigurationSection (serviceSection As ServiceElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void LoadConfigurationSection(System::ServiceModel::Configuration::ServiceElement ^ serviceSection);" />
      <MemberSignature Language="F#" Value="member this.LoadConfigurationSection : System.ServiceModel.Configuration.ServiceElement -&gt; unit" Usage="serviceHostBase.LoadConfigurationSection serviceSection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceSection" Type="System.ServiceModel.Configuration.ServiceElement" />
      </Parameters>
      <Docs>
        <param name="serviceSection">El <see cref="T:System.ServiceModel.Configuration.ServiceElement" /> que se va a cargar desde la configuración.</param>
        <summary>Carga el elemento de servicio desde el archivo de configuración o el servicio hospedado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="serviceSection" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">La descripción del servicio hospedado es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ManualFlowControlLimit">
      <MemberSignature Language="C#" Value="public int ManualFlowControlLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManualFlowControlLimit" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.ManualFlowControlLimit" />
      <MemberSignature Language="VB.NET" Value="Public Property ManualFlowControlLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManualFlowControlLimit { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ManualFlowControlLimit : int with get, set" Usage="System.ServiceModel.ServiceHostBase.ManualFlowControlLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el límite del control de flujo para los mensajes recibidos por el servicio hospedado.</summary>
        <value>El límite del control de flujo para los mensajes recibidos por el servicio hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este límite se puede incrementar utilizando el método <xref:System.ServiceModel.ServiceHostBase.IncrementManualFlowControlLimit%28System.Int32%29>.  
  
   
  
## Examples  
 [!code-csharp[S_SelfHost#39](~/samples/snippets/csharp/VS_Snippets_CFX/s_selfhost/cs/wholeenchilada.cs#39)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnAbort">
      <MemberSignature Language="C#" Value="protected override void OnAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnAbort" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAbort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAbort();" />
      <MemberSignature Language="F#" Value="override this.OnAbort : unit -&gt; unit" Usage="serviceHostBase.OnAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anula el servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginClose">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginClose (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginClose(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginClose (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginClose(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginClose : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="serviceHostBase.OnBeginClose (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de cierre asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de cierre asincrónica.</param>
        <summary>Comienza una operación asincrónica invocada en el cierre del host del servicio.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cierre asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginOpen">
      <MemberSignature Language="C#" Value="protected override IAsyncResult OnBeginOpen (TimeSpan timeout, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.IAsyncResult OnBeginOpen(valuetype System.TimeSpan timeout, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnBeginOpen (timeout As TimeSpan, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override IAsyncResult ^ OnBeginOpen(TimeSpan timeout, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.OnBeginOpen : TimeSpan * AsyncCallback * obj -&gt; IAsyncResult" Usage="serviceHostBase.OnBeginOpen (timeout, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</param>
        <param name="callback">El delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de apertura asincrónica.</param>
        <param name="state">Objeto, especificado por la aplicación, que contiene información de estado asociada a la operación de apertura asincrónica.</param>
        <summary>Comienza una operación asincrónica invocada en la apertura del host del servicio.</summary>
        <returns><see cref="T:System.IAsyncResult" /> que hace referencia a la operación de apertura asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClose">
      <MemberSignature Language="C#" Value="protected override void OnClose (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClose(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnClose(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClose (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClose(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnClose : TimeSpan -&gt; unit" Usage="serviceHostBase.OnClose timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de cierre para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Cierra el servicio hospedado, incluso sus distribuidores de canal y sus contextos de instancia y agentes de escucha asociados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a <xref:System.ServiceModel.ServiceHostBase.OnClose%28System.TimeSpan%29> tiene el siguiente efecto:  
  
-   Cierra toda la entrada a <xref:System.ServiceModel.Dispatcher.ChannelDispatcher>, lo que también cierra sus instancias <xref:System.ServiceModel.Channels.IChannelListener> asociadas. Esto detiene la aceptación de todos los canales nuevos.  
  
-   Llama a <xref:System.ServiceModel.Dispatcher.ChannelDispatcher.CloseInput%2A> en todos los objetos <xref:System.ServiceModel.InstanceContext>, lo que significa que dejarán de aceptar los nuevos mensajes.  
  
-   Espera a que todos los objetos <xref:System.ServiceModel.InstanceContext> se cierren, lo que sucede cuando sus canales asociados terminan de enviar todos los mensajes pendientes.  
  
-   Cierra los objetos <xref:System.ServiceModel.Dispatcher.ChannelDispatcher> asociados al host.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected override void OnClosed ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnClosed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnClosed" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnClosed ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnClosed();" />
      <MemberSignature Language="F#" Value="override this.OnClosed : unit -&gt; unit" Usage="serviceHostBase.OnClosed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos utilizados por el host de servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndClose">
      <MemberSignature Language="C#" Value="protected override void OnEndClose (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndClose(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnEndClose(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndClose (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndClose(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndClose : IAsyncResult -&gt; unit" Usage="serviceHostBase.OnEndClose result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> devuelto por una llamada al método <see cref="M:System.ServiceModel.ServiceHostBase.OnBeginClose(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Completa una operación asincrónica invocada en el cierre del host del servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndOpen">
      <MemberSignature Language="C#" Value="protected override void OnEndOpen (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndOpen(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnEndOpen(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndOpen (result As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndOpen(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="override this.OnEndOpen : IAsyncResult -&gt; unit" Usage="serviceHostBase.OnEndOpen result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">El <see cref="T:System.IAsyncResult" /> devuelto por una llamada al método <see cref="M:System.ServiceModel.ServiceHostBase.OnBeginOpen(System.TimeSpan,System.AsyncCallback,System.Object)" />.</param>
        <summary>Completa una operación asincrónica invocada en la apertura del host del servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpen">
      <MemberSignature Language="C#" Value="protected override void OnOpen (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpen(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnOpen(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpen (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpen(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="override this.OnOpen : TimeSpan -&gt; unit" Usage="serviceHostBase.OnOpen timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">El <see cref="T:System.TimeSpan" /> que especifica el tiempo con el que cuenta la operación de apertura para completarse antes de que se agote el tiempo de espera.</param>
        <summary>Abre los distribuidores del canal.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected override void OnOpened ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnOpened() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.OnOpened" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnOpened ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnOpened();" />
      <MemberSignature Language="F#" Value="override this.OnOpened : unit -&gt; unit" Usage="serviceHostBase.OnOpened " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene las credenciales de servicio, la autenticación de servicio y el comportamiento de autorización del servicio hospedado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez que se inicializan esos comportamientos al abrir el servicio, no se pueden cambiar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan OpenTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan OpenTimeout" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.ServiceHostBase.OpenTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property OpenTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan OpenTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.OpenTimeout : TimeSpan with get, set" Usage="System.ServiceModel.ServiceHostBase.OpenTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el intervalo de tiempo permitido para que el host del servicio se abra.</summary>
        <value><see cref="T:System.TimeSpan" /> que especifica el intervalo de tiempo permitido para que el host del servicio se abra</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor es menor que cero o es mayor que <see cref="F:System.Int32.MaxValue" /> (2,147,483,647 o, en notación hexadecimal, 0X7FFFFFFF).</exception>
        <exception cref="T:System.InvalidOperationException">El host está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Opening" /> o <see cref="F:System.ServiceModel.CommunicationState.Closing" /> y no se puede modificar.</exception>
        <exception cref="T:System.ObjectDisposedException">El host está ya en un estado <see cref="F:System.ServiceModel.CommunicationState.Closed" /> y no se puede modificar.</exception>
        <exception cref="T:System.ServiceModel.CommunicationObjectFaultedException">El host está en un estado de <see cref="F:System.ServiceModel.CommunicationState.Faulted" /> y no se puede modificar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleasePerformanceCounters">
      <MemberSignature Language="C#" Value="protected void ReleasePerformanceCounters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReleasePerformanceCounters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.ReleasePerformanceCounters" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReleasePerformanceCounters ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReleasePerformanceCounters();" />
      <MemberSignature Language="F#" Value="member this.ReleasePerformanceCounters : unit -&gt; unit" Usage="serviceHostBase.ReleasePerformanceCounters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera el servicio y los contadores de rendimiento de distribuidor de canal para el servicio hospedado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca este método al llamar <xref:System.ServiceModel.ServiceHostBase.OnClose%28System.TimeSpan%29> y  
  
 <xref:System.ServiceModel.ServiceHostBase.OnEndClose%28System.IAsyncResult%29>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEndpointAddress">
      <MemberSignature Language="C#" Value="public void SetEndpointAddress (System.ServiceModel.Description.ServiceEndpoint endpoint, string relativeAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetEndpointAddress(class System.ServiceModel.Description.ServiceEndpoint endpoint, string relativeAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.SetEndpointAddress(System.ServiceModel.Description.ServiceEndpoint,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetEndpointAddress (endpoint As ServiceEndpoint, relativeAddress As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetEndpointAddress(System::ServiceModel::Description::ServiceEndpoint ^ endpoint, System::String ^ relativeAddress);" />
      <MemberSignature Language="F#" Value="member this.SetEndpointAddress : System.ServiceModel.Description.ServiceEndpoint * string -&gt; unit" Usage="serviceHostBase.SetEndpointAddress (endpoint, relativeAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.ServiceModel.Description.ServiceEndpoint" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="relativeAddress" Type="System.String" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="endpoint">Extremo del servicio.</param>
        <param name="relativeAddress">Dirección del punto de conexión.</param>
        <summary>Establece la dirección del extremo especificado en la dirección especificada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.ServiceHostBase.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra el host del servicio.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnknownMessageReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt; UnknownMessageReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.ServiceModel.UnknownMessageReceivedEventArgs&gt; UnknownMessageReceived" />
      <MemberSignature Language="DocId" Value="E:System.ServiceModel.ServiceHostBase.UnknownMessageReceived" />
      <MemberSignature Language="VB.NET" Value="Public Event UnknownMessageReceived As EventHandler(Of UnknownMessageReceivedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::ServiceModel::UnknownMessageReceivedEventArgs ^&gt; ^ UnknownMessageReceived;" />
      <MemberSignature Language="F#" Value="member this.UnknownMessageReceived : EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt; " Usage="member this.UnknownMessageReceived : System.EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.ServiceModel.UnknownMessageReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se recibe un mensaje desconocido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Cuando se usa <xref:System.ServiceModel.WorkflowServiceHost>, exponer un extremo de hospedaje y un <xref:System.ServiceModel.ServiceHostBase.UnknownMessageReceived> excepción, el host pasa el mensaje al controlador de eventos. Si se realiza un intento de leer este mensaje un <xref:System.InvalidOperationException> se produce. La descripción de la excepción dirá "este mensaje no puede admitir la operación porque se ha leído."  La infraestructura de WCF lee el mensaje al extraer los parámetros de mensaje. Este mensaje, a continuación, se pasa al controlador de eventos y cualquier intento para leerlo provoca una excepción. Si necesita tener acceso a los parámetros de mensaje en su <xref:System.InvalidOperationException> controlador desde un punto de conexión de hospedaje, defina el contrato de punto de conexión de hospedaje mediante MessageContract y colocar los datos necesarios en un encabezado de mensaje. Para obtener más información sobre el hospedaje de los puntos de conexión, consulte [Workflow Service Host Extensibility](~/docs/framework/wcf/feature-details/workflow-service-host-extensibility.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>