<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="76d4d835f6dce4521d61c90bd9496531e320c717" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58701888" /></Metadata><TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <TypeSignature Language="F#" Value="type Encoding = class&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una codificación de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes. En cambio, la descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode. Para obtener información sobre los formatos de transformación de Unicode (UTF) y otras codificaciones compatibles con <xref:System.Text.Encoding>, consulte [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
 Tenga en cuenta que <xref:System.Text.Encoding> está diseñado para operar en caracteres Unicode en lugar de los datos binarios arbitrarios, como matrices de bytes. Si se deben codificar datos binarios arbitrarios en texto, debe usar un protocolo como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET proporciona las siguientes implementaciones de la <xref:System.Text.Encoding> clase para admitir actuales codificaciones Unicode y otras codificaciones:  
  
-   <xref:System.Text.ASCIIEncoding> codifica los caracteres Unicode como caracteres ASCII de 7 bits. Esta codificación solo admite valores de caracteres entre U + 0000 y 007F U +. Página de códigos 20127. También está disponible a través de la <xref:System.Text.Encoding.ASCII%2A> propiedad.  
  
-   <xref:System.Text.UTF7Encoding> codifica los caracteres Unicode mediante la codificación UTF-7. Esta codificación es compatible con todos los valores de caracteres Unicode. Página de códigos 65000. También está disponible a través de la <xref:System.Text.Encoding.UTF7%2A> propiedad.  
  
-   <xref:System.Text.UTF8Encoding> codifica los caracteres Unicode mediante la codificación UTF-8. Esta codificación es compatible con todos los valores de caracteres Unicode. Página de códigos 65001. También está disponible a través de la <xref:System.Text.Encoding.UTF8%2A> propiedad.  
  
-   <xref:System.Text.UnicodeEncoding> codifica los caracteres Unicode mediante la codificación UTF-16. Se admiten dos criterios de pequeño de bytes endian y big-endian. También está disponible a través de la <xref:System.Text.Encoding.Unicode%2A> propiedad y el <xref:System.Text.Encoding.BigEndianUnicode%2A> propiedad.  
  
-   <xref:System.Text.UTF32Encoding> codifica los caracteres Unicode mediante la codificación UTF-32. Little endian (página de códigos 12000) tanto bytes big endian (página de códigos 12001) se admiten los pedidos. También está disponible a través de la <xref:System.Text.Encoding.UTF32%2A> propiedad.  
  
 La <xref:System.Text.Encoding> clase está pensada principalmente para convertir entre codificaciones diferentes y Unicode. A menudo una de las clases derivadas de Unicode es la opción correcta para su aplicación.  
  
 Use la <xref:System.Text.Encoding.GetEncoding%2A> método para obtener otras codificaciones y llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una lista de todas las codificaciones.  
  
 En la tabla siguiente se enumera las codificaciones admitidas por .NET Framework y .NET Core. Enumera número de página de códigos del cada codificación y los valores de la codificación <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> y <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propiedades. Una marca de verificación en la **compatibilidad de .NET Framework** y **compatibilidad con .NET Core** columnas indica que la página de códigos de forma nativa es compatible con esa implementación. NET, independientemente de la plataforma subyacente. Para .NET Framework, la disponibilidad de otras codificaciones que se muestran en la tabla depende del sistema operativo. Para .NET Core, otras codificaciones están disponibles mediante el <xref:System.Text.CodePagesEncodingProvider?displayProperty=nameWithType> de clase o derivando por la <xref:System.Text.EncodingProvider?displayProperty=nameWithType> clase.  

> [!NOTE]
> Las páginas de códigos cuya <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propiedad se corresponde con un estándar internacional no son necesariamente compatibles en su totalidad con dicho estándar. 

|Página de códigos|nombre|Nombre para mostrar|Compatibilidad con .NET framework| Compatibilidad de .NET Core | 
|---------|----|------------|----------------------|-------------------|    
|37|IBM037|IBM EBCDIC (EE)|||  
|437|IBM437|Estados Unidos de OEM|||  
|500|IBM500|IBM EBCDIC (International)|||  
|708|ASMO-708|Árabe (ASMO 708)|||  
|720|DOS-720|Árabe (DOS)|||  
|737|ibm737|Griego (DOS)|||  
|775|ibm775|Pobaltské Jazyky (DOS)|||  
|850|ibm850|Západoevropské Jazyky (DOS)|||  
|852|ibm852|Centroeuropeo (DOS)|||  
|855|IBM855|OEM Cyrillic|||  
|857|ibm857|Turco (DOS)|||  
|858|IBM00858|Latín multilingüe OEM I|||  
|860|IBM860|Portugués (DOS)|||  
|861|ibm861|Islandés (DOS)|||  
|862|DOS-862|Hebreo (DOS)|||  
|863|IBM863|Francés canadiense (DOS)|||  
|864|IBM864|Árabe (864)|||  
|865|IBM865|Severské Jazyky (DOS)|||  
|866|cp866|Cyrilice (DOS)|||  
|869|ibm869|Griego moderno (DOS)|||  
|870|IBM870|IBM EBCDIC (Latín multilingüe-2)|||  
|874|windows-874|Tailandés (Windows)|||  
|875|cp875|IBM EBCDIC (Griego moderno)|||  
|932|shift_jis|Japonés (Shift-JIS)|||  
|936|gb2312|Chino simplificado (GB2312)|✓||  
|949|ks_c_5601-1987|Coreano|||  
|950|big5|Chino tradicional (Big5)|||  
|1026|IBM1026|IBM EBCDIC (Turco latino-5)|||  
|1047|IBM01047|IBM Latin 1|||  
|1140|IBM01140|IBM EBCDIC (EE. UU.-Kanada-Euro)|||  
|1141|IBM01141|IBM EBCDIC (Alemania-Euro)|||  
|1142|IBM01142|IBM EBCDIC (Dinamarca a Norsko-Euro)|||  
|1143|IBM01143|IBM EBCDIC (Sweden-Finland-Euro)|||  
|1144|IBM01144|IBM EBCDIC (Italy-Euro)|||  
|1145|IBM01145|IBM EBCDIC (España-Euro)|||  
|1146|IBM01146|IBM EBCDIC (Reino Unido-Euro)|||  
|1147|IBM01147|IBM EBCDIC (Francie-Euro)|||  
|1148|IBM01148|IBM EBCDIC (International-Euro)|||  
|1149|IBM01149|IBM EBCDIC (Island-Euro)|||  
|1200|utf-16|Unicode|✓|✓|  
|1201|unicodeFFFE|Unicode (Big-endian)|✓|✓|  
|1250|windows-1250|Centroeuropeo (Windows)|||  
|1251|windows-1251|Cirílico (Windows)|||  
|1252|Windows-1252|Europeo occidental (Windows)|✓||  
|1253|windows-1253|Griego (Windows)|||  
|1254|windows-1254|Turco (Windows)|||  
|1255|windows-1255|Hebrew (Windows)|||  
|1256|windows-1256|Árabe (Windows)|||  
|1257|windows-1257|Báltico (Windows)|||  
|1258|windows-1258|Vietnamita (Windows)|||  
|1361|Johab|Coreano (Johab)|||  
|10000|macintosh|Europeo occidental (Mac)|||  
|10001|x-mac-japanese|Japonés (Mac)|||  
|10002|x-mac-chinesetrad|Chino tradicional (Mac)|||  
|10003|x-mac-korean|Coreano (Mac)|✓||  
|10004|x-mac-arabic|Árabe (Mac)|||  
|10005|x-mac-hebrew|Hebreo (Mac)|||  
|10006|x-mac-greek|Griego (Mac)|||  
|10007|x-mac-cyrillic|Cyrilice (Mac)|||  
|10008|x-mac-chinesesimp|Chino simplificado (Mac)|✓||  
|10010|mac-x-rumano|Rumano (Mac)|||  
|10017|x-mac-ukrainian|Ucraniano (Mac)|||  
|10021|x-mac-thai|Tailandés (Mac)|||  
|10029|x-mac-ce|Centroeuropeo (Mac)|||  
|10079|x-mac-icelandic|Islandés (Mac)|||  
|10081|x-mac-turkish|Turco (Mac)|||  
|10082|x-mac-croatian|Croata (Mac)|||  
|12000|utf-32|Unicode (UTF-32)|✓|✓|  
|12001|utf-32BE|Unicode (UTF-32 Big-endian)|✓|✓|  
|20000|Chino-x-CNS|Chino tradicional (CNS)|||  
|20001|x-cp20001|Tchaj-WAN|||  
|20002|Chino-x-Eten|Chino tradicional (Eten)|||  
|20003|x-cp20003|WAN Ibm5550|||  
|20004|x-cp20004|Tchaj-WAN teleText|||  
|20005|x-cp20005|Tchaj-WAN Wang|||  
|20105|x-IA5|Europeo occidental (IA5)|||  
|20106|x-IA5-German|Alemán (IA5)|||  
|20107|x-IA5-Swedish|Sueco (IA5)|||  
|20108|x-IA5-Noruego|Noruego (IA5)|||  
|20127|us-ascii|US-ASCII|✓|✓|  
|20261|x-cp20261|T.61|||  
|20269|x-cp20269|ISO-6937|||  
|20273|IBM273|IBM EBCDIC (Alemania)|||  
|20277|IBM277|IBM EBCDIC (Dánsko a Norsko)|||  
|20278|IBM278|IBM EBCDIC (Finlandia-Suecia)|||  
|20280|IBM280|IBM EBCDIC (Itálie)|||  
|20284|IBM284|IBM EBCDIC (España)|||  
|20285|IBM285|IBM EBCDIC (UK)|||  
|20290|IBM290|IBM EBCDIC (japonsko-katakana)|||  
|20297|IBM297|IBM EBCDIC (Francie)|||  
|20420|IBM420|IBM EBCDIC (árabe)|||  
|20423|IBM423|IBM EBCDIC (griego)|||  
|20424|IBM424|IBM EBCDIC (hebreo)|||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (coreano extendido)|||  
|20838|IBM-Thai|IBM EBCDIC (tailandés)|||  
|20866|koi8-r|Cirílico (KOI8-R)|||  
|20871|IBM871|IBM EBCDIC (Islandés)|||  
|20880|IBM880|IBM EBCDIC (Ruská cyrilice)|||  
|20905|IBM905|IBM EBCDIC (turco)|||  
|20924|IBM00924|IBM Latin 1|||  
|20932|EUC-JP|Japonés (JIS 0208-1990 y 0212 1990)|||  
|20936|x-cp20936|Chino simplificado (GB2312-80)|✓||  
|20949|x-cp20949|Coreano Wansung|✓||  
|21025|cp1025|IBM EBCDIC (Srbská a Bulharská)|||  
|21866|koi8-u|Cirílico (KOI8-U)|||  
|28591|iso-8859-1|Europeo occidental (ISO)|✓|✓|  
|28592|iso-8859-2|Centroeuropeo (ISO)|||  
|28593|iso-8859-3|Latín 3 (ISO)|||  
|28594|iso-8859-4|Báltico (ISO)|||  
|28595|iso-8859-5|Cyrilice (ISO)|||  
|28596|iso-8859-6|Árabe (ISO)|||  
|28597|iso-8859-7|Griego (ISO)|||  
|28598|iso-8859-8|Hebreo (ISO-Visual)|✓||  
|28599|iso-8859-9|Turco (ISO)|||  
|28603|iso-8859-13|Estonio (ISO)|||  
|28605|iso-8859-15|Latín 9 (ISO)|||  
|29001|x-Europa|Europa|||  
|38598|iso-8859-8-i|Hebreo (ISO-lógico)|✓||  
|50220|iso-2022-jp|Japonés (JIS)|✓||  
|50221|csISO2022JP|Japonés (JIS-permitir 1 byte Kana)|✓||  
|50222|iso-2022-jp|Japonés (JIS-permitir 1 byte Kana - tan / SI)|✓||  
|50225|iso-2022-kr|Coreano (ISO)|✓||  
|50227|x-cp50227|Chino simplificado (ISO-2022)|✓||  
|51932|euc-jp|Japonés (EUC)|✓||  
|51936|EUC-CN|Chino simplificado (EUC)|✓||  
|51949|euc-kr|Coreano (EUC)|✓||  
|52936|hz-gb-2312|Chino simplificado (HZ)|✓||  
|54936|GB18030|Chino simplificado (GB18030)|✓||  
|57002|x-iscii-de|ISCII Devanagari|✓||  
|57003|x-iscii-be|ISCII Bengali|✓||  
|57004|x-iscii-ta|ISCII Tamil|✓||  
|57005|x-iscii-te|ISCII Telugu|✓||  
|57006|x-iscii-as|ISCII Asamés|✓||  
|57007|x-iscii-or|ISCII Oriya|✓||  
|57008|x-iscii-ka|ISCII Kannada|✓||  
|57009|x-iscii-ma|ISCII Malayalam|✓||  
|57010|x-iscii-gu|ISCII Gujarati|✓||  
|57011|x-iscii-pa|ISCII Punjabi|✓||  
|65000|utf-7|Unicode (UTF-7)|✓|✓|  
|65001|utf-8|Unicode (UTF-8)|✓|✓|  
  
 El ejemplo siguiente se llama el <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> y <xref:System.Text.Encoding.GetEncoding%28System.String%29> codificación de la página de código de los métodos para obtener el griego (Windows). Compara la <xref:System.Text.Encoding> los objetos devueltos por las llamadas de método para mostrar que son iguales y, a continuación, se asigna muestra el punto de código Unicode y el valor de página de códigos correspondiente para cada carácter del alfabeto griego.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 Los codificadores UTF-32 y la UTF-16 pueden usar el orden de bytes big endian (byte más significativo primero) o el orden de bytes endian little (byte menos significativo primero). Por ejemplo, la letra mayúscula latina A (u+0041) se serializa como sigue (en hexadecimal):  
  
-   Orden de bytes big endian de UTF-16: 00 41  
  
-   Orden little-endian bytes de UTF-16: 41 00  
  
-   Orden de bytes big endian de UTF-32: 00 00 00 41  
  
-   Orden little-endian bytes de UTF-32: 41 00 00 00  
  
 Es normalmente más eficaz para almacenar caracteres Unicode mediante el orden de bytes nativo. Por ejemplo, es mejor utilizar el orden de bytes endian little en plataformas little-endian, como equipos Intel.  
  
 El <xref:System.Text.Encoding.GetPreamble%2A> método recupera una matriz de bytes que incluye la marca de orden de bytes (BOM). Si esta matriz de bytes se antepone a una secuencia codificada, ayuda al descodificador a identificar el formato de codificación utilizado.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en el [página principal de Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Tenga en cuenta que las clases de codificación que los errores:  
  
-   En modo silencioso, cambie a un "?" caracteres.  
  
-   Utilice un carácter "ajuste perfecto".  
  
-   Cambiar a un comportamiento específico de la aplicación mediante el uso de la <xref:System.Text.EncoderFallback> y <xref:System.Text.DecoderFallback> clases con el carácter de reemplazo Unicode U+FFFD.  
  
 Debe producir una excepción en cualquier error de flujo de datos. Una aplicación, usa un marcador "throwonerror" cuando sea aplicable o usa el <xref:System.Text.EncoderExceptionFallback> y <xref:System.Text.DecoderExceptionFallback> clases. Retroceso de ajuste perfecto a menudo no se recomienda porque puede provocar pérdida de datos o confusión y es más lenta que la sustitución de caracteres simple. Codificaciones ANSI, el comportamiento de ajuste perfecto es el valor predeterminado.  
  
   
  
## Examples  
 El ejemplo siguiente convierte una cadena de una codificación a otra.  
  
> [!NOTE]
>  La matriz de byte [] es el único tipo en este ejemplo que contiene los datos codificados. Los tipos .NET Char y String son Unicode, por lo que el <xref:System.Text.Encoding.GetChars%2A> llamada descodifica los datos a Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas invalidar este constructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int -&gt; System.Text.Encoding" Usage="new System.Text.Encoding codePage" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificador de página de códigos de la codificación preferida.  
  
O bien 
0, para utilizar la codificación predeterminada.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" /> que corresponde a la página de códigos especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas invalidar este constructor.  
  
 Las llamadas a este constructor desde una clase derivada crean un <xref:System.Text.Encoding> objeto que usa la reserva con ajuste perfecto para las operaciones de descodificación y codificación. Tanto el <xref:System.Text.Encoding.DecoderFallback%2A> y <xref:System.Text.Encoding.EncoderFallback%2A> propiedades son de solo lectura y no se puede modificar. Para controlar la estrategia de reserva para una clase derivada de <xref:System.Text.Encoding>, llame a la <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> es menor que cero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="new System.Text.Encoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="new System.Text.Encoding (codePage, encoderFallback, decoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificador de página de códigos de codificación.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" /> que corresponde a la página de códigos indicada que tiene las estrategias de reserva de codificador y descodificador especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor es `protected`; derivada clases invalidación.  
  
 Llamar a este constructor desde una clase derivada para controlar la reserva de codificación y descodificación de estrategias. El <xref:System.Text.Encoding> constructores de clase crean objetos de codificación de solo lectura que no permiten el codificador o descodificador de reserva debe establecerse después de crear el objeto.  
  
 Si bien `encoderFallback` o `decoderFallback` es null, se usa la reserva con ajuste perfecto como la estrategia de reserva correspondiente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codePage" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ASCII : System.Text.Encoding" Usage="System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el juego de caracteres ASCII (de 7 bits).</summary>
        <value>Codificación para el juego de caracteres ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres ASCII se limitan a los 128 caracteres Unicode más bajos, de u+0000 a 007F U +.  
  
 Al seleccionar la codificación ASCII para la aplicación, tenga en cuenta lo siguiente:  
  
-   La codificación ASCII es normalmente adecuada para los protocolos que requieren ASCII.  
  
-   Si se requiere la codificación de 8 bits (que a veces incorrectamente se denomina "ASCII"), la codificación UTF-8 es preferible el ASCII codificación. Para los caracteres 0-7F, los resultados son idénticos, pero el uso de UTF-8 evita la pérdida de datos, ya que permite la representación de todos los caracteres Unicode que se puede representar. Tenga en cuenta que la codificación ASCII tiene un 8 bit ambigüedad que puede permitir el uso malintencionado, pero la codificación UTF-8 elimina la ambigüedad acerca de los 8 bits.  
  
-   Antes de la versión 2.0 de .NET Framework, .NET Framework permite la suplantación de identidad pasando por alto el bit 8. A partir de .NET Framework 2.0, los puntos de código que no son ASCII retrocedan durante la descodificación.  
  
 La <xref:System.Text.ASCIIEncoding> objeto devuelto por esta propiedad puede no tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> método para crear instancias de un <xref:System.Text.ASCIIEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente muestra el efecto de la codificación ASCII en caracteres que están fuera del intervalo ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BigEndianUnicode : System.Text.Encoding" Usage="System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-16 que utiliza el orden de bytes big endian.</summary>
        <value>Objeto de codificación para el formato UTF-16 que utiliza el orden de bytes big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UnicodeEncoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un big endian <xref:System.Text.UnicodeEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 El valor devuelto <xref:System.Text.UnicodeEncoding> objeto tiene <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, y <xref:System.Text.Encoding.WebName%2A> propiedades, que producen el nombre "unicodeFFFE". Aunque la marca de orden de bytes big endian de UTF-16 es FEFF hexadecimal, se ha elegido el nombre "unicodeFFFE" porque la marca de orden de bytes aparece como FFFE hexadecimal en little-endian equipos de Windows.  
  
   
  
## Examples  
 El ejemplo siguiente lee un archivo de texto con una codificación UTF-16 utilizando el orden de bytes big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BodyName : string" Usage="System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un nombre para la codificación actual que se puede utilizar con etiquetas de cuerpo de un programa de correo.</summary>
        <value>Nombre para la clase <see cref="T:System.Text.Encoding" /> actual, que puede utilizarse con etiquetas de cuerpo de un programa de correo.  
  
O bien 
Una cadena vacía (""), si no se puede usar la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita una codificación para un nombre del cuerpo, debe llamar a <xref:System.Text.Encoding.GetEncoding%2A> con el <xref:System.Text.Encoding.BodyName%2A> propiedad. A menudo el método recupera una codificación distinta de la codificación de pruebas proporcionada en la llamada. Por lo general necesitan recuperar este tipo de codificación; solo las aplicaciones de correo electrónico deben usar la mayoría de otras aplicaciones que necesitan para describir una codificación su <xref:System.Text.Encoding.WebName%2A>.  
  
 En algunos casos, el valor de la <xref:System.Text.Encoding.BodyName%2A> propiedad se corresponde con el estándar internacional que define esa codificación. Esto no significa que la implementación cumple plenamente con dicho estándar.  
  
   
  
## Examples  
 El ejemplo siguiente se recuperan los nombres diferentes para cada tipo de codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="encoding.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, crea una copia superficial del objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <returns>Copia del objeto <see cref="T:System.Text.Encoding" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El clon es grabable aunque original <xref:System.Text.Encoding> objeto es de solo lectura. Por lo tanto, se pueden modificar las propiedades del clon.  
  
 Una copia superficial de un objeto es una copia del objeto únicamente. Si el objeto contiene referencias a otros objetos, la copia superficial no crea copias de los objetos que se hace referencia. Se refiere a los objetos originales en su lugar. En cambio, una copia en profundidad de un objeto crea una copia del objeto y una copia de todo lo que hace referencia directa o indirectamente por ese objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CodePage : int" Usage="System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el identificador de la página de códigos de la clase <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Identificador de la página de códigos de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se recuperan los nombres diferentes para cada tipo de codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte una matriz de bytes de una codificación a otra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Formato de codificación de <paramref name="bytes" />.</param>
        <param name="dstEncoding">Formato de codificación de destino.</param>
        <param name="bytes">Bytes que se van a convertir.</param>
        <summary>Convierte una matriz de bytes completa de una codificación a otra.</summary>
        <returns>Matriz de tipo <see cref="T:System.Byte" /> que contiene el resultado de convertir <paramref name="bytes" /> de <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente convierte una cadena con codificación Unicode en una cadena codificada en ASCII. Dado que el objeto de codificación ASCII devuelto por la <xref:System.Text.Encoding.ASCII%2A> propiedad usa la reserva de reemplazo y el carácter de Pi no forma parte del juego de caracteres ASCII, el carácter de Pi se reemplaza por un signo de interrogación, como la salida se muestra en el ejemplo.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> es <see langword="null" />.  
  
O bien 
 <paramref name="dstEncoding" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 **srcEncoding.** El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 **dstEncoding.** El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Convert : System.Text.Encoding * System.Text.Encoding * byte[] * int * int -&gt; byte[]" Usage="System.Text.Encoding.Convert (srcEncoding, dstEncoding, bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Codificación de la matriz de origen, <paramref name="bytes" />.</param>
        <param name="dstEncoding">Codificación de la matriz de salida.</param>
        <param name="bytes">Matriz de bytes que se va a convertir.</param>
        <param name="index">Índice del primer elemento de <paramref name="bytes" /> que se va a convertir.</param>
        <param name="count">Número de bytes que se va a convertir.</param>
        <summary>Convierte un intervalo de bytes de una matriz de una codificación a otra.</summary>
        <returns>Matriz de tipo <see cref="T:System.Byte" /> que contiene el resultado de convertir un intervalo de bytes de <paramref name="bytes" /> de <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="srcEncoding" /> es <see langword="null" />.  
  
O bien 
 <paramref name="dstEncoding" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> y <paramref name="count" /> no especifican un intervalo válido en la matriz de bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 **srcEncoding.** El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 **dstEncoding.** El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DecoderFallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Text.DecoderFallback" /> para el objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Objeto de reserva del descodificador para el objeto <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.DecoderFallback> objeto representa un controlador de errores que se invoca cuando no se puede descodificar una secuencia de bytes codificada en un carácter. Es compatible con cualquiera de los siguientes tipos de controlador:  
  
-   Un ajuste perfecto controlador de reserva, que reemplaza los bytes que no se puede descodificar con algún carácter de reemplazo adecuado.  
  
-   Un reemplazo controlador de reserva, que reemplaza los bytes que no se puede descodificar con algún carácter de reemplazo arbitrario. .NET incluye un controlador de reserva de reemplazo, <xref:System.Text.DecoderFallback>, que de forma predeterminada reemplaza los bytes que no se puede descodificar con un signo de interrogación ("?") caracteres.  
  
-   Reserva controladores de excepciones, que produce una excepción cuando no se puede descodificar bytes. .NET incluye un controlador de reserva de excepción, <xref:System.Text.DecoderExceptionFallback>, que produce una <xref:System.Text.DecoderFallbackException> cuando no se puede descodificar bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de una operación Set es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede asignar un valor en una operación de conjunto porque el objeto <see cref="T:System.Text.Encoding" /> actual es de sólo lectura.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Encoding" Usage="System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la codificación predeterminada para esta implementación de .NET.</summary>
        <value>La codificación predeterminada para esta implementación. NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Diferentes equipos pueden utilizar diferentes codificaciones como valor predeterminado y la codificación predeterminada puede cambiar en un único equipo. Si usas el <xref:System.Text.Encoding.Default%2A> codificación para codificar y descodificar los datos se transmiten entre equipos o se recupera en momentos diferentes en el mismo equipo, pueden traducir datos incorrectamente. Además, la codificación devuelta por la <xref:System.Text.Encoding.Default%2A> propiedad usa la reserva con ajuste perfecto para asignar caracteres no admitidos a caracteres compatibles con la página de códigos. Por estas razones, no se recomienda usar la codificación predeterminada. Para garantizar que los bytes codificados se descodifican correctamente, debe usar una codificación Unicode, como <xref:System.Text.UTF8Encoding> o <xref:System.Text.UnicodeEncoding>. También puede usar un protocolo de nivel superior para asegurarse de que se usa el mismo formato de codificación y descodificación.  

### <a name="the-default-property-in-the-net-framework"></a>La propiedad predeterminada en .NET Framework

En .NET Framework en el escritorio de Windows, el <xref:System.Text.Encoding.Default%2A> propiedad siempre obtiene la página de códigos activa del sistema y crea un <xref:System.Text.Encoding> objeto que corresponde a él. La página de códigos activa puede ser una página de códigos ANSI, lo que incluye el conjunto junto con caracteres adicionales que varían por página de códigos de caracteres ASCII. Dado que todos los <xref:System.Text.Encoding.Default%2A> codificaciones basadas en las páginas de códigos ANSI perder datos, considere el uso de la <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> codificación en su lugar. UTF-8 a menudo es 00 U + idéntico al intervalo U + 7F, pero puede codificar caracteres fuera del intervalo ASCII sin pérdida.

## <a name="the-default-property-on-net-core"></a>La propiedad predeterminada en .NET Core

En .NET Core, el <xref:System.Text.Encoding.Default%2A> propiedad siempre devuelve el <xref:System.Text.UTF8Encoding>. UTF-8 se admite en todos los sistemas operativos (Windows, Linux y Max OS X) en las aplicaciones de .NET Core que ejecutar.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.EncoderFallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Text.EncoderFallback" /> para el objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Objeto de reserva del codificador para el objeto <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.EncoderFallback> objeto representa un controlador de errores que se invoca cuando un carácter no se puede convertir en una secuencia de bytes codificada. Es compatible con cualquiera de los siguientes tipos de controlador:  
  
-   Un ajuste perfecto controlador de reserva, que reemplaza los caracteres que no se puede codificar con algún carácter de reemplazo adecuado.  
  
-   Un reemplazo controlador de reserva, que reemplaza los caracteres que no se puede codificar con algún carácter de reemplazo arbitrario. .NET incluye un controlador de reserva de reemplazo, <xref:System.Text.EncoderFallback>, que de forma predeterminada reemplaza los caracteres que no se puede codificar con un signo de interrogación ("?") caracteres.  
  
-   Reserva controladores de excepciones, que produce una excepción cuando no se puede codificar caracteres. .NET incluye un controlador de reserva de excepción, <xref:System.Text.EncoderExceptionFallback>, que produce una <xref:System.Text.EncoderFallbackException> cuando no se puede descodificar caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de una operación Set es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede asignar un valor en una operación de conjunto porque el objeto <see cref="T:System.Text.Encoding" /> actual es de sólo lectura.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EncodingName : string" Usage="System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la descripción inteligible de la codificación actual.</summary>
        <value>Descripción inteligible de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.EncodingName%2A> propiedad está pensada para su presentación. Para buscar un nombre que se puede pasar a la <xref:System.Text.Encoding.GetEncoding%2A> método, use el <xref:System.Text.Encoding.WebName%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente se recuperan los nombres diferentes para cada tipo de codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a comparar con la instancia actual.</param>
        <summary>Determina si el objeto <see cref="T:System.Object" /> especificado es igual a la instancia actual.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> es una instancia de <see cref="T:System.Text.Encoding" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos instancias de <xref:System.Text.Encoding> se consideran iguales si corresponden a la misma página de códigos y sus `EncoderFallback` y `DecoderFallback` objetos son iguales. En concreto, todas las páginas de código derivado tienen una página de códigos de 0 y sus retrocesos son normalmente `null` (`Nothing` en Visual Basic. NET). Por lo tanto son todas se consideran iguales entre sí. Una consecuencia es que cuando <xref:System.Text.Encoding.Equals%2A> se usa para rellenar una tabla hash, todas derivadas codificaciones son iguales y se dividen en la misma ranura de la tabla hash.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una por página de códigos) y otra por nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] -&gt; int&#xA;override this.GetByteCount : char[] -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene los caracteres que se codifican.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar todos los caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes generados al codificar todos los caracteres de la matriz de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar.  
  
-   Si la aplicación controla las entradas de cadena, debe usar las versiones de cadena de la <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="encoding.GetByteCount chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : string -&gt; int&#xA;override this.GetByteCount : string -&gt; int" Usage="encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar los caracteres de la cadena especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar.  
  
-   Si la aplicación controla las entradas de cadena, la versión de cadena <xref:System.Text.Encoding.GetBytes%2A> se recomienda.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una cadena o un rango en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres a partir del puntero de caracteres especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoding.GetBytes%2A> requiere para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones sobre el uso de estos métodos:  
  
-   Puede necesitar la aplicación codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar.  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena del <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%2A> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int -&gt; int" Usage="encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar.  
  
-   Si la aplicación controla las entradas de cadena, la versión de cadena <xref:System.Text.Encoding.GetBytes%2A> se recomienda.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : string * int * int -&gt; int" Usage="encoding.GetByteCount (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] -&gt; byte[]&#xA;override this.GetBytes : char[] -&gt; byte[]" Usage="encoding.GetBytes chars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene los caracteres que se codifican.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica todos los caracteres de la matriz de caracteres especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe llamar a la versión de cadena del <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string -&gt; byte[]&#xA;override this.GetBytes : string -&gt; byte[]" Usage="encoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene los caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica todos los caracteres de la cadena especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una cadena o un rango en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; -&gt; int" Usage="encoding.GetBytes (chars, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int -&gt; byte[]&#xA;override this.GetBytes : char[] * int * int -&gt; byte[]" Usage="encoding.GetBytes (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la matriz de caracteres especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetBytes : string * int * int -&gt; byte[]" Usage="encoding.GetBytes (s, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Byte*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por el parámetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoding.GetBytes%2A> requiere para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> o <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la matriz de caracteres especificada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : string * int * int * byte[] * int -&gt; int&#xA;override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la cadena especificada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   Para codificar los caracteres de entrada muchas a una página de códigos y procesar los caracteres utilizando varias llamadas, podría necesitar la aplicación. En este caso, probablemente necesite mantener el estado entre llamadas, teniendo en cuenta el estado que se conserve el <xref:System.Text.Encoder> de objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no será capaz de mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación controla las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o insertar en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admita las matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tantos datos como sea posible y producir una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una cadena o un rango en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] -&gt; int&#xA;override this.GetCharCount : byte[] -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar todos los bytes de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método. Para calcular el tamaño máximo de la matriz, se debe utilizar el <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> método. El <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas.  
  
-   Si la aplicación administra los resultados de la cadena, debe usar el <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="encoding.GetCharCount bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes a partir del puntero de bytes especificado.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoding.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas.  
  
-   Si la aplicación administra los resultados de la cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas.  
  
-   Si la aplicación administra los resultados de la cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente convierte una cadena de una codificación a otra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes en un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] -&gt; char[]&#xA;override this.GetChars : byte[] -&gt; char[]" Usage="encoding.GetChars bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica todos los bytes de la matriz de bytes especificada en un juego de caracteres.</summary>
        <returns>Matriz de caracteres que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para varios pasos en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en los datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe usar un protocolo como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas, porque se pueden interrumpir las secuencias de bytes cuando se procesen en lotes. (Por ejemplo, puede finalizar la parte de una secuencia de ISO-2022 MAYÚS uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio del siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la siguiente llamada.)  
  
-   Si la aplicación administra los resultados de la cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; -&gt; int" Usage="encoding.GetChars (bytes, chars)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int -&gt; char[]&#xA;override this.GetChars : byte[] * int * int -&gt; char[]" Usage="encoding.GetChars (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en un juego de caracteres.</summary>
        <returns>Matriz de caracteres que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para varios pasos en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en los datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe usar un protocolo como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas, porque se pueden interrumpir las secuencias de bytes cuando se procesen en lotes. (Por ejemplo, puede finalizar la parte de una secuencia de ISO-2022 MAYÚS uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio del siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la siguiente llamada.)  
  
-   Si la aplicación administra los resultados de la cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="chars" Type="System.Char*" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="charCount" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</summary>
        <returns>Número real de caracteres escritos en la ubicación indicada por el parámetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoding.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para varios pasos en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en los datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe usar un protocolo como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas, porque se pueden interrumpir las secuencias de bytes cuando se procesen en lotes. (Por ejemplo, puede finalizar la parte de una secuencia de ISO-2022 MAYÚS uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio del siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la siguiente llamada.)  
  
-   Si la aplicación administra los resultados de la cadena, la <xref:System.Text.Encoding.GetString%2A> método es recomendable. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.  
  
O bien 
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> o <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > obtiene caracteres de una secuencia de bytes de entrada. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñada para varios pasos en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en los datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe usar un protocolo como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, en contraposición al <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en un único flujo de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación deba descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre llamadas, porque se pueden interrumpir las secuencias de bytes cuando se procesen en lotes. (Por ejemplo, puede finalizar la parte de una secuencia de ISO-2022 MAYÚS uno [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > llamar y continuar desde el principio del siguiente [\], Int32, Int32, Char\<xref : System.Text.Encoding.GetChars%2A > llamar. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la siguiente llamada.)  
  
-   Si la aplicación administra los resultados de la cadena, la <xref:System.Text.Encoding.GetString%2A> método es recomendable. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a usar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite caracteres de salida búferes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método en lugar de <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tantos datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de un flujo, este método suele ser la mejor opción.  
  
   
  
## Examples  
 El ejemplo siguiente convierte una cadena de una codificación a otra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.  
  
O bien 
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
O bien 
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="abstract member GetDecoder : unit -&gt; System.Text.Decoder&#xA;override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un descodificador que convierte una secuencia de bytes codificada en una secuencia de caracteres.</summary>
        <returns>Clase <see cref="T:System.Text.Decoder" /> que convierte una secuencia de bytes codificada en una secuencia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <xref:System.Text.Encoding.GetChars%2A> método de esta clase. Sin embargo, un <xref:System.Text.Decoder> mantiene la información de estado entre llamadas, de modo que descodifica correctamente las secuencias de bytes que abarcan distintos bloques. El <xref:System.Text.Decoder> también conserva los bytes al final de los bloques de datos y usa los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La implementación predeterminada devuelve un <see cref="T:System.Text.Decoder" /> que llama el <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> y <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> métodos del actual <see cref="T:System.Text.Encoding" />. Debe invalidar este método para devolver un <see cref="T:System.Text.Decoder" /> que mantiene su estado entre llamadas.</para></block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="abstract member GetEncoder : unit -&gt; System.Text.Encoder&#xA;override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada.</summary>
        <returns>Clase <see cref="T:System.Text.Encoder" /> que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes, de forma similar a la <xref:System.Text.Encoding.GetBytes%2A> método de esta clase. Sin embargo, un <xref:System.Text.Encoder> mantiene información de estado entre llamadas, por lo que codifica correctamente las secuencias de caracteres que abarcan distintos bloques. El <xref:System.Text.Encoder> también conserva finales caracteres al final de los bloques de datos y usa caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto no coincidente, y el suplente bajo podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>La implementación predeterminada devuelve un <see cref="T:System.Text.Encoder" /> que llama el <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> y <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> métodos del actual <see cref="T:System.Text.Encoding" />. Debe invalidar este método para devolver un <see cref="T:System.Text.Encoder" /> que mantiene su estado entre llamadas.</para></block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una codificación para la página de códigos especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding codepage" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificador de página de códigos de la codificación preferida. Se hace una lista de los valores posibles en la columna Página de códigos de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.  
  
O bien 
0 (cero), para utilizar la codificación predeterminada.</param>
        <summary>Devuelve la codificación asociada al identificador de página de códigos especificado.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El controlador de reserva depende del tipo de codificación `codepage`. Si `codepage` está establecido de un carácter de código de página o de doble byte (DBCS) de codificación, se usa un controlador de reserva con ajuste perfecto. En caso contrario, se usa un controlador de reserva de reemplazo. Estos controladores de reserva pueden no ser adecuados para la aplicación. Para especificar el controlador de reserva usa la codificación especificada por `codepage`, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  
  
 En .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de las páginas de código. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. En .NET Core, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve las codificaciones compatibles de forma nativa con .NET Core. En ambas implementaciones de. NET, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones disponibles. 

 Además de las codificaciones que están disponibles de forma nativa en .NET Core o que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve cualquier codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  

También puede proporcionar un valor de 0 para el `codepage` argumento. Su comportamiento exacto depende de si las codificaciones están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto:

- Si se han registrado uno o varios proveedores de codificación, devuelve la codificación del último proveedor registrado que ha elegido para devolver una codificación cuando la <xref:System.Text.Encoding.GetEncoding%2A> se pasa al método un `codepage` argumento de 0.     

- En .NET Framework, si ninguna codificación proveedor se ha registrado, si la <xref:System.Text.CodePagesEncodingProvider> es el proveedor de codificación registrado, o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve la página de códigos activa del sistema operativo. Para determinar la página de códigos activa en sistemas Windows, llame a la Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) función desde .NET Framework en el escritorio de Windows.

- En .NET Core, si no se ha registrado el proveedor de codificación o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve el <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Páginas de código no compatible causa un <xref:System.ArgumentException> que se produzca, mientras que otras producen un <xref:System.NotSupportedException>. Por lo tanto, el código debe detectar todas las excepciones indicadas en la sección excepciones.  
  
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Por este motivo, si la página de códigos activa es una página de códigos ANSI, codificación y descodificación de datos mediante la página de códigos del valor predeterminado devuelven por `Encoding.GetEncoding(0)` no se recomienda. Para obtener resultados más coherentes, debe usar una codificación Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  

   
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una página de códigos) y otra por nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> es menor que cero o mayor que 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la página de códigos de la codificación preferida. Cualquier valor devuelto por la propiedad <see cref="P:System.Text.Encoding.WebName" /> es válido. Se hace una lista de los valores posibles en la columna Nombre de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.</param>
        <summary>Devuelve la codificación asociada al nombre especificado de la página de códigos.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El controlador de reserva depende del tipo de codificación `name`. Si `name` está establecido de un carácter de código de página o de doble byte (DBCS) de codificación, se usa un controlador de reserva con ajuste perfecto. En caso contrario, se usa un controlador de reserva de reemplazo. Estos controladores de reserva pueden no ser adecuados para la aplicación. Para especificar el controlador de reserva usa la codificación especificada por `name`, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  

En .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de las páginas de código. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. En .NET Core, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve las codificaciones compatibles de forma nativa con .NET Core. En ambas implementaciones de. NET, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones disponibles. 

 Además de las codificaciones que están disponibles de forma nativa en .NET Core o que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve cualquier codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  
   
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos, o se pueden cambiar para un único equipo, dando lugar a daños en los datos. Para obtener resultados más coherentes, debe utilizar Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una página de códigos) y otra por nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> no es un nombre de página de códigos válido.  
  
O bien 
La página de códigos indicada por <paramref name="name" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : int * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (codepage, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificador de página de códigos de la codificación preferida. Se hace una lista de los valores posibles en la columna Página de códigos de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.  
  
O bien 
0 (cero), para utilizar la codificación predeterminada.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Devuelve la codificación asociada al identificador de página de códigos especificado. Los parámetros especifican un controlador de errores para los caracteres que no se pueden codificar y para las secuencias de bytes que no se pueden descodificar.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Algunas páginas de códigos no compatibles provocan la excepción <xref:System.ArgumentException> que se produzca, mientras que otras producen <xref:System.NotSupportedException>. Por lo tanto, el código debe detectar todas las excepciones indicadas en la sección excepciones.  

En .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de las páginas de código. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. En .NET Core, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve las codificaciones compatibles de forma nativa con .NET Core. En ambas implementaciones de. NET, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones disponibles. 

 Además de las codificaciones que están disponibles de forma nativa en .NET Core o que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve cualquier codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  

También puede proporcionar un valor de 0 para el `codepage` argumento. Su comportamiento exacto depende de si las codificaciones están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto:

- Si se han registrado uno o varios proveedores de codificación, devuelve la codificación del último proveedor registrado que ha elegido para devolver una codificación cuando la <xref:System.Text.Encoding.GetEncoding%2A> se pasa al método un `codepage` argumento de 0.     

- En .NET Framework, si ninguna codificación proveedor se ha registrado, si la <xref:System.Text.CodePagesEncodingProvider> es el proveedor de codificación registrado, o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve la página de código activo.

- En .NET Core, si no se ha registrado el proveedor de codificación o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve el <xref:System.Text.UTF8Encoding> codificación.

> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Por este motivo, si la página de códigos activa es una página de códigos ANSI, codificación y descodificación de datos mediante la página de códigos del valor predeterminado devuelven por `Encoding.GetEncoding(0)` no se recomienda. Para obtener resultados más coherentes, debe utilizar Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica. 
  
 Para obtener la codificación asociada a la página de código activo, o bien puede proporcionar un valor de 0 para el `codepage` argumento o bien, si el código se ejecuta en .NET Framework en el escritorio de Windows, recupere el valor de la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propiedad. Para determinar la página de código activo actual, llame a la Windows [GetACP](https://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) función desde .NET Framework en el escritorio de Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="codepage" /> es menor que cero o mayor que 65535.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberSignature Language="F#" Value="static member GetEncoding : string * System.Text.EncoderFallback * System.Text.DecoderFallback -&gt; System.Text.Encoding" Usage="System.Text.Encoding.GetEncoding (name, encoderFallback, decoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la página de códigos de la codificación preferida. Cualquier valor devuelto por la propiedad <see cref="P:System.Text.Encoding.WebName" /> es válido. Se hace una lista de los valores posibles en la columna Nombre de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Devuelve la codificación asociada al nombre especificado de la página de códigos. Los parámetros especifican un controlador de errores para los caracteres que no se pueden codificar y para las secuencias de bytes que no se pueden descodificar.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

En .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de las páginas de código. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. En .NET Core, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve las codificaciones compatibles de forma nativa con .NET Core. En ambas implementaciones de. NET, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones disponibles. 

 Además de las codificaciones que están disponibles de forma nativa en .NET Core o que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve cualquier codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  
  
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Para obtener resultados más coherentes, debe usar una codificación Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> no es un nombre de página de códigos válido.  
  
O bien 
La página de códigos indicada por <paramref name="name" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberSignature Language="F#" Value="static member GetEncodings : unit -&gt; System.Text.EncodingInfo[]" Usage="System.Text.Encoding.GetEncodings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz que contiene todas las codificaciones.</summary>
        <returns>Matriz que contiene todas las codificaciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una lista de codificaciones compatibles, diferenciadas de forma exclusiva por página de códigos. Para una tabla que enumera las codificaciones admitidas, vea el <xref:System.Text.Encoding> tema de la clase.  
  
> [!NOTE]
>  La lista de codificaciones compatibles devueltas por la <xref:System.Text.Encoding.GetEncodings%2A> método no incluye las codificaciones adicionales disponible por cualquier <xref:System.Text.EncodingProvider> implementaciones que se registraron mediante llamadas a la <xref:System.Text.Encoding.RegisterProvider%2A> método.  
  
 En .NET Framework, las codificaciones 50220 y 50222 son ambos asocian con el nombre "iso-2022-jp", pero no son idénticos. Codificación 50220 convierte los caracteres Katakana de ancho medio a caracteres Katakana de ancho completo, mientras que la codificación 50222 utiliza una secuencia de MAYÚS-y desplazamiento horizontal para codificar los caracteres Katakana de ancho medio. El nombre para mostrar para la codificación 50222 es "japonés (JIS-Permitir Kana - de 1 byte por lo tanto / SI)" para distinguirlo de codificación 50220, que tiene la presentación de nombres "japonés (JIS)".  
  
 Si se solicita la codificación nombre "iso-2022-jp", el .NET Framework devuelve la codificación 50220. Sin embargo, la codificación adecuada para su aplicación depende del tratamiento de los caracteres Katakana de ancho medio preferido.  
  
 Para obtener una codificación específica, debe usar el <xref:System.Text.Encoding.GetEncoding%2A> método.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> a veces se utiliza para presentar al usuario una lista de codificaciones en un archivo **Guardar como** cuadro de diálogo. Sin embargo, muchas codificaciones no Unicode son incompletos y traducir el número de caracteres a "?", o tienen un comportamiento ligeramente diferente en distintas plataformas. Considere usar UTF-8 o UTF-16 como valor predeterminado.  
  
   
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de la instancia actual.</summary>
        <returns>Código hash de la instancia actual.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxByteCount : int -&gt; int" Usage="encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número máximo de bytes que se generan al codificar el número de caracteres especificado.</summary>
        <returns>Número máximo de bytes generados al codificar el número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `charCount` parámetro especifica el número de <xref:System.Char> objetos que representan los caracteres Unicode que se va a codificar, porque .NET utiliza internamente UTF-16 para representar caracteres Unicode. Por lo tanto, se puede representar la mayoría de los caracteres Unicode por uno <xref:System.Char> objeto, pero un carácter Unicode representado por un par suplente, por ejemplo, se requieren dos <xref:System.Char> objetos.  
  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe usar el <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Recupera un número de caso peor, incluyendo el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.EncoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera valores grandes, especialmente en casos donde el peor caso para la codificación implica cambiar los modos de cada carácter. Por ejemplo, esto puede ocurrir para ISO-2022-JP. Para obtener más información, consulte la entrada de blog "[What ' s con Encoding.GetMaxByteCount y Encoding.GetMaxCharCount ()?](https://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 En la mayoría de los casos, este método recupera valores razonables para cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el extraño caso cuando un búfer más razonable es demasiado pequeño. También puede tener en cuenta un enfoque diferente utilizando <xref:System.Text.Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Cuando se usa <xref:System.Text.Encoding.GetMaxByteCount%2A>, debe asignar el búfer de salida en función del tamaño máximo del búfer de entrada. Si el búfer de salida está restringido en tamaño, puede usar el <xref:System.Text.Encoding.Convert%2A> método.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.GetMaxByteCount%2A> considera los suplentes potenciales de una operación del descodificador anterior. Debido al descodificador, pasando el valor 1 para el método recupera 2 para una codificación de byte único, como ASCII. Debe usar el <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propiedad si esta información es necesaria.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` no es necesariamente el mismo valor que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Todos los <see cref="T:System.Text.Encoding" /> implementaciones deben garantizar que ninguna excepción de desbordamiento de búfer se producirá si los búferes según los resultados de cálculos de este método.</para></block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="abstract member GetMaxCharCount : int -&gt; int" Usage="encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número máximo de caracteres que se generan al descodificar el número de bytes especificado.</summary>
        <returns>Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método generalmente permite asignar menos memoria, mientras que el <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Recupera un número de caso peor, incluyendo el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.DecoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera valores grandes.  
  
 En la mayoría de los casos, este método recupera un número razonable de las cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el caso excepcional de que un búfer más razonable es demasiado pequeño. También puede tener en cuenta un enfoque diferente utilizando <xref:System.Text.Encoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> no tiene ninguna relación con <xref:System.Text.Encoding.GetBytes%2A>. Si necesita una función similar a usar con <xref:System.Text.Encoding.GetBytes%2A>, debe usar <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Cuando se usa <xref:System.Text.Encoding.GetMaxCharCount%2A>, debe asignar el búfer de salida en función del tamaño máximo del búfer de entrada. Si el búfer de salida está restringido en tamaño, puede usar el <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.GetMaxCharCount%2A> considera el peor caso para los bytes de una operación del codificador anterior. Para la mayoría de las páginas de código, pasando un valor de 0 a este método recupera valores mayores o iguales que 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` no es necesariamente el mismo valor que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides"><para>Todos los <see cref="T:System.Text.Encoding" /> implementaciones deben garantizar que ninguna excepción de desbordamiento de búfer se producirá si los búferes según los resultados de cálculos de este método.</para></block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="abstract member GetPreamble : unit -&gt; byte[]&#xA;override this.GetPreamble : unit -&gt; byte[]" Usage="encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, devuelve una secuencia de bytes que especifica la codificación utilizada.</summary>
        <returns>Matriz de bytes que contiene una secuencia de bytes que especifica la codificación utilizada.  
  
O bien 
Matriz de bytes de longitud cero, si no se requiere un preámbulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcionalmente, el <xref:System.Text.Encoding> objeto proporciona un preámbulo que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Si el preámbulo contiene una marca de orden de bytes (en formato Unicode, el punto de código U+FEFF), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF.  
  
 La marca de orden de bytes Unicode (BOM) se serializa como se indica a continuación (en hexadecimal):  
  
-   UTF-8: EF BB BF  
  
-   Orden de bytes big endian de UTF-16: FE FF  
  
-   Orden little-endian bytes de UTF-16: FF FE  
  
-   Orden de bytes big endian de UTF-32: 00 00 FE FF  
  
-   Orden little-endian bytes de UTF-32: FF FE 00 00  
  
 Debe usar la marca BOM, ya que proporciona cierta identificación de una codificación para los archivos en caso contrario es han perdido la referencia a la <xref:System.Text.Encoding> objeto, por ejemplo, no etiquetado, o etiquetados incorrectamente datos web o archivos de texto aleatorio almacenados cuando una empresa no lo hizo tengan intereses internacionales u otros datos. Problemas de los usuarios a menudo pueden evitarse si los datos es coherente y correctamente etiquetados, preferiblemente en UTF-8 o UTF-16.  
  
 Los estándares que proporcionan un tipo de codificación, una marca BOM es redundante. Sin embargo, se puede usar para ayudar a un servidor de enviar el encabezado de codificación correcto. Como alternativa, se puede usar como reserva en caso de que la codificación en caso contrario, se pierde.  
  
 Existen algunas desventajas del uso de una marca BOM. Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una marca BOM. Concatenación de archivos también puede ser un problema, por ejemplo, cuando se mezclan los archivos de tal forma que un carácter innecesario puede acabar en el centro de datos. A pesar de la serie de desventajas, sin embargo, el uso de una lista de materiales se recomienda encarecidamente.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en el [página principal de Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para asegurarse de que los bytes codificados se descodifican correctamente, se deben anteponer bytes codificados con un preámbulo. Sin embargo, la mayoría de las codificaciones no proporcionan un preámbulo. Para asegurarse de que los bytes codificados se descodifican correctamente, debe usar una codificación Unicode, es decir, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, o <xref:System.Text.UTF32Encoding>, con un preámbulo.  
  
   
  
## Examples  
 El ejemplo siguiente determina el orden de bytes de la codificación según el preámbulo.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes en una cadena.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] -&gt; string&#xA;override this.GetString : byte[] -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica todos los bytes de la matriz de bytes especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> objeto devuelto por la <xref:System.Text.Encoding.GetDecoder%2A> de un mo (método) clase vados.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de técnicas y consideraciones de descodificación.  
  
 Tenga en cuenta que el comportamiento exacto de la <xref:System.Text.Encoding.GetString%2A> método para un determinado <xref:System.Text.Encoding> implementación depende de la estrategia de reserva definida para esa <xref:System.Text.Encoding> objeto. Para obtener más información, vea la sección "Elegir una estrategia de reserva" de la [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md) tema.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee una cadena con codificación UTF-8 desde un archivo binario representado por un <xref:System.IO.FileStream> objeto. Los archivos que tengan menos de 2.048 bytes, lee el contenido de todo el archivo en una matriz de bytes y llama a la <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> método para realizar la descodificación. Archivos de mayor tamaño, lo lee 2.048 bytes cada vez en una matriz de bytes, llama a la <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar cuántos caracteres se encuentran en la matriz y, a continuación, llama a la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para realizar la descodificación.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 El ejemplo utiliza el siguiente texto, que debe guardarse en un archivo con codificación UTF-8 denominado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz de bytes contiene puntos de código Unicode no válidos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberSignature Language="F#" Value="member this.GetString : ReadOnlySpan&lt;byte&gt; -&gt; string" Usage="encoding.GetString bytes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.GetString : nativeptr&lt;byte&gt; * int -&gt; string" Usage="encoding.GetString (bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="byteCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero a una matriz de bytes.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica un número determinado de bytes a partir de una dirección especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.GetString%2A> método está diseñado para optimizar el rendimiento cuando tenga un puntero nativo en una matriz de bytes. En lugar de crear una matriz de bytes administrada y, a continuación, la descodificación, en su lugar, se puede llamar a este método sin tener que crear los objetos intermedios.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> objeto devuelto por la <xref:System.Text.Encoding.GetDecoder%2A> de un mo (método) clase vados.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de técnicas y consideraciones de descodificación.  
  
 Tenga en cuenta que el comportamiento exacto de la <xref:System.Text.Encoding.GetString%2A> método para un determinado <xref:System.Text.Encoding> implementación depende de la estrategia de reserva definida para esa <xref:System.Text.Encoding> objeto. Para obtener más información, vea la sección "Elegir una estrategia de reserva" de la [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md) tema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es un puntero nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetString : byte[] * int * int -&gt; string&#xA;override this.GetString : byte[] * int * int -&gt; string" Usage="encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, se debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o la <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de técnicas y consideraciones de descodificación.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee una cadena con codificación UTF-8 desde un archivo binario que se representa mediante un <xref:System.IO.FileStream> objeto. Los archivos que tengan menos de 2.048 bytes, lee el contenido de todo el archivo en una matriz de bytes y llama a la <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para realizar la descodificación. Archivos de mayor tamaño, lo lee 2.048 bytes cada vez en una matriz de bytes, llama a la <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar cuántos caracteres se encuentran en la matriz y, a continuación, llama a la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para realizar la descodificación.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 El ejemplo utiliza el siguiente texto, que debe guardarse en un archivo con codificación UTF-8 denominado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz de bytes contiene puntos de código Unicode no válidos.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres de .NET](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HeaderName : string" Usage="System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un nombre para la codificación actual que se puede utilizar con etiquetas de encabezado de un programa de correo.</summary>
        <value>Nombre del objeto <see cref="T:System.Text.Encoding" /> actual que se debe usar con las etiquetas de encabezado de un agente de correo.  
  
O bien 
Una cadena vacía (""), si no se puede usar la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita una codificación para un nombre de encabezado, debe llamar a la <xref:System.Text.Encoding.GetEncoding%2A> método con el <xref:System.Text.Encoding.HeaderName%2A> propiedad. A menudo el método recupera una codificación distinta de la codificación de pruebas proporcionada en la llamada. Por lo general solo las aplicaciones de correo electrónico deben recuperar esta codificación.  
  
 En algunos casos, el valor de la <xref:System.Text.Encoding.BodyName%2A> propiedad se corresponde con el estándar internacional que define esa codificación. Esto no significa que la implementación cumple plenamente con dicho estándar.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.WebName%2A> devuelve el nombre que se utilizará para describir una codificación. El <xref:System.Text.Encoding.HeaderName%2A> propiedad define una codificación diferente que podría funcionar mejor para una aplicación de correo electrónico, por ejemplo. Sin embargo, no se recomienda el uso de la propiedad para definir la codificación.  
  
   
  
## Examples  
 El ejemplo siguiente se recuperan los nombres diferentes para cada tipo de codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un valor que indica si la codificación actual siempre se normaliza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsAlwaysNormalized : unit -&gt; bool" Usage="encoding.IsAlwaysNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si la codificación actual siempre se normaliza, utilizando la forma de normalización predeterminada.</summary>
        <returns><see langword="true" /> si la clase <see cref="T:System.Text.Encoding" /> actual siempre se normaliza; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de normalización predeterminada es <xref:System.Text.NormalizationForm.FormC>, que utiliza la descomposición canónica completa, seguida de la sustitución de secuencias por sus compuestos principales, si es posible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberSignature Language="F#" Value="abstract member IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool&#xA;override this.IsAlwaysNormalized : System.Text.NormalizationForm -&gt; bool" Usage="encoding.IsAlwaysNormalized form" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="form">Uno de los valores de <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual siempre se normaliza mediante la forma de normalización especificada.</summary>
        <returns><see langword="true" /> si el objeto <see cref="T:System.Text.Encoding" /> actual siempre se normaliza mediante el valor de <see cref="T:System.Text.NormalizationForm" /> especificado; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de normalización predeterminada es <xref:System.Text.NormalizationForm.FormC>, que utiliza la descomposición canónica completa, seguida de la sustitución de secuencias por sus compuestos principales, si es posible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserDisplay : bool" Usage="System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes del explorador pueden utilizar la codificación actual para mostrar el contenido.</summary>
        <value><see langword="true" /> si los clientes del explorador pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para mostrar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBrowserSave : bool" Usage="System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes del explorador pueden utilizar la codificación actual para guardar el contenido.</summary>
        <value><see langword="true" /> si los clientes del explorador pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para guardar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsDisplay : bool" Usage="System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes de correo y de noticias pueden utilizar la codificación actual para mostrar el contenido.</summary>
        <value><see langword="true" /> si los clientes de correo y de noticias pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para mostrar el contenido; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMailNewsSave : bool" Usage="System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes de correo y de noticias pueden utilizar la codificación actual para guardar el contenido.</summary>
        <value><see langword="true" /> si los clientes de correo y de noticias pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para guardar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual es de solo lectura.</summary>
        <value><see langword="true" /> si el <see cref="T:System.Text.Encoding" /> actual es de sólo lectura; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSingleByte : bool" Usage="System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual utiliza puntos de código de un solo byte.</summary>
        <value><see langword="true" /> si la clase <see cref="T:System.Text.Encoding" /> actual utiliza puntos de código de un solo byte; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para un solo byte de codificación, por ejemplo, <xref:System.Text.ASCIIEncoding>, esta propiedad recupera `true`.  
  
> [!CAUTION]
>  Debe tener cuidado en lo que hace la aplicación con el valor de <xref:System.Text.Encoding.IsSingleByte%2A>. Una suposición de cómo se llevará a cabo una codificación aún puede ser incorrecta. Por ejemplo, Windows 1252 tiene un valor de `true` para <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, pero Encoding.GetMaxByteCount (1) devuelve 2. Esto es porque el método considera los suplentes potenciales de una operación del descodificador anterior.  
  
   
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Preamble : ReadOnlySpan&lt;byte&gt;" Usage="System.Text.Encoding.Preamble" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member RegisterProvider : System.Text.EncodingProvider -&gt; unit" Usage="System.Text.Encoding.RegisterProvider provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Subclase de <see cref="T:System.Text.EncodingProvider" /> que proporciona acceso a codificaciones de caracteres adicionales.</param>
        <summary>Registra un proveedor de codificación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.RegisterProvider%2A> método le permite registrar una clase derivada de <xref:System.Text.EncodingProvider> que hace carácter codificaciones disponibles en una plataforma que no los admite en caso contrario. Una vez registrado el proveedor de codificación, se pueden recuperar las codificaciones que admite mediante una llamada a cualquier <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> sobrecargar. Si hay varios proveedores de codificación, el <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> método intenta recuperar una codificación especificada de cada proveedor empezando por la que se registró más recientemente.

Registrar un proveedor de codificación mediante la <xref:System.Text.Encoding.RegisterProvider%2A> método también modifica el comportamiento de la [Encoding.GetEncoding (Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) y [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) métodos cuando se pasa un argumento de `0`:

- Si el proveedor registrado es el <xref:System.Text.CodePagesEncodingProvider>, el método devuelve la codificación que coincida con la página de códigos activa del sistema cuando se ejecuta en el sistema operativo Windows.

- Un proveedor de codificación personalizado puede elegir qué codificación se debe devolver cuando cualquiera de estos <xref:System.Text.Encoding.GetEncoding%2A> sobrecargas del método se pasa un argumento de `0`. El proveedor también puede optar por no devolver una codificación al tener el <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> devuelto del método `null`. 
  
A partir de la versión 4.6 de .NET Framework, .NET Framework incluye un proveedor de codificación y <xref:System.Text.CodePagesEncodingProvider>, que hace que las codificaciones disponibles que están presentes en la versión completa de .NET Framework pero que no están disponibles en la plataforma Universal de Windows. De forma predeterminada, la plataforma Universal de Windows solo admite las codificaciones Unicode, ASCII y la página de códigos 28591.  
  
 Si se usa el mismo proveedor de codificación en varias llamadas a la <xref:System.Text.Encoding.RegisterProvider%2A> método, solo la primera llamada al método registra el proveedor. Se omiten las llamadas subsiguientes.  
  
 Si el <xref:System.Text.Encoding.RegisterProvider%2A> método se invoca para registrar varios proveedores que administran la misma codificación, el último proveedor registrado es el utilizado para codificar todos y las operaciones de descodificación. Se omiten todos los proveedores registrados anteriormente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="provider" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unicode : System.Text.Encoding" Usage="System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-16 utilizando el orden de bytes little endian.</summary>
        <value>Codificación para el formato UTF-16 utilizando el orden de bytes little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de las codificaciones compatibles con .NET y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UnicodeEncoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un poco endian <xref:System.Text.UnicodeEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF32 : System.Text.Encoding" Usage="System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-32 utilizando el orden de bytes little endian.</summary>
        <value>Objeto de codificación para el formato UTF-32 utilizando el orden de bytes little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UTF32Encoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Reserva de reemplazo usa para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con el carácter de reemplazo Unicode (U + FFFE). En su lugar, puede llamar a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un <xref:System.Text.UTF32Encoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, tal y como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Para obtener una explicación del orden de bytes endian little, consulte el <xref:System.Text.Encoding> tema de la clase.  
  
 Para obtener información acerca de las codificaciones compatibles con .NET y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF7 : System.Text.Encoding" Usage="System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-7.</summary>
        <value>Codificación para el formato UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se utiliza la codificación UTF-7 principalmente en entornos que históricamente han restringido a 7 bits, por ejemplo, NNTP y algunas aplicaciones de correo electrónico. Debido a problemas con la seguridad y solidez, no debe usar codificación UTF7 en entornos de 8 bits en codificación UTF-8 puede usarse en su lugar.  
  
   
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UTF8 : System.Text.Encoding" Usage="System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-8.</summary>
        <value>Codificación para el formato UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve un <xref:System.Text.UTF8Encoding> objeto que codifica los caracteres de Unicode (UTF-16-codificada) en una secuencia de uno a cuatro bytes por carácter, y que descodifica una matriz de bytes codificada en UTF-8 a Unicode (UTF-16-codificada) caracteres. Para obtener información acerca de las codificaciones de caracteres compatibles con .NET y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UTF8Encoding> objeto devuelto por esta propiedad puede no tener el comportamiento adecuado para la aplicación.  
  
-   Devuelve un <xref:System.Text.UTF8Encoding> objeto que proporciona una marca de orden de bytes Unicode (BOM). Para crear una instancia de una codificación UTF8 que no proporciona una lista de materiales, llamar a ninguna sobrecarga de la <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.  
  
-   Devuelve un <xref:System.Text.UTF8Encoding> objeto que usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un <xref:System.Text.UTF8Encoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, tal y como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 El ejemplo siguiente define una matriz que consta de los siguientes caracteres:  
  
-   LETRA MINÚSCULA LATINA Z (007A)  
  
-   LETRA LATINA MINÚSCULA UN (U+0061)  
  
-   COMBINACIÓN CORTA (0306)  
  
-   LETRA LATINA MINÚSCULA AE CON AGUDA (U + 01FD)  
  
-   LETRA GRIEGA BETA (03B2)  
  
-   Un par suplente (U+D800 U + DD54) que los formularios GRIEGA ACROPHONIC ATTIC uno MILES STATERS (10154).  
  
 Muestra las unidades de código UTF-16 de cada carácter y determina el número de bytes requeridos por un codificador UTF-8 para codificar la matriz de caracteres. A continuación, se codifica los caracteres y se muestran los bytes resultantes codificado en UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebName : string" Usage="System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el nombre registrado en IANA (Internet Assigned Numbers Authority) para la codificación actual.</summary>
        <value>Nombre IANA de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.WebName%2A> propiedad es el mismo que el <xref:System.Text.EncodingInfo.Name%2A> propiedad.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.WebName%2A> devuelve un nombre registrado en IANA para la codificación. Cuando su valor es el nombre de un estándar, la implementación de la codificación no podría cumplir en su totalidad para dicho estándar. El <xref:System.Text.Encoding.HeaderName%2A> propiedad define una codificación diferente que podría funcionar mejor para los encabezados de correo electrónico. Sin embargo, debe usar la mayoría de las aplicaciones <xref:System.Text.Encoding.WebName%2A> en su lugar.  
  
 Para obtener más información sobre IANA, vaya a [www.iana.org](https://www.iana.org/).  
  
 El <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> es el mismo que el <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> devuelto por <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Algunos de los nombres de web son duplicados; vea los comentarios sobre <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> para obtener más información.  
  
   
  
## Examples  
 En el ejemplo siguiente se incluye el <xref:System.Text.Encoding.WebName%2A> en un encabezado HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 El ejemplo siguiente se recuperan los nombres diferentes para cada tipo de codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowsCodePage : int" Usage="System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la página de códigos del sistema operativo Windows que se corresponde mejor con la codificación actual.</summary>
        <value>Página de códigos del sistema operativo Windows que se corresponde mejor con la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona para ofrecer compatibilidad con la multilingüe de Windows (MLang) API, por ejemplo, en la determinación de las familias de fuentes. Para la globalización, una de las codificaciones Unicode se recomienda usar en su lugar. También se recomienda usar <xref:System.Text.Encoding.WebName%2A> en lugar de <xref:System.Text.Encoding.WindowsCodePage%2A> para identificar la página de códigos.  
  
   
  
## Examples  
 El ejemplo siguiente determina la página de códigos de Windows que se corresponde mejor con cada tipo de codificación.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>