<Type Name="Encoding" FullName="System.Text.Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adda8f83141f6520fcaefa264a4ae9446935542e" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683697" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoding&#xA;Implements ICloneable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoding abstract : ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una codificación de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes. En cambio, la descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode. Para obtener información acerca de los formatos de transformación de Unicode (UTF) y otras codificaciones admitidas por <xref:System.Text.Encoding>, consulte [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Tenga en cuenta que <xref:System.Text.Encoding> está diseñado para operar en caracteres Unicode en lugar de los datos binarios arbitrarios, como matrices de bytes. Si se debe codificar datos binarios arbitrarios en texto, debe utilizar un protocolo, como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 .NET Framework proporciona las siguientes implementaciones de la <xref:System.Text.Encoding> clase para admitir actuales codificaciones Unicode y otras codificaciones:  
  
-   <xref:System.Text.ASCIIEncoding> codifica los caracteres Unicode como caracteres ASCII de 7 bits. Esta codificación sólo admite valores de caracteres entre U+0000 y 0000 y 007F U +. Página de códigos 20127. También está disponible a través de la <xref:System.Text.Encoding.ASCII%2A> propiedad.  
  
-   <xref:System.Text.UTF7Encoding> codifica los caracteres Unicode mediante la codificación UTF-7. Esta codificación acepta todos los valores de caracteres Unicode. Página de códigos 65000. También está disponible a través de la <xref:System.Text.Encoding.UTF7%2A> propiedad.  
  
-   <xref:System.Text.UTF8Encoding> codifica los caracteres Unicode mediante la codificación UTF-8. Esta codificación acepta todos los valores de caracteres Unicode. Página de códigos 65001. También está disponible a través de la <xref:System.Text.Encoding.UTF8%2A> propiedad.  
  
-   <xref:System.Text.UnicodeEncoding> codifica los caracteres Unicode mediante la codificación UTF-16. Se admite tanto el orden little little endian y big endian bytes. También está disponible a través de la <xref:System.Text.Encoding.Unicode%2A> propiedad y el <xref:System.Text.Encoding.BigEndianUnicode%2A> propiedad.  
  
-   <xref:System.Text.UTF32Encoding> codifica los caracteres Unicode mediante la codificación UTF-32. Little endian (página de códigos 12000) tanto bytes big endian (página de códigos 12001) se admiten los pedidos. También está disponible a través de la <xref:System.Text.Encoding.UTF32%2A> propiedad.  
  
 La <xref:System.Text.Encoding> clase está diseñada principalmente para convertir entre diferentes codificaciones y Unicode. A menudo una de las clases derivadas de Unicode es la opción correcta para la aplicación.  
  
 Use la <xref:System.Text.Encoding.GetEncoding%2A> método para obtener otras codificaciones y llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una lista de todas las codificaciones.  
  
 En la tabla siguiente se enumera las codificaciones admitidas por .NET Framework. Enumera número de página de códigos del cada codificación y los valores de la codificación <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> y <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propiedades. Un asterisco en la última columna indica que la página de códigos de forma nativa es compatible con .NET Framework, independientemente de la plataforma subyacente. Tenga en cuenta que las páginas de códigos cuya <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propiedad se corresponde con un estándar internacional no cumplen necesariamente en su totalidad con dicho estándar.  
  
|Página de códigos|nombre|Nombre para mostrar|Compatibilidad de .NET framework|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (EE.)||  
|437|IBM437|Estados Unidos de OEM||  
|500|IBM500|IBM EBCDIC (internacional)||  
|708|ASMO-708|Árabe (ASMO 708)||  
|720|DOS-720|Árabe (DOS)||  
|737|ibm737|Griego (DOS)||  
|775|ibm775|Báltico (DOS)||  
|850|ibm850|Europeo occidental (DOS)||  
|852|ibm852|Centroeuropeo (DOS)||  
|855|IBM855|OEM Cirílico||  
|857|ibm857|Turco (DOS)||  
|858|IBM00858|Latín multilingüe OEM I||  
|860|IBM860|Portugués (DOS)||  
|861|ibm861|Islandés (DOS)||  
|862|DOS-862|Hebreo (DOS)||  
|863|IBM863|Francés canadiense (DOS)||  
|864|IBM864|Árabe (864)||  
|865|IBM865|Nórdico (DOS)||  
|866|cp866|Cirílico (DOS)||  
|869|ibm869|Griego moderno (DOS)||  
|870|IBM870|IBM EBCDIC (multilingüe Latín-2)||  
|874|windows-874|Tailandés (Windows)||  
|875|cp875|IBM EBCDIC (Griego moderno)||  
|932|shift_jis|Japonés (Shift-JIS)||  
|936|gb2312|Chino simplificado (GB2312)|✓|  
|949|ks_c_5601-1987|Coreano||  
|950|Big5|Chino tradicional (Big5)||  
|1026|IBM1026|IBM EBCDIC (turco Latín-5)||  
|1047|IBM01047|IBM Latín-1||  
|1140|IBM01140|IBM EBCDIC (EE. UU.-Canadá-Euro)||  
|1141|IBM01141|IBM EBCDIC (Alemania-Euro)||  
|1142|IBM01142|IBM EBCDIC (Noruega-Dinamarca-Euro)||  
|1143|IBM01143|IBM EBCDIC (Finlandia-Suecia-Euro)||  
|1144|IBM01144|IBM EBCDIC (Italia-Euro)||  
|1145|IBM01145|IBM EBCDIC (España-Euro)||  
|1146|IBM01146|IBM EBCDIC (Reino Unido-Euro)||  
|1147|IBM01147|IBM EBCDIC (Francia-Euro)||  
|1148|IBM01148|IBM EBCDIC (internacional-Euro)||  
|1149|IBM01149|IBM EBCDIC (Islandés-Euro)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big-endian)|✓|  
|1250|windows-1250|Centroeuropeo (Windows)||  
|1251|windows-1251|Cirílico (Windows)||  
|1252|Windows-1252|Europeo occidental (Windows)|✓|  
|1253|windows-1253|Griego (Windows)||  
|1254|windows-1254|Turco (Windows)||  
|1255|Windows-1255|Hebreo (Windows)||  
|1256|Windows-1256|Árabe (Windows)||  
|1257|windows-1257|Báltico (Windows)||  
|1258|windows-1258|Vietnamita (Windows)||  
|1361|Johab|Coreano (Johab)||  
|10000|Macintosh|Europeo occidental (Mac)||  
|10001|x-mac-japonés|Japonés (Mac)||  
|10002|x-mac-Chino trad.|Chino tradicional (Mac)||  
|10003|x-mac-coreano|Coreano (Mac)|✓|  
|10004|x-mac-árabe|Árabe (Mac)||  
|10005|x-mac-hebreo|Hebreo (Mac)||  
|10006|x-mac-griego|Griego (Mac)||  
|10007|x-mac-cirílico|Cirílico (Mac)||  
|10008|mac-x-chinesesimp|Chino simplificado (Mac)|✓|  
|10010|mac-x-rumano|Rumano (Mac)||  
|10017|mac-x-ucraniano|Ucraniano (Mac)||  
|10021|x-mac-tailandés|Tailandés (Mac)||  
|10029|mac-x-ce|Centroeuropeo (Mac)||  
|10079|x-mac-islandés|Islandés (Mac)||  
|10081|x-mac-turco|Turco (Mac)||  
|10082|mac-x-croata|Croata (Mac)||  
|12000|UTF-32|Unicode (UTF-32)|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big-endian)|✓|  
|20000|Chino-x-CNS|Chino tradicional (CNS)||  
|20001|x-cp20001|TCA Taiwán||  
|20002|Chino-x-Eten|Chino tradicional (Eten)||  
|20003|x-cp20003|IBM5550 Taiwán||  
|20004|x-cp20004|Taiwán Teletexto||  
|20005|x-cp20005|Wang Taiwán||  
|20105|IA5 x|Europeo occidental (IA5)||  
|20106|x-IA5-Alemán|Alemán (IA5)||  
|20107|x-IA5-sueco|Sueco (IA5)||  
|20108|x-IA5-Noruego|Noruego (IA5)||  
|20127|us-ascii|US-ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO 6937||  
|20273|IBM273|IBM EBCDIC (Alemania)||  
|20277|IBM277|IBM EBCDIC (Dinamarca-Noruega)||  
|20278|IBM278|IBM EBCDIC (Finlandia, Suecia)||  
|20280|IBM280|IBM EBCDIC (Italia)||  
|20284|IBM284|IBM EBCDIC (España)||  
|20285|IBM285|IBM EBCDIC (REINO UNIDO)||  
|20290|IBM290|IBM EBCDIC (katakana japonés)||  
|20297|IBM297|IBM EBCDIC (Francia)||  
|20420|IBM420|IBM EBCDIC (árabe)||  
|20423|IBM423|IBM EBCDIC (griego)||  
|20424|IBM424|IBM EBCDIC (hebreo)||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (coreano extendido)||  
|20838|IBM-tailandés|IBM EBCDIC (tailandés)||  
|20866|koi8-r|Cirílico (KOI8-R)||  
|20871|IBM871|IBM EBCDIC (Islandés)||  
|20880|IBM880|IBM EBCDIC (Cirílico ruso)||  
|20905|IBM905|IBM EBCDIC (turco)||  
|20924|IBM00924|IBM Latín-1||  
|20932|EUC-JP|Japonés (JIS 0208-1990 y 0212-1990)||  
|20936|x-cp20936|Chino simplificado (GB2312-80)|✓|  
|20949|x-cp20949|Coreano Wansung|✓|  
|21025|cp1025|IBM EBCDIC (serbio-búlgaro cirílico)||  
|21866|KOI8-u|Cirílico (KOI8-U)||  
|28591|ISO-8859-1|Europeo occidental (ISO)|✓|  
|28592|ISO-8859-2|Centroeuropeo (ISO)||  
|28593|ISO-8859-3|Latín 3 (ISO)||  
|28594|iso-8859-4|Báltico (ISO)||  
|28595|ISO-8859-5|Cirílico (ISO)||  
|28596|ISO-8859-6|Árabe (ISO)||  
|28597|ISO-8859-7|Griego (ISO)||  
|28598|ISO-8859-8|Hebreo (ISO-Visual)|✓|  
|28599|iso-8859-9|Turco (ISO)||  
|28603|ISO-8859-13|Estonio (ISO)||  
|28605|ISO-8859-15|Latín 9 (ISO)||  
|29001|x-Europa|Europa||  
|38598|ISO-8859-8-i|Hebreo (ISO-lógico)|✓|  
|50220|ISO-2022-jp|Japonés (JIS)|✓|  
|50221|csISO2022JP|Japonés (JIS-permitir 1 byte Kana)|✓|  
|50222|ISO-2022-jp|Japonés (JIS-permitir 1 byte Kana - tan / SI)|✓|  
|50225|ISO-2022-kr|Coreano (ISO)|✓|  
|50227|x-cp50227|Chino simplificado (ISO-2022)|✓|  
|51932|euc-jp|Japonés (EUC)|✓|  
|51936|EUC-CN|Chino simplificado (EUC)|✓|  
|51949|euc-kr|Coreano (EUC)|✓|  
|52936|Hz-gb-2312|Chino simplificado (HZ)|✓|  
|54936|GB18030|Chino simplificado (GB18030)|✓|  
|57002|x-iscii-Alemania|Devanagari (ISCII)|✓|  
|57003|x iscii ser|Bengalí (ISCII)|✓|  
|57004|x-iscii-ta|Tamil (ISCII)|✓|  
|57005|x-iscii-te|Telugu (ISCII)|✓|  
|57006|x iscii como|Asamés (ISCII)|✓|  
|57007|iscii de x o|Oriya (ISCII)|✓|  
|57008|x-iscii-ka|Kannada (ISCII)|✓|  
|57009|x-iscii-ma|Malayalam (ISCII)|✓|  
|57010|x-iscii-gu|Gujarati (ISCII)|✓|  
|57011|x-iscii-pa|ISCII punjabí|✓|  
|65000|UTF-7|Unicode (UTF-7)|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|  
  
 El ejemplo siguiente se llama el <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> y <xref:System.Text.Encoding.GetEncoding%28System.String%29> codificación de la página de código de métodos para obtener el griego (Windows). Compara la <xref:System.Text.Encoding> objetos devueltos por las llamadas al método para indicar que son iguales y, a continuación, se asigna muestra el punto de código Unicode y el valor de página de códigos correspondiente para cada carácter en el alfabeto griego.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 UTF-16 y los codificadores UTF-32 pueden utilizar el orden de bytes big endian (byte más significativo primero) o el orden de bytes endian little (byte menos significativo primero). Por ejemplo, la letra mayúscula latina A (u+0041) se serializa como sigue (en formato hexadecimal):  
  
-   Orden de bytes big endian de UTF-16: 00 41  
  
-   Orden de UTF-16 little endian bytes: 41 00  
  
-   Orden de bytes big endian de UTF-32: 00 00 00 41  
  
-   Orden de bytes endian little UTF-32: 41 00 00 00  
  
 Es normalmente más eficaz para almacenar caracteres Unicode mediante el orden de bytes nativo. Por ejemplo, es mejor usar el orden de bytes endian little en plataformas little-endian, como equipos Intel.  
  
 El <xref:System.Text.Encoding.GetPreamble%2A> método recupera una matriz de bytes que incluye la marca de orden de bytes (BOM). Si esta matriz de bytes se antepone a una secuencia codificada, ayuda al descodificador a identificar el formato de codificación utilizado.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la [página principal de Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Tenga en cuenta que las clases de codificación permiten errores:  
  
-   Cambiar automáticamente a un "?" caracteres.  
  
-   Utilice un carácter "ajuste perfecto".  
  
-   Cambiar a un comportamiento específico de la aplicación mediante el uso de la <xref:System.Text.EncoderFallback> y <xref:System.Text.DecoderFallback> clases con el carácter de reemplazo Unicode U+FFFD.  
  
 Debería iniciar una excepción en cualquier error de flujo de datos. Una aplicación, usa un marcador "throwonerror" cuando corresponda o usa el <xref:System.Text.EncoderExceptionFallback> y <xref:System.Text.DecoderExceptionFallback> clases. A menudo no se recomienda el retroceso de ajuste perfecto porque puede producir pérdida de datos o confusión y es más lento que simples reemplazos de caracteres. Para las codificaciones ANSI, el comportamiento de ajuste perfecto es el valor predeterminado.  
  
   
  
## Examples  
 En el ejemplo siguiente se convierte una cadena de una codificación a otra.  
  
> [!NOTE]
>  La matriz de bytes es el único tipo de este ejemplo que contiene los datos codificados. Los tipos String y Char de .NET son Unicode, por lo que el <xref:System.Text.Encoding.GetChars%2A> llamada descodifica los datos a Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas invalidar este constructor.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (codePage As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificador de página de códigos de la codificación preferida.  
  
 O bien  
  
 0, para utilizar la codificación predeterminada.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" /> que corresponde a la página de códigos especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas invalidar este constructor.  
  
 Llamadas a este constructor desde una clase derivada crean un <xref:System.Text.Encoding> objeto que usa la reserva con ajuste perfecto para las operaciones de descodificación y codificación. Tanto el <xref:System.Text.Encoding.DecoderFallback%2A> y <xref:System.Text.Encoding.EncoderFallback%2A> propiedades son de solo lectura y no se puede modificar. Para controlar la estrategia de reserva para una clase derivada de <xref:System.Text.Encoding>, llame a la <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> constructor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> es menor que cero.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoding(int codePage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">Identificador de página de códigos de codificación.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoding" /> que corresponde a la página de códigos indicada que tiene las estrategias de reserva de codificador y descodificador especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor es `protected`; derivada clases invalidación.  
  
 Llamar a este constructor desde una clase derivada para controlar la reserva de codificación y descodificación estrategias. El <xref:System.Text.Encoding> constructores de clase crean objetos de codificación de solo lectura que no permiten el codificador o descodificador de reserva para establecerse después de crear el objeto.  
  
 Si el valor `encoderFallback` o `decoderFallback` es null, se usa la reserva con ajuste perfecto como la estrategia de reserva correspondiente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ASCII As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ ASCII { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el juego de caracteres ASCII (de 7 bits).</summary>
        <value>Codificación para el juego de caracteres ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres ASCII se limitan a los 128 caracteres Unicode más bajo, de u+0000 a 007F U +.  
  
 Al seleccionar la codificación ASCII para la aplicación, tenga en cuenta lo siguiente:  
  
-   La codificación ASCII es normalmente adecuada para los protocolos que requieren ASCII.  
  
-   Si se requiere codificación de 8 bits (que a veces incorrectamente se denomina "ASCII"), la codificación UTF-8 es preferible el ASCII codificación. Para los caracteres 0-7F, los resultados son idénticos, pero el uso de UTF-8 evita la pérdida de datos al permitir que la representación de todos los caracteres Unicode que se puede representar. Tenga en cuenta que la codificación ASCII tiene un 8 bits ambigüedad que puede permitir el uso malintencionado, pero la codificación UTF-8 elimina la ambigüedad acerca del bit 8.  
  
-   Antes de la versión 2.0 de .NET Framework, .NET Framework permite la suplantación de identidad sin tener en cuenta los 8 bits. A partir de .NET Framework 2.0, puntos de código no ASCII retrocedan durante la descodificación.  
  
 La <xref:System.Text.ASCIIEncoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> método para crear instancias de un <xref:System.Text.ASCIIEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el efecto de la codificación ASCII en caracteres que están fuera del intervalo ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.ASCIIEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BigEndianUnicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ BigEndianUnicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-16 que utiliza el orden de bytes big endian.</summary>
        <value>Objeto de codificación para el formato UTF-16 que utiliza el orden de bytes big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UnicodeEncoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un big endian <xref:System.Text.UnicodeEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 El valor devuelto <xref:System.Text.UnicodeEncoding> objeto tiene <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, y <xref:System.Text.Encoding.WebName%2A> propiedades, que producen el nombre "unicodeFFFE". Aunque la marca de orden de bytes big endian de UTF-16 es FEFF hexadecimal, se ha elegido el nombre "unicodeFFFE" porque la marca de orden de bytes aparece como FFFE hexadecimal little-endian en equipos con Windows.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee un archivo de texto con una codificación UTF-16 utilizando el orden de bytes big-endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BodyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BodyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un nombre para la codificación actual que se puede utilizar con etiquetas de cuerpo de un programa de correo.</summary>
        <value>Nombre para la clase <see cref="T:System.Text.Encoding" /> actual, que puede utilizarse con etiquetas de cuerpo de un programa de correo.  
  
 O bien  
  
 Una cadena vacía (""), si no se puede usar la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita una codificación para un nombre del cuerpo, debe llamar a <xref:System.Text.Encoding.GetEncoding%2A> con el <xref:System.Text.Encoding.BodyName%2A> propiedad. A menudo el método recupera una codificación diferente de la codificación de pruebas proporcionada en la llamada. Generalmente es necesario recuperar esta codificación; sólo las aplicaciones de correo electrónico deben usar otras aplicaciones que necesitan para describir una codificación su <xref:System.Text.Encoding.WebName%2A>.  
  
 En algunos casos, el valor de la <xref:System.Text.Encoding.BodyName%2A> propiedad se corresponde con el estándar internacional que define esa codificación. Esto no significa que la implementación sea compatible en su totalidad con dicho estándar.  
  
   
  
## Examples  
 En el ejemplo siguiente se recuperan los distintos nombres de cada codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, crea una copia superficial del objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <returns>Copia del objeto <see cref="T:System.Text.Encoding" /> actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El clon es grabable aunque original <xref:System.Text.Encoding> objeto es de solo lectura. Por lo tanto, se pueden modificar las propiedades de la clonación.  
  
 Una copia superficial de un objeto es una copia del objeto únicamente. Si el objeto contiene referencias a otros objetos, la copia superficial no crea copias de los objetos que se hace referencia. Hace referencia a los objetos originales en su lugar. En cambio, una copia en profundidad de un objeto crea una copia del objeto y una copia de todo lo que el objeto hace referencia directa o indirectamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el identificador de la página de códigos de la clase <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Identificador de la página de códigos de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se recuperan los distintos nombres de cada codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
        <altmember cref="P:System.Text.Encoding.WindowsCodePage" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte una matriz de bytes de una codificación a otra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Formato de codificación de <c>bytes</c>.</param>
        <param name="dstEncoding">Formato de codificación de destino.</param>
        <param name="bytes">Bytes que se van a convertir.</param>
        <summary>Convierte una matriz de bytes completa de una codificación a otra.</summary>
        <returns>Matriz de tipo <see cref="T:System.Byte" /> que contiene el resultado de convertir <paramref name="bytes" /> de <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se convierte una cadena con codificación Unicode en una cadena codificada en ASCII. Dado que el objeto de codificación ASCII devuelve el <xref:System.Text.Encoding.ASCII%2A> propiedad usa la reserva de reemplazo y el carácter de Pi no forma parte del juego de caracteres ASCII, el carácter de Pi se reemplaza con un signo de interrogación, como la salida se muestra en el ejemplo.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="dstEncoding" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 **srcEncoding.** El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 **dstEncoding.** El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Convert (srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Convert(System::Text::Encoding ^ srcEncoding, System::Text::Encoding ^ dstEncoding, cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">Codificación de la matriz de origen, <c>bytes</c>.</param>
        <param name="dstEncoding">Codificación de la matriz de salida.</param>
        <param name="bytes">Matriz de bytes que se va a convertir.</param>
        <param name="index">Índice del primer elemento de <c>bytes</c> que se va a convertir.</param>
        <param name="count">Número de bytes que se va a convertir.</param>
        <summary>Convierte un intervalo de bytes de una matriz de una codificación a otra.</summary>
        <returns>Matriz de tipo <see cref="T:System.Byte" /> que contiene el resultado de convertir un intervalo de bytes de <paramref name="bytes" /> de <paramref name="srcEncoding" /> a <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="dstEncoding" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> y <paramref name="count" /> no especifican un intervalo válido en la matriz de bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 **srcEncoding.** El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 **dstEncoding.** El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property DecoderFallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ DecoderFallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Text.DecoderFallback" /> para el objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Objeto de reserva del descodificador para el objeto <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.DecoderFallback> objeto representa un controlador de errores que se invoca cuando no se puede descodificar una secuencia de bytes codificada en un carácter. Se admite cualquiera de los siguientes tipos de controlador:  
  
-   Un ajuste perfecto controlador de reserva, que reemplaza los bytes que no se puede descodificar con algún carácter de reemplazo adecuado.  
  
-   Un reemplazo controlador de reserva, que reemplaza los bytes que no se puede descodificar con algún carácter de reemplazo arbitrario. .NET Framework incluye un controlador de reserva de reemplazo, <xref:System.Text.DecoderFallback>, que de forma predeterminada reemplaza los bytes que no se puede descodificar con un signo de interrogación ("?") caracteres.  
  
-   Reserva controladores de excepciones, que produce una excepción cuando no se puede descodificar bytes. .NET Framework incluye un controlador de reserva de excepción, <xref:System.Text.DecoderExceptionFallback>, que produce una <xref:System.Text.DecoderFallbackException> cuando no se puede descodificar los bytes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor en una operación de conjunto es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede asignar un valor en una operación de conjunto porque el objeto <see cref="T:System.Text.Encoding" /> actual es de sólo lectura.</exception>
        <altmember cref="T:System.Text.DecoderFallback" />
        <altmember cref="T:System.Text.DecoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Default { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la codificación predeterminada para esta implementación de .NET.</summary>
        <value>La codificación predeterminada para esta implementación. NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Diferentes equipos pueden usar distintas codificaciones como valor predeterminado y la codificación predeterminada puede cambiar en un único equipo. Si usas el <xref:System.Text.Encoding.Default%2A> codificación para codificar y descodificar datos transmitir en secuencias entre equipos o se recupera en momentos diferentes en el mismo equipo, pueden traducir los datos incorrectamente. Además, la codificación devuelta por la <xref:System.Text.Encoding.Default%2A> propiedad utiliza la reserva con ajuste perfecto para los caracteres no compatibles se asignan a caracteres admitidos por la página de códigos. Por estos motivos, no se recomienda usar la codificación predeterminada. Para garantizar que los bytes codificados se descodifiquen correctamente, debe usar una codificación Unicode, como <xref:System.Text.UTF8Encoding> o <xref:System.Text.UnicodeEncoding>. También puede usar un protocolo de nivel superior para asegurarse de que el mismo formato se usa para codificar y descodificar.  

### <a name="the-default-property-in-the-net-framework"></a>La propiedad predeterminada en .NET Framework

En .NET Framework en el escritorio de Windows, la <xref:System.Text.Encoding.Default%2A> propiedad siempre obtiene la página de códigos activa del sistema y crea un <xref:System.Text.Encoding> objeto que corresponde a él. La página de códigos activa puede ser una página de códigos ANSI, que incluye el conjunto junto con caracteres adicionales que varían por página de códigos de caracteres ASCII. Dado que todos los <xref:System.Text.Encoding.Default%2A> codificaciones basados en páginas de códigos ANSI perder datos, considere el uso de la <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> codificación en su lugar. UTF-8 a menudo es idéntico en U + 00 al intervalo U + 7F, pero puede codificar caracteres fuera del intervalo ASCII sin pérdida.

## <a name="the-default-property-on-net-core"></a>La propiedad predeterminada en .NET Core

En .NET Core, el <xref:System.Text.Encoding.Default%2A> propiedad siempre devuelve el <xref:System.Text.UTF8Encoding>. UTF-8 se admite en todos los sistemas operativos (Windows, Linux y Max OS X) en las aplicaciones de .NET Core ejecutar.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberSignature Language="VB.NET" Value="Public Property EncoderFallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ EncoderFallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Text.EncoderFallback" /> para el objeto <see cref="T:System.Text.Encoding" /> actual.</summary>
        <value>Objeto de reserva del codificador para el objeto <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.EncoderFallback> objeto representa un controlador de errores que se invoca cuando un carácter no se puede convertir en una secuencia de bytes codificada. Se admite cualquiera de los siguientes tipos de controlador:  
  
-   Un ajuste perfecto controlador de reserva, que reemplaza los caracteres que no se puede codificar con algún carácter de reemplazo adecuado.  
  
-   Un reemplazo controlador de reserva, que reemplaza los caracteres que no se puede codificar con algún carácter de reemplazo arbitrario. .NET Framework incluye un controlador de reserva de reemplazo, <xref:System.Text.EncoderFallback>, que de forma predeterminada reemplaza los caracteres que no se puede codificar con un signo de interrogación ("?") caracteres.  
  
-   Reserva controladores de excepciones, que produce una excepción cuando no se puede codificar caracteres. .NET Framework incluye un controlador de reserva de excepción, <xref:System.Text.EncoderExceptionFallback>, que produce una <xref:System.Text.EncoderFallbackException> cuando no se puede descodificar los caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor en una operación de conjunto es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">No se puede asignar un valor en una operación de conjunto porque el objeto <see cref="T:System.Text.Encoding" /> actual es de sólo lectura.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EncodingName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EncodingName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la descripción inteligible de la codificación actual.</summary>
        <value>Descripción inteligible de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.EncodingName%2A> propiedad está pensada para su presentación. Para buscar un nombre que puede pasarse a la <xref:System.Text.Encoding.GetEncoding%2A> método, use la <xref:System.Text.Encoding.WebName%2A> propiedad.  
  
   
  
## Examples  
 En el ejemplo siguiente se recuperan los distintos nombres de cada codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.DisplayName" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a comparar con la instancia actual.</param>
        <summary>Determina si el objeto <see cref="T:System.Object" /> especificado es igual a la instancia actual.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> es una instancia de <see cref="T:System.Text.Encoding" /> y es igual a la instancia actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos instancias de <xref:System.Text.Encoding> se consideran iguales si corresponden a la misma página de código y sus `EncoderFallback` y `DecoderFallback` objetos son iguales. En particular, todas las páginas de códigos derivadas tienen una página de códigos de 0 y sus retrocesos son normalmente `null` (`Nothing` en Visual Basic. NET). Por lo tanto son todas se consideran iguales entre sí. Una consecuencia es que cuando <xref:System.Text.Encoding.Equals%2A> se usa para rellenar una tabla hash, derivan todas las codificaciones son iguales y se encuadran en la misma ranura de la tabla hash.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una por página de códigos) y otro por su nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Text.Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene los caracteres que se codifican.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar todos los caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes generados al codificar todos los caracteres de la matriz de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar.  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar las versiones de cadena de la <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar los caracteres de la cadena especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar.  
  
-   Si la aplicación administra las entradas de cadena, la versión de cadena <xref:System.Text.Encoding.GetBytes%2A> se recomienda.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una cadena o un intervalo en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres a partir del puntero de caracteres especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular la matriz exacta de tamaño que <xref:System.Text.Encoding.GetBytes%2A> requiere para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones para utilizar estos métodos:  
  
-   La aplicación que necesite codificar muchos caracteres de entrada a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar.  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena de la <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%2A> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar.  
  
-   Si la aplicación administra las entradas de cadena, la versión de cadena <xref:System.Text.Encoding.GetBytes%2A> se recomienda.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar los tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (s As String, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene los caracteres que se codifican.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica todos los caracteres de la matriz de caracteres especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, se debe llamar a la versión de cadena de la <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene los caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica todos los caracteres de la cadena especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una cadena o un intervalo en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As Char(), index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetBytes(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la matriz de caracteres especificada en una secuencia de bytes.</summary>
        <returns>Matriz de bytes que contiene los resultados de codificar el juego de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar los tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBytes (s As String, index As Integer, count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por el parámetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular la matriz exacta de tamaño que <xref:System.Text.Encoding.GetBytes%2A> requiere para almacenar los bytes resultantes, llame a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          El valor de <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la matriz de caracteres especificada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar los tres caracteres de una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
 O bien  
  
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la cadena especificada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe llamar a la <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 El <xref:System.Text.Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoding.GetBytes%2A> método realiza la codificación real. El <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que administra varias conversiones en un flujo de entrada único.  
  
 Varias versiones de <xref:System.Text.Encoding.GetByteCount%2A> y <xref:System.Text.Encoding.GetBytes%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación podría necesitar codificar los caracteres de entrada muchas a una página de códigos y procese los caracteres mediante varias llamadas. En este caso, probablemente se deba mantener el estado entre las llamadas, teniendo en cuenta el estado que se mantiene por la <xref:System.Text.Encoder> del objeto que se va a usar. (Por ejemplo, una secuencia de caracteres que incluye pares suplentes podría finalizar con un suplente alto. El <xref:System.Text.Encoder> le recordará ese suplente alto para que se puede combinar con un suplente bajo al principio de una llamada siguiente. <xref:System.Text.Encoding> no podrá mantener el estado, por lo que el carácter se enviarán a la <xref:System.Text.EncoderFallback>.)  
  
-   Si la aplicación encarga de las entradas de cadena, debe usar la versión de cadena <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   La versión del búfer de caracteres Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas mediante la <xref:System.Text.Encoder> objeto o la inserción en los búferes existentes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el <xref:System.Text.Encoding.GetBytes%2A> versión que admite matrices de bytes es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetByteCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la codificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una cadena o un intervalo en la cadena, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
 O bien  
  
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar todos los bytes de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método. Para calcular el tamaño máximo de la matriz, debe usar el <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> método. El <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas.  
  
-   Si la aplicación administra los resultados de cadena, debe utilizar el <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes a partir del puntero de bytes especificado.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular la matriz exacta de tamaño que <xref:System.Text.Encoding.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas.  
  
-   Si la aplicación administra los resultados de cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas.  
  
-   Si la aplicación administra los resultados de cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se convierte una cadena de una codificación a otra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.Encoding.GetChars" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes en un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte()) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica todos los bytes de la matriz de bytes especificada en un juego de caracteres.</summary>
        <returns>Matriz de caracteres que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para pasar varias veces en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe utilizar un protocolo, como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas, como las secuencias de bytes pueden interrumpirse cuando procesa por lotes. (Por ejemplo, parte de una secuencia de desplazamiento a la ISO-2022 puede terminar uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio de la siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la llamada siguiente.)  
  
-   Si la aplicación administra los resultados de cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), index As Integer, count As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;char&gt; ^ GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en un juego de caracteres.</summary>
        <returns>Matriz de caracteres que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para pasar varias veces en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe utilizar un protocolo, como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas, como las secuencias de bytes pueden interrumpirse cuando procesa por lotes. (Por ejemplo, parte de una secuencia de desplazamiento a la ISO-2022 puede terminar uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio de la siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la llamada siguiente.)  
  
-   Si la aplicación administra los resultados de cadena, se recomienda utilizar la <xref:System.Text.Encoding.GetString%2A> método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</summary>
        <returns>Número real de caracteres escritos en la ubicación indicada por el parámetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular la matriz exacta de tamaño que <xref:System.Text.Encoding.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> Obtiene los caracteres de una secuencia de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para pasar varias veces en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.Encoding.GetDecoder%2A> o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe utilizar un protocolo, como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas, como las secuencias de bytes pueden interrumpirse cuando procesa por lotes. (Por ejemplo, parte de una secuencia de desplazamiento a la ISO-2022 puede terminar uno <xref:System.Text.Encoding.GetChars%2A> llamar y continuar desde el principio de la siguiente <xref:System.Text.Encoding.GetChars%2A> llamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la llamada siguiente.)  
  
-   Si la aplicación administra los resultados de cadena, el <xref:System.Text.Encoding.GetString%2A> se recomienda usar el método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          El valor de <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > recibe los caracteres de una secuencia de bytes de entrada. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > es diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversiones discretas, mientras que <xref:System.Text.Decoder> está diseñado para pasar varias veces en un único flujo de entrada.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 **Tenga en cuenta** este método está pensado para operar en caracteres Unicode, no en datos binarios arbitrarios, como matrices de bytes. Si tiene que codificar datos binarios arbitrarios en texto, debe utilizar un protocolo, como uuencode, que se implementa mediante métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 El <xref:System.Text.Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Encoding.GetChars%2A> método realiza la descodificación real. El <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversiones discretas, contrasta con la <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que administra varios pasos en una sola secuencia de entrada.  
  
 Varias versiones de <xref:System.Text.Encoding.GetCharCount%2A> y <xref:System.Text.Encoding.GetChars%2A> son compatibles. Éstas son algunas consideraciones de programación para su uso de estos métodos:  
  
-   La aplicación necesite descodificar varios bytes de entrada de una página de códigos y procesar los bytes mediante varias llamadas. En este caso, probablemente necesite mantener el estado entre las llamadas, como las secuencias de bytes pueden interrumpirse cuando procesa por lotes. (Por ejemplo, parte de una secuencia de desplazamiento a la ISO-2022 puede terminar uno [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > llamar y continuar desde el principio de la siguiente [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > llamar. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > llamará a la reserva para esas secuencias incompletas, pero <xref:System.Text.Decoder> recordará esas secuencias para la llamada siguiente.)  
  
-   Si la aplicación administra los resultados de cadena, el <xref:System.Text.Encoding.GetString%2A> se recomienda usar el método. Dado que este método debe comprobar la longitud de cadena y asignar un búfer, es algo más lento, pero resultante <xref:System.String> tipo es preferible.  
  
-   La versión de bytes de <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite algunas técnicas rápidas, especialmente con varias llamadas a los búferes grandes. Tenga en cuenta, sin embargo, esta versión del método a veces es segura, puesto que los punteros son necesarios.  
  
-   Si la aplicación debe convertir una gran cantidad de datos, debe volver a utilizar el búfer de salida. En este caso, el [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versión que admite búferes de caracteres de salida es la mejor opción.  
  
-   Considere el uso de la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> en lugar del método <xref:System.Text.Encoding.GetCharCount%2A>. El método de conversión convierte tanto datos como sea posible y produce una excepción si el búfer de salida es demasiado pequeño. Para la descodificación continua de una secuencia, este método suele ser la mejor opción.  
  
   
  
## Examples  
 En el ejemplo siguiente se convierte una cadena de una codificación a otra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica un intervalo de bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
 O bien  
  
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un descodificador que convierte una secuencia de bytes codificada en una secuencia de caracteres.</summary>
        <returns>Clase <see cref="T:System.Text.Decoder" /> que convierte una secuencia de bytes codificada en una secuencia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <xref:System.Text.Encoding.GetChars%2A> método de esta clase. Sin embargo, un <xref:System.Text.Decoder> mantiene la información de estado entre llamadas, de modo que descodifica correctamente las secuencias de bytes que abarquen varios bloques. El <xref:System.Text.Decoder> también conserva los bytes finales al final de bloques de datos y utiliza los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La implementación predeterminada devuelve un <see cref="T:System.Text.Decoder" /> que llama el <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> y <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> métodos del elemento actual <see cref="T:System.Text.Encoding" />. Debe reemplazar este método para devolver un <see cref="T:System.Text.Decoder" /> que mantiene su estado entre las llamadas.</para>
        </block>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada.</summary>
        <returns>Clase <see cref="T:System.Text.Encoder" /> que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes, de forma similar a la <xref:System.Text.Encoding.GetBytes%2A> método de esta clase. Sin embargo, un <xref:System.Text.Encoder> mantiene la información de estado entre llamadas, de modo que puede codificar correctamente secuencias de caracteres que abarquen varios bloques. El <xref:System.Text.Encoder> también conserva finales caracteres al final de bloques de datos y utiliza los caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto sin equivalente y el suplente bajo correspondiente podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>La implementación predeterminada devuelve un <see cref="T:System.Text.Encoder" /> que llama el <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> y <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> métodos del elemento actual <see cref="T:System.Text.Encoding" />. Debe reemplazar este método para devolver un <see cref="T:System.Text.Encoder" /> que mantiene su estado entre las llamadas.</para>
        </block>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEncoding">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una codificación para la página de códigos especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (codepage As Integer) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificador de página de códigos de la codificación preferida. Se hace una lista de los valores posibles en la columna Página de códigos de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.  
  
 O bien  
  
 0 (cero), para utilizar la codificación predeterminada.</param>
        <summary>Devuelve la codificación asociada al identificador de página de códigos especificado.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El controlador de reserva depende del tipo de codificación de `codepage`. Si `codepage` es un carácter de doble byte o de página de código establece la codificación (DBCS), se utiliza un controlador de reserva con ajuste perfecto. En caso contrario, se utiliza un controlador de reserva de reemplazo. Estos controladores de reserva pueden no ser adecuados para la aplicación. Para especificar el controlador de reserva usa la codificación especificada por `codepage`, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  
  
 El <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de páginas de códigos. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. Como alternativa, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones.  
  
 Además de las codificaciones que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  

También puede proporcionar un valor de 0 para el `codepage` argumento. Su comportamiento exacto depende de si las codificaciones se hayan lanzado registrando una <xref:System.Text.EncodingProvider> objeto:

- Si se han registrado uno o más proveedores de codificación, devuelve la codificación del último proveedor registrado que ha decidido devolver una codificación cuando la <xref:System.Text.Encoding.GetEncoding%2A> se pasa al método un `codepage` argumento de 0.     

- En .NET Framework, si ninguna codificación proveedor se ha registrado, si la <xref:System.Text.CodePagesEncodingProvider> es el proveedor de codificación registrado, o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve la página de códigos activa del sistema operativo. Para determinar la página de códigos activa en los sistemas Windows, llame a las ventanas [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) función de .NET Framework en el escritorio de Windows.

- En .NET Core, si no se ha registrado el proveedor de codificación o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve el <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Páginas de código no compatible causa un <xref:System.ArgumentException> que se produzca, mientras que otras producen un <xref:System.NotSupportedException>. Por lo tanto, el código debe detectar todas las excepciones indicadas en la sección excepciones.  
  
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Por esta razón, si la página de códigos activa es una página de códigos ANSI, codificación y descodificación de datos mediante la página de códigos del valor predeterminado devuelven por `Encoding.GetEncoding(0)` no se recomienda. Para obtener resultados más coherentes, debe usar una codificación Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  

   
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una por página de códigos) y otro por su nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> es menor que cero o mayor que 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncoding (name As String) As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la página de códigos de la codificación preferida. Cualquier valor devuelto por la propiedad <see cref="P:System.Text.Encoding.WebName" /> es válido. Se hace una lista de los valores posibles en la columna Nombre de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.</param>
        <summary>Devuelve la codificación asociada al nombre especificado de la página de códigos.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El controlador de reserva depende del tipo de codificación de `name`. Si `name` es un carácter de doble byte o de página de código establece la codificación (DBCS), se utiliza un controlador de reserva con ajuste perfecto. En caso contrario, se utiliza un controlador de reserva de reemplazo. Estos controladores de reserva pueden no ser adecuados para la aplicación. Para especificar el controlador de reserva usa la codificación especificada por `name`, puede llamar a la <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> de sobrecarga.  
  
 El <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de páginas de códigos. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. Como alternativa, puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método para obtener una matriz de <xref:System.Text.EncodingInfo> objetos que contiene información sobre todas las codificaciones. 
  
 Además de las codificaciones que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  
   
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos, o se pueden cambiar para un único equipo, dando lugar a daños en los datos. Para obtener resultados más coherentes, debe utilizar Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
## Examples  
 En el ejemplo siguiente se obtiene dos instancias de la misma codificación (una por página de códigos) y otro por su nombre y comprueba si son iguales.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> no es un nombre de página de códigos válido.  
  
 O bien  
  
 La página de códigos indicada por <paramref name="name" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(int codepage, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">Identificador de página de códigos de la codificación preferida. Se hace una lista de los valores posibles en la columna Página de códigos de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.  
  
 O bien  
  
 0 (cero), para utilizar la codificación predeterminada.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Devuelve la codificación asociada al identificador de página de códigos especificado. Los parámetros especifican un controlador de errores para los caracteres que no se pueden codificar y para las secuencias de bytes que no se pueden descodificar.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Algunas páginas de códigos no admitida producen la excepción <xref:System.ArgumentException> que se produzca, mientras que otras producen <xref:System.NotSupportedException>. Por lo tanto, el código debe detectar todas las excepciones indicadas en la sección excepciones.  
  
 El <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de páginas de códigos. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa. Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. Puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método en .NET Framework completo en el escritorio de Windows para obtener una lista de todas las codificaciones.   
  
 Además de las codificaciones que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto.  Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado.  

También puede proporcionar un valor de 0 para el `codepage` argumento. Su comportamiento exacto depende de si las codificaciones se hayan lanzado registrando una <xref:System.Text.EncodingProvider> objeto:

- Si se han registrado uno o más proveedores de codificación, devuelve la codificación del último proveedor registrado que ha decidido devolver una codificación cuando la <xref:System.Text.Encoding.GetEncoding%2A> se pasa al método un `codepage` argumento de 0.     

- En .NET Framework, si ninguna codificación proveedor se ha registrado, si la <xref:System.Text.CodePagesEncodingProvider> es el proveedor de codificación registrado, o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve la página de códigos activa.

- En .NET Core, si no se ha registrado el proveedor de codificación o si no hay ningún proveedor de codificación registrado controla un `codepage` valor de 0, devuelve el <xref:System.Text.UTF8Encoding> codificación.

> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Por esta razón, si la página de códigos activa es una página de códigos ANSI, codificación y descodificación de datos mediante la página de códigos del valor predeterminado devuelven por `Encoding.GetEncoding(0)` no se recomienda. Para obtener resultados más coherentes, debe utilizar Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica. 
  
 Para obtener la codificación asociada a la página de códigos activa, o bien puede proporcionar un valor de 0 para el `codepage` argumento o, si el código se ejecuta en .NET Framework completo en el escritorio de Windows, recuperar el valor de la <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propiedad. Para determinar la página de códigos activa actual, llame a las ventanas [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) función de .NET Framework en el escritorio de Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" /> es menor que cero o mayor que 65535.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="codepage" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Encoding ^ GetEncoding(System::String ^ name, System::Text::EncoderFallback ^ encoderFallback, System::Text::DecoderFallback ^ decoderFallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la página de códigos de la codificación preferida. Cualquier valor devuelto por la propiedad <see cref="P:System.Text.Encoding.WebName" /> es válido. Se hace una lista de los valores posibles en la columna Nombre de la tabla que aparece en el tema de la clase <see cref="T:System.Text.Encoding" />.</param>
        <param name="encoderFallback">Objeto que proporciona un procedimiento de control de errores cuando no se puede codificar un carácter con la codificación actual.</param>
        <param name="decoderFallback">Objeto que proporciona un procedimiento de control de errores cuando una secuencia de bytes no se puede descodificar con la codificación actual.</param>
        <summary>Devuelve la codificación asociada al nombre especificado de la página de códigos. Los parámetros especifican un controlador de errores para los caracteres que no se pueden codificar y para las secuencias de bytes que no se pueden descodificar.</summary>
        <returns>Codificación asociada a la página de códigos especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.GetEncoding%2A> método se basa en la plataforma subyacente para admitir la mayoría de páginas de códigos. Sin embargo, .NET Framework admite algunas codificaciones de forma nativa.  
  
 Además de las codificaciones que son compatibles de forma intrínseca en una versión de plataforma concreta de .NET Framework, el <xref:System.Text.Encoding.GetEncoding%2A> método devuelve codificaciones adicionales que están disponibles al registrar un <xref:System.Text.EncodingProvider> objeto. Si se ha registrado la misma codificación mediante varias <xref:System.Text.EncodingProvider> objetos, este método devuelve el último registrado. 
  
> [!NOTE]
>  Las páginas de códigos ANSI pueden ser diferentes en distintos equipos y pueden cambiar en un único equipo, dando lugar a daños en los datos. Para obtener resultados más coherentes, debe usar una codificación Unicode, como UTF-8 (página de códigos 65001) o UTF-16, en lugar de una página de códigos específica.  
  
 Para obtener una lista de páginas de códigos, vea el <xref:System.Text.Encoding> tema de la clase. Puede llamar a la <xref:System.Text.Encoding.GetEncodings%2A> método en .NET Framework completo en el escritorio de Windows para obtener una lista de todas las codificaciones.  
  
 <xref:System.Text.Encoding.GetEncoding%2A> Devuelve una instancia almacenada en caché con la configuración predeterminada. Debe usar los constructores de clases derivadas para obtener una instancia con una configuración diferente. Por ejemplo, el <xref:System.Text.UTF32Encoding> clase proporciona un constructor que le permite habilitar la detección de errores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> no es un nombre de página de códigos válido.  
  
 O bien  
  
 La página de códigos indicada por <paramref name="name" /> no es compatible con la plataforma subyacente.</exception>
        <altmember cref="P:System.Text.Encoding.EncoderFallback" />
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="M:System.Text.Encoding.GetEncodings" />
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEncodings () As EncodingInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Text::EncodingInfo ^&gt; ^ GetEncodings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz que contiene todas las codificaciones.</summary>
        <returns>Matriz que contiene todas las codificaciones.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve una lista de codificaciones compatibles, diferenciadas de forma exclusiva por página de códigos. Para una tabla que enumera las codificaciones admitidas, vea el <xref:System.Text.Encoding> tema de la clase.  
  
> [!NOTE]
>  La lista de codificaciones admitidas devuelto por la <xref:System.Text.Encoding.GetEncodings%2A> método no incluye las codificaciones adicionales facilitadas por cualquier <xref:System.Text.EncodingProvider> implementaciones que se registraron mediante llamadas a la <xref:System.Text.Encoding.RegisterProvider%2A> método.  
  
 Codificaciones 50220 y 50222 son ambos asocian con el nombre "iso-2022-jp", pero no son idénticas. Codificación 50220 convierte caracteres de ancho medio Katakana a caracteres Katakana de ancho completo, mientras que la codificación 50222 utiliza una secuencia de Mayús-Mayús-entre para codificar caracteres Katakana de ancho medio. El nombre para mostrar para la codificación 50222 es "japonés (JIS-permitir 1 byte Kana - tan / SI)" para distinguirlo de codificación 50220, que tiene la pantalla nombre "japonés (JIS)".  
  
 Si se solicita la codificación nombre "iso-2022-jp", el .NET Framework devuelve la codificación 50220. Sin embargo, la codificación que sea adecuada para su aplicación depende del tratamiento preferido de los caracteres Katakana de ancho medio.  
  
 Para obtener una codificación concreta, debe usar el <xref:System.Text.Encoding.GetEncoding%2A> método.  
  
 <xref:System.Text.Encoding.GetEncodings%2A> a veces se utiliza para presentar al usuario una lista de codificaciones en un archivo **Guardar como** cuadro de diálogo. Sin embargo, muchas codificaciones no Unicode son incompletas y traducen muchos caracteres a "?", o tienen un comportamiento ligeramente diferente en distintas plataformas. Considere el uso de UTF-8 o UTF-16 como valor predeterminado.  
  
   
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de la instancia actual.</summary>
        <returns>Código hash de la instancia actual.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número máximo de bytes que se generan al codificar el número de caracteres especificado.</summary>
        <returns>Número máximo de bytes generados al codificar el número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `charCount` parámetro realmente especifica el número de <xref:System.Char> objetos que representan los caracteres Unicode que se va a codificar, porque .NET Framework utiliza internamente UTF-16 para representar caracteres Unicode. Por lo tanto, muchos otros caracteres Unicode se pueden representar en uno <xref:System.Char> objeto, pero un carácter Unicode representado por un par suplente, por ejemplo, requiere dos <xref:System.Char> objetos.  
  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetBytes%2A> para almacenar los bytes resultantes, debe usar el <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.Encoding.GetByteCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A> Recupera un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.EncoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera valores grandes, especialmente en casos donde el peor caso para la codificación implica cambiar los modos para cada carácter. Por ejemplo, esto puede ocurrir por ISO-2022-JP. Para obtener más información, vea la entrada de blog "[novedades con Encoding.GetMaxByteCount y Encoding.GetMaxCharCount ()?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 En la mayoría de los casos, este método recupera valores razonables para cadenas pequeñas. Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional cuando un búfer más razonable es demasiado pequeño. Puede que le interese tener en cuenta un enfoque diferente utilizando <xref:System.Text.Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Al utilizar <xref:System.Text.Encoding.GetMaxByteCount%2A>, debe asignar el búfer de salida en función del tamaño máximo del búfer de entrada. Si el búfer de salida está restringido en tamaño, podría usar la <xref:System.Text.Encoding.Convert%2A> método.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.GetMaxByteCount%2A> considera los suplentes potenciales de una operación del descodificador anterior. Debido al descodificador, se pasa un valor de 1 al método recupera 2 para una codificación de un solo byte, como ASCII. Debe utilizar el <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propiedad si esta información es necesaria.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` no es necesariamente el mismo valor que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos los <see cref="T:System.Text.Encoding" /> implementaciones deben garantizar que ninguna excepción de desbordamiento de búfer se produce si los búferes según los resultados de los cálculos de este método.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetBytes(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetByteCount(System.Char[])" />
        <altmember cref="M:System.Text.Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número máximo de caracteres que se generan al descodificar el número de bytes especificado.</summary>
        <returns>Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.Encoding.GetChars%2A> para almacenar los caracteres resultantes, debe usar el <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, use el <xref:System.Text.Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.Encoding.GetCharCount%2A> método permite generalmente asignar menos memoria, mientras que la <xref:System.Text.Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> Recupera un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.DecoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera valores grandes.  
  
 En la mayoría de los casos, este método recupera números razonables para cadenas pequeñas. Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional de que un búfer más razonable es demasiado pequeño. Puede que le interese tener en cuenta un enfoque diferente utilizando <xref:System.Text.Encoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A> no tiene ninguna relación con <xref:System.Text.Encoding.GetBytes%2A>. Si necesita una función similar a usar con <xref:System.Text.Encoding.GetBytes%2A>, debe usar <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Al utilizar <xref:System.Text.Encoding.GetMaxCharCount%2A>, debe asignar el búfer de salida en función del tamaño máximo del búfer de entrada. Si el búfer de salida está restringido en tamaño, podría usar la <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.GetMaxCharCount%2A> tiene en cuenta el peor caso para los bytes de una operación del codificador anterior. Para la mayoría de las páginas de códigos, se pasa un valor de 0 a este método recupera valores mayores o iguales que 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` no es necesariamente el mismo valor que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena en una matriz de bytes y, a continuación, se descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos los <see cref="T:System.Text.Encoding" /> implementaciones deben garantizar que ninguna excepción de desbordamiento de búfer se produce si los búferes según los resultados de los cálculos de este método.</para>
        </block>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetString(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, devuelve una secuencia de bytes que especifica la codificación utilizada.</summary>
        <returns>Matriz de bytes que contiene una secuencia de bytes que especifica la codificación utilizada.  
  
 O bien  
  
 Matriz de bytes de longitud cero, si no se requiere un preámbulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcionalmente, la <xref:System.Text.Encoding> objeto proporciona un preámbulo que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Si el preámbulo contiene una marca de orden de bytes (en formato Unicode, el punto de código U+FEFF), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF.  
  
 La marca de orden de bytes Unicode (BOM) se serializa como se indica a continuación (en formato hexadecimal):  
  
-   UTF-8: EF BB BF  
  
-   Orden de bytes big endian de UTF-16: FF FE  
  
-   Orden de UTF-16 little endian bytes: FF FE  
  
-   Orden de bytes big endian de UTF-32: 00 00 FE FF  
  
-   Orden de bytes endian little UTF-32: FF FE 00 00  
  
 Debe usar la lista de materiales, ya que proporciona cierta identificación de una codificación para los archivos en caso contrario es han perdido la referencia a la <xref:System.Text.Encoding> objeto, por ejemplo, no etiquetado o etiquetados incorrectamente datos web o archivos de texto aleatorios almacenados cuando un negocio no tenía intereses internacionales u otros datos. Problemas de los usuarios a menudo pueden evitarse si datos es coherente y correctamente etiquetados, preferiblemente en UTF-8 o UTF-16.  
  
 Estándares que proporcionan un tipo de codificación, una marca BOM es redundante en cierto modo. Sin embargo, se puede utilizar para ayudar a un servidor de enviar el encabezado de codificación correcto. Como alternativa, se puede utilizar como reserva en caso de que la codificación en caso contrario, se pierde.  
  
 Existen algunas desventajas del uso de una lista de materiales. Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una lista de materiales. Concatenación de archivos puede ser un problema también, por ejemplo, cuando se combinan los archivos de tal forma que un carácter innecesario puede terminar en el centro de datos. A pesar de los inconvenientes de algunos, sin embargo, el uso de una lista de materiales se recomienda.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la [página principal de Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para asegurarse de que los bytes codificados se descodifiquen correctamente, se deben anteponer bytes codificados con un preámbulo. Sin embargo, la mayoría de las codificaciones no proporciona un preámbulo. Para garantizar que los bytes codificados se descodifiquen correctamente, debe usar una codificación Unicode, es decir, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, o <xref:System.Text.UTF32Encoding>, con un preámbulo.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el orden de bytes de la codificación basándose en el preámbulo.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetString">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes en una cadena.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica todos los bytes de la matriz de bytes especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> objeto devuelto por la <xref:System.Text.Encoding.GetDecoder%2A> método de una clase derivada.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de la descodificación de técnicas y consideraciones.  
  
 Tenga en cuenta que el comportamiento exacto de la <xref:System.Text.Encoding.GetString%2A> método para un determinado <xref:System.Text.Encoding> implementación depende de la estrategia de reserva definida para esa <xref:System.Text.Encoding> objeto. Para obtener más información, vea la sección "Elegir una estrategia de reserva" de la [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) tema.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee una cadena con codificación UTF-8 desde un archivo binario representado por un <xref:System.IO.FileStream> objeto. Para los archivos que tengan menos de 2.048 bytes, lee el contenido de todo el archivo en una matriz de bytes y llama el <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> método para realizar la descodificación. Para archivos de mayor tamaño, lee 2.048 bytes a la vez en una matriz de bytes, llamadas el <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar cuántos caracteres se encuentran en la matriz y, a continuación, llama a la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para realizar la descodificación.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 En el ejemplo se usa el siguiente texto, que debe guardarse en un archivo con codificación UTF-8 con el nombre Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz de bytes contiene puntos de código Unicode no válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (ReadOnlySpan&lt;byte&gt; bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetString (bytes As ReadOnlySpan(Of Byte)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(ReadOnlySpan&lt;System::Byte&gt; bytes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetString(System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero a una matriz de bytes.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica un número determinado de bytes a partir de una dirección especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.GetString%2A> método está diseñado para optimizar el rendimiento cuando tiene un puntero nativo en una matriz de bytes. En lugar de crear una matriz de bytes administrada y, a continuación, la descodificación, en su lugar, se puede llamar a este método sin tener que crear los objetos intermedios.  
  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> objeto devuelto por la <xref:System.Text.Encoding.GetDecoder%2A> método de una clase derivada.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de la descodificación de técnicas y consideraciones.  
  
 Tenga en cuenta que el comportamiento exacto de la <xref:System.Text.Encoding.GetString%2A> método para un determinado <xref:System.Text.Encoding> implementación depende de la estrategia de reserva definida para esa <xref:System.Text.Encoding> objeto. Para obtener más información, vea la sección "Elegir una estrategia de reserva" de la [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) tema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es un puntero nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si los datos que se va a convertir están disponibles sólo en bloques secuenciales (como los datos leídos de una secuencia) o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, debe usar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.Encoding.GetDecoder%2A> método o el <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de una clase derivada.  
  
 Vea la sección Comentarios de la <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema de referencia para obtener una explicación de la descodificación de técnicas y consideraciones.  
  
   
  
## Examples  
 En el ejemplo siguiente se lee una cadena con codificación UTF-8 desde un archivo binario que se representa mediante un <xref:System.IO.FileStream> objeto. Para los archivos que tengan menos de 2.048 bytes, lee el contenido de todo el archivo en una matriz de bytes y llama el <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para realizar la descodificación. Para archivos de mayor tamaño, lee 2.048 bytes a la vez en una matriz de bytes, llamadas el <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar cuántos caracteres se encuentran en la matriz y, a continuación, llama a la <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para realizar la descodificación.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 En el ejemplo se usa el siguiente texto, que debe guardarse en un archivo con codificación UTF-8 con el nombre Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La matriz de bytes contiene puntos de código Unicode no válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetDecoder" />
        <altmember cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
        <altmember cref="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HeaderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HeaderName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un nombre para la codificación actual que se puede utilizar con etiquetas de encabezado de un programa de correo.</summary>
        <value>Nombre del objeto <see cref="T:System.Text.Encoding" /> actual que se debe usar con las etiquetas de encabezado de un agente de correo.  
  
 O bien  
  
 Una cadena vacía (""), si no se puede usar la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si necesita una codificación para un nombre de encabezado, debe llamar a la <xref:System.Text.Encoding.GetEncoding%2A> método con el <xref:System.Text.Encoding.HeaderName%2A> propiedad. A menudo el método recupera una codificación diferente de la codificación de pruebas proporcionada en la llamada. Generalmente sólo las aplicaciones de correo electrónico necesitan recuperar esta codificación.  
  
 En algunos casos, el valor de la <xref:System.Text.Encoding.BodyName%2A> propiedad se corresponde con el estándar internacional que define esa codificación. Esto no significa que la implementación sea compatible en su totalidad con dicho estándar.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.WebName%2A> devuelve el nombre que se utilizará para describir una codificación. El <xref:System.Text.Encoding.HeaderName%2A> propiedad define una codificación diferente que podría funcionar mejor para una aplicación de correo electrónico, por ejemplo. Sin embargo, no se recomienda el uso de la propiedad para definir la codificación.  
  
   
  
## Examples  
 En el ejemplo siguiente se recuperan los distintos nombres de cada codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.WebName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAlwaysNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un valor que indica si la codificación actual siempre se normaliza.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAlwaysNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAlwaysNormalized();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si la codificación actual siempre se normaliza, utilizando la forma de normalización predeterminada.</summary>
        <returns>
          <see langword="true" /> si la clase <see cref="T:System.Text.Encoding" /> actual siempre se normaliza; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de normalización predeterminada es <xref:System.Text.NormalizationForm.FormC>, que utiliza la descomposición canónica completa, seguida de la sustitución de secuencias por sus compuestos primarios, si es posible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAlwaysNormalized (form As NormalizationForm) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAlwaysNormalized(System::Text::NormalizationForm form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Uno de los valores de <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual siempre se normaliza mediante la forma de normalización especificada.</summary>
        <returns>
          <see langword="true" /> si el objeto <see cref="T:System.Text.Encoding" /> actual siempre se normaliza mediante el valor de <see cref="T:System.Text.NormalizationForm" /> especificado; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La forma de normalización predeterminada es <xref:System.Text.NormalizationForm.FormC>, que utiliza la descomposición canónica completa, seguida de la sustitución de secuencias por sus compuestos primarios, si es posible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.NormalizationForm" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes del explorador pueden utilizar la codificación actual para mostrar el contenido.</summary>
        <value>
          <see langword="true" /> si los clientes del explorador pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para mostrar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserSave" />
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsBrowserSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsBrowserSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes del explorador pueden utilizar la codificación actual para guardar el contenido.</summary>
        <value>
          <see langword="true" /> si los clientes del explorador pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para guardar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsBrowserDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsDisplay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsDisplay { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes de correo y de noticias pueden utilizar la codificación actual para mostrar el contenido.</summary>
        <value>
          <see langword="true" /> si los clientes de correo y de noticias pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para mostrar el contenido; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsDisplay" />
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMailNewsSave As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMailNewsSave { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si los clientes de correo y de noticias pueden utilizar la codificación actual para guardar el contenido.</summary>
        <value>
          <see langword="true" /> si los clientes de correo y de noticias pueden utilizar la clase <see cref="T:System.Text.Encoding" /> actual para guardar el contenido; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.IsMailNewsSave" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual es de solo lectura.</summary>
        <value>
          <see langword="true" /> si el <see cref="T:System.Text.Encoding" /> actual es de sólo lectura; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSingleByte As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSingleByte { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene un valor que indica si la codificación actual utiliza puntos de código de un solo byte.</summary>
        <value>
          <see langword="true" /> si la clase <see cref="T:System.Text.Encoding" /> actual utiliza puntos de código de un solo byte; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para un solo byte de codificación, por ejemplo, <xref:System.Text.ASCIIEncoding>, esta propiedad recupera `true`.  
  
> [!CAUTION]
>  Es preciso tener cuidado en lo que hace la aplicación con el valor de <xref:System.Text.Encoding.IsSingleByte%2A>. Una suposición de cómo se llevará a cabo una codificación aún puede estar equivocada. Por ejemplo, Windows-1252 tiene un valor de `true` para <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, pero Encoding.GetMaxByteCount (1) devuelve 2. Esto es debido a que el método considera los suplentes potenciales de una operación del descodificador anterior.  
  
   
  
## Examples  
 El ejemplo siguiente comprueba los valores de las propiedades booleanas de cada codificación.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preamble">
      <MemberSignature Language="C#" Value="public virtual ReadOnlySpan&lt;byte&gt; Preamble { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; Preamble" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Preamble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Preamble As ReadOnlySpan(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property ReadOnlySpan&lt;System::Byte&gt; Preamble { ReadOnlySpan&lt;System::Byte&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterProvider (provider As EncodingProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterProvider(System::Text::EncodingProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Subclase de <see cref="T:System.Text.EncodingProvider" /> que proporciona acceso a codificaciones de caracteres adicionales.</param>
        <summary>Registra un proveedor de codificación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.RegisterProvider%2A> método le permite registrar una clase derivada de <xref:System.Text.EncodingProvider> que convierte caracteres codificaciones disponibles en una plataforma que no los admite en caso contrario. Una vez que se registra el proveedor de codificación, se pueden recuperar las codificaciones que admite mediante una llamada a cualquier <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> sobrecarga. Si hay varios proveedores de codificación, la <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> método intenta recuperar una codificación especificada de cada proveedor empezando por la que se registró más recientemente.

Registrar un proveedor de codificación mediante la <xref:System.Text.Encoding.RegisterProvider%2A> método también modifica el comportamiento de la [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) y [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) métodos cuando se pasa un argumento de `0`:

- Si el proveedor registrado es el <xref:System.Text.CodePagesEncodingProvider>, el método devuelve la codificación que coincida con la página de códigos activa del sistema cuando se ejecuta en el sistema operativo Windows.

- Un proveedor de codificación personalizado puede elegir la codificación que devolver si cualquiera de estos <xref:System.Text.Encoding.GetEncoding%2A> sobrecargas de método se pasa un argumento de `0`. El proveedor también puede optar por no devolver una codificación manteniendo la <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> devuelto del método `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)] incluye un proveedor de codificación, <xref:System.Text.CodePagesEncodingProvider>, que hace que las codificaciones disponibles que están presentes en la versión completa de .NET Framework pero no están disponibles en [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. De forma predeterminada, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] solo admite las codificaciones Unicode, ASCII y página de códigos 28591.  
  
 Si se utiliza el mismo proveedor de codificación en varias llamadas a la <xref:System.Text.Encoding.RegisterProvider%2A> método, solo la primera llamada al método registra el proveedor. Se omiten las llamadas subsiguientes.  
  
 Si el <xref:System.Text.Encoding.RegisterProvider%2A> método se invoca para registrar varios proveedores que administran la misma codificación, el último proveedor registrado es el valor utilizado para codificar todos y las operaciones de descodificación. Se omiten los proveedores registrados anteriormente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Text.CodePagesEncodingProvider" />
        <altmember cref="T:System.Text.EncodingProvider" />
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Unicode As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ Unicode { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-16 utilizando el orden de bytes little endian.</summary>
        <value>Codificación para el formato UTF-16 utilizando el orden de bytes little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener información acerca de las codificaciones admitidas por .NET Framework y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UnicodeEncoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un poco endian <xref:System.Text.UnicodeEncoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UnicodeEncoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF32 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF32 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-32 utilizando el orden de bytes little endian.</summary>
        <value>Objeto de codificación para el formato UTF-32 utilizando el orden de bytes little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UTF32Encoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación. Reserva de reemplazo usa para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con el carácter de reemplazo Unicode (U + FFFE). En su lugar, puede llamar a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un <xref:System.Text.UTF32Encoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Para obtener una explicación del orden de bytes endian little, consulte el <xref:System.Text.Encoding> tema de la clase.  
  
 Para obtener información acerca de las codificaciones admitidas por .NET Framework y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF32Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
        <altmember cref="P:System.Text.Encoding.Unicode" />
        <altmember cref="P:System.Text.Encoding.BigEndianUnicode" />
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF7 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF7 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-7.</summary>
        <value>Codificación para el formato UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación UTF-7 se utiliza principalmente en entornos que tradicionalmente se ha restringido a 7 bits, por ejemplo, NNTP y algunas aplicaciones de correo electrónico. Debido a problemas con la seguridad y solidez, no debe utilizar codificación UTF7 en entornos de 8 bits en codificación UTF-8 puede utilizarse en su lugar.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina el número de bytes necesarios para codificar una matriz de caracteres, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF7Encoding" />
        <altmember cref="P:System.Text.Encoding.UTF8" />
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UTF8 As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ UTF8 { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una codificación para el formato UTF-8.</summary>
        <value>Codificación para el formato UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve un <xref:System.Text.UTF8Encoding> objeto que codifica los caracteres Unicode (UTF-16-codificada) en una secuencia de uno a cuatro bytes por carácter, y que descodifica una matriz de bytes codificados en UTF-8 a Unicode (UTF-16-codificada) caracteres. Para obtener información acerca de las codificaciones de caracteres compatibles con .NET Framework y una explicación de qué codificación Unicode para usar, vea [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UTF8Encoding> objeto devuelto por esta propiedad no puede tener el comportamiento adecuado para la aplicación.  
  
-   Devuelve un <xref:System.Text.UTF8Encoding> objeto que proporciona una marca de orden de bytes Unicode (BOM). Para crear una instancia de una codificación UTF8 que no proporciona una lista de materiales, llame a ninguna sobrecarga de la <xref:System.Text.UTF8Encoding.%23ctor%2A> constructor.  
  
-   Devuelve un <xref:System.Text.UTF8Encoding> objeto que usa la reserva de reemplazo para reemplazar cada cadena que no se puede codificar y cada byte que no se puede descodificar con un signo de interrogación ("?") caracteres. En su lugar, puede llamar a la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> constructor para crear instancias de un <xref:System.Text.UTF8Encoding> objeto cuya reserva sea un <xref:System.Text.EncoderFallbackException> o un <xref:System.Text.DecoderFallbackException>, como se muestra en el ejemplo siguiente.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 En el ejemplo siguiente se define una matriz que consta de los siguientes caracteres:  
  
-   LETRA LATINA MINÚSCULA Z (007A)  
  
-   LETRA LATINA MINÚSCULA UN (U+0061)  
  
-   ACENTO BREVE COMBINABLE (0306)  
  
-   LETRA LATINA MINÚSCULA AE CON ACENTO AGUDO (U + 01FD)  
  
-   LETRA GRIEGA MINÚSCULA BETA (03B2)  
  
-   Un par suplente (U+D800 U + DD54) que los formularios GRIEGA ACROPHONIC ATTIC uno MILES STATERS (10154).  
  
 Muestra las unidades de código UTF-16 de cada carácter y determina el número de bytes necesarios para un codificador UTF-8 para codificar la matriz de caracteres. A continuación, se codifica los caracteres y se muestran los bytes resultantes codificado en UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.UTF8Encoding" />
        <altmember cref="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WebName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ WebName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene el nombre registrado en IANA (Internet Assigned Numbers Authority) para la codificación actual.</summary>
        <value>Nombre IANA de la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoding.WebName%2A> propiedad es el mismo que el <xref:System.Text.EncodingInfo.Name%2A> propiedad.  
  
 Tenga en cuenta que <xref:System.Text.Encoding.WebName%2A> devuelve un nombre registrado en IANA para la codificación. Cuando su valor es el nombre de un estándar, la implementación de la codificación no puede ajustarse en su totalidad para dicho estándar. El <xref:System.Text.Encoding.HeaderName%2A> propiedad define una codificación diferente que podría funcionar mejor para los encabezados de correo electrónico. Sin embargo, la mayoría de las aplicaciones debe usar <xref:System.Text.Encoding.WebName%2A> en su lugar.  
  
 Para obtener más información sobre la IANA, vaya a [www.iana.org](https://www.iana.org/).  
  
 El <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> es el mismo que el <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> devuelto por <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Algunos de los nombres web están duplicados; vea la sección Comentarios para <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> para obtener más información.  
  
   
  
## Examples  
 En el ejemplo siguiente se incluye el <xref:System.Text.Encoding.WebName%2A> en un encabezado HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 En el ejemplo siguiente se recuperan los distintos nombres de cada codificación y muestra las codificaciones con uno o varios nombres que son diferentes de <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Muestra <xref:System.Text.Encoding.EncodingName%2A> pero no se compara con ella.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.EncodingInfo.Name" />
        <altmember cref="P:System.Text.Encoding.BodyName" />
        <altmember cref="P:System.Text.Encoding.EncodingName" />
        <altmember cref="P:System.Text.Encoding.HeaderName" />
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property WindowsCodePage As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int WindowsCodePage { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la página de códigos del sistema operativo Windows que se corresponde mejor con la codificación actual.</summary>
        <value>Página de códigos del sistema operativo Windows que se corresponde mejor con la clase <see cref="T:System.Text.Encoding" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se proporciona por compatibilidad con la multilingüe de Windows (MLang) API, por ejemplo, para determinar las familias de fuentes. Para la globalización, una de las codificaciones Unicode se recomienda usar en su lugar. También se recomienda usar <xref:System.Text.Encoding.WebName%2A> en lugar de <xref:System.Text.Encoding.WindowsCodePage%2A> para identificar la página de códigos.  
  
   
  
## Examples  
 En el ejemplo siguiente se determina la página de códigos de Windows que se corresponde mejor con cada codificación.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Text.Encoding.CodePage" />
        <altmember cref="P:System.Text.EncodingInfo.CodePage" />
      </Docs>
    </Member>
  </Members>
</Type>