<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9400910a9b479507f698dda5b833c16e8e1557de" /><Meta Name="ms.sourcegitcommit" Value="b99ec7065534584bfab2aebde9f144bedabb075a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="58185329" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una cadena de caracteres mutable. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase representa un objeto de tipo cadena cuyo valor es una secuencia de caracteres mutable.  
  
 En esta sección:  
  
-   [Los tipos String y StringBuilder](#StringAndSB)  
  
-   [Cómo funciona StringBuilder](#HowWorks)  
  
-   [Asignación de memoria](#Memory)  
  
-   [Instancias de un objeto StringBuilder](#Instantiating)  
  
-   [Llamar a métodos de StringBuilder](#Calling)  
  
-   [Realización de operaciones de StringBuilder](#Operations)  
  
    -   [Recorrer en iteración los caracteres de StringBuilder](#Iterating)  
  
    -   [Agregar texto a un objeto StringBuilder](#Adding)  
  
    -   [Eliminación de texto de un objeto StringBuilder](#Deleting)  
  
    -   [Modificar el texto en un objeto StringBuilder](#Modifying)  
  
-   [Buscar el texto en un objeto StringBuilder](#Searching)  
  
-   [Convertir el objeto StringBuilder en string](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Los tipos String y StringBuilder  
 Aunque <xref:System.Text.StringBuilder> y <xref:System.String> los dos representan secuencias de caracteres, se implementan de manera diferente. <xref:System.String> es un tipo inmutable. Es decir, cada operación que aparece para modificar un <xref:System.String> objeto realmente crea una nueva cadena.  
  
 Por ejemplo, la llamada a la <xref:System.String.Concat%2A?displayProperty=nameWithType> aparece el método en el siguiente ejemplo de C# cambiar el valor de una variable de cadena denominada `value`. De hecho, el <xref:System.String.Concat%2A> método devuelve un `value` objeto que tiene un valor diferente y una dirección de la `value` objeto que se pasó al método. Tenga en cuenta que se debe compilar el ejemplo con el `/unsafe` opción del compilador.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Las rutinas que realizan la manipulación de cadenas amplia (por ejemplo, las aplicaciones que modifican una cadena de varias veces en un bucle), modificar varias veces una cadena puede suponer una reducción significativa del rendimiento. La alternativa es usar <xref:System.Text.StringBuilder>, que es una clase de cadena modificable. Mutabilidad significa que una vez creada una instancia de la clase, puede modificar por anexar, quitar, reemplazar o inserción de caracteres. Un <xref:System.Text.StringBuilder> objeto mantiene un búfer para dar cabida a las expansiones en la cadena. Nuevos datos se anexan al búfer si hay espacio disponible; en caso contrario, se asigna un búfer nuevo y mayor, se copian datos desde el búfer original para el nuevo búfer y, a continuación, se anexan los nuevos datos para el nuevo búfer.  
  
> [!IMPORTANT]
>  Aunque el <xref:System.Text.StringBuilder> clase por lo general ofrece un rendimiento mejor que la <xref:System.String> (clase), debe no reemplazar automáticamente <xref:System.String> con <xref:System.Text.StringBuilder> siempre que desee para manipular las cadenas. Rendimiento depende del tamaño de la cadena, la cantidad de memoria que se va a asignar para la nueva cadena, el sistema en que se ejecuta la aplicación y el tipo de operación. Debe estar preparado para probar la aplicación para determinar si <xref:System.Text.StringBuilder> realmente ofrece una mejora considerable del rendimiento.  
  
 Considere el uso de la <xref:System.String> clase bajo estas condiciones:  
  
-   Cuando el número de cambios que hará que la aplicación en una cadena es pequeño. En estos casos, <xref:System.Text.StringBuilder> podría oferta insignificante o ninguna mejora de rendimiento a través de <xref:System.String>.  
  
-   Cuando se realiza un número fijo de operaciones de concatenación, especialmente con literales de cadena. En este caso, el compilador puede combinar las operaciones de concatenación en una sola operación.  
  
-   Cuando tenga que realizar operaciones de búsqueda mientras se crea la cadena. El <xref:System.Text.StringBuilder> carece de clase, como métodos de búsqueda `IndexOf` o `StartsWith`. Debe convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> para estas operaciones y esto pueden invalidar las ventajas de rendimiento de uso <xref:System.Text.StringBuilder>. Para obtener más información, consulte el [buscar el texto en un objeto StringBuilder](#Searching) sección.  
  
 Considere el uso de la <xref:System.Text.StringBuilder> clase bajo estas condiciones:  
  
-   Cuando se espera la aplicación para realizar un número desconocido de cambios en una cadena en tiempo de diseño (por ejemplo, cuando se usa un bucle para concatenar un número aleatorio de cadenas que contienen entradas de usuario).  
  
-   Cuando se espera la aplicación para realizar un número significativo de los cambios en una cadena.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Cómo funciona StringBuilder  
 El <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> propiedad indica el número de caracteres del <xref:System.Text.StringBuilder> actualmente contiene el objeto. Si se agregan caracteres a la <xref:System.Text.StringBuilder> objeto, su longitud se incrementa siempre que sea igual que el tamaño de la <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propiedad, que define el número de caracteres que puede contener el objeto. Si el número de caracteres agregados hace que la longitud de la <xref:System.Text.StringBuilder> objeto supere su capacidad actual, la nueva memoria se asigna el valor de la <xref:System.Text.StringBuilder.Capacity%2A> se duplica la propiedad, se agregan nuevos caracteres a la <xref:System.Text.StringBuilder> objeto y su <xref:System.Text.StringBuilder.Length%2A>se ajusta la propiedad. Memoria adicional para el <xref:System.Text.StringBuilder> objeto se asigna dinámicamente hasta que alcanza el valor definido por el <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propiedad. Cuando se alcanza la capacidad máxima, no se puede asignar ninguna memoria adicional para el <xref:System.Text.StringBuilder> objeto y al intentar agregar caracteres o se expande más allá de su capacidad máxima inicia ya sea un <xref:System.ArgumentOutOfRangeException> o un <xref:System.OutOfMemoryException> excepción.  
  
 El ejemplo siguiente se muestra cómo un <xref:System.Text.StringBuilder> objeto asigna memoria nueva y aumenta su capacidad dinámicamente a medida se expande la cadena asignada al objeto. El código crea un <xref:System.Text.StringBuilder> objeto mediante una llamada a su constructor (sin parámetros) predeterminado. La capacidad predeterminada de este objeto es 16 caracteres y su capacidad máxima es de más de 2 millones de caracteres. Anexar la cadena "Es una frase". da como resultado una nueva asignación de memoria porque la longitud de cadena (19 caracteres) supera la capacidad predeterminada de la <xref:System.Text.StringBuilder> objeto. Duplica la capacidad del objeto y 32 caracteres, se agrega la nueva cadena y la longitud del objeto ahora es igual a 19 caracteres. El código, a continuación, anexa la cadena "Es una frase adicional". en el valor de la <xref:System.Text.StringBuilder> objeto 11 veces. Cada vez que la operación de anexado hace que la longitud de la <xref:System.Text.StringBuilder> objeto supere su capacidad, su capacidad existente se duplica y <xref:System.Text.StringBuilder.Append%2A> operación se realiza correctamente.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Asignación de memoria  
 La capacidad predeterminada de un <xref:System.Text.StringBuilder> objeto es 16 caracteres y su capacidad máxima del valor predeterminado es <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Estos valores predeterminados se utilizan si se llama a la <xref:System.Text.StringBuilder.%23ctor> y <xref:System.Text.StringBuilder.%23ctor%28System.String%29> constructores.  
  
 Puede definir explícitamente la capacidad inicial de un <xref:System.Text.StringBuilder> objeto de las maneras siguientes:  
  
-   Al llamar a cualquiera de los <xref:System.Text.StringBuilder> constructores que incluye un `capacity` parámetro cuando se crea el objeto.  
  
-   Asignando explícitamente un valor nuevo a la <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propiedad para expandir una existente <xref:System.Text.StringBuilder> objeto. Tenga en cuenta que la propiedad produce una excepción si la nueva capacidad sea menor que el existente capacidad o mayor que el <xref:System.Text.StringBuilder> capacidad máxima del objeto.  
  
-   Mediante una llamada a la <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> método con la nueva capacidad. La nueva capacidad no debe ser mayor que el <xref:System.Text.StringBuilder> capacidad máxima del objeto. Sin embargo, a diferencia de una asignación a la <xref:System.Text.StringBuilder.Capacity%2A> propiedad <xref:System.Text.StringBuilder.EnsureCapacity%2A> no produce una excepción si la nueva capacidad deseada es menor que la capacidad existente; en este caso, la llamada al método no tiene ningún efecto.  
  
 Si la longitud de la cadena asignada a la <xref:System.Text.StringBuilder> objeto en la llamada al constructor supera la capacidad predeterminada o la capacidad especificada, el <xref:System.Text.StringBuilder.Capacity%2A> propiedad está establecida en la longitud de la cadena especificada con el `value` parámetro.  
  
 Puede definir explícitamente la capacidad máxima de un <xref:System.Text.StringBuilder> objeto mediante una llamada a la <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructor. No se puede cambiar la capacidad máxima, se asigna un nuevo valor para el <xref:System.Text.StringBuilder.MaxCapacity%2A> propiedad, porque es de solo lectura.  
  
 La sección anterior se muestra, siempre que la capacidad existente es inadecuado, más memoria se asigna y la capacidad de un <xref:System.Text.StringBuilder> objeto dobles hasta el valor definido por el <xref:System.Text.StringBuilder.MaxCapacity%2A> propiedad.  
  
 En general, la capacidad predeterminada y la capacidad máxima son adecuados para la mayoría de las aplicaciones. Considere la posibilidad de establecer estos valores en las siguientes condiciones:  
  
-   Si el tamaño final de la <xref:System.Text.StringBuilder> objeto es probable que crezcan extremadamente grande, normalmente por encima de varios megabytes. En este caso, puede haber algunas ventajas de rendimiento desde la configuración inicial <xref:System.Text.StringBuilder.Capacity%2A> propiedad en un valor alto significativamente para eliminar la necesidad de demasiados reasignaciones de memoria.  
  
-   Si la aplicación se ejecuta en un sistema con memoria limitada. En este caso, puede desear considerar la configuración del <xref:System.Text.StringBuilder.MaxCapacity%2A> propiedad a menos de <xref:System.Int32.MaxValue?displayProperty=nameWithType> si la aplicación está controlando las cadenas de gran tamaño que pueden provocar que se ejecutan en un entorno con restricciones de memoria.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Instancias de un objeto StringBuilder  
 Crea instancias de un <xref:System.Text.StringBuilder> objeto llamando a uno de sus seis constructores de clase sobrecargados, que se enumeran en la tabla siguiente. Crear tres de los constructores de instancias de un <xref:System.Text.StringBuilder> objeto cuyo valor es una cadena vacía, pero establecer su <xref:System.Text.StringBuilder.Capacity%2A> y <xref:System.Text.StringBuilder.MaxCapacity%2A> valores de forma diferente. Definen los tres constructores restantes un <xref:System.Text.StringBuilder> objeto que tiene un valor de cadena específico y la capacidad. Dos de los tres constructores usan la capacidad máxima predeterminada de <xref:System.Int32.MaxValue?displayProperty=nameWithType>, mientras que la tercera le permite establecer la capacidad máxima.  
  
|Constructor|Valor de cadena|Capacity|Capacidad máxima|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido por el `capacity` parámetro|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido por el `capacity` parámetro|Definido por el `maxCapacity` parámetro|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definido por el `value` parámetro|16 o `value`. <xref:System.String.Length%2A>, lo que sea mayor|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definido por el `value` parámetro|Definido por el `capacity` parámetro o `value`. <xref:System.String.Length%2A>, lo que sea mayor.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definido por `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definido por el `capacity` parámetro o `value`. <xref:System.String.Length%2A>, lo que sea mayor.|Definido por el `maxCapacity` parámetro|  
  
 En el siguiente ejemplo usa tres de estas sobrecargas de constructor para crear instancias <xref:System.Text.StringBuilder> objetos.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Llamar a métodos de StringBuilder  
 La mayoría de los métodos que modifican la cadena en un <xref:System.Text.StringBuilder> instancia devuelven una referencia a esa misma instancia. Esto le permite llamar a <xref:System.Text.StringBuilder> métodos de dos maneras:  
  
-   Puede realizar llamadas a métodos individuales y omitir el valor devuelto, como el siguiente ejemplo.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Puede realizar una serie de llamadas de método en una sola instrucción. Esto puede ser conveniente si desea escribir una sola instrucción que se vincula operaciones sucesivas. El ejemplo siguiente consolida tres llamadas de método del ejemplo anterior en una sola línea de código.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Realización de operaciones de StringBuilder  
 Puede usar los métodos de la <xref:System.Text.StringBuilder> clase para recorrer en iteración, agregar, eliminar o modificar los caracteres de un <xref:System.Text.StringBuilder> objeto.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Recorrer en iteración los caracteres de StringBuilder  
 Puede tener acceso a los caracteres de un <xref:System.Text.StringBuilder> objeto utilizando el <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propiedad. En C#, <xref:System.Text.StringBuilder.Chars%2A> es un indizador; en Visual Basic, es la propiedad predeterminada de la <xref:System.Text.StringBuilder> clase. Esto le permite establecer o recuperar los caracteres individuales utilizando su índice solo, sin hacer referencia explícita a la <xref:System.Text.StringBuilder.Chars%2A> propiedad. Los caracteres de un <xref:System.Text.StringBuilder> objeto comienzan en el índice 0 (cero) y continuar indizar <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 El ejemplo siguiente ilustra la <xref:System.Text.StringBuilder.Chars%2A> propiedad. Anexa diez números aleatorios a una <xref:System.Text.StringBuilder> de objetos y, a continuación, recorre en iteración cada carácter. Si es la categoría del carácter Unicode <xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, disminuye la cantidad en 1 (o cambia el número a 9 si su valor es 0). En el ejemplo se muestra el contenido de la <xref:System.Text.StringBuilder> objeto ambos antes y después de que se han cambiado los valores de caracteres individuales.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Agregar texto a un objeto StringBuilder  
 El <xref:System.Text.StringBuilder> clase incluye los siguientes métodos para expandir el contenido de un <xref:System.Text.StringBuilder> objeto:  
  
-   El <xref:System.Text.StringBuilder.Append%2A> método anexa una cadena, una subcadena, una matriz de caracteres, una parte de una matriz de caracteres, un carácter único se repite varias veces, o tipo de representación de cadena de datos primitivos por un <xref:System.Text.StringBuilder> objeto.  
  
-   El <xref:System.Text.StringBuilder.AppendLine%2A> método anexa un terminador de línea o una cadena junto con un terminador de línea en un <xref:System.Text.StringBuilder> objeto.  
  
-   El <xref:System.Text.StringBuilder.AppendFormat%2A> método anexa una a una <xref:System.Text.StringBuilder> objeto. Las representaciones de cadena de objetos incluidos en la cadena de resultado pueden reflejar las convenciones de formato de la referencia cultural actual del sistema o una referencia cultural especificada.  
  
-   El <xref:System.Text.StringBuilder.Insert%2A> método inserta una cadena, una subcadena, varias repeticiones de una cadena, una matriz de caracteres, una parte de una matriz de caracteres o la representación de cadena de datos primitivos que se escriba en una posición especificada en el <xref:System.Text.StringBuilder> objeto. La posición se define mediante un índice de base cero.  
  
 En el ejemplo siguiente se usa el <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, y <xref:System.Text.StringBuilder.Insert%2A> métodos para expandir el texto de un <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Eliminación de texto de un objeto StringBuilder  
 El <xref:System.Text.StringBuilder> clase incluye métodos que pueden reducir el tamaño del elemento actual <xref:System.Text.StringBuilder> instancia. El <xref:System.Text.StringBuilder.Clear%2A> método quita todos los caracteres y establece el <xref:System.Text.StringBuilder.Length%2A> propiedad en cero. El <xref:System.Text.StringBuilder.Remove%2A> método elimina un número especificado de caracteres a partir de una posición de índice determinada. Además, puede quitar los caracteres del final de un <xref:System.Text.StringBuilder> objeto estableciendo sus <xref:System.Text.StringBuilder.Length%2A> propiedad con un valor que es menor que la longitud de la instancia actual.  
  
 En el ejemplo siguiente se quita alguna parte del texto de un <xref:System.Text.StringBuilder> objeto, muestra su capacidad resultante, capacidad máxima y los valores de propiedad de longitud y, a continuación, llama a la <xref:System.Text.StringBuilder.Clear%2A> método para quitar todos los caracteres desde la <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Modificar el texto en un objeto StringBuilder  
 El <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> método reemplaza todas las apariciones de un carácter o una cadena en todo el <xref:System.Text.StringBuilder> objeto o en un intervalo de caracteres determinada. En el ejemplo siguiente se usa el <xref:System.Text.StringBuilder.Replace%2A> método para reemplazar todos los signos de exclamación (!) con signos de interrogación (?) en el <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Buscar el texto en un objeto StringBuilder  
 El <xref:System.Text.StringBuilder> clase no incluye métodos similares a los <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, y <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos proporcionados por el <xref:System.String> (clase), que le permiten buscar el objeto para un determinado carácter o una subcadena. Determinar la presencia o la posición de carácter de una subcadena inicial requiere que buscar un <xref:System.String> valor mediante un método de búsqueda de cadena o un método de expresión regular. Hay cuatro maneras de implementar dichas búsquedas, como se muestra en la tabla siguiente.  
  
|Técnica|Profesionales|Desventajas|  
|---------------|----------|----------|  
|Buscar valores de cadena antes de agregarlos a la <xref:System.Text.StringBuilder> objeto.|Es útil para determinar si existe una subcadena.|No se puede usar cuando la posición de índice de una subcadena es importante.|  
|Llame a <xref:System.Text.StringBuilder.ToString%2A> y buscar el valor devuelto <xref:System.String> objeto.|Fácil de usar si se asigna a todo el texto a un <xref:System.Text.StringBuilder> de objetos y, a continuación, comience a modificarlo.|Complicado llamar repetidamente a <xref:System.Text.StringBuilder.ToString%2A> si debe realizar modificaciones antes de que todo el texto se agrega a la <xref:System.Text.StringBuilder> objeto.<br /><br /> Debe recordar al trabajar desde el final de la <xref:System.Text.StringBuilder> texto objeto si va a realizar cambios.|  
|Use el <xref:System.Text.StringBuilder.Chars%2A> propiedad para buscar un intervalo de caracteres de forma secuencial.|Resulta útil si desea realizar con los caracteres individuales o una subcadena pequeño.|Complicado si el número de caracteres que se va a buscar es grande o si la lógica de búsqueda es compleja.<br /><br />Tiene como resultado un rendimiento muy deficiente para los objetos que han crecido muy grandes a través de llamadas de método repetidas.  |  
|Convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> de objetos y realizar modificaciones en el <xref:System.String> objeto.|Resulta útil si el número de modificaciones es pequeño.|Niega la ventaja de rendimiento de la <xref:System.Text.StringBuilder> clase si la cantidad de modificaciones es grande.|  
  
 Vamos a examinar estas técnicas con mayor detalle.  
  
-   Si el objetivo de la búsqueda es determinar si una subcadena determinada existe (es decir, si no está interesado en la posición de la subcadena), puede buscar cadenas antes de almacenarlos en el <xref:System.Text.StringBuilder> objeto. El ejemplo siguiente proporciona una implementación posible. Define un `StringBuilderFinder` clase cuyo constructor se pasa una referencia a un <xref:System.Text.StringBuilder> objeto y la subcadena que se va a buscar en la cadena. En este caso, el ejemplo intenta determinar si las temperaturas grabadas en grados Fahrenheit o Celsius y agrega el texto introductorio adecuado al principio de la <xref:System.Text.StringBuilder> objeto. Un generador de números aleatorios se utiliza para seleccionar una matriz que contiene los datos en grados centígrados o grados Fahrenheit.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Llame a la <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> objeto. Puede buscar la cadena con métodos como <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> o <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, o bien puede usar expresiones regulares y la <xref:System.Text.RegularExpressions.Regex> clase para buscar patrones. Dado que ambos <xref:System.Text.StringBuilder> y <xref:System.String> objetos utilizan la codificación para almacenar caracteres, las posiciones de índice de caracteres, subcadenas, UTF-16 y coincidencias de expresiones regulares son iguales en ambos objetos. Esto le permite usar <xref:System.Text.StringBuilder> métodos para realizar cambios en la misma posición en el que se encuentra ese texto en el <xref:System.String> objeto.  
  
    > [!NOTE]
    >  Si adopta este enfoque, debe trabajar desde el final de la <xref:System.Text.StringBuilder> objeto en sus comienzos para que no tiene que convertir repetidamente el <xref:System.Text.StringBuilder> objeto en una cadena.  
  
     En el ejemplo siguiente se muestra este enfoque. Almacena las cuatro repeticiones de cada letra del alfabeto inglés en un <xref:System.Text.StringBuilder> objeto. A continuación, convierte el texto a un <xref:System.String> de objetos y usa una expresión regular para identificar la posición inicial de cada secuencia de cuatro caracteres. Por último, se agrega un carácter de subrayado antes de cada secuencia de cuatro caracteres, excepto la primera secuencia y convierte el primer carácter de la secuencia de letras en mayúsculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Use la <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propiedad que se va a buscar secuencialmente en un intervalo de caracteres en un <xref:System.Text.StringBuilder> objeto. Este enfoque puede no resultar práctico si el número de caracteres que se va a buscar es grande o la lógica de búsqueda es especialmente compleja. Para las implicaciones de rendimiento de acceso basado en índice de carácter a carácter para muy grandes, chunked <xref:System.Text.StringBuilder> objetos, consulte la documentación de la <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propiedad. 
  
     En el ejemplo siguiente es idéntico en funcionalidad al ejemplo anterior, pero difiere de la implementación. Usa el <xref:System.Text.StringBuilder.Chars%2A> propiedad para detectar cuándo cambia un valor de carácter, inserta un carácter de subrayado en esa posición y convierte el primer carácter en la nueva secuencia a mayúsculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Store todo el texto sin modificar en el <xref:System.Text.StringBuilder> de objeto, llame a la <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> de objetos y realizar las modificaciones en el <xref:System.String> objeto. Puede usar este enfoque si tiene sólo unas pocas modificaciones; en caso contrario, el costo de trabajar con cadenas inmutable puede invalidar las ventajas de rendimiento de uso de un <xref:System.Text.StringBuilder> objeto.  
  
     El ejemplo siguiente es idéntico en funcionalidad a los dos ejemplos anteriores, pero difiere de la implementación. Crea un <xref:System.Text.StringBuilder> objeto, lo convierte en un <xref:System.String> de objetos y, a continuación, utiliza una expresión regular para realizar todas las modificaciones restantes en la cadena. El <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método usa una expresión lambda para realizar el reemplazo de cada coincidencia.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Convertir el objeto StringBuilder en string  
 Debe convertir primero el objeto <xref:System.Text.StringBuilder> en un objeto <xref:System.String> para poder pasar la cadena representada por el objeto <xref:System.Text.StringBuilder> a un método con un parámetro <xref:System.String> o mostrarla en la interfaz de usuario. Realizar esta conversión mediante una llamada a la <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método. Para ver una ilustración, vea el ejemplo anterior, que llama a la <xref:System.Text.StringBuilder.ToString%2A> método para convertir un <xref:System.Text.StringBuilder> objeto en una cadena para que se puede pasar a un método de expresión regular.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a muchos de los métodos definidos por el <xref:System.Text.StringBuilder> clase.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de cadena de esta instancia se establece en <xref:System.String.Empty?displayProperty=nameWithType>, y la capacidad se establece en la capacidad predeterminada específica de la implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor sin parámetros.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerencia de tamaño inicial de la instancia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" /> con la capacidad especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `capacity` parámetro define el número máximo de caracteres que se pueden almacenar en la memoria asignada por la instancia actual. Su valor se asigna a la <xref:System.Text.StringBuilder.Capacity%2A> propiedad. Si el número de caracteres que se almacenará en la instancia actual supera este `capacity` valor, el <xref:System.Text.StringBuilder> objeto asigna memoria adicional para almacenarlos.  
  
 El valor de cadena de esta instancia se establece en <xref:System.String.Empty?displayProperty=nameWithType>. Si `capacity` es cero, se usa la capacidad predeterminada específica de la implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor con una capacidad especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena usada para inicializar el valor de la instancia. Si <paramref name="value" /> es <see langword="null" />, el nuevo <see cref="T:System.Text.StringBuilder" /> contendrá la cadena vacía (o sea, <see cref="F:System.String.Empty" />).</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" /> con la cadena especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` es `null`, el nuevo <xref:System.Text.StringBuilder> contendrá la cadena vacía (o sea, <xref:System.String.Empty>).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor con la cadena especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Sugerencia de tamaño inicial de <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">Número máximo de caracteres que puede contener la cadena actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" /> que empieza con una capacidad concreta y puede aumentar hasta un máximo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `capacity` parámetro define el número máximo de caracteres que se pueden almacenar en la memoria asignada por la instancia actual. Su valor se asigna a la <xref:System.Text.StringBuilder.Capacity%2A> propiedad. Si el número de caracteres que se almacenará en la instancia actual supera este `capacity` valor, el <xref:System.Text.StringBuilder> objeto asigna memoria adicional para almacenarlos.  
  
 Si `capacity` es cero, se usa la capacidad predeterminada específica de la implementación.  
  
 El `maxCapacity` propiedad define el número máximo de caracteres que puede contener la instancia actual. Su valor se asigna a la <xref:System.Text.StringBuilder.MaxCapacity%2A> propiedad. Si el número de caracteres que se almacenará en la instancia actual supera este `maxCapacity` valor, el <xref:System.Text.StringBuilder> objeto no asigna memoria adicional, pero en su lugar, se produce una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor con una capacidad concreta y una capacidad máxima.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> es menor que uno, <paramref name="capacity" /> es menor que cero o <paramref name="capacity" /> es mayor que <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena usada para inicializar el valor de la instancia. Si <paramref name="value" /> es <see langword="null" />, el nuevo <see cref="T:System.Text.StringBuilder" /> contendrá la cadena vacía (o sea, <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">Sugerencia de tamaño inicial de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" /> con la capacidad y la cadena especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `capacity` parámetro define el número máximo de caracteres que se pueden almacenar en la memoria asignada por la instancia actual. Su valor se asigna a la <xref:System.Text.StringBuilder.Capacity%2A> propiedad. Si el número de caracteres que se almacenará en la instancia actual supera este `capacity` valor, el <xref:System.Text.StringBuilder> objeto asigna memoria adicional para almacenarlos.  
  
 Si `capacity` es cero, se usa la capacidad predeterminada específica de la implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor con una cadena inicial y una capacidad especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene la subcadena que se usa para inicializar el valor de esta instancia. Si <paramref name="value" /> es <see langword="null" />, el nuevo <see cref="T:System.Text.StringBuilder" /> contendrá la cadena vacía (o sea, <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">Posición de <paramref name="value" /> en la que comienza la subcadena.</param>
        <param name="length">Número de caracteres de la subcadena.</param>
        <param name="capacity">Sugerencia de tamaño inicial de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.StringBuilder" /> a partir de la subcadena y la capacidad especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `capacity` parámetro define el número máximo de caracteres que se pueden almacenar en la memoria asignada por la instancia actual. Su valor se asigna a la <xref:System.Text.StringBuilder.Capacity%2A> propiedad. Si el número de caracteres que se almacenará en la instancia actual supera este `capacity` valor, el <xref:System.Text.StringBuilder> objeto asigna memoria adicional para almacenarlos.  
  
 Si `capacity` es cero, se usa la capacidad predeterminada específica de la implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo llamar a la <xref:System.Text.StringBuilder.%23ctor%2A> constructor con la cadena especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> más <paramref name="length" /> no es una posición dentro de <paramref name="value" />.</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa a esta instancia la representación en forma de cadena de un objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valor booleano que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un valor booleano especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Boolean%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Boolean%29> llamadas al método el <xref:System.Boolean.ToString?displayProperty=nameWithType> método para obtener la representación de cadena de `value`. La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero sin signo de 8 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Byte%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Byte%29> llamadas al método el <xref:System.Byte.ToString%28System.IFormatProvider%29> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Unidad de código codificado en UTF-16 que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un objeto <see cref="T:System.Char" /> especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Char%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Matriz de caracteres que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de los caracteres Unicode de una matriz especificada.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método anexa todos los caracteres de la matriz especificada a la instancia actual en el mismo orden en que aparecen en `value`. Si `value` es `null`, se realiza ningún cambio.  
  
 El <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un número decimal especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Decimal%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Decimal%29> llamadas al método el <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un número de punto flotante de precisión doble especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Double%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Double%29> llamadas al método el <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero con signo de 16 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Int16%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Int16%29> llamadas al método el <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero con signo de 32 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Int32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Int32%29> llamadas al método el <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero con signo de 64 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Int64%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Int64%29> llamadas al método el <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un objeto especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Object%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente. Define un `Dog` de clase, crea un `Dog` objeto y realiza tres llamadas a la <xref:System.Text.StringBuilder.Append%2A> método para crear una cadena que contiene el nombre y la raza el perro.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Object%29> llamadas al método el <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para obtener la representación de cadena de `value`. Si `value` es `null`, se realiza ningún cambio a la <xref:System.Text.StringBuilder> objeto.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero con signo de 8 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.SByte%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.SByte%29> llamadas al método el <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un número de punto flotante de precisión sencilla especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Single%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.Single%29> llamadas al método el <xref:System.Single.ToString%2A?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a anexar.</param>
        <summary>Anexa a esta instancia una copia de la cadena especificada.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.String%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Si `value` es `null`, se realiza ningún cambio.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero sin signo de 16 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.UInt16%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.UInt16%29> llamadas al método el <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value`. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero sin signo de 32 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.UInt32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.UInt32%29> llamadas la <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valor que se va a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de un entero sin signo de 64 bits especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.UInt64%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 El <xref:System.Text.StringBuilder.Append%28System.UInt64%29> llamadas al método el <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obtener la representación de cadena de `value` para la referencia cultural actual. Para controlar el formato de `value`, llame a la <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Carácter que se va a anexar.</param>
        <param name="repeatCount">Número de veces que se va a anexar <paramref name="value" />.</param>
        <summary>Anexa a esta instancia un número especificado de copias de la representación en forma de cadena de un carácter Unicode.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> es menor que cero.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Memoria insuficiente</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Puntero a una matriz de caracteres Unicode.</param>
        <param name="valueCount">Número de caracteres de la matriz.</param>
        <summary>Anexa a esta instancia una matriz de caracteres Unicode a partir de una dirección especificada.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método anexa `valueCount` caracteres a partir de la dirección `value` a la instancia actual.  
  
 El <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> objeto.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> es menor que cero.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> es un puntero nulo.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Matriz de caracteres.</param>
        <param name="startIndex">Posición inicial en <paramref name="value" />.</param>
        <param name="charCount">Número de caracteres que se van a anexar.</param>
        <summary>Anexa a esta instancia la representación en forma de cadena de una submatriz de caracteres Unicode especificada.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método anexa el intervalo especificado de caracteres de `value` a la instancia actual. Si `value` es `null` y `startIndex` y `count` son cero, no los cambios se realizan.  
  
 El <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />, y <paramref name="startIndex" /> y <paramref name="charCount" /> no son cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> + <paramref name="charCount" /> es mayor que la longitud de <paramref name="value" />.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que contiene la subcadena que se va a anexar.</param>
        <param name="startIndex">Posición inicial de la subcadena dentro de <paramref name="value" />.</param>
        <param name="count">Número de caracteres de <paramref name="value" /> que se van a anexar.</param>
        <summary>Anexa a esta instancia una copia de una subcadena especificada.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método anexa el intervalo especificado de caracteres de `value` a la instancia actual. Si `value` es `null` y `startIndex` y `count` son cero, no los cambios se realizan.  
  
 El <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> método modifica la instancia existente de esta clase; no devuelve una nueva instancia de clase. Por este motivo, se puede llamar a un método o propiedad en la referencia existente y no es necesario que asignar el valor devuelto para un <xref:System.Text.StringBuilder> de objeto, como se muestra en el ejemplo siguiente.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />, y <paramref name="startIndex" /> y <paramref name="count" /> no son cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> es menor que cero.  
  
O bien 
 <paramref name="startIndex" /> + <paramref name="count" /> es mayor que la longitud de <paramref name="value" />.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza con la representación de cadena de un argumento de objeto correspondiente.</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Objeto al que se va a aplicar el formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación en forma de cadena de un único argumento.</summary>
        <returns>Referencia a la instancia con <paramref name="format" /> anexado. Cada elemento de formato de <paramref name="format" /> se reemplaza por la representación en forma de cadena de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato. El índice de los elementos de formato debe ser 0, que corresponden a `arg0`, el objeto único en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena de `arg0`.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` representa el objeto que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena de `arg0`. Si el elemento de formato incluye `formatString` y `arg0` implementa el <xref:System.IFormattable> interfaz, a continuación, `arg0.ToString(formatString, null)` define el formato. En caso contrario, `arg0.ToString()` define el formato.  
  
 Si la cadena asignada a `format` es "agradecimiento por su donación de {0: ###} latas de comida a nuestra organización benéfica." y `arg0` es un entero con el valor 10, el valor devuelto será "Gracias por su donación de 10 latas de comida a nuestra organización benéfica."  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="args">Matriz de objetos a la que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación de cadena del argumento correspondiente de una matriz de parámetros.</summary>
        <returns>Referencia a la instancia con <paramref name="format" /> anexado. Cada elemento de formato de <paramref name="format" /> se reemplaza con la representación de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a objetos de la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args` representa los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena del objeto correspondiente en `args`. Si el elemento de formato incluye `formatString` y el objeto correspondiente en `args` implementa el <xref:System.IFormattable> interfaz, a continuación, `args[index].ToString(formatString, provider)` define el formato. En caso contrario, `args[index].ToString()` define el formato.  
  
 Si la cadena asignada a `format` es "agradecimiento por su donación de {0: ###} latas de comida a nuestra organización benéfica." y `arg0` es un entero con el valor 10, el valor devuelto será "Gracias por su donación de 10 latas de comida a nuestra organización benéfica."  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> o <paramref name="args" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que la longitud de la matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Objeto al que se va a aplicar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación en forma de cadena de un único argumento utilizando un proveedor de formato especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado. Después de la operación de anexado, esta instancia contiene todos los datos que existían antes de la operación, seguidos de una copia de <paramref name="format" /> como sufijo, en la que cualquier especificación de formato se reemplaza con la representación en forma de cadena de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de `arg0` en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato. El índice de cada elemento de formato debe ser cero (0), ya que este método incluye una lista de argumentos con un único argumento. El proceso de formato reemplaza cada elemento de formato con la representación de cadena de `arg0`.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. En este caso, puesto que la <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> el método tiene un único argumento en la lista de argumentos, el valor de *índice* siempre debe ser 0. Si no, es un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 El `provider` parámetro especifica un <xref:System.IFormatProvider> implementación que puede proporcionar información de formato para los objetos en `args`. `provider` puede ser de cualquiera de las funciones siguientes:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que proporciona información de formato específica de la referencia cultural.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0` si es un valor numérico.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0` si es un valor de fecha y hora.  
  
-   Personalizada <xref:System.IFormatProvider> implementación que proporciona información de formato para `arg0`. Normalmente, este tipo de implementación también implementa el <xref:System.ICustomFormatter> interfaz.  
  
 Si el `provider` parámetro es `null`, el formato se obtiene información de la referencia cultural actual.  
  
 `arg0` representa el objeto que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena de `arg0`. Si el elemento de formato incluye `formatString` y `arg0` implementa el <xref:System.IFormattable> interfaz, a continuación, `arg0.ToString(formatString, provider)` define el formato. En caso contrario, `arg0.ToString()` define el formato.  
  
   
  
## Examples  
 La siguiente incluye dos llamadas a la <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> método. Ambos utilizan las convenciones de formato de la referencia cultural de inglés-Reino Unido (en GB). El primero inserta la representación de cadena de un <xref:System.Decimal> valor de moneda en una cadena de resultado. El segundo inserta un <xref:System.DateTime> valor en dos lugares de un resultado de la cadena, la primera, incluidos solo corto de fecha cadena y el segundo la cadena de hora corta.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que uno (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Cómo: Definir y usar proveedores de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="args">Matriz de objetos a la que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza con la representación de cadena del argumento correspondiente de una matriz de parámetros, utilizando el proveedor de formato especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado. Después de la operación de anexado, esta instancia contiene todos los datos que existían antes de la operación, seguidos de una copia de <paramref name="format" /> como sufijo, en la que cualquier especificación de formato se reemplaza con la representación en forma de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a objetos de la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 El `provider` parámetro especifica un <xref:System.IFormatProvider> implementación que puede proporcionar información de formato para los objetos en `args`. `provider` puede ser de cualquiera de las funciones siguientes:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que proporciona información de formato específica de la referencia cultural.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural para los valores numéricos en `args`.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objeto que proporciona información de formato específica de la referencia cultural para los valores de fecha y hora en `args`.  
  
-   Personalizada <xref:System.IFormatProvider> implementación que proporciona información de formato para uno o varios de los objetos en `args`. Normalmente, este tipo de implementación también implementa el <xref:System.ICustomFormatter> interfaz. El segundo ejemplo en la sección siguiente se ilustra un <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> llamada al método con un personalizado <xref:System.IFormatProvider> implementación.  
  
 Si el `provider` parámetro es `null`, se obtiene información del proveedor de formato de la referencia cultural actual.  
  
 `args` representa los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena del objeto correspondiente en `args`. Si el elemento de formato incluye `formatString` y el objeto correspondiente en `args` implementa el <xref:System.IFormattable> interfaz, a continuación, `args[index].ToString(formatString, provider)` define el formato. En caso contrario, `args[index].ToString()` define el formato.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 En el ejemplo siguiente se define un personalizado <xref:System.IFormatProvider> implementación denominada `CustomerFormatter` que da formato a un cliente de 10 dígitos con guiones después de la cuarto y séptimo dígitos. Se pasa a la <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método para crear una cadena que incluye el número de cliente con formato y el nombre del cliente.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que la longitud de la matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Cómo: Definir y usar proveedores de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación en forma de cadena de uno de dos argumentos.</summary>
        <returns>Referencia a la instancia con <paramref name="format" /> anexado. Cada elemento de formato de <paramref name="format" /> se reemplaza con la representación de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a `arg0` y `arg1`, los dos objetos en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0` y `arg1` representan los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena `arg0` o `arg1`. Si el elemento de formato incluye `formatString` e implementa el objeto correspondiente del <xref:System.IFormattable> interfaz, a continuación, `arg` *x* `.ToString(formatString, provider)` define el formato, donde *x* es el índice del argumento. En caso contrario, `arg` *x* `.ToString()` define el formato.  
  
 Si la cadena asignada a `format` es "agradecimiento por su donación de {0: ###} latas de comida a nuestra organización benéfica." y `arg0` es un entero con el valor 10, el valor devuelto será "Gracias por su donación de 10 latas de comida a nuestra organización benéfica."  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación de cadena de dos argumentos utilizando un proveedor de formato especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado. Después de la operación de anexado, esta instancia contiene todos los datos que existían antes de la operación, seguidos de una copia de <paramref name="format" /> como sufijo, en la que cualquier especificación de formato se reemplaza con la representación en forma de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a objetos de la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 El `provider` parámetro especifica un <xref:System.IFormatProvider> implementación que puede proporcionar información de formato de `arg0` y `arg1`. `provider` puede ser de cualquiera de las funciones siguientes:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que proporciona información de formato específica de la referencia cultural.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0` o `arg1` si son valores numéricos.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0` o `arg1` si son valores de fecha y hora.  
  
-   Personalizada <xref:System.IFormatProvider> implementación que proporciona información de formato de `arg0` y `arg1`. Normalmente, este tipo de implementación también implementa el <xref:System.ICustomFormatter> interfaz.  
  
 Si el `provider` parámetro es `null`, se obtiene información del proveedor de formato de la referencia cultural actual.  
  
 `arg0` y `arg1` representan los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena del objeto que tiene el índice correspondiente. Si el elemento de formato incluye `formatString` y el argumento correspondiente implementa la <xref:System.IFormattable> interfaz y, a continuación, el argumento `ToString(formatString, provider)` método define el formato. En caso contrario, el argumento `ToString()` método define el formato.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> método para mostrar la temperatura y la hora de los datos almacenados en un tipo genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Tenga en cuenta que la cadena de formato tiene tres elementos de formato, aunque existen sólo para objetos que se va a dar formato. Esto es porque el primer objeto en la lista (un valor de fecha y hora) usan formato dos elementos: El primer formato elemento muestra el tiempo y el segundo muestra la fecha.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que 2 (dos).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Cómo: Definir y usar proveedores de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <param name="arg2">Tercer objeto al que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación en forma de cadena de uno de tres argumentos.</summary>
        <returns>Referencia a la instancia con <paramref name="format" /> anexado. Cada elemento de formato de <paramref name="format" /> se reemplaza con la representación de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a `arg0` a través de `arg2`, los objetos en la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, y `arg2` representan los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena `arg0`, `arg1`, o `arg2`, según el índice del elemento de formato. Si el elemento de formato incluye `formatString` y el objeto correspondiente en `args` implementa el <xref:System.IFormattable> interfaz, a continuación, `arg` *x* `.ToString(formatString, null)` define el formato, donde  *x* es el índice del argumento. En caso contrario, `arg` *x* `.ToString()` define el formato.  
  
 Si la cadena asignada a `format` es "agradecimiento por su donación de {0: ###} latas de comida a nuestra organización benéfica." y `arg0` es un entero con el valor 10, el valor devuelto será "Gracias por su donación de 10 latas de comida a nuestra organización benéfica."  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Objeto que proporciona información de formato específica de la referencia cultural.</param>
        <param name="format">Cadena de formato compuesto.</param>
        <param name="arg0">Primer objeto al que se va a dar formato.</param>
        <param name="arg1">Segundo objeto al que se va a dar formato.</param>
        <param name="arg2">Tercer objeto al que se va a dar formato.</param>
        <summary>Anexa a esta instancia la cadena que se devuelve al procesar una cadena con formato compuesto, que contiene cero o más elementos de formato. Cada elemento de formato se reemplaza por la representación de cadena de tres argumentos utilizando un proveedor de formato especificado.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado. Después de la operación de anexado, esta instancia contiene todos los datos que existían antes de la operación, seguidos de una copia de <paramref name="format" /> como sufijo, en la que cualquier especificación de formato se reemplaza con la representación en forma de cadena del argumento de objeto correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa la [característica de formato compuesto](~/docs/standard/base-types/composite-formatting.md) de .NET Framework para convertir el valor de un objeto en su representación de texto e insertar esa representación actual <xref:System.Text.StringBuilder> objeto.  
  
 El `format` parámetro consta de cero o más ejecuciones de texto mezclado con cero o más marcadores de posición indizados, denominados elementos de formato, que corresponden a objetos de la lista de parámetros de este método. El proceso de formato reemplaza cada elemento de formato con la representación de cadena del objeto correspondiente.  
  
 La sintaxis de un elemento de formato es como sigue:  
  
 {*index*[,*length*][:*formatString*]}  
  
 Los elementos entre corchetes son opcionales. En esta tabla se describe cada elemento.  
  
|Elemento|Descripción|  
|-------------|-----------------|  
|*index*|La posición de base cero en la lista de parámetros del objeto para dar formato. Si el objeto especificado por *índice* es `null`, el elemento de formato se reemplaza por <xref:System.String.Empty?displayProperty=nameWithType>. Si no hay ningún parámetro en el *índice* posición, un <xref:System.FormatException> se produce.|  
|,*longitud*|El número mínimo de caracteres en la representación de cadena del parámetro. Si es positivo, el parámetro está alineado a la derecha; Si es negativo, está alineado a izquierda.|  
|:*formatString*|Una cadena de formato estándar o personalizado que sea compatible con el parámetro.|  
  
> [!NOTE]
>  Para las cadenas de formato estándar y personalizado utilizadas con valores de fecha y hora, vea [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) y [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para las cadenas de formato estándar y personalizadas utilizadas con valores numéricos, vea [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) y [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md). Para las cadenas de formato estándar puede usar con las enumeraciones, vea [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 El `provider` parámetro especifica un <xref:System.IFormatProvider> implementación que puede proporcionar información de formato de `arg0` y `arg1`. `provider` puede ser de cualquiera de las funciones siguientes:  
  
-   Un <xref:System.Globalization.CultureInfo> objeto que proporciona información de formato específica de la referencia cultural.  
  
-   Un <xref:System.Globalization.NumberFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0` o `arg1` si son valores numéricos.  
  
-   Un <xref:System.Globalization.DateTimeFormatInfo> objeto que proporciona información de formato específica de la referencia cultural `arg0`, `arg1`, o `arg2` si son valores de fecha y hora.  
  
-   Personalizada <xref:System.IFormatProvider> implementación que proporciona información de formato de `arg0`, `arg1`, y `arg2`. Normalmente, este tipo de implementación también implementa el <xref:System.ICustomFormatter> interfaz.  
  
 Si el `provider` parámetro es `null`, se obtiene información del proveedor de formato de la referencia cultural actual.  
  
 `arg0`, `arg1`, y `arg2` representan los objetos que se va a dar formato. Cada elemento de formato de `format` se reemplaza por la representación de cadena del objeto que tiene el índice correspondiente. Si el elemento de formato incluye `formatString` y el argumento correspondiente implementa la <xref:System.IFormattable> interfaz y, a continuación, el argumento `ToString(formatString, provider)` método define el formato. En caso contrario, el argumento `ToString()` método define el formato.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para mostrar el resultado de un valor booleano `And` operación con valores enteros. Tenga en cuenta que la cadena de formato incluye seis elementos de formato, pero el método tiene solo tres elementos en su lista de argumentos, porque cada elemento es un formato de dos maneras diferentes.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> es <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> no es válido.  
  
O bien 
El índice de un elemento de formato es menor que 0 (cero), o mayor o igual que 3 (tres).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud de la cadena expandida superaría <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Aplicar formato a tipos en .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatos compuestos</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">Cómo: Definir y usar proveedores de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadenas con formato numérico estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadenas con formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadenas con formato de fecha y hora estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadenas con formato de fecha y hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadenas de formato TimeSpan estándar</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadenas de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadenas de formato de enumeración</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Anexa el terminador de línea predeterminado, o una copia de una cadena especificada y el terminador de línea predeterminado, al final de esta instancia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anexa el terminador de línea predeterminado al final del objeto <see cref="T:System.Text.StringBuilder" /> actual.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El terminador de línea predeterminado es el valor actual de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propiedad.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.AppendLine%2A> método.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se va a anexar.</param>
        <summary>Anexa una copia de la cadena especificada seguida del terminador de línea predeterminado al final del objeto <see cref="T:System.Text.StringBuilder" /> actual.</summary>
        <returns>Referencia a esta instancia después de que se complete la operación de anexado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El terminador de línea predeterminado es el valor actual de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propiedad.  
  
 La capacidad de esta instancia se ajusta según sea necesario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <see cref="T:System.Text.StringBuilder" /> objeto mediante una llamada a la <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> constructor, la longitud y la capacidad de la <see cref="T:System.Text.StringBuilder" /> instancia puede crecer más allá del valor de su <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propiedad. Esto puede ocurrir especialmente cuando se llama a la <see cref="M:System.Text.StringBuilder.Append(System.String)" /> y <see cref="System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos para anexar cadenas pequeñas.</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número máximo de caracteres que puede contener la memoria asignada por la instancia en uso.</summary>
        <value>Número máximo de caracteres que puede contener la memoria asignada por la instancia en uso. Este valor puede variar de <see cref="P:System.Text.StringBuilder.Length" /> a <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A> no afecta el valor de cadena de la instancia actual. <xref:System.Text.StringBuilder.Capacity%2A> se puede reducir siempre y cuando no es menor que <xref:System.Text.StringBuilder.Length%2A>.  
  
 El <xref:System.Text.StringBuilder> asigna más espacio cuando sea necesario y aumenta dinámicamente <xref:System.Text.StringBuilder.Capacity%2A> en consecuencia. Por motivos de rendimiento, un <xref:System.Text.StringBuilder> podría asignar más memoria que sea necesario. La cantidad de memoria asignada es específica de la implementación.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Capacity%2A> propiedad.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación set es menor que la longitud actual de esta instancia.  
  
O bien 
El valor especificado para una operación set es mayor que la capacidad máxima.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición del carácter.</param>
        <summary>Obtiene o establece el carácter en la posición de carácter especificada en la instancia.</summary>
        <value>Carácter Unicode en la posición <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `index` parámetro es la posición de un carácter en el <xref:System.Text.StringBuilder>. Es el primer carácter de la cadena en el índice 0. La longitud de una cadena es el número de caracteres que contiene. El último carácter accesibles de un <xref:System.Text.StringBuilder> instancia está en el índice <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A> es la propiedad predeterminada de la <xref:System.Text.StringBuilder> clase. En C# es un indizador. Esto significa que se pueden recuperar los caracteres individuales de la <xref:System.Text.StringBuilder.Chars%2A> propiedad tal como se muestra en el ejemplo siguiente, que cuenta el número de es un carácter alfabético, espacio en blanco y caracteres de puntuación en una cadena.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>Rendimiento y la indexación basada en caracteres

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fuera de los límites de esta instancia mientras se establece un carácter.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> está fuera de los límites de esta instancia mientras se obtiene un carácter.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los caracteres de la instancia de <see cref="T:System.Text.StringBuilder" /> actual.</summary>
        <returns>Objeto cuya propiedad <see cref="P:System.Text.StringBuilder.Length" /> tiene un valor 0 (cero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> es un método de conveniencia que es equivalente a establecer el <xref:System.Text.StringBuilder.Length%2A> propiedad de la instancia actual en 0 (cero).  
  
## Examples

El ejemplo siguiente crea un <xref:System.Text.StringBuilder> objeto con una cadena, llama a la <xref:System.Text.StringBuilder.Clear%2A> método y, a continuación, se anexa una nueva cadena.  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Posición inicial de esta instancia de donde se copiarán los caracteres. El índice está basado en cero.</param>
        <param name="destination">Matriz en la que se copiarán los caracteres.</param>
        <param name="destinationIndex">Posición inicial de <paramref name="destination" /> en la que se copiarán los caracteres. El índice está basado en cero.</param>
        <param name="count">Número de caracteres que se van a copiar.</param>
        <summary>Copia los caracteres de un segmento especificado de esta instancia al segmento especificado de una matriz <see cref="T:System.Char" /> de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.StringBuilder.CopyTo%2A> método está pensado para usarse en la situación poco frecuente cuando necesite copiar eficazmente las sucesivas secciones de un <xref:System.Text.StringBuilder> objeto en una matriz. La matriz debe ser un tamaño fijo, preasignado, reutilizable y posiblemente globalmente accesible.  
  
 Por ejemplo, podría rellenar su aplicación un <xref:System.Text.StringBuilder> objeto con un gran número de caracteres, a continuación, utilice el <xref:System.Text.StringBuilder.CopyTo%2A> método para copiar pequeñas partes sucesivas de la <xref:System.Text.StringBuilder> objeto en una matriz donde se procesan las piezas. Cuando todos los datos de la <xref:System.Text.StringBuilder> se procesa el objeto, el tamaño de la <xref:System.Text.StringBuilder> objeto se establece en cero y el ciclo se repite.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.CopyTo%2A> método.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="sourceIndex" /> es mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> es mayor que la longitud de esta instancia.  
  
O bien 
 <paramref name="destinationIndex" /> + <paramref name="count" /> es mayor que la longitud de <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Capacidad mínima que se va a garantizar.</param>
        <summary>Garantiza que la capacidad de la instancia de <see cref="T:System.Text.StringBuilder" /> corresponde como mínimo al valor especificado.</summary>
        <returns>Nueva capacidad de esta instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la capacidad actual es menor que el `capacity` parámetro, se vuelve a asignar memoria para esta instancia para que contenga al menos `capacity` número de caracteres; de lo contrario, no se modificará la memoria.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.EnsureCapacity%2A> método.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> es menor que cero.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="span">El intervalo de caracteres que se va a comparar con la instancia actual.</param>
        <summary>Devuelve un valor que indica si los caracteres de esta instancia son iguales a los caracteres de un intervalo de caracteres especificado de solo lectura.</summary>
        <returns><see langword="true" /> si los caracteres de esta instancia y <paramref name="span" /> son iguales; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

El `Equals` método realiza una comparación ordinal para determinar si los caracteres de la instancia actual y `span` son iguales.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Objeto que se va a comparar con esta instancia o <see langword="null" />.</param>
        <summary>Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</summary>
        <returns><see langword="true" /> si esta instancia y <paramref name="sb" /> tienen los mismos valores de cadena, <see cref="P:System.Text.StringBuilder.Capacity" /> y <see cref="P:System.Text.StringBuilder.MaxCapacity" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET framework y .NET Core 2.2 y versiones anteriores:** La instancia actual y `sb` son iguales si tienen la cadena igual, <xref:System.Text.StringBuilder.Capacity>, y <xref:System.Text.StringBuilder.MaxCapacity> valores. El `Equals` método usa la comparación de ordinales para determinar si las cadenas son iguales.

**.NET core 3.0 y versiones posteriores:** La instancia actual y `sb` son iguales si las cadenas que se asignan a ambos <xref:System.Text.StringBuilder> objetos son iguales.  Para determinar la igualdad, la `Equals` método usa la comparación ordinal. El <xref:System.Text.StringBuilder.Capacity> y <xref:System.Text.StringBuilder.MaxCapacity> los valores de propiedad no se usan en la comparación.

## Examples  
 El siguiente código utiliza el <xref:System.Text.StringBuilder.Equals%2A> método para comprobar si dos <xref:System.Text.StringBuilder> objetos son iguales. El método se llama varias veces después de que se realizan pequeños cambios para cada objeto y los resultados se muestran en la consola.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inserta en la instancia la representación en forma de cadena de un objeto concreto en la posición del carácter que se haya especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un valor booleano en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 8 bits sin signo, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un carácter Unicode concreto en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Matriz de caracteres que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de una matriz concreta de caracteres Unicode en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
 Si `value` es `null`, el <xref:System.Text.StringBuilder> no cambia.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un número decimal en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un número de punto flotante de doble precisión en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 16 bits con signo especificado, en la posición del carácter que se haya indicado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 32 bits con signo especificado, en la posición del carácter que se haya indicado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 64 bits con signo, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Objeto que se va a insertar o <see langword="null" />.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un objeto en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
 Si `value` es `null`, no se ha modificado el valor de esta instancia.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 8 bits con signo especificado, en la posición del carácter que se haya indicado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un número de punto flotante de precisión sencilla, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Cadena que se va a insertar.</param>
        <summary>Inserta una cadena en la instancia en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad se ajusta según sea necesario.  
  
 Esta instancia de <xref:System.Text.StringBuilder> no cambia si `value` es `null`, o `value` no `null` pero su longitud es cero.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud actual de esta instancia.  
  
O bien 
La longitud actual de este objeto <see cref="T:System.Text.StringBuilder" /> más la longitud de <paramref name="value" /> supera <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 16 bits sin signo, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 32 bits sin signo, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Valor que se va a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de un entero de 64 bits sin signo, en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> se utiliza para obtener una representación de cadena de `value`. Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud de esta instancia.</exception>
        <exception cref="T:System.OutOfMemoryException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage"><para>En el [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] y versiones anteriores, las llamadas a este método produjo una <see cref="T:System.ArgumentOutOfRangeException" /> si insertar <paramref name="value" /> provocaría que la longitud total del objeto supere <see cref="P:System.Text.StringBuilder.MaxCapacity" />. A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el método produce una <see cref="T:System.OutOfMemoryException" />.</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Cadena que se va a insertar.</param>
        <param name="count">Número de veces que se va a insertar <paramref name="value" />.</param>
        <summary>Inserta en la instancia una o más copias de una cadena concreta en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
 Esto <xref:System.Text.StringBuilder> objeto no cambia si `value` es `null`, `value` no `null` pero su longitud es cero, o `count` es cero.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que cero o mayor que la longitud actual de esta instancia.  
  
O bien 
 <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.OutOfMemoryException">La longitud actual de este objeto <see cref="T:System.Text.StringBuilder" /> más la longitud de <paramref name="value" /> veces <paramref name="count" /> supera <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Posición en la que comienza la inserción en la instancia.</param>
        <param name="value">Matriz de caracteres.</param>
        <param name="startIndex">Índice inicial de <paramref name="value" />.</param>
        <param name="charCount">Número de caracteres que se van a insertar.</param>
        <summary>Inserta en la instancia la representación en forma de cadena de una submatriz concreta de caracteres Unicode en la posición del carácter que se haya especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de inserción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los caracteres existentes se desplazan para dejar espacio para el nuevo texto. La capacidad de esta instancia se ajusta según sea necesario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> es <see langword="null" />, y <paramref name="startIndex" /> y <paramref name="charCount" /> no son cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />, <paramref name="startIndex" /> o <paramref name="charCount" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es mayor que la longitud de esta instancia.  
  
O bien 
 <paramref name="startIndex" /> más <paramref name="charCount" /> no es una posición dentro de <paramref name="value" />.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la longitud del objeto <see cref="T:System.Text.StringBuilder" /> actual.</summary>
        <value>Longitud de la instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longitud de un <xref:System.Text.StringBuilder> objeto se define por su número de <xref:System.Char> objetos.  
  
 Al igual que el <xref:System.String.Length%2A?displayProperty=nameWithType> propiedad, el <xref:System.Text.StringBuilder.Length%2A> propiedad indica la longitud del objeto string actual. A diferencia de la <xref:System.String.Length%2A?displayProperty=nameWithType> propiedad, que es de solo lectura, el <xref:System.Text.StringBuilder.Length%2A> propiedad le permite modificar la longitud de la cadena almacenada en el <xref:System.Text.StringBuilder> objeto.  
  
 Si la longitud especificada es menor que la longitud actual, actual <xref:System.Text.StringBuilder> objeto se trunca a la longitud especificada. Si la longitud especificada es mayor que la longitud actual, al final del valor de cadena del elemento actual <xref:System.Text.StringBuilder> objeto se rellena con el carácter NULL de Unicode (u+0000).  
  
 Si la longitud especificada es mayor que la capacidad actual, <xref:System.Text.StringBuilder.Capacity%2A> aumenta para que sea mayor o igual que la longitud especificada.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Length%2A> propiedad.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor especificado para una operación Set es menor que cero o mayor que <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la capacidad máxima de la instancia.</summary>
        <value>Número máximo de caracteres que la instancia puede contener.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La capacidad máxima para esta implementación es <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Sin embargo, este valor es específico de la implementación y puede ser diferente en las implementaciones de otras o posteriores. Puede establecer explícitamente la capacidad máxima de un <xref:System.Text.StringBuilder> objeto mediante una llamada a la <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> constructor.  
  
En .NET Core y en el .NET Framework 4.0 y versiones posteriores, al crear instancias de la <xref:System.Text.StringBuilder> objeto mediante una llamada a la <xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)> constructor, la longitud y la capacidad de la <xref:System.Text.StringBuilder> instancia puede crecer más allá del valor de su <xref:System.Text.StringBuilder.MaxCapacity> propiedad. Esto puede ocurrir especialmente cuando se llama a la <xref:System.Text.StringBuilder.Append(System.String)> y <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)> métodos para anexar cadenas pequeñas.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición de base cero en esta instancia donde comienza la eliminación.</param>
        <param name="length">Número de caracteres que se van a quitar.</param>
        <summary>Quita de la instancia el intervalo de caracteres especificado.</summary>
        <returns>Referencia a la instancia después de que se complete la operación de eliminación.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método actual quita el intervalo de caracteres especificado de la instancia actual. Los caracteres en (`startIndex` + `length`) se mueven a `startIndex`, y el valor de cadena de la instancia actual se ha reducido por `length`. No se ve afectada la capacidad de la instancia actual.  
  
> [!NOTE]
>  El <xref:System.Text.StringBuilder.Remove%2A> método modifica el valor del elemento actual <xref:System.Text.StringBuilder> de instancia y devuelve dicha instancia. No crear y devolver un nuevo <xref:System.Text.StringBuilder> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Remove%2A> método.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Si <paramref name="startIndex" /> o <paramref name="length" /> es menor que cero o <paramref name="startIndex" /> + <paramref name="length" /> es mayor que la longitud de esta instancia.</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reemplaza todas las apariciones de un carácter o cadena en la instancia por otro carácter o cadena especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carácter que se va a reemplazar.</param>
        <param name="newChar">Carácter que reemplaza a <paramref name="oldChar" />.</param>
        <summary>Reemplaza todas las apariciones de un carácter en la instancia por otro carácter especificado.</summary>
        <returns>Referencia a la instancia con <paramref name="oldChar" /> reemplazado por <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal, distingue mayúsculas de minúsculas para identificar las apariciones de `oldChar` en la instancia actual. El tamaño del elemento actual <xref:System.Text.StringBuilder> instancia se modifica después de la sustitución.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Cadena que se va a reemplazar.</param>
        <param name="newValue">Cadena que reemplaza a <paramref name="oldValue" />, o <see langword="null" />.</param>
        <summary>Reemplaza todas las apariciones de una cadena especificada en la instancia por otra cadena especificada.</summary>
        <returns>Referencia a la instancia junto a todas las instancias de <paramref name="oldValue" /> reemplazadas por <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal, distingue mayúsculas de minúsculas para identificar las apariciones de `oldValue` en la instancia actual. Si `newValue` es `null` o <xref:System.String.Empty?displayProperty=nameWithType>, todas las apariciones de `oldValue` se quitan.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="oldValue" /> es cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">Carácter que se va a reemplazar.</param>
        <param name="newChar">Carácter que reemplaza a <paramref name="oldChar" />.</param>
        <param name="startIndex">Posición de la instancia en la que comienza la subcadena.</param>
        <param name="count">Longitud de la subcadena.</param>
        <summary>En una subcadena de la instancia, reemplaza todas las apariciones de un carácter especificado por otro carácter especificado.</summary>
        <returns>Referencia a esta instancia con <paramref name="oldChar" /> reemplazado por <paramref name="newChar" /> en el intervalo de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal, distingue mayúsculas de minúsculas para identificar las apariciones de `oldChar` en la instancia actual. El tamaño del elemento actual <xref:System.Text.StringBuilder> objeto se modifica después de la sustitución.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> es mayor que la longitud del valor de esta instancia.  
  
O bien 
 <paramref name="startIndex" /> o <paramref name="count" /> es menor que cero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">Cadena que se va a reemplazar.</param>
        <param name="newValue">Cadena que reemplaza a <paramref name="oldValue" />, o <see langword="null" />.</param>
        <param name="startIndex">Posición de la instancia en la que comienza la subcadena.</param>
        <param name="count">Longitud de la subcadena.</param>
        <summary>En una subcadena de la instancia, reemplaza todas las apariciones de una cadena especificada por otra cadena especificada.</summary>
        <returns>Referencia a esta instancia con todas las instancias de <paramref name="oldValue" /> reemplazadas por <paramref name="newValue" /> en el intervalo de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método realiza una comparación ordinal, distingue mayúsculas de minúsculas para identificar las apariciones de `oldValue` en la subcadena especificada. Si `newValue` es `null` o <xref:System.String.Empty?displayProperty=nameWithType>, todas las apariciones de `oldValue` se quitan.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="oldValue" /> es cero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 La suma de <paramref name="startIndex" /> y <paramref name="count" /> indica una posición de carácter fuera de la instancia.  
  
O bien 
Si se amplía el valor de esta instancia, se superará <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Objeto que se va a rellenar con información de serialización.</param>
        <param name="context">Sitio para almacenar y recuperar los datos serializados. Reservado para un uso futuro.</param>
        <summary>Rellena un objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para deserializar el objeto <see cref="T:System.Text.StringBuilder" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `context` parámetro está reservado para uso futuro y no participa en esta operación.  
  
 Para obtener más información, vea el método <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte el valor de un objeto <see cref="T:System.Text.StringBuilder" /> en un objeto <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el valor de la instancia en un objeto <see cref="T:System.String" />.</summary>
        <returns>Cadena cuyo valor es el mismo que el de la instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a la <xref:System.Text.StringBuilder.ToString%2A> método para convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> objeto antes de pasar la cadena representada por el <xref:System.Text.StringBuilder> objeto a un método que tiene un <xref:System.String> parámetro o para mostrarlo en la interfaz de usuario.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la forma de llamar al método <xref:System.Text.StringBuilder.ToString%2A>. Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Text.StringBuilder> clase.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Posición inicial de la subcadena en la instancia.</param>
        <param name="length">Longitud de la subcadena.</param>
        <summary>Convierte el valor de una subcadena de la instancia en un objeto <see cref="T:System.String" />.</summary>
        <returns>Cadena cuyo valor es el mismo que el de la subcadena especificada de la instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe llamar a la <xref:System.Text.StringBuilder.ToString%2A> método para convertir el <xref:System.Text.StringBuilder> objeto a un <xref:System.String> objeto antes de pasar la cadena representada por el <xref:System.Text.StringBuilder> objeto a un método que tiene un <xref:System.String> parámetro o para mostrarlo en la interfaz de usuario.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> o <paramref name="length" /> es menor que cero.  
  
O bien 
La suma de <paramref name="startIndex" /> y <paramref name="length" /> es mayor que la longitud de la instancia actual.</exception>
      </Docs>
    </Member>
  </Members>
</Type>