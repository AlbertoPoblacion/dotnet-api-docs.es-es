<Type Name="Encoder" FullName="System.Text.Encoder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bb12dbcb1e7a94e49295d807121b8a314f56c31f" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48734251" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Encoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Encoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Encoder abstract" />
  <TypeSignature Language="F#" Value="type Encoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Codifica un juego de caracteres en una secuencia de bytes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una instancia de una implementación de la <xref:System.Text.Encoder> (clase), la aplicación debe utilizar el <xref:System.Text.Encoding.GetEncoder%2A> método de un <xref:System.Text.Encoding> implementación.  
  
 El <xref:System.Text.Encoder.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.Encoder.GetBytes%2A> método realiza la codificación real. Hay varias versiones de estos dos métodos disponibles en la <xref:System.Text.Encoder> clase. Para obtener más información, vea <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType>.  
  
 Un <xref:System.Text.Encoder> objeto mantiene información de estado entre las llamadas sucesivas a `GetBytes` o <xref:System.Text.Decoder.Convert%2A> secuencias que abarcan distintos bloques de caracteres de los métodos, de modo que TI puede codificar correctamente. El <xref:System.Text.Encoder> también conserva finales caracteres al final de los bloques de datos y usa caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto no coincidente, y el suplente bajo podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
> [!NOTE]
>  Cuando la aplicación ha terminado con un flujo de datos debe asegurarse de que se vacíe la información de estado estableciendo el `flush` parámetro `true` en la llamada al método apropiado. Si se produce una excepción o si la aplicación modifica los flujos, debe llamar a <xref:System.Text.Encoder.Reset%2A> para borrar el estado interno de la `Encoder` objeto.  
  
## <a name="version-considerations"></a>Consideraciones sobre la versión  
 Un <xref:System.Text.Decoder> o <xref:System.Text.Encoder> se puede serializar el objeto durante una operación de conversión. El estado del objeto se conserva si se ha deserializado en la misma versión de .NET Framework, pero se pierden si se deserializa en otra versión.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo convertir una matriz de caracteres Unicode en bloques de bytes con una codificación especificada. Para la comparación, la matriz de caracteres se codifica primero mediante <xref:System.Text.UTF7Encoding>. A continuación, la matriz de caracteres se codifica mediante un <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.Encoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.Encoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder Example/VB/snippet.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Cuando la aplicación se hereda de esta clase, deben invalidar a todos los miembros.</para>
    </block>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoding" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Encoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Encoder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una instancia de una implementación de esta clase, la aplicación debe utilizar el <xref:System.Text.Encoding.GetEncoder%2A> método de un <xref:System.Text.Encoding> implementación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra dos técnicas para inicializar una nueva <xref:System.Text.Encoder> instancia.  
  
 [!code-cpp[System.Text.Encoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Encoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Encoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte un búfer o una matriz de caracteres Unicode en una secuencia de bytes codificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, bytes, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char* chars, int charCount, byte* bytes, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charCount, bytes, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Dirección de una cadena de caracteres UTF-16 codificados que se va a convertir.</param>
        <param name="charCount">Número de caracteres en <c>chars</c> que se van a convertir.</param>
        <param name="bytes">Dirección de un búfer para almacenar los bytes convertidos.</param>
        <param name="byteCount">Número máximo de bytes en <c>bytes</c> que se pueden usar en la conversión.</param>
        <param name="flush">Es <see langword="true" /> para indicar que no se van a convertir más datos; en caso contrario, es <see langword="false" />.</param>
        <param name="charsUsed">Cuando este método devuelve un resultado, contiene el número de caracteres de <c>chars</c> que se han usado en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="bytesUsed">Cuando este método vuelve, contiene el número de bytes que se usaron en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="completed">Cuando este método devuelve un resultado, contiene <see langword="true" /> si todos los caracteres especificados por <c>charCount</c> se han convertido; de lo contrario, <see langword="false" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte un búfer de caracteres Unicode en una secuencia de bytes codificada y almacena el resultado en otro búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Encoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Encoder.Convert%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el codificador omite los bytes no válidos al final del bloque de datos y borra el búfer interno. Los datos procesados restantes que forma parte de una unidad lógica, como suplente alto de un par suplente, se convierten según la configuración de reserva actual.  
  
 El `Convert` método está diseñado para usarse en un bucle para codificar una cantidad arbitraria de entrada, como los datos leídos de un archivo o secuencia. Almacena el resultado de la operación de codificación en un búfer de tamaño fijo. <xref:System.Text.Encoder.GetBytes%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Encoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los caracteres leídos y bytes escritos. Consulte también el <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 El `completed` parámetro de salida que indica si todos los datos en el búfer de entrada se convierten y se almacena en el búfer de salida. Este parámetro se establece en `false` si el número de caracteres especificado por el `charCount` parámetro no se puede convertir sin exceder el número de bytes especificado por el `byteCount` parámetro. En esa situación, la aplicación debe usar el contenido del búfer de salida o proporcione un nuevo búfer de salida, incremento el `chars` parámetro por el número de caracteres especificados por el `charsUsed` parámetro, a continuación, llame al `Convert` nuevo al método para procesar las entradas restantes.  
  
 El `completed` parámetro también se puede establecer en `false`, aunque el `charsUsed` y `charCount` parámetros son iguales. Esta situación se produce si todavía hay datos en el <xref:System.Text.Encoder> objeto que no se ha almacenado en el `chars` búfer.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> o <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charCount" /> u <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El búfer de salida no tiene capacidad para contener las entradas convertidas. El búfer de salida debe tener un tamaño mayor o igual que el indicado por el método <see cref="Overload:System.Text.Encoder.GetByteCount" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, out int charsUsed, out int bytesUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, int32 byteCount, bool flush, [out] int32&amp; charsUsed, [out] int32&amp; bytesUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Convert(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, byteCount As Integer, flush As Boolean, ByRef charsUsed As Integer, ByRef bytesUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, bool flush, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : char[] * int * int * byte[] * int * int * bool *  *  *  -&gt; unit" Usage="encoder.Convert (chars, charIndex, charCount, bytes, byteIndex, byteCount, flush, charsUsed, bytesUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que se van a convertir.</param>
        <param name="charIndex">Primer elemento de <c>chars</c> que se va a convertir.</param>
        <param name="charCount">Número de elementos de <c>chars</c> que se va a convertir.</param>
        <param name="bytes">Matriz donde se almacenan los bytes convertidos.</param>
        <param name="byteIndex">Primer elemento de <c>bytes</c> en el que se almacenan los datos.</param>
        <param name="byteCount">Número máximo de elementos de <c>bytes</c> que se puede usar en la conversión.</param>
        <param name="flush">Es <see langword="true" /> para indicar que no se van a convertir más datos; en caso contrario, es <see langword="false" />.</param>
        <param name="charsUsed">Cuando este método devuelve un resultado, contiene el número de caracteres de <c>chars</c> que se han usado en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="bytesUsed">Cuando este método vuelve, contiene el número de bytes que ha generado la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="completed">Cuando este método devuelve un resultado, contiene <see langword="true" /> si todos los caracteres especificados por <c>charCount</c> se han convertido; de lo contrario, <see langword="false" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte una matriz de caracteres Unicode en una secuencia de bytes codificada y almacena el resultado en una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Encoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Encoder.Convert%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el codificador omite los bytes no válidos al final del bloque de datos y borra el búfer interno. Los datos procesados restantes que forma parte de una unidad lógica, como suplente alto de un par suplente, se convierten según la configuración de reserva actual.  
  
 El `Convert` método está diseñado para usarse en un bucle para descodificar una cantidad arbitraria de entrada, como los datos leídos de un archivo o secuencia. Almacena el resultado de la operación de codificación en un búfer de tamaño fijo. <xref:System.Text.Encoder.GetBytes%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Encoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los caracteres leídos y bytes escritos. Consulte también el <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 El `completed` parámetro de salida que indica si todos los datos en el búfer de entrada se convierten y se almacena en el búfer de salida. Este parámetro se establece en `false` si el número de caracteres especificado por el `charCount` parámetro no se puede convertir sin exceder el número de bytes especificado por el `byteCount` parámetro. En esa situación, la aplicación debe usar el contenido del búfer de salida o proporcione un nuevo búfer de salida, incremento el `chars` parámetro por el número de caracteres especificados por el `charsUsed` parámetro, a continuación, llame al `Convert` nuevo al método para procesar las entradas restantes.  
  
 El `completed` parámetro también se puede establecer en `false`, aunque el `charsUsed` y `charCount` parámetros son iguales. Esta situación se produce si todavía hay datos en el <xref:System.Text.Encoder> objeto que no se ha almacenado en el `chars` búfer.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.Encoder.Convert%2A> método para convertir un archivo de UTF-16 caracteres en UTF-8, a continuación, usa el <xref:System.Text.Decoder.Convert%2A> método para convertir los caracteres UTF-8 a UTF-16 caracteres.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> o <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" /> o <paramref name="byteCount" /> es menor que cero.  
  
O bien 
La longitud de <paramref name="chars" /> - <paramref name="charIndex" /> es menor que <paramref name="charCount" />.  
  
O bien 
La longitud de <paramref name="bytes" /> - <paramref name="byteIndex" /> es menor que <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">El búfer de salida no tiene capacidad para contener las entradas convertidas. El búfer de salida debe tener un tamaño mayor o igual que el indicado por el método <see cref="Overload:System.Text.Encoder.GetByteCount" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As EncoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallback ^ Fallback { System::Text::EncoderFallback ^ get(); void set(System::Text::EncoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.EncoderFallback with get, set" Usage="System.Text.Encoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto <see cref="T:System.Text.EncoderFallback" /> para el objeto <see cref="T:System.Text.Encoder" /> actual.</summary>
        <value>Un objeto <see cref="T:System.Text.EncoderFallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.EncoderFallback> objeto representa un controlador de errores que se invoca cuando un carácter no se puede convertir en una secuencia de bytes codificada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de una operación Set es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">No se puede asignar un nuevo valor en una operación de establecimiento porque el objeto <see cref="T:System.Text.EncoderFallbackBuffer" /> actual contiene datos que todavía no se han codificado.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As EncoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::EncoderFallbackBuffer ^ FallbackBuffer { System::Text::EncoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.EncoderFallbackBuffer" Usage="System.Text.Encoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Text.EncoderFallbackBuffer" /> asociado al objeto <see cref="T:System.Text.Encoder" /> actual.</summary>
        <value>Un objeto <see cref="T:System.Text.EncoderFallbackBuffer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.FallbackBuffer%2A> objeto representa datos que usa el <xref:System.Text.EncoderFallback> objeto. La <xref:System.Text.EncoderFallback> objeto representa un controlador de errores que se invoca cuando un carácter no se puede convertir en una secuencia de bytes codificada.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes generado al codificar un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.ReadOnlySpan{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetByteCount (chars As ReadOnlySpan(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(ReadOnlySpan&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int&#xA;override this.GetByteCount : ReadOnlySpan&lt;char&gt; * bool -&gt; int" Usage="encoder.GetByteCount (chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetByteCount(char* chars, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetByteCount : nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se debe codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <param name="flush">Es <see langword="true" /> para simular el borrado del estado interno del codificador después del cálculo; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se invalida en una clase derivada, calcula el número de bytes que se generan al codificar un juego de caracteres a partir del puntero de carácter especificado. Un parámetro indica si se debe borrar el estado interno del codificador después del cálculo.</summary>
        <returns>Número de bytes generado al codificar los caracteres especificados y cualquier carácter del búfer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no afecta el estado del codificador.  
  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoder.GetBytes%2A> requiere para almacenar los bytes resultantes, debe usar la aplicación <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Si `GetBytes` se llama con `flush` establecido en `false`, el codificador almacena caracteres finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de codificación. La aplicación debe llamar a `GetByteCount` en un bloque de datos inmediatamente antes de llamar a `GetBytes` en el mismo bloque, por lo que cualquier finales caracteres del bloque anterior se incluyen en el cálculo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetByteCount (chars As Char(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : char[] * int * int * bool -&gt; int" Usage="encoder.GetByteCount (chars, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <param name="flush">Es <see langword="true" /> para simular el borrado del estado interno del codificador después del cálculo; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de bytes generado al codificar un juego de caracteres de la matriz de caracteres especificada. Un parámetro indica si se debe borrar el estado interno del codificador después del cálculo.</summary>
        <returns>Número de bytes generado al codificar los caracteres especificados y cualquier carácter del búfer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no afecta el estado del codificador.  
  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Encoder.GetBytes%2A> requiere para almacenar los bytes resultantes, debe usar la aplicación <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Si `GetBytes` se llama con `flush` establecido en `false`, el codificador almacena caracteres finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de codificación. La aplicación debe llamar a `GetByteCount` en un bloque de datos inmediatamente antes de llamar a `GetBytes` en el mismo bloque, por lo que cualquier finales caracteres del bloque anterior se incluyen en el cálculo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Text.Encoder.GetByteCount%2A> método para devolver el número de bytes necesarios para codificar una matriz de caracteres mediante Unicode <xref:System.Text.Encoder>.  
  
 [!code-cpp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CPP/getbytecount-char[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/CS/getbytecount-char[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetByteCount Example/VB/getbytecount-char[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="index" /> u <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (ReadOnlySpan&lt;char&gt; chars, Span&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(valuetype System.ReadOnlySpan`1&lt;char&gt; chars, valuetype System.Span`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBytes (chars As ReadOnlySpan(Of Char), bytes As Span(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(ReadOnlySpan&lt;char&gt; chars, Span&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int&#xA;override this.GetBytes : ReadOnlySpan&lt;char&gt; * Span&lt;byte&gt; * bool -&gt; int" Usage="encoder.GetBytes (chars, bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="bytes" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charCount, bytes, byteCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se debe codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <param name="flush">Es <see langword="true" /> para borrar el estado interno del codificador después de la conversión; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres a partir del puntero de carácter especificado y cualquier carácter del búfer interno en una secuencia de bytes que se almacenan a partir del puntero de byte especificado. Un parámetro indica si se debe borrar el estado interno del codificador después de la conversión.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por el parámetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Encoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Encoder.GetBytes%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` en la última llamada a `GetBytes` para asegurarse de que se vacíe la información de estado y que los bytes codificados se terminan correctamente. Con esta configuración, el codificador omite los bytes no válidos al final del bloque de datos, como suplentes no coincidentes o combinación incompleta secuencias y borra el búfer interno.  
  
 Para calcular el tamaño del búfer exacto que `GetBytes` requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Si `GetBytes` se llama con `flush` establecido en `false`, el codificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de codificación. La aplicación debe llamar a `GetByteCount` en un bloque de datos inmediatamente antes de llamar a `GetBytes` en el mismo bloque, por lo que cualquier finales caracteres del bloque anterior se incluyen en el cálculo.  
  
 Si la aplicación consiste en convertir muchos segmentos de un flujo de entrada, considere el uso de la <xref:System.Text.Encoder.Convert%2A> método. <xref:System.Text.Encoder.GetBytes%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Encoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los caracteres leídos y bytes escritos. Consulte también el <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charCount" /> u <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetBytes : char[] * int * int * byte[] * int * bool -&gt; int" Usage="encoder.GetBytes (chars, charIndex, charCount, bytes, byteIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <param name="flush">Es <see langword="true" /> para borrar el estado interno del codificador después de la conversión; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, codifica un juego de caracteres de la matriz de caracteres especificada y cualquier carácter del búfer interno en la matriz de bytes especificada. Un parámetro indica si se debe borrar el estado interno del codificador después de la conversión.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Encoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Encoder.GetBytes%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` en la última llamada a `GetBytes` para asegurarse de que se vacíe la información de estado y que los bytes codificados se terminan correctamente. Con esta configuración, el codificador omite los bytes no válidos al final del bloque de datos, como suplentes no coincidentes o combinación incompleta secuencias y borra el búfer interno.  
  
 Para calcular el tamaño del búfer exacto que `GetBytes` requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Encoder.GetByteCount%2A>.  
  
 Si `GetBytes` se llama con `flush` establecido en `false`, el codificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de codificación. La aplicación debe llamar a `GetByteCount` en un bloque de datos inmediatamente antes de llamar a `GetBytes` en el mismo bloque, por lo que cualquier finales caracteres del bloque anterior se incluyen en el cálculo.  
  
 Si la aplicación consiste en convertir muchos segmentos de un flujo de entrada, considere el uso de la <xref:System.Text.Encoder.Convert%2A> método. <xref:System.Text.Encoder.GetBytes%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Encoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los caracteres leídos y bytes escritos. Consulte también el <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo codificar un intervalo de elementos de una matriz de caracteres y almacenar los bytes codificados en un intervalo de elementos de una matriz de bytes. El <xref:System.Text.Encoder.GetByteCount%2A> método se utiliza para determinar el tamaño de la matriz requerido <xref:System.Text.Encoder.GetBytes%2A>.  
  
 [!code-cpp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.Encoder.GetBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoder.GetBytes Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 La propiedad <see cref="P:System.Text.Encoder.Fallback" /> está establecida en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Encoder.GetByteCount(System.Char[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Encoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="encoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, restablece el estado inicial del codificador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método borra el estado interno de la <xref:System.Text.Encoder> objeto. El método borra cualquier información de estado de una llamada anterior a <xref:System.Text.Encoder.GetBytes%2A> o <xref:System.Text.Decoder.Convert%2A>, incluidos los caracteres situados al final del bloque de datos anterior, por ejemplo, un suplente alto no coincidente.  
  
 La aplicación debe llamar a la `Reset` método si desea reutilizar el mismo codificador incluso después de que se produce una excepción por <xref:System.Text.Encoder.GetBytes%2A> o <xref:System.Text.Encoder.GetByteCount%2A>, o si la aplicación modifica los flujos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>