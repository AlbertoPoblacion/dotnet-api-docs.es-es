<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f0f047d3b7e414417b38badf4c585451ca50e6cc" /><Meta Name="ms.sourcegitcommit" Value="3efce15f3841385ee3ba24bd71ff0c0cf9a47815" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/03/2019" /><Meta Name="ms.locfileid" Value="58874727" /></Metadata><TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class UTF32Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF32Encoding sealed : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UTF32Encoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una codificación UTF-32 de caracteres Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes. La descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode.  
  
 El [estándar Unicode](https://go.microsoft.com/fwlink/?linkid=37123) asigna un punto de código (un número) a cada carácter en todos los scripts admitidos. Un formato de transformación Unicode (UTF) es una manera de codificar ese punto de código. El [estándar Unicode](https://go.microsoft.com/fwlink/?linkid=37123) usa las siguientes codificaciones UTF:  
  
-   UTF-8, que representa cada punto de código como una secuencia de uno a cuatro bytes.  
  
-   UTF-16, que representa cada punto de código como una secuencia de uno o dos enteros de 16 bits.  
  
-   UTF-32, que representa cada punto de código como un entero de 32 bits.  
  
 Para obtener más información acerca de las codificaciones UTF y otras codificaciones admitidas por <xref:System.Text>, consulte [codificación de caracteres en .NET](~/docs/standard/base-types/character-encoding.md).
  
 La <xref:System.Text.UTF32Encoding> clase representa una codificación UTF-32. El codificador puede usar el orden de bytes big endian (byte más significativo primero) o el orden de bytes endian little (byte menos significativo primero). Por ejemplo, la letra mayúscula latina (punto de código u+0041) se serializa como sigue (en hexadecimal):  
  
-   Orden de bytes big endian: 00 00 00 41  
  
-   Orden de bytes endian little: 41 00 00 00  
  
 Es normalmente más eficaz para almacenar caracteres Unicode mediante el orden de bytes nativo. Por ejemplo, es mejor utilizar el orden de bytes endian little en plataformas little-endian, como equipos Intel. <xref:System.Text.UTF32Encoding> corresponde a las páginas de códigos de Windows 12000 (orden de bytes endian little) y 12001 (orden de bytes big endian). Puede determinar los "modos endian" de una arquitectura concreta mediante una llamada a la <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> método.  
  
 Opcionalmente, el <xref:System.Text.UTF32Encoding> objeto proporciona una marca de orden de bytes (BOM), que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Si el preámbulo contiene una marca de orden de bytes (BOM), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF de una matriz de bytes.  
  
 Si el <xref:System.Text.UTF32Encoding> instancia está configurada para proporcionar una lista de materiales, puede recuperarlo mediante una llamada a la <xref:System.Text.UTF32Encoding.GetPreamble%2A> método; en caso contrario, el método devuelve una matriz vacía. Tenga en cuenta que, incluso si un <xref:System.Text.UTF32Encoding> objeto está configurado para admitir l. MAT, debe incluir la marca BOM al principio de la secuencia de bytes codificada según corresponda; los métodos de codificación de la <xref:System.Text.UTF32Encoding> clase no lo hace automáticamente.  

> [!CAUTION]  
> Para habilitar la detección de errores y hacer que la instancia de clase sea más segura, debe crear una instancia un <xref:System.Text.UTF32Encoding> objeto mediante una llamada a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidBytes` argumento `true`. Con la detección de errores, un método que detecta una secuencia de caracteres o bytes no válida inicia una <xref:System.ArgumentException> excepción. Sin detección de errores, se produce ninguna excepción y, por lo general se omite la secuencia no válida.  
  
 Puede crear instancias de un <xref:System.Text.UTF32Encoding> objetos de varias maneras, dependiendo de si desea que se proporciona una marca de orden de bytes (BOM), si desea que la codificación big endian o little-endian y si desea habilitar la detección de errores. La siguiente tabla se enumeran los <xref:System.Text.UTF32Encoding> constructores y el <xref:System.Text.Encoding> propiedades que devuelven un <xref:System.Text.UnicodeEncoding> objeto.  
  
|Miembro|Modos endian|BOM|Detección de errores|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little-endian|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little-endian|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Configurable|  
  
 El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.UTF32Encoding.GetBytes%2A> método realiza la codificación real.  
  
 Del mismo modo, el <xref:System.Text.UTF32Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.UTF32Encoding.GetChars%2A> y <xref:System.Text.UTF32Encoding.GetString%2A> métodos realizan la descodificación real.  
  
 Para un codificador o descodificador que es capaz de guardar información de estado al codificar o descodificar los datos que abarca varios bloques (por ejemplo, la cadena de 1 millón de caracteres que se codifica en segmentos de 100 000 caracteres), use el <xref:System.Text.UTF32Encoding.GetEncoder%2A> y <xref:System.Text.UTF32Encoding.GetDecoder%2A> propiedades, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el comportamiento de <xref:System.Text.UTF32Encoding> objetos con y sin detección de errores habilitado. Crea una matriz de bytes cuyos último cuatro bytes que representan un par suplente no válido; U + D8FF suplente alto seguido de una U + 01FF, que está fuera del intervalo de caracteres suplentes bajo (0xDC00 a 0xDFFF). Sin detección de errores, el descodificador UTF32 usa la reserva de reemplazo para reemplazar el par suplente no válido con el carácter de reemplazo (U+FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 El ejemplo siguiente codifica una cadena de caracteres Unicode en una matriz de bytes usando un <xref:System.Text.UTF32Encoding> objeto. La matriz de bytes se descodifica, a continuación, en una cadena para demostrar que no hay ninguna pérdida de datos.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 En el ejemplo siguiente se usa la misma cadena que el anterior, excepto en que escribe los bytes codificados en un archivo y prefijos de la secuencia de bytes con una marca de orden de bytes (BOM). A continuación, lee el archivo de dos maneras diferentes: como un archivo de texto mediante el uso de un <xref:System.IO.StreamReader> objeto; y como un archivo binario. Como cabría esperar, ninguna cadena recién lectura incluye la marca BOM.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Text.UnicodeEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF32Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que usa el orden de bytes endian little, proporciona una marca de orden de bytes Unicode y no produce una excepción cuando se detecta una codificación no válida.  
  
> [!CAUTION]
>  Por motivos de seguridad, debe habilitar detección de errores mediante una llamada a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidCharacters` argumento `true`.  
  
   
  
## Examples  
 El siguiente ejemplo recupera y muestra el orden de bytes marcar para diferentes <xref:System.Text.UTF32Encoding> instancias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> para usar el orden de bytes big endian (primero el byte más significativo), o bien <see langword="false" /> para usar el orden de bytes little endian (primero el byte menos significativo).</param>
        <param name="byteOrderMark"><see langword="true" /> para especificar que se proporciona una marca de orden de bytes Unicode; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF32Encoding" />. Los parámetros especifican si se usa el orden de bytes big endian y si el método <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> devuelve una marca de orden de bytes Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que no produce una excepción cuando se detecta una codificación no válida.  
  
> [!CAUTION]
>  Por motivos de seguridad, debe habilitar detección de errores mediante una llamada a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidCharacters` argumento `true`.  
  
## Examples  
 El siguiente ejemplo recupera y muestra el orden de bytes marcar para diferentes <xref:System.Text.UTF32Encoding> instancias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidCharacters As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="F#" Value="new System.Text.UTF32Encoding : bool * bool * bool -&gt; System.Text.UTF32Encoding" Usage="new System.Text.UTF32Encoding (bigEndian, byteOrderMark, throwOnInvalidCharacters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian"><see langword="true" /> para usar el orden de bytes big endian (primero el byte más significativo), o bien <see langword="false" /> para usar el orden de bytes little endian (primero el byte menos significativo).</param>
        <param name="byteOrderMark"><see langword="true" /> para especificar que se proporciona una marca de orden de bytes Unicode; de lo contrario, es <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters"><see langword="true" /> para especificar que se debe iniciar una excepción cuando se detecte una codificación no válida; de lo contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF32Encoding" />. Los parámetros especifican si se usa el orden de bytes big endian, si se proporciona una marca de orden de bytes Unicode y si se produce una excepción cuando se detecta una codificación no válida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `throwOnInvalidCharacters` es `true`, un método que detecta una secuencia de bytes no válida inicia <xref:System.ArgumentException?displayProperty=nameWithType>. En caso contrario, el método no produce una excepción y se omite la secuencia no válida.  
  
> [!CAUTION]
>  Por motivos de seguridad, debe habilitar detección de errores mediante una llamada a la <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidCharacters` argumento `true`.
  
## Examples  
 En el ejemplo siguiente se muestra el comportamiento de <xref:System.Text.UTF32Encoding>, con la detección de errores habilitado y sin.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="uTF32Encoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> que se va a comparar con el objeto actual.</param>
        <summary>Determina si el objeto <see cref="T:System.Object" /> especificado es igual al objeto <see cref="T:System.Text.UTF32Encoding" /> actual.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> es una instancia de <see cref="T:System.Text.UTF32Encoding" /> y es igual al objeto actual; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos <xref:System.Text.UTF32Encoding> objetos se consideran iguales si se cumplen todas las condiciones siguientes:  
  
-   Ambos objetos utilizan el mismo orden de bytes.  
  
-   Ambos objetos proporcionan la marca de orden de bytes, o ambos no lo hacen.  
  
-   Ambos objetos utilizan la misma reserva del codificador.  
  
-   Ambos objetos utilizan la misma reserva del descodificador.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea <xref:System.Text.UTF32Encoding> objetos con valores de parámetro diferente y, a continuación, comprueba si son iguales.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF32Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="uTF32Encoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> que contiene el juego de caracteres que se va a codificar.</param>
        <summary>Calcula el número de bytes generado al codificar los caracteres del objeto <see cref="T:System.String" /> especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> y <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> métodos para calcular el número real y máximo de bytes necesarios para codificar una cadena. También muestra el número real de bytes necesarios para almacenar una secuencia de bytes con una marca BOM.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="s" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres a partir del puntero de caracteres especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar un preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="uTF32Encoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar un preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente rellena una matriz con un alfabeto latino en mayúsculas y minúsculas y llama a la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar el número de bytes necesarios para codificar los caracteres en minúsculas latinos. A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca BOM. Compara este número con el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica el número máximo de bytes necesarios para codificar los caracteres en minúsculas latinos. El ejemplo siguiente rellena una matriz con una combinación de caracteres griego y cirílico y llama a la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar el número de bytes necesarios para codificar los caracteres cirílico. A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca BOM. Compara este número con el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica el número máximo de bytes necesarios para codificar los caracteres cirílico.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o bien <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <summary>Codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por el parámetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación utiliza el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!IMPORTANT]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar un preámbulo al principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF32Encoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> o bien <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres de la matriz de caracteres determinada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación utiliza el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!IMPORTANT]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar un preámbulo al principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF32Encoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar tres caracteres de una matriz de caracteres, a continuación, codifica los caracteres y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="uTF32Encoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s"><see cref="T:System.String" /> que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres del objeto <see cref="T:System.String" /> especificado en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación utiliza el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!IMPORTANT]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar un preámbulo al principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF32Encoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una cadena, a continuación, codifica la cadena y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" /> o <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="s" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir del puntero de bytes especificado.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A> calcula el tamaño de matriz exacto que requiere el <xref:System.Text.UTF32Encoding.GetChars%2A> método para almacenar los caracteres resultantes. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="uTF32Encoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método calcula el tamaño de matriz exacto que requiere el <xref:System.Text.UTF32Encoding.GetChars%2A> método para almacenar los caracteres resultantes. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o bien <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF32Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Descodifica una secuencia de bytes en un conjunto de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <summary>Descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</summary>
        <returns>Número real de caracteres escrito en la ubicación indicada por <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y se devolvió la matriz de bytes por un método de un tipo compatible con no BOM, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación utiliza el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.  
  
O bien 
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> o bien <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
O bien 
 <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="uTF32Encoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y se devolvió la matriz de bytes por un método de un tipo compatible con no BOM, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación utiliza el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.  
  
O bien 
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteIndex" /> o <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
O bien 
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
O bien 
 <paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para acomodar los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="uTF32Encoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un descodificador que convierte una secuencia de bytes codificada en UTF-32 en una secuencia de caracteres Unicode.</summary>
        <returns>Objeto <see cref="T:System.Text.Decoder" /> que convierte una secuencia de bytes codificada en UTF-32 en una secuencia de caracteres Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <xref:System.Text.UTF32Encoding.GetChars%2A> método. Sin embargo, un <xref:System.Text.Decoder> mantiene la información de estado entre llamadas, de modo que puede descodificar correctamente las secuencias de bytes que abarcan distintos bloques. El <xref:System.Text.Decoder> también conserva los bytes al final de los bloques de datos y usa los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.UTF32Encoding.GetDecoder%2A> y <xref:System.Text.UTF32Encoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidCharacters` parámetro del constructor se estableció en `true`, también se habilita la detección de errores en el <xref:System.Text.Decoder> devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del descodificador no está definido y debe detener el procesamiento.  
  
   
  
## Examples  
 El ejemplo siguiente usa un codificador y un descodificador para codificar una cadena en una matriz de bytes y, a continuación, descodificar los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="uTF32Encoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada en UTF-32.</summary>
        <returns>Objeto <see cref="T:System.Text.Encoder" /> que convierte una secuencia de caracteres Unicode en una secuencia de bytes UTF-32 codificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes, de forma similar a la <xref:System.Text.UTF32Encoding.GetBytes%2A> método. Sin embargo, un <xref:System.Text.Encoder> mantiene la información de estado entre llamadas, de modo que puede codificar correctamente las secuencias de caracteres que abarcan distintos bloques. El <xref:System.Text.Encoder> también conserva finales caracteres al final de los bloques de datos y usa caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto no coincidente, y el suplente bajo podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.UTF32Encoding.GetDecoder%2A> y <xref:System.Text.UTF32Encoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidCharacters` parámetro del constructor se estableció en `true`, también se habilita la detección de errores en el <xref:System.Text.Encoder> devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del codificador está definido y debe detener el procesamiento.  
  
   
  
## Examples  
 El ejemplo siguiente usa un codificador y un descodificador para codificar una cadena en una matriz de bytes y, a continuación, descodificar los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="uTF32Encoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de la instancia actual.</summary>
        <returns>Código hash para el objeto <see cref="T:System.Text.UTF32Encoding" /> actual.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="uTF32Encoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número máximo de bytes generado mediante la codificación del número de caracteres especificado.</summary>
        <returns>Número máximo de bytes generados al codificar el número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF32Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> es un número peor, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.EncoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> puede devolver valores grandes.  
  
 En la mayoría de los casos, este método devuelve un número razonable de las cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el caso excepcional de que se ha superado un búfer más razonable. También puede considerar un enfoque diferente y usar <xref:System.Text.UTF32Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> no tiene relación con <xref:System.Text.UTF32Encoding.GetChars%2A>. Si necesita una función similar a usar con <xref:System.Text.UTF32Encoding.GetChars%2A>, utilice <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` no es necesariamente el mismo valor que `N* GetMaxByteCount(1)`.  
  
## Examples  
 El ejemplo siguiente determina el número de bytes necesarios para codificar una cadena, a continuación, codifica la cadena y muestra los bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="uTF32Encoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número máximo de caracteres generado mediante la descodificación del número de bytes especificado.</summary>
        <returns>Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UTF32Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF32Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> es un número peor, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.DecoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> puede devolver valores grandes.  
  
 En la mayoría de los casos, este método devuelve un número razonable de las cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el caso excepcional de que se ha superado un búfer más razonable. También puede considerar un enfoque diferente y usar <xref:System.Text.UTF32Encoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> no tiene relación con <xref:System.Text.UTF32Encoding.GetBytes%2A>. Si necesita una función similar a usar con <xref:System.Text.UTF32Encoding.GetBytes%2A>, utilice <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` no es necesariamente el mismo valor que `N* GetMaxCharCount(1)`.  
  
## Examples  
 El ejemplo siguiente codifica una cadena en una matriz de bytes y, a continuación, descodifica los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="uTF32Encoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una marca de orden de bytes Unicode codificada en formato UTF-32, si el objeto <see cref="T:System.Text.UTF32Encoding" /> está configurado para proporcionarla.</summary>
        <returns>Matriz de bytes que contiene la marca de orden de bytes Unicode, si el objeto <see cref="T:System.Text.UTF32Encoding" /> está configurado para proporcionar una. De lo contrario, este método devuelve una matriz de bytes de longitud cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UTF32Encoding> objeto puede proporcionar un preámbulo, que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Delante de una secuencia de bytes codificados con una marca BOM (puntos de código U + 0000 U+FEFF) ayuda a que el descodificador de determinar el orden de bytes y el formato de transformación o UTF. La marca de orden de bytes Unicode (BOM) se serializa como se indica a continuación (en hexadecimal):  
  
-   Orden de bytes big endian: 00 00 FE FF  
  
-   Orden de bytes endian little: FF FE 00 00  
  
 Puede crear instancias de un <xref:System.Text.UTF32Encoding> cuyo <xref:System.Text.UTF32Encoding.GetPreamble%2A> método devuelve una lista de materiales válido de las maneras siguientes:  
  
-   Recuperando el <xref:System.Text.UTF32Encoding> objeto devuelto por la <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> propiedad.  
  
-   Mediante una llamada sin parámetros <xref:System.Text.UTF32Encoding.%23ctor> constructor para crear instancias de un <xref:System.Text.UTF32Encoding> objeto.  
  
-   Si se suministra `true` como el valor de la `byteOrderMark` argumento para el <xref:System.Text.UTF32Encoding.%23ctor%2A> y <xref:System.Text.UTF32Encoding.%23ctor%2A> constructores.  
  
 Se recomienda usar la marca BOM, ya que ofrece cierta identificación de una codificación para los archivos en caso contrario es han perdido la referencia a la <xref:System.Text.UTF32Encoding> etiquetados incorrectamente datos web o sin etiquetar de objeto, por ejemplo, o archivos de texto aleatorios almacenan cuando un negocio no tenía intereses internacionales u otros datos. A menudo, se podrían evitar problemas de los usuarios si los datos se etiquetan de forma coherente y correctamente.  
  
 Los estándares que proporcionan un tipo de codificación, una marca BOM es redundante. Sin embargo, se puede usar para ayudar a un servidor de enviar el encabezado de codificación correcto. Como alternativa, se puede usar como reserva en caso de que la codificación en caso contrario, se pierde.  
  
 Existen algunas desventajas del uso de una marca BOM. Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una marca BOM. Concatenación de archivos también puede ser un problema, por ejemplo, cuando se mezclan los archivos de tal forma que un carácter innecesario puede acabar en el centro de datos. A pesar de la serie de desventajas, sin embargo, el uso de una lista de materiales se recomienda encarecidamente.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en el [página principal de Unicode](https://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!IMPORTANT]
>  Para asegurarse de que los bytes codificados se descodifican correctamente, se deben anteponer bytes codificados con un preámbulo. Tenga en cuenta que el <xref:System.Text.UTF32Encoding.GetBytes%2A> método no anteponer una marca BOM a una secuencia de bytes codificados; proporcionando una marca BOM al principio de una secuencia de bytes apropiada es responsabilidad del desarrollador.  
  
## Examples  
 El siguiente código en el ejemplo se recupera y se muestra el orden de bytes marcar para diferentes <xref:System.Text.UTF32Encoding> instancias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 El ejemplo siguiente crea dos <xref:System.Text.UTF32Encoding> objetos, el primero de los cuales no proporciona una marca BOM y el segundo de los que hace. A continuación, llama el <xref:System.Text.UTF32Encoding.GetPreamble%2A> método para escribir la lista de materiales en un archivo antes de escribir una cadena codificada en UTF-32. Como se muestra el resultado del ejemplo, el archivo que guarda los bytes del segundo codificador tiene más de cuatro bytes que el primero.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 También puede comparar los archivos mediante el `fc` comando en una ventana de consola, o bien puede inspeccionar los archivos en un editor de texto que incluye un modo de vista hexadecimal. Tenga en cuenta que cuando se abre el archivo en un editor que admite UTF-32, no se muestra la lista de materiales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="uTF32Encoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Descodifica un intervalo de bytes de una matriz de bytes en una cadena.</summary>
        <returns>Cadena que contiene el resultado de la descodificación de la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM), y un método de un tipo compatible con materiales no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF32Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 El ejemplo siguiente codifica una cadena en dos matrices de bytes, de uno en orden little-endian y otro en orden big-endian. Los bytes descodifica, a continuación, convertirlo en una cadena.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 En el ejemplo siguiente se inicializa una matriz mediante una llamada a la <xref:System.Text.UTF32Encoding.GetByteCount%2A> método para determinar exactamente cuántos bytes son necesarios para una cadena codificada y, a continuación, agregar el tamaño de la marca de orden de bytes (BOM). El ejemplo llama a la <xref:System.Text.UTF32Encoding.GetPreamble%2A> método para almacenar la marca BOM a la matriz antes de llamar a la <xref:System.Text.UTF32Encoding.GetBytes%2A> método para almacenar los bytes codificados en la matriz. El ejemplo llama a la <xref:System.Text.UTF32Encoding.GetString%2A> método para descodificar la cadena.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Tenga en cuenta que en este caso la cadena descodificada difiere de la cadena original, ya que comienza con una marca de orden de bytes de 32 bits U + FFFE u+0000. Esto significa que las dos cadenas se consideran diferente, y que, si la cadena es la salida, se mostrará la lista de materiales como el carácter de reemplazo "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o bien <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa). 
- y - 
 <see cref="P:System.Text.Encoding.DecoderFallback" /> se establece en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>