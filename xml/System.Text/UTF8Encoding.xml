<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="UTF8Encoding.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Represents a UTF-8 encoding of Unicode characters.</source>
          <target state="translated">Representa una codificación UTF-8 de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.</source>
          <target state="translated">Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.</source>
          <target state="translated">La descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>UTF-8 is a Unicode encoding that represents each code point as a sequence of one to four bytes.</source>
          <target state="translated">UTF-8 es una codificación que Unicode representa cada punto de código como una secuencia de uno a cuatro bytes.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Unlike the UTF-16 and UTF-32 encodings, the UTF-8 encoding does not require "endianness"; the encoding scheme is the same regardless of whether the processor is big-endian or little-endian.</source>
          <target state="translated">A diferencia de las codificaciones UTF-16 y UTF-32, la codificación UTF-8 no requieren "endian"; el esquema de codificación es el mismo independientemente de si el procesador es big-endian o little-endian.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> corresponds to the Windows code page 65001.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> corresponde a la página de códigos 65001 de Windows.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information about the UTFs and other encodings supported by <ph id="ph1">&lt;xref:System.Text&gt;</ph>, see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de las codificaciones UTF y otras codificaciones admitidas por <ph id="ph1">&lt;xref:System.Text&gt;</ph>, consulte <bpt id="p1">[</bpt>codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM) and whether you want to enable error detection.</source>
          <target state="translated">Puede crear instancias de un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto en una de varias maneras, dependiendo de si desea que se proporciona una marca de orden de bytes (BOM) y si desea habilitar la detección de errores.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following table lists the constructors and the <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> property that return a <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">En la tabla siguiente se enumera los constructores y los <ph id="ph1">&lt;xref:System.Text.Encoding&gt;</ph> propiedades que devuelven un <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Member</source>
          <target state="translated">Miembro</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>BOM</source>
          <target state="translated">BOM</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Error detection</source>
          <target state="translated">Detección de errores</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Yes</source>
          <target state="translated">Sí</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Ninguna (reserva de reemplazo)</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No</source>
          <target state="translated">No</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Ninguna (reserva de reemplazo)</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>No (Replacement fallback)</source>
          <target state="translated">Ninguna (reserva de reemplazo)</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Configurable</source>
          <target state="translated">Configurable</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método realiza la codificación real.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Likewise, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> methods perform the actual decoding.</source>
          <target state="translated">Del mismo modo, el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> métodos realizan la descodificación real.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> properties, respectively.</source>
          <target state="translated">Para un codificador o descodificador que es capaz de guardar información de estado cuando la codificación o descodificación de datos que abarca varios bloques (como las cadenas de caracteres de 1 millón se codifica en segmentos de carácter de 100.000), use la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> propiedades, respectivamente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Optionally, the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the beginning of the byte stream that results from the encoding process.</source>
          <target state="translated">Opcionalmente, la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto proporciona una marca de orden de bytes (BOM), que es una matriz de bytes que se puede anteponer al principio de la secuencia de bytes resultante del proceso de codificación.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If a UTF-8 encoded byte stream is prefaced with a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF.</source>
          <target state="translated">Si una secuencia de bytes codificada UTF-8 se prologa con una marca de orden de bytes (BOM), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note, however, that the Unicode Standard neither requires nor recommends a BOM in UTF-8 encoded streams.</source>
          <target state="translated">Sin embargo, tenga en cuenta que el estándar Unicode no requiere ni recomienda una marca BOM en UTF-8 codificada secuencias.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la <bpt id="p1">[</bpt>página principal de Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>If the encoder is configured to provide a BOM, you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.</source>
          <target state="translated">Si el codificador está configurado para proporcionar una lista de materiales, puede recuperarlo mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método; en caso contrario, el método devuelve una matriz vacía.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Note that, even if a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> class do not do this automatically.</source>
          <target state="translated">Tenga en cuenta que, aunque un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto está configurado para admitir l. MAT, debe incluir la lista de materiales al principio de la secuencia de bytes codificada según corresponda; los métodos de codificación de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> clase no lo hace automáticamente.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>To enable error detection and to make the class instance more secure, you should call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and set the <ph id="ph2">`throwOnInvalidBytes`</ph> parameter to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Para habilitar la detección de errores y para hacer que la instancia de clase sea más segura, debe llamar a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29&gt;</ph> constructor y establezca el <ph id="ph2">`throwOnInvalidBytes`</ph> parámetro <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>With error detection enabled, a method that detects an invalid sequence of characters or bytes throws an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores habilitada, un método que detecta una secuencia de caracteres o bytes no válida inicia una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>Without error detection, no exception is thrown, and the invalid sequence is generally ignored.</source>
          <target state="translated">Sin detección de errores, se inicia ninguna excepción y, por lo general se omite la secuencia no válida.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The state of a UTF-8 encoded object is not preserved if the object is serialized and deserialized using different .NET Framework versions.</source>
          <target state="translated">No se conserva el estado de un objeto de codificación UTF-8 si el objeto se serializa y deserializa con distintas versiones de .NET Framework.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object to encode a string of Unicode characters and store them in a byte array.</source>
          <target state="translated">En el ejemplo siguiente se usa un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto para codificar una cadena de caracteres Unicode y almacenarlos en una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The Unicode string includes two characters, Pi (U+03A0) and Sigma (U+03A3), that are outside the ASCII character range.</source>
          <target state="translated">La cadena de Unicode incluye dos caracteres, Pi (03A0) y Sigma (U + 03A3), que están fuera del intervalo de caracteres ASCII.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>When the encoded byte array is decoded back to a string, the Pi and Sigma characters are still present.</source>
          <target state="translated">Cuando se descodifica la matriz de bytes codificada en una cadena, los caracteres de Pi y Sigma siguen estando presentes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>The following example uses the same string as the previous example, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM).</source>
          <target state="translated">En el ejemplo siguiente se utiliza la misma cadena que el ejemplo anterior, salvo que escribe los bytes codificados en un archivo y agrega el prefijo de la secuencia de bytes con una marca de orden de bytes (BOM).</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>It then reads the file in two different ways: as a text file by using a <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> object; and as a binary file.</source>
          <target state="translated">A continuación, lee el archivo de dos maneras diferentes: como un archivo de texto mediante un <ph id="ph1">&lt;xref:System.IO.StreamReader&gt;</ph> objeto; y como un archivo binario.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Text.UTF8Encoding">
          <source>As you would expect, in neither case is the BOM included in the newly read string.</source>
          <target state="translated">Tal como se esperaría en ningún caso la marca BOM pertenece a la cadena recién lectura.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>This constructor creates an instance that does not provide a Unicode byte order mark and does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este constructor crea una instancia que no proporciona una marca de orden de bytes Unicode y no produce una excepción cuando se detecta una codificación no válida.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>For security reasons, we recommend that you enable error detection by calling a constructor with a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de seguridad, se recomienda habilitar la detección de errores mediante una llamada a un constructor con un <ph id="ph1">`throwOnInvalidBytes`</ph> parámetro y establece su valor en <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and displays its name.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instancia y se muestra su nombre.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method returns a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que el método <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> devuelve una marca de orden de bytes Unicode; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>A parameter specifies whether to provide a Unicode byte order mark.</source>
          <target state="translated">Un parámetro especifica si se proporciona una marca de orden de bytes Unicode.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>This constructor creates an instance that does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Este constructor crea una instancia que no produce una excepción cuando se detecta una codificación no válida.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting its value to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de seguridad, debe habilitar la detección de errores mediante una llamada a un constructor que incluye un <ph id="ph1">`throwOnInvalidBytes`</ph> parámetro y establece su valor en <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parámetro controla el funcionamiento de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Si <ph id="ph1">`true`</ph>, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-8.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Si <ph id="ph1">`false`</ph>, devuelve una matriz de bytes de longitud cero.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Sin embargo, establecer <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> a <ph id="ph2">`true`</ph> no provoca la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método debe incluir el número de bytes en la lista de materiales en el recuento de bytes.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance and specifies that a Unicode byte order mark prefix should be emitted by the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> de la instancia y especifica que se debería emitir un prefijo de marca de orden de bytes Unicode mediante la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method then returns the Unicode byte order mark prefix.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método, a continuación, devuelve el prefijo de marca de orden de bytes Unicode.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that the <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> method should return a Unicode byte order mark; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que el método <ph id="ph2">&lt;see cref="M:System.Text.UTF8Encoding.GetPreamble" /&gt;</ph> debe devolver una marca de orden de bytes Unicode; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception when an invalid encoding is detected; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para que se produzca una excepción cuando se detecta una codificación no válida; en caso contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Parameters specify whether to provide a Unicode byte order mark and whether to throw an exception when an invalid encoding is detected.</source>
          <target state="translated">Algunos parámetros especifican si se proporciona una marca de orden de bytes Unicode y si debe producirse una excepción cuando se detecta una codificación no válida.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parameter controls the operation of the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> parámetro controla el funcionamiento de la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`true`</ph>, the method returns a byte array containing the Unicode byte order mark (BOM) in UTF-8 format.</source>
          <target state="translated">Si <ph id="ph1">`true`</ph>, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-8.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`false`</ph>, it returns a zero-length byte array.</source>
          <target state="translated">Si <ph id="ph1">`false`</ph>, devuelve una matriz de bytes de longitud cero.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>However, setting <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> to <ph id="ph2">`true`</ph> does not cause the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to prefix the BOM at the beginning of the byte array, nor does it cause the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to include the number of bytes in the BOM in the byte count.</source>
          <target state="translated">Sin embargo, establecer <ph id="ph1">`encoderShouldEmitUTF8Identifier`</ph> a <ph id="ph2">`true`</ph> no provoca la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método debe incluir el número de bytes en la lista de materiales en el recuento de bytes.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnInvalidBytes`</ph> is <ph id="ph2">`true`</ph>, a method that detects an invalid byte sequence throws an <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> exception.</source>
          <target state="translated">Si <ph id="ph1">`throwOnInvalidBytes`</ph> es <ph id="ph2">`true`</ph>, un método que detecta una secuencia de bytes no válida inicia una <ph id="ph3">&lt;xref:System.ArgumentException?displayProperty=nameWithType&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>Otherwise, the method does not throw an exception, and the invalid sequence is ignored.</source>
          <target state="translated">En caso contrario, el método no produce una excepción y se omite la secuencia no válida.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>For security reasons, you should enable error detection by calling a constructor that includes a <ph id="ph1">`throwOnInvalidBytes`</ph> parameter and setting that parameter to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Por motivos de seguridad, debe habilitar la detección de errores mediante una llamada a un constructor que incluye un <ph id="ph1">`throwOnInvalidBytes`</ph> parámetro y establece ese parámetro en <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The following example creates a new <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instance, specifying that the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method should not emit a Unicode byte order mark prefix, and an exception should be thrown when an invalid encoding is detected.</source>
          <target state="translated">En el ejemplo siguiente se crea un nuevo <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instancia especificando que el <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método no debe emitir un prefijo de marca de orden de bytes Unicode y se debe producir una excepción cuando se detecta una codificación no válida.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The behavior of this constructor is compared to the default <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not throw an exception when an invalid encoding is detected.</source>
          <target state="translated">El comportamiento de este constructor se compara con el valor predeterminado <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, que no produce una excepción cuando se detecta una codificación no válida.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)">
          <source>The two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances encode a character array that contains two high surrogates (U+D801 and U+D802) in a row, which is an invalid character sequence; a high surrogate should always be followed by a low surrogate.</source>
          <target state="translated">Los dos <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instancias codifican una matriz de caracteres que contiene dos suplentes alta (U + D801 y D802 + U) en una fila, que es una secuencia de caracteres no válidos; un suplente alto siempre debe ir seguido por un suplente bajo.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">Objeto que se va a comparar con la instancia actual.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Determines whether the specified object is equal to the current <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> object.</source>
          <target state="translated">Determina si el objeto especificado es igual al objeto <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> actual.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="value" /&gt;</ph> is an instance of <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> and is equal to the current object; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="value" /&gt;</ph> es una instancia de <ph id="ph3">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> y es igual al objeto actual; en caso contrario, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are considered equal if all of the following conditions are true:</source>
          <target state="translated">Dos <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos se consideran iguales si se cumplen todas las condiciones siguientes:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects provide the byte order mark, or both do not.</source>
          <target state="translated">Ambos objetos proporcionan la marca de orden de bytes, o ambos no lo hace.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same encoder fallback.</source>
          <target state="translated">Ambos objetos utilizan el mismo codificador reserva.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Both objects use the same decoder fallback.</source>
          <target state="translated">Ambos objetos utilizan la misma reserva del descodificador.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> method to test whether the current <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object is equal to a different <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.Equals%2A&gt;</ph> método para probar si la actual <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> es igual a otro objeto <ph id="ph3">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.Equals(System.Object)">
          <source>Four <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are created and compared and the results of the comparisons are displayed.</source>
          <target state="translated">Cuatro <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos se crean y se comparan y se muestran los resultados de las comparaciones.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of bytes produced by encoding a set of characters.</source>
          <target state="translated">Calcula el número de bytes generado mediante la codificación de un juego de caracteres.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el juego de caracteres que se va a codificar.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Calculates the number of bytes produced by encoding the characters in the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>.</source>
          <target state="translated">Calcula el número de bytes generado al codificar los caracteres del objeto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> especificado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Número de bytes que se generan al codificar los caracteres especificados.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> methods to calculate the maximum and actual number of bytes required to encode a string.</source>
          <target state="translated">El ejemplo siguiente se llama el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29&gt;</ph> métodos para calcular el número real y máximo de bytes necesarios para codificar una cadena.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>It also displays the actual number of bytes required to store a byte stream with a byte order mark.</source>
          <target state="translated">También muestra el número real de bytes necesarios para almacenar una secuencia de bytes con una marca de orden de bytes.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.String)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Puntero al primer carácter que se va a codificar.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</source>
          <target state="translated">Calcula el número de bytes generado mediante la codificación de un juego de caracteres a partir del puntero de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Número de bytes que se generan al codificar los caracteres especificados.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the exact array size required by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método utilizado para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Índice del primer carácter que se va a codificar.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Calculates the number of bytes produced by encoding a set of characters from the specified character array.</source>
          <target state="translated">Calcula el número de bytes generado mediante la codificación de un juego de caracteres de la matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The number of bytes produced by encoding the specified characters.</source>
          <target state="translated">Número de bytes que se generan al codificar los caracteres especificados.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the uses <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, llame a los usos <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The following example populates an array with a Latin uppercase and lowercase characters and calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> method to determine the number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">En el ejemplo siguiente se rellena una matriz con un alfabeto latino en mayúsculas y minúsculas y llama el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> método para determinar el número de bytes necesarios para codificar los caracteres en minúsculas latinos.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It then displays this information along with the total number of bytes needed if a byte order mark is added.</source>
          <target state="translated">A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca de orden de bytes.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>It compares this number with the value returned by the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters.</source>
          <target state="translated">Este número compara con el valor devuelto por la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método, que indica el número máximo de bytes necesarios para codificar los caracteres en minúsculas latinos.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> property is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">La propiedad <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> se establece en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Encodes a set of characters into a sequence of bytes.</source>
          <target state="translated">Codifica un juego de caracteres en una secuencia de bytes.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the first character to encode.</source>
          <target state="translated">Puntero al primer carácter que se va a codificar.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The maximum number of bytes to write.</source>
          <target state="translated">Número máximo de bytes que se pueden escribir.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</source>
          <target state="translated">Codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The actual number of bytes written at the location indicated by <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Número real de bytes escritos en la ubicación indicada por <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> returned by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> devuelto por la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> o <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than the resulting number of bytes.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> es menor que el número resultante de bytes.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The character array containing the set of characters to encode.</source>
          <target state="translated">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Índice del primer carácter que se va a codificar.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Matriz de bytes que contendrá la secuencia de bytes resultante.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified character array into the specified byte array.</source>
          <target state="translated">Codifica un juego de caracteres de la matriz de caracteres determinada en la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Número real de bytes escritos en <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> proporcionada por el <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of characters from a string and stores the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para codificar un intervalo de caracteres de una cadena y almacena los bytes codificados en un intervalo de elementos de una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> o <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> no es un índice válido para <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="chars" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> no tiene suficiente capacidad desde <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> hasta el final de la matriz para alojar los bytes resultantes.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the set of characters to encode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene el juego de caracteres que se va a codificar.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index of the first character to encode.</source>
          <target state="translated">Índice del primer carácter que se va a codificar.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The byte array to contain the resulting sequence of bytes.</source>
          <target state="translated">Matriz de bytes que contendrá la secuencia de bytes resultante.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The index at which to start writing the resulting sequence of bytes.</source>
          <target state="translated">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Encodes a set of characters from the specified <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> into the specified byte array.</source>
          <target state="translated">Codifica un juego de caracteres del objeto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> especificado en la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The actual number of bytes written into <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated">Número real de bytes escritos en <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> proporcionada por el <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.</source>
          <target state="translated">Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to encode a range of elements from a Unicode character array and store the encoded bytes in a range of elements in a byte array.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método para codificar un intervalo de elementos de una matriz de caracteres Unicode y almacenar los bytes codificados en un intervalo de elementos de una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="s" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="s" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> o <ph id="ph3">&lt;paramref name="byteIndex" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> no es un índice válido para <ph id="ph2">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contains an invalid sequence of characters.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="s" /&gt;</ph> contiene una secuencia de caracteres no válida.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> to the end of the array to accommodate the resulting bytes.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> no tiene suficiente capacidad desde <ph id="ph2">&lt;paramref name="byteIndex" /&gt;</ph> hasta el final de la matriz para alojar los bytes resultantes.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Calculates the number of characters produced by decoding a sequence of bytes.</source>
          <target state="translated">Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Puntero al primer byte que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</source>
          <target state="translated">Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir del puntero de bytes especificado.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para almacenar los caracteres resultantes, llame a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, llame a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contiene una secuencia de bytes no válida.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Índice del primer byte que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</source>
          <target state="translated">Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir de la matriz de bytes especificada.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The number of characters produced by decoding the specified sequence of bytes.</source>
          <target state="translated">Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para almacenar los caracteres resultantes, llame a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, llame a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method to return the number of characters produced by decoding a range of elements in a byte array.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método para devolver el número de caracteres generado mediante la descodificación de un intervalo de elementos de una matriz de bytes.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contiene una secuencia de bytes no válida.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="T:System.Text.UTF8Encoding">
          <source>Decodes a sequence of bytes into a set of characters.</source>
          <target state="translated">Descodifica una secuencia de bytes en un conjunto de caracteres.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the first byte to decode.</source>
          <target state="translated">Puntero al primer byte que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A pointer to the location at which to start writing the resulting set of characters.</source>
          <target state="translated">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The maximum number of characters to write.</source>
          <target state="translated">Número máximo de caracteres que se van a escribir.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</source>
          <target state="translated">Descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The actual number of characters written at the location indicated by <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Número real de caracteres escrito en la ubicación indicada por <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para almacenar los caracteres resultantes, llame a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, llame a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se puede quitar mediante una llamada a la <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> object provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use la <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> objeto proporcionado por el <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o la <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> o <ph id="ph2">&lt;paramref name="charCount" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contiene una secuencia de bytes no válida.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than the resulting number of characters.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> es menor que el número de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">requiere plena confianza para el llamador inmediato.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Este miembro no puede usarse por código de confianza parcial o transparente.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Índice del primer byte que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The character array to contain the resulting set of characters.</source>
          <target state="translated">Matriz de caracteres que contendrá el juego de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The index at which to start writing the resulting set of characters.</source>
          <target state="translated">Índice en el que se inicia la escritura del juego de caracteres resultante.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Decodes a sequence of bytes from the specified byte array into the specified character array.</source>
          <target state="translated">Descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The actual number of characters written into <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated">Número real de caracteres escritos en <ph id="ph1">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para almacenar los caracteres resultantes, llame a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>To calculate the maximum array size, call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, llame a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se puede quitar mediante una llamada a la <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> proporcionada por el <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method to decode a range of elements in a byte array and store the result in a character array.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> método para descodificar un intervalo de elementos de una matriz de bytes y almacena el resultado en una matriz de caracteres.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph> or <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> or <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> is less than zero.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="byteIndex" /&gt;</ph>, <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> o <ph id="ph3">&lt;paramref name="charIndex" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> and <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteindex" /&gt;</ph> y <ph id="ph2">&lt;paramref name="byteCount" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> is not a valid index in <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charIndex" /&gt;</ph> no es un índice válido para <ph id="ph2">&lt;paramref name="chars" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contiene una secuencia de bytes no válida.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> does not have enough capacity from <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> to the end of the array to accommodate the resulting characters.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="chars" /&gt;</ph> no tiene suficiente capacidad desde <ph id="ph2">&lt;paramref name="charIndex" /&gt;</ph> hasta el final de la matriz para aloja los caracteres resultantes.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Obtains a decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Obtiene un descodificador que convierte una secuencia de bytes codificada en UTF-8 en una secuencia de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>A decoder that converts a UTF-8 encoded sequence of bytes into a sequence of Unicode characters.</source>
          <target state="translated">Descodificador que convierte una secuencia de bytes codificada en UTF-8 en una secuencia de caracteres Unicode.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> method of this class.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType&gt;</ph> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> método de esta clase.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.</source>
          <target state="translated">Sin embargo, un <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> mantiene la información de estado entre llamadas, de modo que puede descodificar correctamente las secuencias de bytes que abarquen varios bloques.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> también conserva los bytes finales al final de bloques de datos y utiliza los bytes finales en la siguiente operación de descodificación.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Por lo tanto, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.</source>
          <target state="translated">Si está habilitada la detección de errores, es decir, el <ph id="ph1">`throwOnInvalidCharacters`</ph> parámetro del constructor se establece en <ph id="ph2">`true`</ph>, detección de errores también se habilita en el <ph id="ph3">&lt;xref:System.Text.Decoder&gt;</ph> devuelto por este método.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.</source>
          <target state="translated">Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del descodificador no está definido y el procesamiento debe detenerse.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method to obtain a UTF-8 decoder.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método para obtener un descodificador UTF-8.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetDecoder">
          <source>The decoder converts a sequence of bytes into a sequence of characters.</source>
          <target state="translated">El descodificador convierte una secuencia de bytes en una secuencia de caracteres.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Obtains an encoder that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada en UTF-8.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>A <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> that converts a sequence of Unicode characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Text.Encoder" /&gt;</ph> que convierte una secuencia de caracteres Unicode en una secuencia de bytes UTF-8 codificada.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType&gt;</ph> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes, de forma similar a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>However, a <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it can correctly encode character sequences that span blocks.</source>
          <target state="translated">Sin embargo, un <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> mantiene la información de estado entre llamadas, de modo que puede codificar correctamente secuencias de caracteres que abarquen varios bloques.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.Encoder&gt;</ph> también conserva finales caracteres al final de bloques de datos y utiliza los caracteres finales en la siguiente operación de codificación.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block.</source>
          <target state="translated">Por ejemplo, un bloque de datos podría finalizar con un suplente alto sin equivalente y el suplente bajo correspondiente podría estar en el siguiente bloque de datos.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>Therefore, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</source>
          <target state="translated">Por lo tanto, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled, that is, the <ph id="ph1">`throwOnInvalidCharacters`</ph> parameter of the constructor is set to <ph id="ph2">`true`</ph>, error detection is also enabled in the <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> returned by this method.</source>
          <target state="translated">Si está habilitada la detección de errores, es decir, el <ph id="ph1">`throwOnInvalidCharacters`</ph> parámetro del constructor se establece en <ph id="ph2">`true`</ph>, detección de errores también se habilita en el <ph id="ph3">&lt;xref:System.Text.Encoder&gt;</ph> devuelto por este método.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.</source>
          <target state="translated">Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del codificador está definido y el procesamiento debe detenerse.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetEncoder">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method to obtain an encoder to convert a sequence of characters into a UTF-8 encoded sequence of bytes.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> secuencia de bytes codificada de método para obtener un codificador para convertir una secuencia de caracteres en un UTF-8.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Returns the hash code for the current instance.</source>
          <target state="translated">Devuelve el código hash de la instancia actual.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The hash code for the current instance.</source>
          <target state="translated">Código hash de la instancia actual.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> method to return a hash code for <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instances.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetHashCode%2A&gt;</ph> método para devolver un código hash para <ph id="ph2">&lt;xref:System.Text.UTF8Encoding&gt;</ph> instancias.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetHashCode">
          <source>Notice that the hash code returned by this method depends on the constructor used to create the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object.</source>
          <target state="translated">Observe que el código hash devuelto por este método depende el constructor utilizado para crear el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The number of characters to encode.</source>
          <target state="translated">Número de caracteres que se van a codificar.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>Calculates the maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Calcula el número máximo de bytes generado mediante la codificación del número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The maximum number of bytes produced by encoding the specified number of characters.</source>
          <target state="translated">Número máximo de bytes generados al codificar el número de caracteres especificado.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> para almacenar los bytes resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> es un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <ph id="ph2">&lt;xref:System.Text.EncoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Si se elige una acción de reserva con una cadena potencialmente grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> puede devolver valores grandes.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">En la mayoría de los casos, este método devuelve números razonables para cadenas pequeñas.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional de que se supere un búfer más razonable.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Puede que le interese tener en cuenta un enfoque diferente utilizando <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>For example, text in English and many other languages often needs only one UTF-8 byte to represent a character, but the number returned by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has to allow for the possibility that the string to be converted will consist entirely of characters that each require four bytes.</source>
          <target state="translated">Por ejemplo, texto en inglés y en muchos otros lenguajes a menudo necesita solo un byte de UTF-8 para representar un carácter, pero el número devuelto por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> tiene que permitir la posibilidad de que la cadena se convierta conste únicamente de caracteres que cada uno requiere cuatro bytes.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> no tiene ninguna relación con <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</source>
          <target state="translated">Si la aplicación necesita una función similar a usar con <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph>, debería utilizar <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">`GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxByteCount(N)`</ph> no es necesariamente el mismo valor que <ph id="ph2">`N* GetMaxByteCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> method to return the maximum number of bytes required to encode a specified number of characters.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph> método para devolver el número máximo de bytes necesarios para codificar un número especificado de caracteres.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="charCount" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.EncoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.EncoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>Calculates the maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Calcula el número máximo de caracteres generado mediante la descodificación del número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The maximum number of characters produced by decoding the specified number of bytes.</source>
          <target state="translated">Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the exact array size required by <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you call the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño de matriz exacto requerido por <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetChars%2A&gt;</ph> para almacenar los caracteres resultantes, se llama a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>To calculate the maximum array size, you call the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method.</source>
          <target state="translated">Para calcular el tamaño máximo de la matriz, se llama a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> método asigna generalmente menos memoria, mientras que la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método generalmente se ejecuta con mayor rapidez.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> es un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <ph id="ph2">&lt;xref:System.Text.DecoderFallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If a fallback is chosen with a potentially large string, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> can return large values.</source>
          <target state="translated">Si se elige una acción de reserva con una cadena potencialmente grande, <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> puede devolver valores grandes.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>In most cases, this method returns reasonable numbers for small strings.</source>
          <target state="translated">En la mayoría de los casos, este método devuelve números razonables para cadenas pequeñas.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.</source>
          <target state="translated">Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional de que se supere un búfer más razonable.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>You might also want to consider a different approach using <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Puede que le interese tener en cuenta un enfoque diferente utilizando <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetCharCount%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> has no relation to <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> no tiene ninguna relación con <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>If your application needs a similar function to use with <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, it should use <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</source>
          <target state="translated">Si la aplicación necesita una función similar a usar con <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph>, debería utilizar <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetMaxByteCount%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">`GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetMaxCharCount(N)`</ph> no es necesariamente el mismo valor que <ph id="ph2">`N* GetMaxCharCount(1)`</ph>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> method to return the maximum number of characters produced by decoding a specified number of bytes.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetMaxCharCount%2A&gt;</ph> método para devolver el número máximo de caracteres generado mediante la descodificación de un número especificado de bytes.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="byteCount" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>The resulting number of bytes is greater than the maximum number that can be returned as an integer.</source>
          <target state="translated">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Returns a Unicode byte order mark encoded in UTF-8 format, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Devuelve una marca de orden de bytes Unicode codificada en formato UTF-8, si el objeto de codificación <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> está configurado para proporcionarla.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>A byte array containing the Unicode byte order mark, if the <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> encoding object is configured to supply one.</source>
          <target state="translated">Una matriz de bytes que contiene la marca de orden de bytes Unicode, si el objeto de codificación <ph id="ph1">&lt;see cref="T:System.Text.UTF8Encoding" /&gt;</ph> está configurado para proporcionarla.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Otherwise, this method returns a zero-length byte array.</source>
          <target state="translated">En caso contrario, este método devuelve una matriz de bytes de longitud cero.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object can provide a preamble, which is a byte array that can be prefixed to the sequence of bytes that result from the encoding process.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto puede proporcionar un preámbulo, que es una matriz de bytes que se puede anteponer a la secuencia de bytes que son el resultado del proceso de codificación.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Prefacing a sequence of encoded bytes with a byte order mark (code point U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF.</source>
          <target state="translated">Delante de una secuencia de bytes codificados con una marca de orden de bytes (punto de código U+FEFF) ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The Unicode byte order mark (BOM) is serialized as 0xEF 0xBB 0xBF.</source>
          <target state="translated">La marca de orden de bytes Unicode (BOM) se serializa como 0xEF 0xBB 0xBF.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the Unicode Standard neither requires nor recommends the use of a BOM for UTF-8 encoded streams.</source>
          <target state="translated">Tenga en cuenta que el estándar Unicode no requiere ni se recomienda el uso de una marca BOM UTF-8 codificada secuencias.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object whose <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:</source>
          <target state="translated">Puede crear instancias de un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> cuyos <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método devuelve una lista de materiales válida de las maneras siguientes:</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By retrieving the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Recuperando la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objeto devuelto por la <ph id="ph2">&lt;xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>By calling a <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> constructor with a <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> parameter and setting its value set to <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Mediante una llamada a un <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> constructor con un <ph id="ph2">`encoderShouldEmitUTF8Identifier`</ph> parámetro y establece su valor establecido en <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>All other <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects are configured to return an empty array rather than a valid BOM.</source>
          <target state="translated">Todos los demás <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos están configurados para devolver una matriz vacía en lugar de una lista de materiales válido.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The BOM provide nearly certain identification of an encoding for files that otherwise have lost a reference to their encoding, such as untagged or improperly tagged web data or random text files stored when a business did not have international concerns.</source>
          <target state="translated">La lista de materiales proporcionan cierta identificación de una codificación para los archivos que han perdido de lo contrario, una referencia a su codificación, como web sin etiqueta o incorrectamente etiquetado datos o archivos de texto aleatorios almacenados cuando un negocio no tenía intereses internacionales.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Often user problems might be avoided if data is consistently and properly tagged.</source>
          <target state="translated">Problemas de los usuarios a menudo pueden evitarse si los datos se etiquetan de forma coherente y configurado correctamente.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For standards that provide an encoding type, a BOM is somewhat redundant.</source>
          <target state="translated">Estándares que proporcionan un tipo de codificación, una marca BOM es redundante en cierto modo.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>However, it can be used to help a server send the correct encoding header.</source>
          <target state="translated">Sin embargo, se puede utilizar para ayudar a un servidor de enviar el encabezado de codificación correcto.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Alternatively, it can be used as a fallback in case the encoding is otherwise lost.</source>
          <target state="translated">Como alternativa, se puede utilizar como reserva en caso de que la codificación en caso contrario, se pierde.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>There are some disadvantages to using a BOM.</source>
          <target state="translated">Existen algunas desventajas del uso de una lista de materiales.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For example, knowing how to limit the database fields that use a BOM can be difficult.</source>
          <target state="translated">Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una lista de materiales.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.</source>
          <target state="translated">Concatenación de archivos puede ser un problema también, por ejemplo, cuando se combinan los archivos de tal forma que un carácter innecesario puede terminar en el centro de datos.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>In spite of the few disadvantages, however, the use of a BOM is highly recommended.</source>
          <target state="translated">A pesar de los inconvenientes de algunos, sin embargo, el uso de una lista de materiales se recomienda.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id="p1">[</bpt>Unicode home page<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</source>
          <target state="translated">Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la <bpt id="p1">[</bpt>página principal de Unicode<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix the beginning of a stream of encoded bytes with a preamble.</source>
          <target state="translated">Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer el principio de una secuencia de bytes codificados con un preámbulo.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.</source>
          <target state="translated">Tenga en cuenta que el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método no anteponer una marca BOM a una secuencia de bytes codificados; la especificación de una lista de materiales al principio de una secuencia de bytes adecuada es responsabilidad del desarrollador.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to return the Unicode byte order mark encoded in UTF-8 format.</source>
          <target state="translated">En el ejemplo siguiente se usa el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> codificado en formato UTF-8 de marca de orden de método para devolver el byte de Unicode.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Notice that the default constructor for <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> does not provide a preamble.</source>
          <target state="translated">Tenga en cuenta que el constructor predeterminado para <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> no proporciona un preámbulo.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>The following example instantiates two <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objects, the first by calling the parameterless <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, which does not provide a BOM, and the second by calling the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> constructor with its <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> argument set to <ph id="ph5">`true`</ph>.</source>
          <target state="translated">En el ejemplo siguiente se crean instancias de dos <ph id="ph1">&lt;xref:System.Text.UTF8Encoding&gt;</ph> objetos, la primera mediante una llamada sin parámetros <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.%23ctor&gt;</ph> constructor, que no proporciona una lista de materiales y el segundo mediante una llamada a la <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29&gt;</ph> constructor con su <ph id="ph4">`encoderShouldEmitUTF8Identifier`</ph> establecido en <ph id="ph5">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>It then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to write the BOM to a file before writing a UF8-encoded string.</source>
          <target state="translated">A continuación, llama el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método para escribir la lista de materiales en un archivo antes de escribir una cadena codificada en UF8.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>As the console output from the example shows, the file that saves the bytes from the second encoder has three more bytes than the first.</source>
          <target state="translated">Como se muestra en la salida del ejemplo de consola, el archivo que guarda los bytes desde el codificador de segundo tiene tres bytes más que el primer parámetro.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>You can also compare the files by using the <ph id="ph1">`fc`</ph> command in a console window, or you can inspect the files in a text editor that includes a Hex View mode.</source>
          <target state="translated">También puede comparar los archivos mediante el <ph id="ph1">`fc`</ph> comando en una ventana de consola, o bien puede inspeccionar los archivos en un editor de texto que incluye un modo de vista hexadecimal.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetPreamble">
          <source>Note that when the file is opened in an editor that supports UTF-8, the BOM is not displayed.</source>
          <target state="translated">Tenga en cuenta que cuando se abre el archivo en un editor que admite UTF-8, no se muestra la lista de materiales.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The byte array containing the sequence of bytes to decode.</source>
          <target state="translated">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The index of the first byte to decode.</source>
          <target state="translated">Índice del primer byte que se va a descodificar.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The number of bytes to decode.</source>
          <target state="translated">Número de bytes que se van a descodificar.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Decodes a range of bytes from a byte array into a string.</source>
          <target state="translated">Descodifica un intervalo de bytes de una matriz de bytes en una cadena.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> containing the results of decoding the specified sequence of bytes.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>With error detection, an invalid sequence causes this method to throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> exception.</source>
          <target state="translated">Con la detección de errores, una secuencia no válida hace que este método producir una <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph> excepción.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Without error detection, invalid sequences are ignored, and no exception is thrown.</source>
          <target state="translated">Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.</source>
          <target state="translated">Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>You can remove it by calling the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Se puede quitar mediante una llamada a la <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Data to be converted, such as data read from a stream, might be available only in sequential blocks.</source>
          <target state="translated">Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, use the <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> method or the <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> method, respectively.</source>
          <target state="translated">En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <ph id="ph1">&lt;xref:System.Text.Decoder&gt;</ph> o <ph id="ph2">&lt;xref:System.Text.Encoder&gt;</ph> proporcionada por el <ph id="ph3">&lt;xref:System.Text.UTF8Encoding.GetDecoder%2A&gt;</ph> método o el <ph id="ph4">&lt;xref:System.Text.UTF8Encoding.GetEncoder%2A&gt;</ph> método, respectivamente.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The following example initializes an array by calling the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM).</source>
          <target state="translated">En el ejemplo siguiente se inicializa una matriz mediante una llamada a la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetByteCount%2A&gt;</ph> método para determinar exactamente cuántos bytes son necesarios para una cadena codificada y, a continuación, agregar el tamaño de la marca de orden de bytes (BOM).</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> method to store the BOM to the array before calling the <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> method to store the encoded bytes to the array.</source>
          <target state="translated">El ejemplo, a continuación, se llama la <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetPreamble%2A&gt;</ph> método utilizado para almacenar la lista de materiales a la matriz antes de llamar a la <ph id="ph2">&lt;xref:System.Text.UTF8Encoding.GetBytes%2A&gt;</ph> método utilizado para almacenar los bytes codificados en la matriz.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>The example then calls the <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> method to decode the string.</source>
          <target state="translated">El ejemplo, a continuación, se llama el <ph id="ph1">&lt;xref:System.Text.UTF8Encoding.GetString%2A&gt;</ph> método para descodificar la cadena.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Note that in this case the decoded string differs from the original string, since it begins with a 16-bit byte order mark U+FFFD.</source>
          <target state="translated">Tenga en cuenta que en este caso la cadena descodificada difiere de la cadena original, ya que comienza con una marca de orden de bytes de 16 bits U+FFFD.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character "?".</source>
          <target state="translated">Esto significa que las dos cadenas comparará diferente, y que, si la cadena es la salida, se mostrará la lista de materiales como el carácter de reemplazo "?".</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>To remove the BOM at the beginning of the string, you can call the <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para quitar la marca BOM al principio de la cadena, puede llamar a la <ph id="ph1">&lt;xref:System.String.TrimStart%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> or <ph id="ph2">&lt;paramref name="count" /&gt;</ph> is less than zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> o <ph id="ph2">&lt;paramref name="count" /&gt;</ph> es menor que cero.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-or-</source>
          <target state="translated">O bien</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="index" /&gt;</ph> and <ph id="ph2">&lt;paramref name="count" /&gt;</ph> do not denote a valid range in <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="index" /&gt;</ph> y <ph id="ph2">&lt;paramref name="count" /&gt;</ph> no denotan un intervalo válido en <ph id="ph3">&lt;paramref name="bytes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>Error detection is enabled, and <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contains an invalid sequence of bytes.</source>
          <target state="translated">Está habilitada la detección de errores, y <ph id="ph1">&lt;paramref name="bytes" /&gt;</ph> contiene una secuencia de bytes no válida.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>A fallback occurred (see <bpt id="p1">[</bpt>Character Encoding in the .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)</source>
          <target state="translated">Se ha producido una acción de reserva (vea <bpt id="p1">[</bpt>Codificación de caracteres en .NET Framework<ept id="p1">](~/docs/standard/base-types/character-encoding.md)</ept> para obtener una explicación completa).</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source>-and-</source>
          <target state="translated">- y -</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;see cref="P:System.Text.Encoding.DecoderFallback" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="T:System.Text.DecoderExceptionFallback" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>