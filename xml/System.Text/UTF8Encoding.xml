<Type Name="UTF8Encoding" FullName="System.Text.UTF8Encoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c200a67bc75e1bfe3c6bbe71ec68fec34b1455fc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30531449" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UTF8Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UTF8Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF8Encoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UTF8Encoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UTF8Encoding : System::Text::Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una codificación UTF-8 de caracteres Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes. La descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode.  
  
 UTF-8 es una codificación que Unicode representa cada punto de código como una secuencia de uno a cuatro bytes. A diferencia de las codificaciones UTF-16 y UTF-32, la codificación UTF-8 no requieren "endian"; el esquema de codificación es el mismo independientemente de si el procesador es big-endian o little-endian. <xref:System.Text.UTF8Encoding> corresponde a la página de códigos 65001 de Windows. Para obtener más información acerca de las codificaciones UTF y otras codificaciones admitidas por <xref:System.Text>, consulte [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Puede crear instancias de un <xref:System.Text.UTF8Encoding> objeto en una de varias maneras, dependiendo de si desea que se proporciona una marca de orden de bytes (BOM) y si desea habilitar la detección de errores. En la tabla siguiente se enumera los constructores y los <xref:System.Text.Encoding> propiedades que devuelven un <xref:System.Text.UTF8Encoding> objeto.  
  
|Miembro|BOM|Detección de errores|  
|------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType>|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF8Encoding.%23ctor?displayProperty=nameWithType>|No|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29?displayProperty=nameWithType>|Configurable|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|  
  
 El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.UTF8Encoding.GetBytes%2A> método realiza la codificación real.  
  
 Del mismo modo, el <xref:System.Text.UTF8Encoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.UTF8Encoding.GetChars%2A> y <xref:System.Text.UTF8Encoding.GetString%2A> métodos realizan la descodificación real.  
  
 Para un codificador o descodificador que es capaz de guardar información de estado cuando la codificación o descodificación de datos que abarca varios bloques (como las cadenas de caracteres de 1 millón se codifica en segmentos de carácter de 100.000), use la <xref:System.Text.UTF8Encoding.GetEncoder%2A> y <xref:System.Text.UTF8Encoding.GetDecoder%2A> propiedades, respectivamente.  
  
 Opcionalmente, la <xref:System.Text.UTF8Encoding> objeto proporciona una marca de orden de bytes (BOM), que es una matriz de bytes que se puede anteponer al principio de la secuencia de bytes resultante del proceso de codificación. Si una secuencia de bytes codificada UTF-8 se prologa con una marca de orden de bytes (BOM), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF. Sin embargo, tenga en cuenta que el estándar Unicode no requiere ni recomienda una marca BOM en UTF-8 codificada secuencias. Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la [página principal de Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Si el codificador está configurado para proporcionar una lista de materiales, puede recuperarlo mediante una llamada a la <xref:System.Text.UTF8Encoding.GetPreamble%2A> método; en caso contrario, el método devuelve una matriz vacía. Tenga en cuenta que, aunque un <xref:System.Text.UTF8Encoding> objeto está configurado para admitir l. MAT, debe incluir la lista de materiales al principio de la secuencia de bytes codificada según corresponda; los métodos de codificación de la <xref:System.Text.UTF8Encoding> clase no lo hace automáticamente.  
  
> [!NOTE]
>  Para habilitar la detección de errores y para hacer que la instancia de clase sea más segura, debe llamar a la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> constructor y establezca el `throwOnInvalidBytes` parámetro `true`. Con la detección de errores habilitada, un método que detecta una secuencia de caracteres o bytes no válida inicia una <xref:System.ArgumentException> excepción. Sin detección de errores, se inicia ninguna excepción y, por lo general se omite la secuencia no válida.  
  
> [!NOTE]
>  No se conserva el estado de un objeto de codificación UTF-8 si el objeto se serializa y deserializa con distintas versiones de .NET Framework.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa un <xref:System.Text.UTF8Encoding> objeto para codificar una cadena de caracteres Unicode y almacenarlos en una matriz de bytes. La cadena de Unicode incluye dos caracteres, Pi (03A0) y Sigma (U + 03A3), que están fuera del intervalo de caracteres ASCII. Cuando se descodifica la matriz de bytes codificada en una cadena, los caracteres de Pi y Sigma siguen estando presentes.  
  
 [!code-cpp[System.Text.UTF8Encoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UTF8Encoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/snippet.vb#1)]  
  
 En el ejemplo siguiente se utiliza la misma cadena que el ejemplo anterior, salvo que escribe los bytes codificados en un archivo y agrega el prefijo de la secuencia de bytes con una marca de orden de bytes (BOM). A continuación, lee el archivo de dos maneras diferentes: como un archivo de texto mediante un <xref:System.IO.StreamReader> objeto; y como un archivo binario. Tal como se esperaría en ningún caso la marca BOM pertenece a la cadena recién lectura.  
  
 [!code-csharp[System.Text.UTF8Encoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UTF8Encoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.Encoder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF8Encoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF8Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que no proporciona una marca de orden de bytes Unicode y no produce una excepción cuando se detecta una codificación no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, se recomienda habilitar la detección de errores mediante una llamada a un constructor con un `throwOnInvalidBytes` parámetro y establece su valor en `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Text.UTF8Encoding> instancia y se muestra su nombre.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor1 Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          Es <see langword="true" /> para especificar que el método <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> devuelve una marca de orden de bytes Unicode; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF8Encoding" />. Un parámetro especifica si se proporciona una marca de orden de bytes Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que no produce una excepción cuando se detecta una codificación no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, debe habilitar la detección de errores mediante una llamada a un constructor que incluye un `throwOnInvalidBytes` parámetro y establece su valor en `true`.  
  
 El `encoderShouldEmitUTF8Identifier` parámetro controla el funcionamiento de la <xref:System.Text.UTF8Encoding.GetPreamble%2A> método. Si `true`, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-8.  Si `false`, devuelve una matriz de bytes de longitud cero. Sin embargo, establecer `encoderShouldEmitUTF8Identifier` a `true` no provoca la <xref:System.Text.UTF8Encoding.GetBytes%2A> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <xref:System.Text.UTF8Encoding.GetByteCount%2A> método debe incluir el número de bytes en la lista de materiales en el recuento de bytes.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Text.UTF8Encoding> de la instancia y especifica que se debería emitir un prefijo de marca de orden de bytes Unicode mediante la <xref:System.Text.UTF8Encoding.GetPreamble%2A> método. El <xref:System.Text.UTF8Encoding.GetPreamble%2A> método, a continuación, devuelve el prefijo de marca de orden de bytes Unicode.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CPP/ctor-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/CS/ctor-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor2 Example/VB/ctor-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF8Encoding (bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (encoderShouldEmitUTF8Identifier As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="encoderShouldEmitUTF8Identifier" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="encoderShouldEmitUTF8Identifier">
          Es <see langword="true" /> para especificar que el método <see cref="M:System.Text.UTF8Encoding.GetPreamble" /> debe devolver una marca de orden de bytes Unicode; en caso contrario, es <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          Es <see langword="true" /> para que se produzca una excepción cuando se detecta una codificación no válida; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UTF8Encoding" />. Algunos parámetros especifican si se proporciona una marca de orden de bytes Unicode y si debe producirse una excepción cuando se detecta una codificación no válida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `encoderShouldEmitUTF8Identifier` parámetro controla el funcionamiento de la <xref:System.Text.UTF8Encoding.GetPreamble%2A> método. Si `true`, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-8.  Si `false`, devuelve una matriz de bytes de longitud cero. Sin embargo, establecer `encoderShouldEmitUTF8Identifier` a `true` no provoca la <xref:System.Text.UTF8Encoding.GetBytes%2A> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <xref:System.Text.UTF8Encoding.GetByteCount%2A> método debe incluir el número de bytes en la lista de materiales en el recuento de bytes.  
  
 Si `throwOnInvalidBytes` es `true`, un método que detecta una secuencia de bytes no válida inicia una <xref:System.ArgumentException?displayProperty=nameWithType> excepción. En caso contrario, el método no produce una excepción y se omite la secuencia no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, debe habilitar la detección de errores mediante una llamada a un constructor que incluye un `throwOnInvalidBytes` parámetro y establece ese parámetro en `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Text.UTF8Encoding> instancia especificando que el <xref:System.Text.UTF8Encoding.GetPreamble%2A> método no debe emitir un prefijo de marca de orden de bytes Unicode y se debe producir una excepción cuando se detecta una codificación no válida. El comportamiento de este constructor se compara con el valor predeterminado <xref:System.Text.UTF8Encoding.%23ctor> constructor, que no produce una excepción cuando se detecta una codificación no válida. Los dos <xref:System.Text.UTF8Encoding> instancias codifican una matriz de caracteres que contiene dos suplentes alta (U + D801 y D802 + U) en una fila, que es una secuencia de caracteres no válidos; un suplente alto siempre debe ir seguido por un suplente bajo.  
  
 [!code-cpp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.ctor3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.ctor3 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con la instancia actual.</param>
        <summary>Determina si el objeto especificado es igual al objeto <see cref="T:System.Text.UTF8Encoding" /> actual.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> es una instancia de <see cref="T:System.Text.UTF8Encoding" /> y es igual al objeto actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos <xref:System.Text.UTF8Encoding> objetos se consideran iguales si se cumplen todas las condiciones siguientes:  
  
-   Ambos objetos proporcionan la marca de orden de bytes, o ambos no lo hace.  
  
-   Ambos objetos utilizan el mismo codificador reserva.  
  
-   Ambos objetos utilizan la misma reserva del descodificador.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.Equals%2A> método para probar si la actual <xref:System.Text.UTF8Encoding> es igual a otro objeto <xref:System.Text.UTF8Encoding> objeto. Cuatro <xref:System.Text.UTF8Encoding> objetos se crean y se comparan y se muestran los resultados de las comparaciones.  
  
 [!code-cpp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CPP/equals-object.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/CS/equals-object.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.Equals Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.Equals Example/VB/equals-object.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UTF8Encoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ chars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="chars">
          <see cref="T:System.String" /> que contiene el juego de caracteres que se va a codificar.</param>
        <summary>Calcula el número de bytes generado al codificar los caracteres del objeto <see cref="T:System.String" /> especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> y <xref:System.Text.UTF8Encoding.GetByteCount%28System.String%29> métodos para calcular el número real y máximo de bytes necesarios para codificar una cadena. También muestra el número real de bytes necesarios para almacenar una secuencia de bytes con una marca de orden de bytes.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres a partir del puntero de caracteres especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por la <xref:System.Text.UTF8Encoding.GetBytes%2A> método utilizado para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, llame a los usos <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se rellena una matriz con un alfabeto latino en mayúsculas y minúsculas y llama el <xref:System.Text.UTF8Encoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar el número de bytes necesarios para codificar los caracteres en minúsculas latinos. A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca de orden de bytes. Este número compara con el valor devuelto por la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método, que indica el número máximo de bytes necesarios para codificar los caracteres en minúsculas latinos.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UTF8Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 La propiedad <see cref="P:System.Text.Encoding.EncoderFallback" /> se establece en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <summary>Codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> devuelto por la <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o el <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF8Encoding.GetBytes%2A> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
 O bien  
  
 El valor de <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres de la matriz de caracteres determinada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o el <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF8Encoding.GetBytes%2A> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetBytes%2A> método para codificar un intervalo de caracteres de una cadena y almacena los bytes codificados en un intervalo de elementos de una matriz de bytes.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
 O bien  
  
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
 O bien  
  
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">
          <see cref="T:System.String" /> que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres del objeto <see cref="T:System.String" /> especificado en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o el <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
 Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo al principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UTF8Encoding.GetBytes%2A> método no anteponer un preámbulo al principio de una secuencia de bytes codificadas.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetBytes%2A> método para codificar un intervalo de elementos de una matriz de caracteres Unicode y almacenar los bytes codificados en un intervalo de elementos de una matriz de bytes.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
 O bien  
  
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="s" /> contiene una secuencia de caracteres no válida.  
  
 O bien  
  
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir del puntero de bytes especificado.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF8Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF8Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF8Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF8Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetCharCount%2A> método para devolver el número de caracteres generado mediante la descodificación de un intervalo de elementos de una matriz de bytes.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UTF8Encoding.GetChars" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Descodifica una secuencia de bytes en un conjunto de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <summary>Descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</summary>
        <returns>Número real de caracteres escrito en la ubicación indicada por <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF8Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF8Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Se puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use la <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o la <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
 O bien  
  
 El valor de <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetChars%2A> para almacenar los caracteres resultantes, llame a la <xref:System.Text.UTF8Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF8Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Se puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o el <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetChars%2A> método para descodificar un intervalo de elementos de una matriz de bytes y almacena el resultado en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
 O bien  
  
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
 O bien  
  
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
 O bien  
  
 <paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un descodificador que convierte una secuencia de bytes codificada en UTF-8 en una secuencia de caracteres Unicode.</summary>
        <returns>Descodificador que convierte una secuencia de bytes codificada en UTF-8 en una secuencia de caracteres Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <xref:System.Text.UTF8Encoding.GetChars%2A> método de esta clase. Sin embargo, un <xref:System.Text.Decoder> mantiene la información de estado entre llamadas, de modo que puede descodificar correctamente las secuencias de bytes que abarquen varios bloques. El <xref:System.Text.Decoder> también conserva los bytes finales al final de bloques de datos y utiliza los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.UTF8Encoding.GetDecoder%2A> y <xref:System.Text.UTF8Encoding.GetEncoder%2A> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidCharacters` parámetro del constructor se establece en `true`, detección de errores también se habilita en el <xref:System.Text.Decoder> devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del descodificador no está definido y el procesamiento debe detenerse.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método para obtener un descodificador UTF-8. El descodificador convierte una secuencia de bytes en una secuencia de caracteres.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CPP/getdecoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/CS/getdecoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetDecoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetDecoder Example/VB/getdecoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada en UTF-8.</summary>
        <returns>Objeto <see cref="T:System.Text.Encoder" /> que convierte una secuencia de caracteres Unicode en una secuencia de bytes UTF-8 codificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes, de forma similar a la <xref:System.Text.UTF8Encoding.GetBytes%2A> método. Sin embargo, un <xref:System.Text.Encoder> mantiene la información de estado entre llamadas, de modo que puede codificar correctamente secuencias de caracteres que abarquen varios bloques. El <xref:System.Text.Encoder> también conserva finales caracteres al final de bloques de datos y utiliza los caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto sin equivalente y el suplente bajo correspondiente podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.UTF8Encoding.GetDecoder%2A> y <xref:System.Text.UTF8Encoding.GetEncoder%2A> son útiles para transmisiones en red y operaciones con archivos, dado que estas operaciones tratan a menudo con bloques de datos en lugar de un flujo de datos completo.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidCharacters` parámetro del constructor se establece en `true`, detección de errores también se habilita en el <xref:System.Text.Encoder> devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del codificador está definido y el procesamiento debe detenerse.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetEncoder%2A> secuencia de bytes codificada de método para obtener un codificador para convertir una secuencia de caracteres en un UTF-8.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CPP/getencoder-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/CS/getencoder-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetEncoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetEncoder Example/VB/getencoder-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de la instancia actual.</summary>
        <returns>Código hash de la instancia actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetHashCode%2A> método para devolver un código hash para <xref:System.Text.UTF8Encoding> instancias. Observe que el código hash devuelto por este método depende el constructor utilizado para crear el <xref:System.Text.UTF8Encoding> objeto.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CPP/gethashcode-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/CS/gethashcode-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetHashCode Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetHashCode Example/VB/gethashcode-.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número máximo de bytes generado mediante la codificación del número de caracteres especificado.</summary>
        <returns>Número máximo de bytes generados al codificar el número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetBytes%2A> para almacenar los bytes resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método. El <xref:System.Text.UTF8Encoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> es un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.EncoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> puede devolver valores grandes.  
  
 En la mayoría de los casos, este método devuelve números razonables para cadenas pequeñas. Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional de que se supere un búfer más razonable. Puede que le interese tener en cuenta un enfoque diferente utilizando <xref:System.Text.UTF8Encoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>. Por ejemplo, texto en inglés y en muchos otros lenguajes a menudo necesita solo un byte de UTF-8 para representar un carácter, pero el número devuelto por <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> tiene que permitir la posibilidad de que la cadena se convierta conste únicamente de caracteres que cada uno requiere cuatro bytes.  
  
 <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> no tiene ninguna relación con <xref:System.Text.UTF8Encoding.GetChars%2A>. Si la aplicación necesita una función similar a usar con <xref:System.Text.UTF8Encoding.GetChars%2A>, debería utilizar <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` no es necesariamente el mismo valor que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A> método para devolver el número máximo de bytes necesarios para codificar un número especificado de caracteres.  
  
 [!code-cpp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.utf8encoding.getmaxbytecount example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> es menor que cero.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número máximo de caracteres generado mediante la descodificación del número de bytes especificado.</summary>
        <returns>Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño de matriz exacto requerido por <xref:System.Text.UTF8Encoding.GetChars%2A> para almacenar los caracteres resultantes, se llama a la <xref:System.Text.UTF8Encoding.GetCharCount%2A> método. Para calcular el tamaño máximo de la matriz, se llama a la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método. El <xref:System.Text.UTF8Encoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que la <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> es un número más desfavorable, incluido el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.DecoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> puede devolver valores grandes.  
  
 En la mayoría de los casos, este método devuelve números razonables para cadenas pequeñas. Para cadenas de gran tamaño, tendrá que elegir entre usar búferes de grandes tamaño y detectar errores en el caso excepcional de que se supere un búfer más razonable.  Puede que le interese tener en cuenta un enfoque diferente utilizando <xref:System.Text.UTF8Encoding.GetCharCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> no tiene ninguna relación con <xref:System.Text.UTF8Encoding.GetBytes%2A>. Si la aplicación necesita una función similar a usar con <xref:System.Text.UTF8Encoding.GetBytes%2A>, debería utilizar <xref:System.Text.UTF8Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` no es necesariamente el mismo valor que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetMaxCharCount%2A> método para devolver el número máximo de caracteres generado mediante la descodificación de un número especificado de bytes.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> es menor que cero.  
  
 O bien  
  
 El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una marca de orden de bytes Unicode codificada en formato UTF-8, si el objeto de codificación <see cref="T:System.Text.UTF8Encoding" /> está configurado para proporcionarla.</summary>
        <returns>Una matriz de bytes que contiene la marca de orden de bytes Unicode, si el objeto de codificación <see cref="T:System.Text.UTF8Encoding" /> está configurado para proporcionarla. En caso contrario, este método devuelve una matriz de bytes de longitud cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UTF8Encoding> objeto puede proporcionar un preámbulo, que es una matriz de bytes que se puede anteponer a la secuencia de bytes que son el resultado del proceso de codificación. Delante de una secuencia de bytes codificados con una marca de orden de bytes (punto de código U+FEFF) ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF. La marca de orden de bytes Unicode (BOM) se serializa como 0xEF 0xBB 0xBF. Tenga en cuenta que el estándar Unicode no requiere ni se recomienda el uso de una marca BOM UTF-8 codificada secuencias.  
  
 Puede crear instancias de un <xref:System.Text.UTF8Encoding> cuyos <xref:System.Text.UTF8Encoding.GetPreamble%2A> método devuelve una lista de materiales válida de las maneras siguientes:  
  
-   Recuperando la <xref:System.Text.UTF8Encoding> objeto devuelto por la <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> propiedad.  
  
-   Mediante una llamada a un <xref:System.Text.UTF8Encoding> constructor con un `encoderShouldEmitUTF8Identifier` parámetro y establece su valor establecido en `true`.  
  
 Todos los demás <xref:System.Text.UTF8Encoding> objetos están configurados para devolver una matriz vacía en lugar de una lista de materiales válido.  
  
 La lista de materiales proporcionan cierta identificación de una codificación para los archivos que han perdido de lo contrario, una referencia a su codificación, como web sin etiqueta o incorrectamente etiquetado datos o archivos de texto aleatorios almacenados cuando un negocio no tenía intereses internacionales. Problemas de los usuarios a menudo pueden evitarse si los datos se etiquetan de forma coherente y configurado correctamente.  
  
 Estándares que proporcionan un tipo de codificación, una marca BOM es redundante en cierto modo. Sin embargo, se puede utilizar para ayudar a un servidor de enviar el encabezado de codificación correcto. Como alternativa, se puede utilizar como reserva en caso de que la codificación en caso contrario, se pierde.  
  
 Existen algunas desventajas del uso de una lista de materiales. Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una lista de materiales. Concatenación de archivos puede ser un problema también, por ejemplo, cuando se combinan los archivos de tal forma que un carácter innecesario puede terminar en el centro de datos. A pesar de los inconvenientes de algunos, sin embargo, el uso de una lista de materiales se recomienda.  
  
 Para obtener más información sobre el orden de bytes y la marca de orden de bytes, vea el estándar Unicode en la [página principal de Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para asegurarse de que los bytes codificados se descodifiquen de forma apropiada cuando se guardan como un archivo o como una secuencia, se puede anteponer el principio de una secuencia de bytes codificados con un preámbulo. Tenga en cuenta que el <xref:System.Text.UTF8Encoding.GetBytes%2A> método no anteponer una marca BOM a una secuencia de bytes codificados; la especificación de una lista de materiales al principio de una secuencia de bytes adecuada es responsabilidad del desarrollador.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Text.UTF8Encoding.GetPreamble%2A> codificado en formato UTF-8 de marca de orden de método para devolver el byte de Unicode. Tenga en cuenta que el constructor predeterminado para <xref:System.Text.UTF8Encoding> no proporciona un preámbulo.  
  
 [!code-cpp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF8Encoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 En el ejemplo siguiente se crean instancias de dos <xref:System.Text.UTF8Encoding> objetos, la primera mediante una llamada sin parámetros <xref:System.Text.UTF8Encoding.%23ctor> constructor, que no proporciona una lista de materiales y el segundo mediante una llamada a la <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%29> constructor con su `encoderShouldEmitUTF8Identifier` establecido en `true`. A continuación, llama el <xref:System.Text.UTF8Encoding.GetPreamble%2A> método para escribir la lista de materiales en un archivo antes de escribir una cadena codificada en UF8. Como se muestra en la salida del ejemplo de consola, el archivo que guarda los bytes desde el codificador de segundo tiene tres bytes más que el primer parámetro.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/cs/getpreamble1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getpreamble/vb/getpreamble1.vb#1)]  
  
 También puede comparar los archivos mediante el `fc` comando en una ventana de consola, o bien puede inspeccionar los archivos en un editor de texto que incluye un modo de vista hexadecimal. Tenga en cuenta que cuando se abre el archivo en un editor que admite UTF-8, no se muestra la lista de materiales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF8Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Descodifica un intervalo de bytes de una matriz de bytes en una cadena.</summary>
        <returns>Objeto <see cref="T:System.String" /> que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException> excepción. Sin detección de errores, se omiten las secuencias no válidas y se inicia ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y un método de un tipo compatible con BOM no devolvió la matriz de bytes, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Se puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que se va a convertir, como los datos leídos de una secuencia, podrían estar disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, use el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UTF8Encoding.GetDecoder%2A> método o el <xref:System.Text.UTF8Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicializa una matriz mediante una llamada a la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método para determinar exactamente cuántos bytes son necesarios para una cadena codificada y, a continuación, agregar el tamaño de la marca de orden de bytes (BOM). El ejemplo, a continuación, se llama la <xref:System.Text.UTF8Encoding.GetPreamble%2A> método utilizado para almacenar la lista de materiales a la matriz antes de llamar a la <xref:System.Text.UTF8Encoding.GetBytes%2A> método utilizado para almacenar los bytes codificados en la matriz. El ejemplo, a continuación, se llama el <xref:System.Text.UTF8Encoding.GetString%2A> método para descodificar la cadena.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Tenga en cuenta que en este caso la cadena descodificada difiere de la cadena original, ya que comienza con una marca de orden de bytes de 16 bits U+FFFD. Esto significa que las dos cadenas comparará diferente, y que, si la cadena es la salida, se mostrará la lista de materiales como el carácter de reemplazo "?". Para quitar la marca BOM al principio de la cadena, puede llamar a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
 O bien  
  
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa).  
  
 - y -  
  
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetDecoder" />
        <altmember cref="M:System.Text.UTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UTF8Encoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>