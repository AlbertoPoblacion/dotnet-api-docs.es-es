<Type Name="UnicodeEncoding" FullName="System.Text.UnicodeEncoding">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d1aa85b04a5602e384614a8d429b6d22f3d9ee9e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52253162" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UnicodeEncoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit UnicodeEncoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UnicodeEncoding" />
  <TypeSignature Language="VB.NET" Value="Public Class UnicodeEncoding&#xA;Inherits Encoding" />
  <TypeSignature Language="C++ CLI" Value="public ref class UnicodeEncoding : System::Text::Encoding" />
  <TypeSignature Language="F#" Value="type UnicodeEncoding = class&#xA;    inherit Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una codificación UTF-16 de caracteres Unicode.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificar es el proceso de transformar un conjunto de caracteres Unicode en una secuencia de bytes. La descodificación es el proceso de transformar una secuencia de bytes codificados en un conjunto de caracteres Unicode.  
  
 El [estándar Unicode](https://go.microsoft.com/fwlink/?linkid=37123) asigna un punto de código (un número) a cada carácter en todos los scripts admitidos. Un formato de transformación Unicode (UTF) es una manera de codificar ese punto de código. El [estándar Unicode](https://go.microsoft.com/fwlink/?linkid=37123) usa las siguientes codificaciones UTF:  
  
-   UTF-8, que representa cada punto de código como una secuencia de uno a cuatro bytes.  
  
-   UTF-16, que representa cada punto de código como una secuencia de uno o dos enteros de 16 bits.  
  
-   UTF-32, que representa cada punto de código como un entero de 32 bits.  
  
 Para obtener más información acerca de las codificaciones UTF y otras codificaciones admitidas por <xref:System.Text>, consulte [codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 La <xref:System.Text.UnicodeEncoding> clase representa una codificación UTF-16. El codificador puede usar en cualquier orden de bytes big endian (byte más significativo primero) o el orden de bytes endian little (byte menos significativo primero). Por ejemplo, la letra mayúscula latina (punto de código u+0041) se serializa como sigue (en hexadecimal):  
  
-   Orden de bytes big endian: 00 00 00 41  
  
-   Orden de bytes endian little: 41 00 00 00  
  
 Es normalmente más eficaz para almacenar caracteres Unicode mediante el orden de bytes nativo de una plataforma concreta. Por ejemplo, es mejor utilizar el orden de bytes endian little en plataformas little-endian, como equipos Intel. La <xref:System.Text.UnicodeEncoding> clase corresponde a las páginas de códigos 1200 (orden de bytes endian little) y 1201 (orden de bytes big endian) de Windows. Puede determinar los "modos endian" de una arquitectura concreta mediante una llamada a la <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> método.  
  
 Opcionalmente, el <xref:System.Text.UnicodeEncoding> objeto proporciona una marca de orden de bytes (BOM), que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Si el preámbulo contiene una marca de orden de bytes (BOM), ayudará al descodificador a determinar el orden de bytes y el formato de transformación o UTF.  
  
 Si el <xref:System.Text.UnicodeEncoding> instancia está configurada para proporcionar una lista de materiales, puede recuperarlo mediante una llamada a la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método; en caso contrario, el método devuelve una matriz vacía. Tenga en cuenta que, incluso si un <xref:System.Text.UnicodeEncoding> objeto está configurado para admitir l. MAT, debe incluir la marca BOM al principio de la secuencia de bytes codificada según corresponda; los métodos de codificación de la <xref:System.Text.UnicodeEncoding> clase no lo hace automáticamente.  
  
 Para habilitar la detección de errores y hacer que la instancia de clase sea más segura, debe crear una instancia un <xref:System.Text.UnicodeEncoding> objeto mediante una llamada a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidBytes` argumento `true`. Con la detección de errores, un método que detecta una secuencia de caracteres o bytes no válida inicia una <xref:System.ArgumentException>. Sin detección de errores, se produce ninguna excepción y, por lo general se omite la secuencia no válida.  
  
 Puede crear instancias de un <xref:System.Text.UnicodeEncoding> objetos de varias maneras, dependiendo de si desea que se proporciona una marca de orden de bytes (BOM), si desea que la codificación big endian o little-endian y si desea habilitar la detección de errores. La siguiente tabla se enumeran los <xref:System.Text.UnicodeEncoding> constructores y el <xref:System.Text.Encoding> propiedades que devuelven un <xref:System.Text.UnicodeEncoding> objeto.  
  
|Miembro|Modos endian|LISTA DE MATERIALES|Detección de errores|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.BigEndianUnicode%2A>|Big-endian|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType>|Little-endian|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UnicodeEncoding.%23ctor?displayProperty=nameWithType>|Little-endian|Sí|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29>|Configurable|Configurable|Ninguna (reserva de reemplazo)|  
|<xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurable|Configurable|Configurable|  
  
 El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método determina el número de bytes resultante de codificar un juego de caracteres Unicode y el <xref:System.Text.UnicodeEncoding.GetBytes%2A> método realiza la codificación real.  
  
 Del mismo modo, el <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.UnicodeEncoding.GetChars%2A> y <xref:System.Text.UnicodeEncoding.GetString%2A> métodos realizan la descodificación real.  
  
 Para un codificador o descodificador que es capaz de guardar información de estado al codificar o descodificar los datos que abarca varios bloques (por ejemplo, la cadena de 1 millón de caracteres que se codifica en segmentos de 100 000 caracteres), use el <xref:System.Text.UnicodeEncoding.GetEncoder%2A> y <xref:System.Text.UnicodeEncoding.GetDecoder%2A> propiedades, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo codificar una cadena de caracteres Unicode en una matriz de bytes mediante el uso de un <xref:System.Text.UnicodeEncoding> objeto. La matriz de bytes se descodifica en una cadena para demostrar que no hay ninguna pérdida de datos.  
  
 [!code-cpp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CPP/snippet.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/snippet.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/snippet.vb#1)]  
  
 En el ejemplo siguiente se usa la misma cadena que el anterior, excepto en que escribe los bytes codificados en un archivo y prefijos de la secuencia de bytes con una marca de orden de bytes (BOM). A continuación, lee el archivo de dos maneras diferentes: como un archivo de texto mediante el uso de un <xref:System.IO.StreamReader> objeto; y como un archivo binario. Como cabría esperar, ninguna cadena recién lectura incluye la marca BOM.  
  
 [!code-csharp[System.Text.UnicodeEncoding Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/CS/bom1.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding Example/VB/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Decoder" />
    <altmember cref="T:System.Text.UTF32Encoding" />
    <altmember cref="T:System.Text.UTF8Encoding" />
    <altmember cref="T:System.Text.UTF7Encoding" />
    <altmember cref="T:System.Text.ASCIIEncoding" />
    <altmember cref="T:System.Globalization.UnicodeCategory" />
    <altmember cref="T:System.Globalization.CharUnicodeInfo" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UnicodeEncoding" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UnicodeEncoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que usa el orden de bytes endian little, proporciona una marca de orden de bytes Unicode y no produce una excepción cuando se detecta una codificación no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, debe habilitar detección de errores mediante una llamada a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidBytes` argumento `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un nuevo <xref:System.Text.UnicodeEncoding> de instancia y muestre el nombre de la codificación.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> para usar el orden de bytes big endian (primero el byte más significativo) o <see langword="false" /> para usar el orden de bytes little endian (primero el byte menos significativo).</param>
        <param name="byteOrderMark">Es <see langword="true" /> para especificar que el método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> devuelve una marca de orden de bytes Unicode; en caso contrario, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UnicodeEncoding" />. Los parámetros especifican si se usa el orden de bytes big endian y si el método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> devuelve una marca de orden de bytes Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor crea una instancia que no produce una excepción cuando se detecta una codificación no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, debe habilitar detección de errores mediante una llamada a la <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor y estableciendo su `throwOnInvalidBytes` argumento `true`.  
  
 El `byteOrderMark` parámetro controla el funcionamiento de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método. Si `true`, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-16.  Si `false`, devuelve una matriz de bytes de longitud cero. Sin embargo, establecer `byteOrderMark` a `true` no provoca la <xref:System.Text.UnicodeEncoding.GetBytes%2A> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método debe incluir el número de bytes en la marca BOM en el recuento de bytes.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear un nuevo <xref:System.Text.UnicodeEncoding> marca de orden de byte Unicode e instancia especificando si se deben admitir el orden de bytes de endian little-endian o big.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UnicodeEncoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (bigEndian As Boolean, byteOrderMark As Boolean, throwOnInvalidBytes As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);" />
      <MemberSignature Language="F#" Value="new System.Text.UnicodeEncoding : bool * bool * bool -&gt; System.Text.UnicodeEncoding" Usage="new System.Text.UnicodeEncoding (bigEndian, byteOrderMark, throwOnInvalidBytes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidBytes" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> para usar el orden de bytes big endian (primero el byte más significativo); <see langword="false" /> para usar el orden de bytes little endian (primero el byte menos significativo).</param>
        <param name="byteOrderMark">Es <see langword="true" /> para especificar que el método <see cref="M:System.Text.UnicodeEncoding.GetPreamble" /> devuelve una marca de orden de bytes Unicode; en caso contrario, es <see langword="false" />.</param>
        <param name="throwOnInvalidBytes">
          <see langword="true" /> para especificar que se produzca una excepción cuando se detecte una codificación no válida, en caso contrario, <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.UnicodeEncoding" />. Los parámetros especifican si se usa el orden de bytes big endian, si se proporciona una marca de orden de bytes Unicode y si se produce una excepción cuando se detecta una codificación no válida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `byteOrderMark` parámetro controla el funcionamiento de la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método. Si `true`, el método devuelve una matriz de bytes que contiene la marca de orden de bytes Unicode (BOM) en formato UTF-16.  Si `false`, devuelve una matriz de bytes de longitud cero. Sin embargo, establecer `byteOrderMark` a `true` no provoca la <xref:System.Text.UnicodeEncoding.GetBytes%2A> método como prefijo la marca BOM al principio de la matriz de bytes, ni hace que el <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método debe incluir el número de bytes en la marca BOM en el recuento de bytes.  
  
 Si el `throwOnInvalidBytes` parámetro es `true`, un método que detecta una secuencia de bytes no válida inicia <xref:System.ArgumentException?displayProperty=nameWithType>. En caso contrario, el método no produce una excepción y se omite la secuencia no válida.  
  
> [!NOTE]
>  Por motivos de seguridad, las aplicaciones se recomiendan utilizar este constructor para crear una instancia de la <xref:System.Text.UnicodeEncoding> clase y activar la detección de errores estableciendo `throwOnInvalidBytes` a `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el comportamiento de <xref:System.Text.UnicodeEncoding>, con la detección de errores habilitado y sin.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ErrorDetection/VB/errordetection.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.GetPreamble" />
      </Docs>
    </Member>
    <Member MemberName="CharSize">
      <MemberSignature Language="C#" Value="public const int CharSize = 2;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 CharSize = (2)" />
      <MemberSignature Language="DocId" Value="F:System.Text.UnicodeEncoding.CharSize" />
      <MemberSignature Language="VB.NET" Value="Public Const CharSize As Integer  = 2" />
      <MemberSignature Language="C++ CLI" Value="public: int CharSize = 2;" />
      <MemberSignature Language="F#" Value="val mutable CharSize : int" Usage="System.Text.UnicodeEncoding.CharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Representa, en bytes, el tamaño de caracteres Unicode. Este campo es una constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor de este campo es una constante de 32 bits con signo con valor 2.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo devolver el valor de <xref:System.Text.UnicodeEncoding.CharSize> y mostrarla.  
  
 [!code-cpp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CPP/charsize.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/CS/charsize.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.CharSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.CharSize Example/VB/charsize.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="unicodeEncoding.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a comparar con el objeto actual.</param>
        <summary>Determina si el objeto <see cref="T:System.Object" /> especificado es igual al objeto <see cref="T:System.Text.UnicodeEncoding" /> actual.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> es una instancia de <see cref="T:System.Text.UnicodeEncoding" /> y es igual al objeto actual; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dos <xref:System.Text.UnicodeEncoding> objetos se consideran iguales si se cumplen todas las condiciones siguientes:  
  
-   Ambos objetos utilizan el mismo orden de bytes (little-endian o big-endian).  
  
-   Ambos objetos proporcionan la marca de orden de bytes, o ambos no lo hacen.  
  
-   Ambos objetos utilizan la misma reserva del codificador.  
  
-   Ambos objetos utilizan la misma reserva del descodificador.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.Equals%2A> método para probar si el actual <xref:System.Text.UnicodeEncoding> es igual a otro objeto <xref:System.Text.UnicodeEncoding> objeto. Cinco <xref:System.Text.UnicodeEncoding> objetos se crean y se comparan y se muestran los resultados de las comparaciones.  
  
 [!code-cpp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CPP/ctor-boolean-boolean.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/CS/ctor-boolean-boolean.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.ctor2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.ctor2 Example/VB/ctor-boolean-boolean.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Text.UnicodeEncoding.#ctor" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteCount">
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : string -&gt; int" Usage="unicodeEncoding.GetByteCount s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <summary>Calcula el número de bytes generado al codificar los caracteres de la cadena especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
> [!NOTE]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> método.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> y <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> métodos para calcular el número real y máximo de bytes necesarios para codificar una cadena. También muestra el número real de bytes necesarios para almacenar una secuencia de bytes con una marca BOM.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="s" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(char* chars, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres a partir del puntero de caracteres especificado.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiere para almacenar los bytes resultantes, llame a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
> [!NOTE]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UTF8Encoding.GetByteCount%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="chars" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">La detección de errores está habilitada y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByteCount (chars As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetByteCount(cli::array &lt;char&gt; ^ chars, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetByteCount : char[] * int * int -&gt; int" Usage="unicodeEncoding.GetByteCount (chars, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="index">Índice del primer carácter que se va a codificar.</param>
        <param name="count">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número de bytes generado mediante la codificación de un juego de caracteres de la matriz de caracteres especificada.</summary>
        <returns>Número de bytes que se generan al codificar los caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetBytes%2A> para almacenar los bytes resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores habilitada, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (como al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador y el número de bytes en el preámbulo no se refleja en el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método.  
  
   
  
## Examples  
 El ejemplo siguiente rellena una matriz con un alfabeto latino en mayúsculas y minúsculas y llama a la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar el número de bytes necesarios para codificar los caracteres en minúsculas latinos. A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca BOM. Compara este número con el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica el número máximo de bytes necesarios para codificar los caracteres en minúsculas latinos. El ejemplo siguiente rellena una matriz con una combinación de caracteres griego y cirílico y llama a la <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar el número de bytes necesarios para codificar los caracteres cirílico. A continuación, muestra esta información junto con el número total de bytes necesarios si se agrega una marca BOM. Compara este número con el valor devuelto por la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica el número máximo de bytes necesarios para codificar los caracteres cirílico.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.UnicodeEncoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.unicodeencoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBytes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica un juego de caracteres en una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetBytes(System::String ^ s);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string -&gt; byte[]" Usage="unicodeEncoding.GetBytes s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(char* chars, int charCount, System::Byte* bytes, int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : nativeptr&lt;char&gt; * int * nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charCount, bytes, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Puntero al primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Puntero a la ubicación en la que se iniciará la escritura de la secuencia de bytes resultante.</param>
        <param name="byteCount">Número máximo de bytes que se pueden escribir.</param>
        <summary>Codifica un juego de caracteres a partir del puntero de caracteres especificado en una secuencia de bytes que se almacenan a partir del puntero de bytes especificado.</summary>
        <returns>Número real de bytes escritos en la ubicación indicada por el parámetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.UnicodeEncoding.GetBytes%2A> requiere para almacenar los bytes resultantes, llame a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o el <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UnicodeEncoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> o <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 El valor de <paramref name="byteCount" /> es menor que el número resultante de bytes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : char[] * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (chars, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Matriz de caracteres que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres de la matriz de caracteres determinada en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método o la <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UnicodeEncoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetBytes%2A> método para codificar un intervalo de caracteres de un <xref:System.String> y almacenar los bytes codificados en un intervalo de elementos de una matriz de bytes.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CPP/getbytes-string-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/CS/getbytes-string-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes3 Example/VB/getbytes-string-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="chars" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetBytes(System::String ^ s, int charIndex, int charCount, cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : string * int * int * byte[] * int -&gt; int" Usage="unicodeEncoding.GetBytes (s, charIndex, charCount, bytes, byteIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que contiene el juego de caracteres que se va a codificar.</param>
        <param name="charIndex">Índice del primer carácter que se va a codificar.</param>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <param name="bytes">Matriz de bytes que contendrá la secuencia de bytes resultante.</param>
        <param name="byteIndex">Índice en el que se inicia la escritura de la secuencia de bytes resultante.</param>
        <summary>Codifica un juego de caracteres del objeto <see cref="T:System.String" /> especificado en la matriz de bytes especificada.</summary>
        <returns>Número real de bytes escritos en <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetBytes%2A> para almacenar los bytes resultantes, llame a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método. Para calcular el tamaño máximo de la matriz, llame a la <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método o la <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para asegurarse de que los bytes codificados se descodifican correctamente cuando se guardan como un archivo o como una secuencia, se puede anteponer una secuencia de bytes codificados con un preámbulo. Insertar el preámbulo del principio de una secuencia de bytes (por ejemplo, al principio de una serie de bytes que se escribirán en un archivo) es responsabilidad del desarrollador. El <xref:System.Text.UnicodeEncoding.GetBytes%2A> método no anteponga un preámbulo al principio de una secuencia de bytes codificadas.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo codificar un intervalo de elementos de una matriz de caracteres Unicode y almacenar los bytes codificados en un intervalo de elementos de una matriz de bytes.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CPP/getbytes-char[]-int32-int32-byte[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/CS/getbytes-char[]-int32-int32-byte[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetBytes1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetBytes1 Example/VB/getbytes-char[]-int32-int32-byte[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="s" /> es <see langword="null" />.  
  
O bien 
 <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="charIndex" />, <paramref name="charCount" /> o <paramref name="byteIndex" /> es menor que cero.  
  
O bien 
 <paramref name="charIndex" /> y <paramref name="charCount" /> no denotan un intervalo válido en <paramref name="chars" />.  
  
O bien 
 <paramref name="byteIndex" /> no es un índice válido para <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="s" /> contiene una secuencia de caracteres no válida.  
  
O bien 
 <paramref name="bytes" /> no tiene suficiente capacidad desde <paramref name="byteIndex" /> hasta el final de la matriz para alojar los bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(System::Byte* bytes, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : nativeptr&lt;byte&gt; * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir del puntero de bytes especificado.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.UnicodeEncoding.GetChars%2A> requiere para almacenar los caracteres resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. El <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetCharCount : byte[] * int * int -&gt; int" Usage="unicodeEncoding.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número de caracteres generado mediante la descodificación de una secuencia de bytes a partir de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetChars%2A> para almacenar los caracteres resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. El <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método para devolver el número de caracteres que se genera al descodificar un intervalo de elementos de una matriz de bytes utilizando <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="Overload:System.Text.UnicodeEncoding.GetChars" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Descodifica una secuencia de bytes en un conjunto de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteCount, chars, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <summary>Descodifica una secuencia de bytes a partir del puntero de bytes especificado en un juego de caracteres que se almacenan a partir del puntero de caracteres especificado.</summary>
        <returns>Número real de caracteres escritos en la ubicación indicada por el parámetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La matriz exacta para calcular el tamaño que <xref:System.Text.UnicodeEncoding.GetChars%2A> requiere para almacenar los caracteres resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. El <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y se devolvió la matriz de bytes por un método de un tipo compatible con no BOM, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o el <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> o <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
O bien 
 El valor de <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="override this.GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="unicodeEncoding.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Descodifica una secuencia de bytes de la matriz de bytes especificada en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetChars%2A> para almacenar los caracteres resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. El <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y se devolvió la matriz de bytes por un método de un tipo compatible con no BOM, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> proporcionada por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> método o la <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetChars%2A> método para descodificar un intervalo de elementos de una matriz de bytes y almacena el resultado en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
O bien 
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.  
  
O bien 
 <paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetDecoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecoder () As Decoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Decoder ^ GetDecoder();" />
      <MemberSignature Language="F#" Value="override this.GetDecoder : unit -&gt; System.Text.Decoder" Usage="unicodeEncoding.GetDecoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un descodificador que convierte una secuencia de bytes codificada en UTF-16 en una secuencia de caracteres Unicode.</summary>
        <returns>Objeto <see cref="T:System.Text.Decoder" /> que convierte una secuencia de bytes codificada en UTF-16 en una secuencia de caracteres Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método convierte bloques secuenciales de bytes en bloques secuenciales de caracteres, de forma similar a la <xref:System.Text.UnicodeEncoding.GetChars%2A>. Sin embargo, un <xref:System.Text.Decoder> mantiene la información de estado entre llamadas, de modo que puede descodificar correctamente las secuencias de bytes que abarcan distintos bloques. El <xref:System.Text.Decoder> también conserva los bytes al final de los bloques de datos y usa los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> y <xref:System.Text.UnicodeEncoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidBytes` parámetro del constructor se establece en `true`, también se habilita la detección de errores en el <xref:System.Text.Decoder> devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del descodificador no está definido y debe detener el procesamiento.  
  
   
  
## Examples  
 El ejemplo siguiente usa un codificador y un descodificador para codificar una cadena en una matriz de bytes y, a continuación, descodificar los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Decoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetEncoder" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEncoder () As Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Text::Encoder ^ GetEncoder();" />
      <MemberSignature Language="F#" Value="override this.GetEncoder : unit -&gt; System.Text.Encoder" Usage="unicodeEncoding.GetEncoder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un codificador que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada en UTF-16.</summary>
        <returns>Objeto <see cref="T:System.Text.Encoder" /> que convierte una secuencia de caracteres Unicode en una secuencia de bytes codificada en UTF-16.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método convierte bloques secuenciales de caracteres en bloques secuenciales de bytes de una manera similar a la <xref:System.Text.UnicodeEncoding.GetBytes%2A> método de esta clase. Sin embargo, un <xref:System.Text.Encoder> objeto mantiene información de estado entre las llamadas, por lo que puede codificar correctamente secuencias de caracteres que abarcan distintos bloques. La <xref:System.Text.Encoder> objeto también conserva los caracteres al final de los bloques de datos y usa caracteres finales en la siguiente operación de codificación. Por ejemplo, un bloque de datos podría finalizar con un suplente alto no coincidente, y el suplente bajo podría estar en el siguiente bloque de datos. Por lo tanto, <xref:System.Text.UnicodeEncoding.GetDecoder%2A> y <xref:System.Text.UnicodeEncoding.GetEncoder%2A> son útiles para la transmisión de red y las operaciones de archivo, porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
 Si está habilitada la detección de errores, es decir, el `throwOnInvalidBytes` parámetro del constructor se establece en `true`, también se habilita la detección de errores en el <xref:System.Text.Encoder> objeto devuelto por este método. Si está habilitada la detección de errores y se encuentra una secuencia no válida, el estado del codificador está definido y debe detener el procesamiento.  
  
   
  
## Examples  
 El ejemplo siguiente usa un codificador y un descodificador para codificar una cadena en una matriz de bytes y, a continuación, descodificar los bytes en una matriz de caracteres.  
  
 [!code-cpp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.EncDec/VB/encdec.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="unicodeEncoding.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el código hash de la instancia actual.</summary>
        <returns>Código hash para el objeto <see cref="T:System.Text.UnicodeEncoding" /> actual.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxByteCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxByteCount (charCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxByteCount(int charCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxByteCount : int -&gt; int" Usage="unicodeEncoding.GetMaxByteCount charCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">Número de caracteres que se van a codificar.</param>
        <summary>Calcula el número máximo de bytes generado mediante la codificación del número de caracteres especificado.</summary>
        <returns>Número máximo de bytes generados al codificar el número de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetBytes%2A> para almacenar los bytes resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetByteCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>. El <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> Recupera un número de caso peor, incluyendo el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.EncoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> puede devolver valores grandes.  
  
 En la mayoría de los casos, este método recupera un número razonable de las cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el caso excepcional de que se ha superado un búfer más razonable. También puede tener en cuenta un enfoque diferente utilizando <xref:System.Text.UnicodeEncoding.GetByteCount%2A> o <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> no tiene ninguna relación con <xref:System.Text.UnicodeEncoding.GetChars%2A>. Si la aplicación necesita una función similar a usar con <xref:System.Text.UnicodeEncoding.GetChars%2A>, debe usar <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)` no es necesariamente el mismo valor que `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método para devolver el número máximo de bytes necesarios para codificar un número especificado de caracteres.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CPP/getmaxbytecount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/CS/getmaxbytecount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxByteCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxByteCount Example/VB/getmaxbytecount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.EncoderFallback" /> está establecido en <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetEncoder" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMaxCharCount (byteCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetMaxCharCount(int byteCount);" />
      <MemberSignature Language="F#" Value="override this.GetMaxCharCount : int -&gt; int" Usage="unicodeEncoding.GetMaxCharCount byteCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <summary>Calcula el número máximo de caracteres generado mediante la descodificación del número de bytes especificado.</summary>
        <returns>Número máximo de caracteres que se generan al descodificar el número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular el tamaño exacto de matriz requerido <xref:System.Text.UnicodeEncoding.GetChars%2A> para almacenar los caracteres resultantes, la aplicación usa <xref:System.Text.UnicodeEncoding.GetCharCount%2A>. Para calcular el tamaño máximo de la matriz, debe usar la aplicación <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A>. El <xref:System.Text.UnicodeEncoding.GetCharCount%2A> método asigna generalmente menos memoria, mientras que el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método generalmente se ejecuta con mayor rapidez.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> Recupera un número de caso peor, incluyendo el peor de los casos para el que se han seleccionado actualmente <xref:System.Text.DecoderFallback>. Si se elige una acción de reserva con una cadena potencialmente grande, <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> recupera valores grandes.  
  
 En la mayoría de los casos, este método recupera un número razonable de las cadenas pequeñas. Cadenas de gran tamaño, tendrá que elegir entre usar búferes muy grandes y detectar errores en el caso excepcional de que se ha superado un búfer más razonable. También puede tener en cuenta un enfoque diferente utilizando <xref:System.Text.UnicodeEncoding.GetCharCount%2A> o <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> no tiene ninguna relación con <xref:System.Text.UnicodeEncoding.GetBytes%2A>. Si la aplicación necesita una función similar a usar con <xref:System.Text.UnicodeEncoding.GetBytes%2A>, debe usar <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)` no es necesariamente el mismo valor que `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetMaxCharCount%2A> método para devolver el número máximo de caracteres que se genera al descodificar un número especificado de bytes.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CPP/getmaxcharcount-int32.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/CS/getmaxcharcount-int32.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetMaxCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetMaxCharCount Example/VB/getmaxcharcount-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> es menor que cero.  
  
O bien 
El número de bytes resultante es mayor que el número máximo que se puede devolver como entero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetPreamble" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreamble () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ GetPreamble();" />
      <MemberSignature Language="F#" Value="override this.GetPreamble : unit -&gt; byte[]" Usage="unicodeEncoding.GetPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una marca de orden de bytes Unicode codificada en formato UTF-16 si el constructor empleado para esta instancia solicita una marca de orden de bytes.</summary>
        <returns>Matriz de bytes que contiene la marca de orden de bytes Unicode, si el objeto <see cref="T:System.Text.UnicodeEncoding" /> está configurado para proporcionar una. En caso contrario, este método devuelve una matriz de bytes de longitud cero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.UnicodeEncoding> objeto puede proporcionar un preámbulo, que es una matriz de bytes que se puede anteponer a la secuencia de bytes resultante del proceso de codificación. Delante de una secuencia de bytes codificados con una marca BOM (punto de código U+FEFF) ayuda a que el descodificador de determinar el orden de bytes y el formato de transformación o UTF. La marca de orden de bytes Unicode (BOM) se serializa como se indica a continuación (en hexadecimal):  
  
-   Orden de bytes big endian: FE FF  
  
-   Orden de bytes endian little: FF FE  
  
 Puede crear instancias de un <xref:System.Text.UnicodeEncoding> cuyo <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método devuelve una lista de materiales válido de las maneras siguientes:  
  
-   Recuperando el <xref:System.Text.UnicodeEncoding> objeto devuelto por la <xref:System.Text.Encoding.Unicode%2A?displayProperty=nameWithType> o <xref:System.Text.Encoding.BigEndianUnicode%2A?displayProperty=nameWithType> propiedad.  
  
-   Mediante una llamada sin parámetros <xref:System.Text.UnicodeEncoding.%23ctor> constructor para crear instancias de un <xref:System.Text.UnicodeEncoding> objeto.  
  
-   Si se suministra `true` como el valor de la `byteOrderMark` argumento para el <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%29> o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructores.  
  
 Se recomienda que utilice la lista de materiales, puesto que ofrece cierta identificación de una codificación para los archivos que si no han perdido una referencia a su codificación, como sin etiqueta o incorrectamente etiquetados no tenía datos web o archivos de texto aleatorio almacenados cuando una empresa intereses internacionales. Problemas de los usuarios a menudo pueden evitarse si los datos se etiquetan de forma coherente y correctamente.  
  
 Los estándares que proporcionan un tipo de codificación, una marca BOM es redundante. Sin embargo, se puede usar para ayudar a un servidor de enviar el encabezado de codificación correcto. Como alternativa, se puede usar como reserva en caso de que la codificación en caso contrario, se pierde.  
  
 Existen algunas desventajas del uso de una marca BOM. Por ejemplo, puede ser difícil saber cómo limitar los campos de la base de datos que usan una marca BOM. Concatenación de archivos también puede ser un problema, por ejemplo, cuando se mezclan los archivos de tal forma que un carácter innecesario puede acabar en el centro de datos. A pesar de la serie de desventajas, sin embargo, el uso de una lista de materiales se recomienda encarecidamente.  
  
> [!CAUTION]
>  Para asegurarse de que los bytes codificados se descodifican correctamente, se debe anteponer el comienzo de una secuencia de bytes codificados con un preámbulo. Tenga en cuenta que el <xref:System.Text.UnicodeEncoding.GetBytes%2A> método no anteponer una marca BOM a una secuencia de bytes codificados; proporcionando una marca BOM al principio de una secuencia de bytes apropiada es responsabilidad del desarrollador.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para recuperar la marca de orden de byte Unicode en big endian o little orden de bytes endian para una instancia de un <xref:System.Text.UnicodeEncoding>.  
  
 [!code-cpp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CPP/getpreamble-.cpp#1)]
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/CS/getpreamble-.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UnicodeEncoding.GetPreamble Example/VB/getpreamble-.vb#1)]  
  
 El ejemplo siguiente crea dos <xref:System.Text.UnicodeEncoding> objetos, el primero de los cuales no proporciona una lista de materiales y el segundo de los que hace. A continuación, llama el <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para escribir la lista de materiales en un archivo antes de escribir una cadena con codificación Unicode. Como se muestra en la consola de salida del ejemplo, el archivo que guarda los bytes del segundo codificador tiene tres más bytes que el primero.  
  
 [!code-csharp[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/cs/GetPreamble1.cs#1)]
 [!code-vb[System.Text.UnicodeEncoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Text.UnicodeEncoding.GetPreamble/vb/GetPreamble1.vb#1)]  
  
 También puede comparar los archivos mediante el `fc` comando en una ventana de consola, o bien puede inspeccionar los archivos en un editor de texto que incluye un modo de vista hexadecimal. Tenga en cuenta que cuando se abre el archivo en un editor que admite la codificación UTF-16, no se muestra la lista de materiales.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UnicodeEncoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (bytes As Byte(), index As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.GetString : byte[] * int * int -&gt; string" Usage="unicodeEncoding.GetString (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Descodifica un intervalo de bytes de una matriz de bytes en una cadena.</summary>
        <returns>Objeto <see cref="T:System.String" /> que contiene los resultados obtenidos al descodificar la secuencia de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con la detección de errores, una secuencia no válida hace que este método producir una <xref:System.ArgumentException>. Sin detección de errores, se omiten las secuencias no válidas y se produce ninguna excepción.  
  
 Si el intervalo de bytes que se desea descodificar incluye la marca de orden de bytes (BOM) y se devolvió la matriz de bytes por un método de un tipo compatible con no BOM, el carácter U + FFFE se incluye en la matriz de caracteres devuelta por este método. Puede quitar mediante una llamada a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Datos que va a convertir, como los datos leídos de una secuencia, podrían ser disponibles sólo en bloques secuenciales. En este caso, o si la cantidad de datos es tan grande que debe dividirse en bloques más pequeños, la aplicación debe utilizar el <xref:System.Text.Decoder> o <xref:System.Text.Encoder> objeto proporcionado por el <xref:System.Text.UnicodeEncoding.GetDecoder%2A> o el <xref:System.Text.UnicodeEncoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 En el ejemplo siguiente se inicializa una matriz mediante una llamada a la <xref:System.Text.UnicodeEncoding.GetByteCount%2A> método para determinar exactamente cuántos bytes son necesarios para una cadena codificada y, a continuación, agregar el tamaño de la marca de orden de bytes (BOM). El ejemplo llama a la <xref:System.Text.UnicodeEncoding.GetPreamble%2A> método para almacenar la marca BOM a la matriz antes de llamar a la <xref:System.Text.Encoding.GetBytes%2A> método para almacenar los bytes codificados en la matriz. El ejemplo llama a la <xref:System.Text.UnicodeEncoding.GetString%2A> método para descodificar la cadena.  
  
 [!code-csharp[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/cs/getstring1.cs#1)]
 [!code-vb[System.Text.UTF8Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf8encoding.getstring/vb/getstring1.vb#1)]  
  
 Tenga en cuenta que en este caso la cadena descodificada difiere de la cadena original, ya que comienza con una marca de orden de bytes de 16 bits U+FFFD. Esto significa que las dos cadenas se consideran diferente, y que, si la cadena es la salida, se mostrará la lista de materiales como el carácter de reemplazo "?". Para quitar la marca BOM al principio de la cadena, puede llamar a la <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">Está habilitada la detección de errores, y <paramref name="bytes" /> contiene una secuencia de bytes no válida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Encoding.DecoderFallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.UnicodeEncoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetDecoder" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.UnicodeEncoding.GetMaxCharCount(System.Int32)" />
      </Docs>
    </Member>
  </Members>
</Type>