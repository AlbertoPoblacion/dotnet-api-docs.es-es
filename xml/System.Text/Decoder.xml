<Type Name="Decoder" FullName="System.Text.Decoder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="675d7441e49cf7cd099bfdfff5b179d6c2b42e3a" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52360282" /></Metadata><TypeSignature Language="C#" Value="public abstract class Decoder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Decoder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Decoder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Decoder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Decoder abstract" />
  <TypeSignature Language="F#" Value="type Decoder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Convierte una secuencia de bytes codificados en un conjunto de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una instancia de una implementación de la <xref:System.Text.Decoder> (clase), la aplicación debe utilizar el <xref:System.Text.Encoding.GetDecoder%2A> método de un <xref:System.Text.Encoding> implementación.  
  
 El <xref:System.Text.Decoder.GetCharCount%2A> método determina el número de caracteres resultante de descodificar una secuencia de bytes y el <xref:System.Text.Decoder.GetChars%2A> método realiza la descodificación real. Hay varias versiones de estos dos métodos disponibles en la <xref:System.Text.Decoder> clase. Para obtener más información, vea <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>. Un <xref:System.Text.Decoder> objeto mantiene información de estado entre las llamadas sucesivas a `GetChars` o <xref:System.Text.Decoder.Convert%2A> métodos de modo que puede descodificar correctamente las secuencias de bytes que abarcan distintos bloques. El <xref:System.Text.Decoder> también conserva los bytes al final de los bloques de datos y usa los bytes finales en la siguiente operación de descodificación. Por lo tanto, <xref:System.Text.Encoding.GetDecoder%2A> y <xref:System.Text.Encoding.GetEncoder%2A> son útiles para las operaciones de transmisión y el archivo de red porque esas operaciones a menudo tratan con bloques de datos en lugar de un flujo de datos completa.  
  
> [!NOTE]
>  Cuando la aplicación se realiza con un flujo de datos, debe asegurarse de que se vacíe la información de estado estableciendo el `flush` parámetro `true` en la llamada al método apropiado. Si se produce una excepción o si la aplicación modifica los flujos, debe llamar a <xref:System.Text.Decoder.Reset%2A> para borrar el estado interno de la `Decoder` objeto.  
  
## <a name="version-considerations"></a>Consideraciones sobre la versión  
 Un <xref:System.Text.Decoder> o <xref:System.Text.Encoder> se puede serializar el objeto durante una operación de conversión. El estado del objeto se conserva si se ha deserializado en la misma versión de .NET Framework, pero se pierden si se deserializa en otra versión.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra el uso de un <xref:System.Text.Decoder> para convertir dos matrices de bytes diferentes en una matriz de caracteres. Uno de los bytes de caracteres abarca las matrices. Esto es similar a lo que un <xref:System.IO.StreamReader> objeto hace internamente cuando lee una secuencia.  
  
 [!code-cpp[Classic Decoder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Decoder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Decoder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Decoder Example/CS/source.cs#1)]
 [!code-vb[Classic Decoder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Decoder Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Cuando la aplicación se hereda de esta clase, deben invalidar a todos los miembros.</para></block>
    <altmember cref="T:System.Text.Encoder" />
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
    <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Decoder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Decoder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Text.Decoder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una instancia de una implementación de esta clase, la aplicación debe utilizar el <xref:System.Text.Encoding.GetDecoder%2A> método de un <xref:System.Text.Encoding> implementación.  
  
   
  
## Examples  
 El ejemplo siguiente muestra dos técnicas para inicializar una nueva <xref:System.Text.Decoder> instancia.  
  
 [!code-cpp[System.Text.Decoder.ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CPP/ctor.cpp#1)]
 [!code-csharp[System.Text.Decoder.ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/CS/ctor.cs#1)]
 [!code-vb[System.Text.Decoder.ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.ctor Example/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Convert">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte una secuencia de bytes codificada en una cadena o matriz de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit&#xA;override this.Convert : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, chars, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <param name="bytesUsed">To be added.</param>
        <param name="charsUsed">To be added.</param>
        <param name="completed">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte* bytes, int byteCount, char* chars, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteCount, chars, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Dirección de un búfer que contiene las secuencias de bytes que convertir.</param>
        <param name="byteCount">Número de bytes en <paramref name="bytes" /> que se va a convertir.</param>
        <param name="chars">Dirección de un búfer donde se van a almacenar los caracteres convertidos.</param>
        <param name="charCount">Número máximo de caracteres en <paramref name="chars" /> que se puede usar en la conversión.</param>
        <param name="flush"><see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
        <param name="bytesUsed">Cuando este método vuelve, contiene el número de bytes que la conversión ha generado. Este parámetro se pasa sin inicializar.</param>
        <param name="charsUsed">Cuando este método vuelve, contiene el número de caracteres de <paramref name="chars" /> que se usaron en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="completed">Cuando este método vuelve, contiene <see langword="true" /> si todos los caracteres especificados por <paramref name="byteCount" /> se han convertido; de lo contrario, <see langword="false" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte un búfer de bytes codificados en caracteres con codificación UTF-16 y almacena el resultado en otro búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Decoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Decoder.Convert%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el descodificador pasa por alto los bytes no válidos al final del bloque de datos y borra el búfer interno. Los datos procesados restantes que forma parte de una unidad lógica, como suplente alto de un par suplente, se convierten según la configuración de reserva actual.  
  
 El `Convert` método está diseñado para usarse en un bucle para descodificar una cantidad arbitraria de entrada, como los datos leídos de un archivo o secuencia. Almacena el resultado de la operación de descodificación en un búfer de tamaño fijo. <xref:System.Text.Decoder.GetChars%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Decoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los bytes leídos y caracteres escritos. Consulte también el <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 El `completed` parámetro de salida que indica si todos los datos en el búfer de entrada se convierten y se almacena en el búfer de salida. Este parámetro se establece en `false` si el número de bytes especificado por el `byteCount` parámetro no se puede convertir sin exceder el número de caracteres especificados por el `charCount` parámetro. En esa situación, la aplicación debe usar el contenido del búfer de salida o proporcione un nuevo búfer de salida, incremento el `bytes` parámetro por el número de bytes especificado por el `bytesUsed` parámetro, a continuación, llame a la `Convert` método nuevo para procesar las entradas restantes.  
  
 El `completed` parámetro también se puede establecer en `false`, aunque el `bytesUsed` y `byteCount` parámetros son iguales. Esta situación se produce si todavía hay datos en el <xref:System.Text.Decoder> objeto que no se ha almacenado en el `bytes` búfer.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> o <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> o <paramref name="byteCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El búfer de salida es demasiado pequeño para contener la entrada convertida. El búfer de salida debe ser mayor o igual que el tamaño indicado por el método <see cref="Overload:System.Text.Decoder.GetCharCount" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public virtual void Convert (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, out int bytesUsed, out int charsUsed, out bool completed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Convert(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, int32 charCount, bool flush, [out] int32&amp; bytesUsed, [out] int32&amp; charsUsed, [out] bool&amp; completed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Convert(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32,System.Boolean,System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Convert (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, charCount As Integer, flush As Boolean, ByRef bytesUsed As Integer, ByRef charsUsed As Integer, ByRef completed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Convert(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, int charCount, bool flush, [Runtime::InteropServices::Out] int % bytesUsed, [Runtime::InteropServices::Out] int % charsUsed, [Runtime::InteropServices::Out] bool % completed);" />
      <MemberSignature Language="F#" Value="abstract member Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit&#xA;override this.Convert : byte[] * int * int * char[] * int * int * bool *  *  *  -&gt; unit" Usage="decoder.Convert (bytes, byteIndex, byteCount, chars, charIndex, charCount, flush, bytesUsed, charsUsed, completed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
        <Parameter Name="bytesUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="charsUsed" Type="System.Int32" RefType="out" />
        <Parameter Name="completed" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes para convertir.</param>
        <param name="byteIndex">Primer elemento de <paramref name="bytes" /> que se va a convertir.</param>
        <param name="byteCount">Número de elementos de <paramref name="bytes" /> que se van a convertir.</param>
        <param name="chars">Matriz para almacenar los caracteres convertidos.</param>
        <param name="charIndex">El primer elemento de <paramref name="chars" /> en el que se almacenan los datos.</param>
        <param name="charCount">Número máximo de elementos de <paramref name="chars" /> que se puede usar en la conversión.</param>
        <param name="flush"><see langword="true" /> para indicar que no se van a convertir más datos; de lo contrario, <see langword="false" />.</param>
        <param name="bytesUsed">Cuando este método vuelve, contiene el número de bytes que se usaron en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="charsUsed">Cuando este método vuelve, contiene el número de caracteres de <paramref name="chars" /> que se produjeron en la conversión. Este parámetro se pasa sin inicializar.</param>
        <param name="completed">Cuando este método vuelve, contiene <see langword="true" /> si todos los caracteres especificados por <paramref name="byteCount" /> se han convertido; de lo contrario, <see langword="false" />. Este parámetro se pasa sin inicializar.</param>
        <summary>Convierte una matriz de bytes codificados en caracteres con codificación UTF-16 y almacena el resultado en otra matriz de caracteres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Decoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Decoder.Convert%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el descodificador pasa por alto los bytes no válidos al final del bloque de datos y borra el búfer interno. Los datos procesados restantes que forma parte de una unidad lógica, como suplente alto de un par suplente, se convierten según la configuración de reserva actual.  
  
 El `Convert` método está diseñado para usarse en un bucle para descodificar una cantidad arbitraria de entrada, como los datos leídos de un archivo o secuencia. Almacena el resultado de la operación de descodificación en un búfer de tamaño fijo. <xref:System.Text.Decoder.GetChars%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Decoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los bytes leídos y caracteres escritos. Consulte también el <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 El `completed` parámetro de salida que indica si todos los datos en el búfer de entrada se convierten y se almacena en el búfer de salida. Este parámetro se establece en `false` si el número de bytes especificado por el `byteCount` parámetro no se puede convertir sin exceder el número de caracteres especificados por el `charCount` parámetro. En esa situación, la aplicación debe usar el contenido del búfer de salida o proporcione un nuevo búfer de salida, incremento el `bytes` parámetro por el número de bytes especificado por el `bytesUsed` parámetro, a continuación, llame a la `Convert` método nuevo para procesar las entradas restantes.  
  
 El `completed` parámetro también se puede establecer en `false`, aunque el `bytesUsed` y `byteCount` parámetros son iguales. Esta situación se produce si todavía hay datos en el <xref:System.Text.Decoder> objeto que no se ha almacenado en el `bytes` búfer.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Text.Encoder.Convert%2A> método para convertir un archivo de caracteres UTF-16 a UTF-8. A continuación, usa el <xref:System.Text.Decoder.Convert%2A> hacer una copia de método para convertir los caracteres UTF-8 a UTF-16 caracteres.  
  
 [!code-csharp[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/cs/edCvt.cs#1)]
 [!code-vb[sys.txt.EncoderDecoder.convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.EncoderDecoder.convert/vb/edCvt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="chars" /> o <paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charIndex" />, <paramref name="charCount" />, <paramref name="byteIndex" /> o <paramref name="byteCount" /> es menor que cero.  
  
O bien 
La longitud de <paramref name="chars" /> - <paramref name="charIndex" /> es menor que <paramref name="charCount" />.  
  
O bien 
La longitud de <paramref name="bytes" /> - <paramref name="byteIndex" /> es menor que <paramref name="byteCount" />.</exception>
        <exception cref="T:System.ArgumentException">El búfer de salida es demasiado pequeño para contener la entrada convertida. El búfer de salida debe ser mayor o igual que el tamaño indicado por el método <see cref="Overload:System.Text.Decoder.GetCharCount" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback Fallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback Fallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.Fallback" />
      <MemberSignature Language="VB.NET" Value="Public Property Fallback As DecoderFallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallback ^ Fallback { System::Text::DecoderFallback ^ get(); void set(System::Text::DecoderFallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Fallback : System.Text.DecoderFallback with get, set" Usage="System.Text.Decoder.Fallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto <see cref="T:System.Text.DecoderFallback" /> para el objeto <see cref="T:System.Text.Decoder" /> actual.</summary>
        <value>Un objeto <see cref="T:System.Text.DecoderFallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Text.DecoderFallback> objeto representa un controlador de errores que se invoca cuando no se puede convertir una secuencia de bytes codificada en un carácter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de una operación Set es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentException">No se puede asignar un nuevo valor en una operación de establecimiento porque el objeto <see cref="T:System.Text.DecoderFallbackBuffer" /> actual contiene datos que aún no se han descodificado.</exception>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.FallbackBuffer" />
        <related type="Article" href="~/docs/standard/base-types/character-encoding.md">Codificaciones de descripción</related>
      </Docs>
    </Member>
    <Member MemberName="FallbackBuffer">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallbackBuffer FallbackBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallbackBuffer FallbackBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Text.Decoder.FallbackBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FallbackBuffer As DecoderFallbackBuffer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::DecoderFallbackBuffer ^ FallbackBuffer { System::Text::DecoderFallbackBuffer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FallbackBuffer : System.Text.DecoderFallbackBuffer" Usage="System.Text.Decoder.FallbackBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallbackBuffer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Text.DecoderFallbackBuffer" /> asociado al objeto <see cref="T:System.Text.Decoder" /> actual.</summary>
        <value>Un objeto <see cref="T:System.Text.DecoderFallbackBuffer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Text.DecoderFallbackBuffer> objeto representa datos que usa el <xref:System.Text.DecoderFallback> objeto. La <xref:System.Text.DecoderFallback> objeto representa un controlador de errores que se invoca cuando no se puede convertir una secuencia de bytes codificada en un carácter.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Text.EncoderFallback" />
        <altmember cref="P:System.Text.Encoder.Fallback" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCharCount">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (ReadOnlySpan&lt;byte&gt; bytes, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As ReadOnlySpan(Of Byte), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(ReadOnlySpan&lt;System::Byte&gt; bytes, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int&#xA;override this.GetCharCount : ReadOnlySpan&lt;byte&gt; * bool -&gt; int" Usage="decoder.GetCharCount (bytes, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(System::Byte* bytes, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int&#xA;override this.GetCharCount : nativeptr&lt;byte&gt; * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <param name="flush"><see langword="true" /> para simular el borrado del estado interno del codificador después del cálculo; de lo contrario, <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes a partir del puntero de bytes especificado. Un parámetro indica si se debe borrar el estado interno del descodificador después del cálculo.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes y los bytes del búfer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no afecta al estado del descodificador.  
  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Decoder.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" /> en Visual Basic .NET).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es menor que cero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCharCount (bytes As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int -&gt; int" Usage="decoder.GetCharCount (bytes, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes de la matriz de bytes especificada.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes y los bytes del búfer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no afecta al estado del descodificador.  
  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Decoder.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Text.Decoder.GetCharCount%2A> método para calcular el número de caracteres necesarios para descodificar el intervalo especificado de bytes de la matriz.  
  
 [!code-cpp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CPP/getcharcount-byte[]-int32-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/CS/getcharcount-byte[]-int32-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetCharCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetCharCount Example/VB/getcharcount-byte[]-int32-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes, int index, int count, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCharCount (bytes As Byte(), index As Integer, count As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetCharCount(cli::array &lt;System::Byte&gt; ^ bytes, int index, int count, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetCharCount : byte[] * int * int * bool -&gt; int&#xA;override this.GetCharCount : byte[] * int * int * bool -&gt; int" Usage="decoder.GetCharCount (bytes, index, count, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="index">Índice del primer byte que se va a descodificar.</param>
        <param name="count">Número de bytes que se van a descodificar.</param>
        <param name="flush"><see langword="true" /> para simular el borrado del estado interno del codificador después del cálculo; de lo contrario, <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, calcula el número de caracteres que se generan al descodificar una secuencia de bytes de la matriz de bytes especificada. Un parámetro indica si se debe borrar el estado interno del descodificador después del cálculo.</summary>
        <returns>Número de caracteres que se generan al descodificar la secuencia especificada de bytes y los bytes del búfer interno.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no afecta al estado del descodificador.  
  
 La matriz exacta para calcular el tamaño que <xref:System.Text.Decoder.GetChars%2A> requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> o <paramref name="count" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> y <paramref name="count" /> no denotan un intervalo válido en <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChars">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes en un juego de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (ReadOnlySpan&lt;byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; bytes, valuetype System.Span`1&lt;char&gt; chars, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As ReadOnlySpan(Of Byte), chars As Span(Of Char), flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(ReadOnlySpan&lt;System::Byte&gt; bytes, Span&lt;char&gt; chars, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int&#xA;override this.GetChars : ReadOnlySpan&lt;byte&gt; * Span&lt;char&gt; * bool -&gt; int" Usage="decoder.GetChars (bytes, chars, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="chars" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">To be added.</param>
        <param name="chars">To be added.</param>
        <param name="flush">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(System::Byte* bytes, int byteCount, char* chars, int charCount, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int&#xA;override this.GetChars : nativeptr&lt;byte&gt; * int * nativeptr&lt;char&gt; * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteCount, chars, charCount, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Puntero al primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Puntero a la ubicación en la que se iniciará la escritura del juego de caracteres resultante.</param>
        <param name="charCount">Número máximo de caracteres que se van a escribir.</param>
        <param name="flush">Es <see langword="true" /> para borrar el estado interno del descodificador después de la conversión; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes a partir del puntero de byte especificado y cualquier byte del búfer interno en un juego de caracteres que se almacena a partir del puntero de caracteres especificado. Un parámetro indica si el estado interno del descodificador se borra después de la conversión.</summary>
        <returns>Número real de caracteres escritos en la ubicación indicada por el parámetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Decoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Decoder.GetChars%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el descodificador pasa por alto los bytes no válidos al final del bloque de datos y borra el búfer interno.  
  
 Para calcular el tamaño del búfer exacto que `GetChars` requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
 Si la aplicación consiste en convertir muchos segmentos de un flujo de entrada, considere el uso de la <xref:System.Text.Decoder.Convert%2A> método. <xref:System.Text.Decoder.GetChars%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Decoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los bytes leídos y caracteres escritos. Consulte también el <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> o <paramref name="charCount" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="charCount" /> es menor que el número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no se puede usar código de confianza parcial o transparente.</permission>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte*,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada y cualquier byte del búfer interno en la matriz de caracteres especificada.</summary>
        <returns>Número real de caracteres escritos en <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Decoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Decoder.GetChars%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el descodificador pasa por alto los bytes no válidos al final del bloque de datos y borra el búfer interno.  
  
 La matriz exacta para calcular el tamaño que `GetChars` requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
 Si la aplicación consiste en convertir muchos segmentos de un flujo de entrada, considere el uso de la <xref:System.Text.Decoder.Convert%2A> método. <xref:System.Text.Decoder.GetChars%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Decoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los bytes leídos y caracteres escritos. Consulte también el <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo descodificar un intervalo de elementos de una matriz de bytes y almacenarlas en una matriz de caracteres Unicode. El <xref:System.Text.Decoder.GetCharCount%2A> método se usa para calcular el número de caracteres necesarios para almacenar los elementos descodificados en la matriz `bytes`. El <xref:System.Text.Decoder.GetChars%2A> método descodifica los elementos especificados en la matriz de bytes y los almacena en la nueva matriz de caracteres.  
  
 [!code-cpp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CPP/getchars-byte[]-int32-int32-char[]-int32.cpp#1)]
 [!code-csharp[System.Text.Decoder.GetChars Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/CS/getchars-byte[]-int32-int32-char[]-int32.cs#1)]
 [!code-vb[System.Text.Decoder.GetChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Decoder.GetChars Example/VB/getchars-byte[]-int32-int32-char[]-int32.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
O bien 
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex, bool flush) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetChars (bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer, flush As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetChars(cli::array &lt;System::Byte&gt; ^ bytes, int byteIndex, int byteCount, cli::array &lt;char&gt; ^ chars, int charIndex, bool flush);" />
      <MemberSignature Language="F#" Value="abstract member GetChars : byte[] * int * int * char[] * int * bool -&gt; int&#xA;override this.GetChars : byte[] * int * int * char[] * int * bool -&gt; int" Usage="decoder.GetChars (bytes, byteIndex, byteCount, chars, charIndex, flush)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="flush" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bytes">Matriz de bytes que contiene la secuencia de bytes que se va a descodificar.</param>
        <param name="byteIndex">Índice del primer byte que se va a descodificar.</param>
        <param name="byteCount">Número de bytes que se van a descodificar.</param>
        <param name="chars">Matriz de caracteres que contendrá el juego de caracteres resultante.</param>
        <param name="charIndex">Índice en el que se inicia la escritura del juego de caracteres resultante.</param>
        <param name="flush">Es <see langword="true" /> para borrar el estado interno del descodificador después de la conversión; de lo contrario, es <see langword="false" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, descodifica una secuencia de bytes de la matriz de bytes especificada y cualquier byte del búfer interno en la matriz de caracteres especificada. Un parámetro indica si el estado interno del descodificador se borra después de la conversión.</summary>
        <returns>Número real de caracteres escrito en el parámetro <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuerde que el <xref:System.Text.Decoder> objeto guarda el estado entre las llamadas a <xref:System.Text.Decoder.GetChars%2A>. Cuando la aplicación se realiza con un flujo de datos, se debe establecer el `flush` parámetro `true` para asegurarse de que se vacíe la información de estado. Con esta configuración, el descodificador pasa por alto los bytes no válidos al final del bloque de datos y borra el búfer interno.  
  
 La matriz exacta para calcular el tamaño que `GetChars` requiere para almacenar los caracteres resultantes, debe usar la aplicación <xref:System.Text.Decoder.GetCharCount%2A>.  
  
 Si `GetChars` se llama con `flush` establecido en `false`, el descodificador almacena los bytes finales al final del bloque de datos en un búfer interno y se utilizan en la siguiente operación de descodificación. La aplicación debe llamar a `GetCharCount` en un bloque de datos inmediatamente antes de llamar a `GetChars` en el mismo bloque, para que todos los bytes finales del bloque anterior se incluyen en el cálculo.  
  
 Si la aplicación consiste en convertir muchos segmentos de un flujo de entrada, considere el uso de la <xref:System.Text.Decoder.Convert%2A> método. <xref:System.Text.Decoder.GetChars%2A> se iniciará una excepción si el búfer de salida no es suficientemente grande, pero <xref:System.Text.Decoder.Convert%2A> se rellenará tanto espacio como sea posible y devolverá los bytes leídos y caracteres escritos. Consulte también el <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tema para obtener más comentarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="bytes" /> es <see langword="null" /> (<see langword="Nothing" />).  
  
O bien 
 <paramref name="chars" /> es <see langword="null" /> (<see langword="Nothing" />).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="byteIndex" />, <paramref name="byteCount" /> o <paramref name="charIndex" /> es menor que cero.  
  
O bien 
 <paramref name="byteindex" /> y <paramref name="byteCount" /> no denotan un intervalo válido en <paramref name="bytes" />.  
  
O bien 
 <paramref name="charIndex" /> no es un índice válido para <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="chars" /> no tiene suficiente capacidad desde <paramref name="charIndex" /> hasta el final de la matriz para aloja los caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Se ha producido una acción de reserva (vea [Codificación de caracteres en .NET Framework](~/docs/standard/base-types/character-encoding.md) para obtener una explicación completa) 
- y - 
 El valor de <see cref="P:System.Text.Decoder.Fallback" /> está establecido en <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <altmember cref="M:System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
        <altmember cref="M:System.Text.Decoder.Reset" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Decoder.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="decoder.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, reestablece el estado inicial del descodificador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método borra el estado interno de la <xref:System.Text.Decoder> objeto. El método borra cualquier información de estado de una llamada anterior a <xref:System.Text.Decoder.GetChars%2A> o <xref:System.Text.Decoder.Convert%2A>, incluidos los finales bytes al final del bloque de datos anterior.  
  
 La aplicación debe llamar a la <xref:System.Text.Decoder.Reset%2A> método si desea reutilizar el mismo descodificador incluso después de que se produce una excepción por <xref:System.Text.Decoder.GetChars%2A>, <xref:System.Text.Decoder.Convert%2A>, o <xref:System.Text.Decoder.GetCharCount%2A>, o si el descodificador de secuencias activa y empieza a descodificar otra secuencia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>