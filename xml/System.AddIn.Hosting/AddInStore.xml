<Type Name="AddInStore" FullName="System.AddIn.Hosting.AddInStore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="960c61cdc90a6436b78d3cd1de9454e4cf45cfc4" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55409775" /></Metadata><TypeSignature Language="C#" Value="public static class AddInStore" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AddInStore extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.AddIn.Hosting.AddInStore" />
  <TypeSignature Language="VB.NET" Value="Public Class AddInStore" />
  <TypeSignature Language="C++ CLI" Value="public ref class AddInStore abstract sealed" />
  <TypeSignature Language="F#" Value="type AddInStore = class" />
  <AssemblyInfo>
    <AssemblyName>System.AddIn</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona los métodos para almacenar y buscar información sobre los complementos y segmentos de canalización disponibles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta clase para compilar, recompilar y actualizar dos archivos caché, tal como se describe en la tabla siguiente.  
  
|Archivo de caché|Métodos que crean el archivo|  
|----------------|----------------------------------|  
|PipelineSegments.store<br /><br /> Este archivo se encuentra en el directorio raíz de la estructura de directorios de canalizaciones.|<xref:System.AddIn.Hosting.AddInStore.Update%2A><br /><br /> Actualiza el archivo con nuevos segmentos de canalización. Si no hay nuevos segmentos están instalados, este método sólo valida la memoria caché.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Rebuild%2A><br /><br /> Vuelve a generar el archivo e incluye nuevos segmentos de canalización.|  
|AddIns.store<br /><br /> Este archivo se encuentra en un directorio que contiene uno o varios subdirectorios de complementos. Si este directorio se encuentra en la estructura de directorios de la canalización, debe denominarse AddIns.|<xref:System.AddIn.Hosting.AddInStore.UpdateAddIns%2A><br /><br /> Actualiza el archivo con nuevos complementos en una ubicación especificada. Llame a este método si los complementos están fuera de la estructura de directorios de la canalización.<br /><br /> Si no hay nuevos complementos están instalados, este método sólo valida la memoria caché.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.RebuildAddIns%2A><br /><br /> Vuelve a generar el archivo e incluye complementos en una ubicación especificada. Llame a este método si los complementos están fuera de la estructura de directorios de la canalización.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Update%2A><br /><br /> Si los complementos se encuentran en la estructura de directorios de canalización, este método actualiza el archivo con nuevos complementos.<br /><br /> <xref:System.AddIn.Hosting.AddInStore.Rebuild%2A><br /><br /> Si los complementos se encuentran en la estructura de directorios de canalización, este método vuelve a generar el archivo e incluye nuevos complementos.|  
  
 Estos métodos crean los archivos en caché si no existen previamente.  
  
 Después de crearán los archivos en caché, utilice el <xref:System.AddIn.Hosting.AddInStore.FindAddIns%2A> método para examinar los archivos para buscar todos los complementos que coinciden con la vista de host especificada del complemento. También puede usar el <xref:System.AddIn.Hosting.AddInStore.FindAddIn%2A> método para buscar un complemento específico.  
  
> [!IMPORTANT]
>  No se admite para permitir que los usuarios de confianza o entidades tener acceso a PipelineSegments.store y Addins.store. Si lo hace, puede causar problemas de corrupción de datos para las aplicaciones.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo actualizar los archivos caché.  
  
 [!code-csharp[AddInP3Host#2](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#2)]
 [!code-vb[AddInP3Host#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#2)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/8dd45b02-7218-40f9-857d-40d7b98b850b">Complementos y extensibilidad</related>
  </Docs>
  <Members>
    <Member MemberName="FindAddIn">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIn (Type hostViewOfAddIn, string pipelineRootFolderPath, string addInFilePath, string addInTypeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIn(class System.Type hostViewOfAddIn, string pipelineRootFolderPath, string addInFilePath, string addInTypeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIn(System.Type,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIn (hostViewOfAddIn As Type, pipelineRootFolderPath As String, addInFilePath As String, addInTypeName As String) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIn(Type ^ hostViewOfAddIn, System::String ^ pipelineRootFolderPath, System::String ^ addInFilePath, System::String ^ addInTypeName);" />
      <MemberSignature Language="F#" Value="static member FindAddIn : Type * string * string * string -&gt; System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;" Usage="System.AddIn.Hosting.AddInStore.FindAddIn (hostViewOfAddIn, pipelineRootFolderPath, addInFilePath, addInTypeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
        <Parameter Name="addInFilePath" Type="System.String" />
        <Parameter Name="addInTypeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Tipo que define la vista del host del complemento.</param>
        <param name="pipelineRootFolderPath">Ruta de acceso a la raíz de la estructura de directorios de canalizaciones.</param>
        <param name="addInFilePath">Ruta de acceso y nombre de archivo del complemento que se va a buscar.</param>
        <param name="addInTypeName">Nombre del tipo del complemento.</param>
        <summary>Busca un complemento concreto.</summary>
        <returns>Colección de tokens, que contiene sólo el token que representa el complemento buscado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se encuentra una sola canalización para un complemento, será el único elemento en el <xref:System.AddIn.Hosting.AddInToken> colección. Si se encuentran varias canalizaciones para el complemento especificado, puede diferenciar examinando el <xref:System.AddIn.Hosting.AddInToken.QualificationData%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente busca un complemento específico.  
  
 [!code-csharp[AddInP3Host#6](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#6)]
 [!code-vb[AddInP3Host#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud de <paramref name="pipelineRootFolderPath" /> o <paramref name="addInFilePath" /> o <paramref name="addInTypeName" /> es 0.  
  
O bien 
El archivo de complemento no existe en <paramref name="addInfilePath" />.</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios parámetros son <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permiso de acceso de lectura a <paramref name="pipelineRootFolderPath" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder leer la carpeta del complemento. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.String,System.String[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindAddIns">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca todos los complementos para la vista de host especificada del complemento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, location As PipelineStoreLocation) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberSignature Language="F#" Value="static member FindAddIns : Type * System.AddIn.Hosting.PipelineStoreLocation -&gt; System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;" Usage="System.AddIn.Hosting.AddInStore.FindAddIns (hostViewOfAddIn, location)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Tipo que define la vista del host del complemento.</param>
        <param name="location">Directorio base de la aplicación host.</param>
        <summary>Busca todos los complementos para la vista de host especificada del complemento en la ubicación especificada por un valor de la enumeración <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />.</summary>
        <returns>Colección de tokens que representan los complementos buscados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.AddIn.Hosting.PipelineStoreLocation> enumeración actualmente contiene solo la <xref:System.AddIn.Hosting.PipelineStoreLocation.ApplicationBase> valor, que señala al directorio de base de la aplicación del host.  
  
   
  
## Examples  
 En el ejemplo siguiente se buscan los complementos en la ubicación especificada por el <xref:System.AddIn.Hosting.PipelineStoreLocation> enumeración.  
  
 [!code-csharp[AddInP3Host#4](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#4)]
 [!code-vb[AddInP3Host#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="location" /> es un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" /> no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, System.AddIn.Hosting.PipelineStoreLocation location, params string[] addInFolderPaths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, valuetype System.AddIn.Hosting.PipelineStoreLocation location, string[] addInFolderPaths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.AddIn.Hosting.PipelineStoreLocation,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, location As PipelineStoreLocation, ParamArray addInFolderPaths As String()) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::AddIn::Hosting::PipelineStoreLocation location, ... cli::array &lt;System::String ^&gt; ^ addInFolderPaths);" />
      <MemberSignature Language="F#" Value="static member FindAddIns : Type * System.AddIn.Hosting.PipelineStoreLocation * string[] -&gt; System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;" Usage="System.AddIn.Hosting.AddInStore.FindAddIns (hostViewOfAddIn, location, addInFolderPaths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
        <Parameter Name="addInFolderPaths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Tipo que define la vista del host del complemento.</param>
        <param name="location">Uno de los valores de enumeración.  
  
Actualmente, el único valor en esta enumeración es el directorio especificado por la propiedad <see cref="P:System.AppDomainSetup.ApplicationBase" /> que se utilizó para configurar el dominio de aplicación del host.</param>
        <param name="addInFolderPaths">(Opcional). Ruta de acceso al directorio que contiene uno o varios subdirectorios de complementos. Dado que este parámetro toma una matriz de cadenas, puede especificar más de una ruta de acceso.  
  
No se requiere este parámetro si los complementos se encuentran en la estructura de directorios de canalizaciones bajo la carpeta AddIns (Complementos).</param>
        <summary>Busca todos los complementos para la vista de host especificada del complemento en la ubicación especificada por un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" /> y una carpeta de complementos opcional.</summary>
        <returns>Colección de tokens que representan los complementos buscados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para habilitar un host de confianza parcial, que no tenga permiso de descubrimiento de ruta de acceso para detectar su propia ubicación buscar complementos en su propio directorio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="location" /> es un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" /> no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAddIns">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt; FindAddIns (Type hostViewOfAddIn, string pipelineRootFolderPath, params string[] addInFolderPaths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.Collection`1&lt;class System.AddIn.Hosting.AddInToken&gt; FindAddIns(class System.Type hostViewOfAddIn, string pipelineRootFolderPath, string[] addInFolderPaths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.FindAddIns(System.Type,System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAddIns (hostViewOfAddIn As Type, pipelineRootFolderPath As String, ParamArray addInFolderPaths As String()) As Collection(Of AddInToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::ObjectModel::Collection&lt;System::AddIn::Hosting::AddInToken ^&gt; ^ FindAddIns(Type ^ hostViewOfAddIn, System::String ^ pipelineRootFolderPath, ... cli::array &lt;System::String ^&gt; ^ addInFolderPaths);" />
      <MemberSignature Language="F#" Value="static member FindAddIns : Type * string * string[] -&gt; System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;" Usage="System.AddIn.Hosting.AddInStore.FindAddIns (hostViewOfAddIn, pipelineRootFolderPath, addInFolderPaths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.AddIn.Hosting.AddInToken&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostViewOfAddIn" Type="System.Type" />
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
        <Parameter Name="addInFolderPaths" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="hostViewOfAddIn">Tipo que define la vista del host del complemento.</param>
        <param name="pipelineRootFolderPath">Ruta de acceso a la raíz de la estructura de directorios de canalizaciones.</param>
        <param name="addInFolderPaths">(Opcional). Ruta de acceso al directorio que contiene uno o varios subdirectorios de complementos. Dado que este parámetro toma una matriz de cadenas, puede especificar más de una ruta de acceso.  
  
No se requiere este parámetro si los complementos se encuentran en la estructura de directorios de canalizaciones bajo la carpeta AddIns (Complementos).</param>
        <summary>Busca todos los complementos para la vista de host especificada del complemento desde el directorio raíz especificado.</summary>
        <returns>Colección de tokens que representan los complementos buscados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina los archivos del almacén de información almacenada en caché de segmento de canalización y de complemento para buscar todos los complementos que coinciden con un determinado `hostAddInView` tipo. A continuación, puede usar uno de los tokens en el valor devuelto <xref:System.AddIn.Hosting.AddInToken> colección para activar un complemento específico mediante una llamada a la <xref:System.AddIn.Hosting.AddInToken.Activate%2A> método de la <xref:System.AddIn.Hosting.AddInToken> clase.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.FindAddIn(System.Type,System.String,System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Rebuild">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recompila la memoria caché de segmentos de canalización e incluye nuevos segmentos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Rebuild">
      <MemberSignature Language="C#" Value="public static string[] Rebuild (System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Rebuild(valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Rebuild(System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rebuild (location As PipelineStoreLocation) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Rebuild(System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberSignature Language="F#" Value="static member Rebuild : System.AddIn.Hosting.PipelineStoreLocation -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.Rebuild location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="location">Uno de los valores de enumeración.  
  
Actualmente, el único valor en esta enumeración es el directorio especificado por la propiedad <see cref="P:System.AppDomainSetup.ApplicationBase" /> que se utilizó para configurar el dominio de aplicación del host.</param>
        <summary>Recompila la memoria caché de segmentos de canalización e incluye nuevos segmentos en la ubicación especificada por un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para habilitar un host de confianza parcial, que no tenga permiso para detectar su propia ubicación detectar complementos en su propio directorio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="location" /> es un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" /> no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rebuild">
      <MemberSignature Language="C#" Value="public static string[] Rebuild (string pipelineRootFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Rebuild(string pipelineRootFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Rebuild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Rebuild (pipelineRootFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Rebuild(System::String ^ pipelineRootFolderPath);" />
      <MemberSignature Language="F#" Value="static member Rebuild : string -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.Rebuild pipelineRootFolderPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipelineRootFolderPath">Ruta de acceso a la raíz de la estructura de directorios de canalizaciones.</param>
        <summary>Recompila la memoria caché de segmentos de canalización e incluye nuevos segmentos del directorio raíz especificado.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método también vuelve a generar la caché de complementos si los complementos se encuentran en la estructura de directorios de la canalización.  
  
 Use este método solo cuando puede haber un problema con la memoria caché y deben volver a generarse. Para mejorar el rendimiento, utilice el <xref:System.AddIn.Hosting.AddInStore.Update%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.Update(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="RebuildAddIns">
      <MemberSignature Language="C#" Value="public static string[] RebuildAddIns (string addInsFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] RebuildAddIns(string addInsFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.RebuildAddIns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RebuildAddIns (addInsFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ RebuildAddIns(System::String ^ addInsFolderPath);" />
      <MemberSignature Language="F#" Value="static member RebuildAddIns : string -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.RebuildAddIns addInsFolderPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addInsFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="addInsFolderPath">Ruta de acceso al directorio que contiene uno o varios subdirectorios de complementos.</param>
        <summary>Recompila la memoria caché de complementos e incluye nuevos complementos del directorio raíz especificado.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método si los complementos están fuera de la estructura de directorios de la canalización.  
  
 Use este método solo cuando puede haber un problema con la memoria caché y deben volver a generarse. Para mejorar el rendimiento, utilice el <xref:System.AddIn.Hosting.AddInStore.UpdateAddIns%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="addInsFolderPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permisos de acceso de lectura y escritura a la ubicación que especifica <paramref name="addInsFolderPath" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder leer y actualizar la carpeta del complemento. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="M:System.AddIn.Hosting.AddInStore.UpdateAddIns(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Update">
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Actualiza la memoria caché de segmentos de canalización con nuevos segmentos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public static string[] Update (System.AddIn.Hosting.PipelineStoreLocation location);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Update(valuetype System.AddIn.Hosting.PipelineStoreLocation location) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Update(System.AddIn.Hosting.PipelineStoreLocation)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update (location As PipelineStoreLocation) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Update(System::AddIn::Hosting::PipelineStoreLocation location);" />
      <MemberSignature Language="F#" Value="static member Update : System.AddIn.Hosting.PipelineStoreLocation -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.Update location" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.5">
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="location" Type="System.AddIn.Hosting.PipelineStoreLocation" />
      </Parameters>
      <Docs>
        <param name="location">Uno de los valores de enumeración.  
  
Actualmente, el único valor en esta enumeración es el directorio especificado por la propiedad <see cref="P:System.AppDomainSetup.ApplicationBase" /> que se utilizó para configurar el dominio de aplicación del host.</param>
        <summary>Actualiza la memoria caché de segmentos de canalización con nuevos segmentos en la ubicación especificada por un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" />.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga del método para habilitar un host de confianza parcial, que no tenga permiso para detectar su propia ubicación detectar complementos en su propio directorio.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="location" /> es un valor de <see cref="T:System.AddIn.Hosting.PipelineStoreLocation" /> no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public static string[] Update (string pipelineRootFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] Update(string pipelineRootFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.Update(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Update (pipelineRootFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ Update(System::String ^ pipelineRootFolderPath);" />
      <MemberSignature Language="F#" Value="static member Update : string -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.Update pipelineRootFolderPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pipelineRootFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="pipelineRootFolderPath">Ruta de acceso a la raíz de la estructura de directorios de canalizaciones.</param>
        <summary>Actualiza la memoria caché de segmentos de canalización con nuevos segmentos del directorio raíz especificado.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método también actualiza la caché de complementos si los complementos se encuentran en la estructura de directorios de la canalización.  
  
 Si no hay ningún nuevos segmentos de canalización o complementos, este método sólo valida la memoria caché.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo actualizar los archivos en caché. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.AddIn.Hosting.AddInStore> clase.  
  
 [!code-csharp[AddInP3Host#3](~/samples/snippets/csharp/VS_Snippets_CLR/addinP3Host/cs/P3Host.cs#3)]
 [!code-vb[AddInP3Host#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/addinP3Host/vb/p3host.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpdateAddIns">
      <MemberSignature Language="C#" Value="public static string[] UpdateAddIns (string addInsFolderPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] UpdateAddIns(string addInsFolderPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AddIn.Hosting.AddInStore.UpdateAddIns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UpdateAddIns (addInsFolderPath As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ UpdateAddIns(System::String ^ addInsFolderPath);" />
      <MemberSignature Language="F#" Value="static member UpdateAddIns : string -&gt; string[]" Usage="System.AddIn.Hosting.AddInStore.UpdateAddIns addInsFolderPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AddIn</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addInsFolderPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="addInsFolderPath">Ruta de acceso al directorio que contiene uno o varios subdirectorios de complementos.</param>
        <summary>Actualiza la memoria caché de complementos e incluye nuevos complementos en la ubicación especificada.</summary>
        <returns>Colección de cadenas que describen advertencias a medida que se evalúan los segmentos de canalización.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método si los complementos están fuera de la estructura de directorios de la canalización.  
  
 Si no hay nuevos complementos están instalados, este método sólo valida la memoria caché.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AddIn.Hosting.AddInSegmentDirectoryNotFoundException">Falta un directorio de segmentos en la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.AddIn.Hosting.InvalidPipelineStoreException">Existe una infracción de acceso a la estructura de directorios de canalizaciones.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="addInsFolderPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permisos de acceso de lectura y escritura a la ubicación que especifica <paramref name="addInsFolderPath" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para poder leer y actualizar la carpeta del complemento. Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>