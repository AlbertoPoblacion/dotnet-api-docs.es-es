<Type Name="MenuCommandService" FullName="System.ComponentModel.Design.MenuCommandService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="26dfea945a3ba697efae1e3824c6a0ccf1f06a96" /><Meta Name="ms.sourcegitcommit" Value="1bb00d2f4343e73ae8d58668f02297a3cf10a4c1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="06/15/2019" /><Meta Name="ms.locfileid" Value="63898604" /></Metadata><TypeSignature Language="C#" Value="public class MenuCommandService : IDisposable, System.ComponentModel.Design.IMenuCommandService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuCommandService extends System.Object implements class System.ComponentModel.Design.IMenuCommandService, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.MenuCommandService" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuCommandService&#xA;Implements IDisposable, IMenuCommandService" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuCommandService : IDisposable, System::ComponentModel::Design::IMenuCommandService" />
  <TypeSignature Language="F#" Value="type MenuCommandService = class&#xA;    interface IMenuCommandService&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.IMenuCommandService</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa la interfaz <see cref="T:System.ComponentModel.Design.IMenuCommandService" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.MenuCommandService> la clase implementa la <xref:System.ComponentModel.Design.IMenuCommandService> interfaz, que es la interfaz administrada que se utiliza para agregar controladores para comandos de menú y definir verbos.  
  
 El <xref:System.ComponentModel.Design.MenuCommandService> clase automáticamente ofrecida por la clase de paquete comandos globales de un paquete completo, y también se ofrece por la `Microsoft.VisualStudio.Shell.WindowPane` clase ofrece los comandos de la ventana actual. Esta oferta siempre se realiza a través del contenedor de servicio, por lo que cualquier persona derivar desde el paquete o clases de ventana de panel pueden quitar o reemplazar la implementación predeterminada de la <xref:System.ComponentModel.Design.IMenuCommandService> interfaz.  
  
 La <xref:System.ComponentModel.Design.MenuCommandService> clase utiliza otros servicios. Todos estos servicios son opcionales, por lo que el comportamiento de la <xref:System.ComponentModel.Design.MenuCommandService> clase degrada si uno o más servicios se han perdido. La siguiente tabla muestra qué servicios se utilizan y su finalidad.  
  
|web de Office|Propósito|  
|-------------|-------------|  
|<xref:System.ComponentModel.Design.ISelectionService>|Se usa para detectar la selección actual con el fin de obtener los verbos proporcionados por el diseñador actualmente seleccionado.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Se usa para obtener el diseñador para el componente seleccionado actualmente, si existe alguno.|  
|`Microsoft.VisualStudio.Shell.Interop.IVsUIShell`|Se utiliza para notificar a Visual Studio que ha cambiado el estado del comando.|  
|`Microsoft.VisualStudio.Shell.Interop.IOleComponentUIManager`|Se usa para mostrar menús contextuales.|  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
    <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
    <altmember cref="T:System.ComponentModel.Design.CommandID" />
    <altmember cref="T:System.IServiceProvider" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuCommandService (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serviceProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuCommandService(IServiceProvider ^ serviceProvider);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Design.MenuCommandService : IServiceProvider -&gt; System.ComponentModel.Design.MenuCommandService" Usage="new System.ComponentModel.Design.MenuCommandService serviceProvider" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Proveedor de servicios que utiliza este servicio para obtener otros servicios.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.MenuCommandService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el servicio se utiliza con un diseñador, el `serviceProvider` parámetro debe ser el proveedor de servicios para el diseñador, como sucede con <xref:System.ComponentModel.Design.DesignSurface>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="AddCommand">
      <MemberSignature Language="C#" Value="public virtual void AddCommand (System.ComponentModel.Design.MenuCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddCommand(class System.ComponentModel.Design.MenuCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.AddCommand(System.ComponentModel.Design.MenuCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddCommand (command As MenuCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddCommand(System::ComponentModel::Design::MenuCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member AddCommand : System.ComponentModel.Design.MenuCommand -&gt; unit&#xA;override this.AddCommand : System.ComponentModel.Design.MenuCommand -&gt; unit" Usage="menuCommandService.AddCommand command" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.AddCommand(System.ComponentModel.Design.MenuCommand)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.ComponentModel.Design.MenuCommand" />
      </Parameters>
      <Docs>
        <param name="command"><see cref="T:System.ComponentModel.Design.MenuCommand" /> que se va a agregar.</param>
        <summary>Agrega un controlador de comandos al servicio de comandos de menú.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.MenuCommandService.AddCommand%2A> método agrega un controlador de comandos para el servicio de comandos de menú. Controladores de comandos no define el texto, el acceso directo o la selección de ubicación de un elemento de menú. En su lugar, define el comportamiento del elemento de menú si se hace clic en el elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ya existe un <paramref name="command" /> de controlador de comandos.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="AddVerb">
      <MemberSignature Language="C#" Value="public virtual void AddVerb (System.ComponentModel.Design.DesignerVerb verb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddVerb(class System.ComponentModel.Design.DesignerVerb verb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.AddVerb(System.ComponentModel.Design.DesignerVerb)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddVerb (verb As DesignerVerb)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddVerb(System::ComponentModel::Design::DesignerVerb ^ verb);" />
      <MemberSignature Language="F#" Value="abstract member AddVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit&#xA;override this.AddVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit" Usage="menuCommandService.AddVerb verb" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.AddVerb(System.ComponentModel.Design.DesignerVerb)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verb" Type="System.ComponentModel.Design.DesignerVerb" />
      </Parameters>
      <Docs>
        <param name="verb"><see cref="T:System.ComponentModel.Design.DesignerVerb" /> que se va a agregar.</param>
        <summary>Agrega un verbo a la tabla de verbos del objeto <see cref="T:System.ComponentModel.Design.MenuCommandService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este verbo está disponible, independientemente de qué diseñador está seleccionado actualmente. A diferencia de los comandos de menú, verbos pueden definir el texto que se muestra al usuario, pero no define la posición del comando en el menú real.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="verb" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.ComponentModel.Design.MenuCommandService" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="menuCommandService.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos los recursos que usa <see cref="T:System.ComponentModel.Design.MenuCommandService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> cuando haya terminado de usar <xref:System.ComponentModel.Design.MenuCommandService>. El método <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> deja el <xref:System.ComponentModel.Design.MenuCommandService> en un estado no utilizable. Después de llamar a <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A>, debe liberar todas las referencias a la <xref:System.ComponentModel.Design.MenuCommandService> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.ComponentModel.Design.MenuCommandService> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.ComponentModel.Design.MenuCommandService.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.ComponentModel.Design.MenuCommandService>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.ComponentModel.Design.MenuCommandService> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="menuCommandService.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera todos los recursos que usa <see cref="T:System.ComponentModel.Design.MenuCommandService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama por el público `Dispose()` método y el <xref:System.Object.Finalize%2A> método. `Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` parámetro es true, este método libera todos los recursos mantenidos por los objetos administrados que este <xref:System.ComponentModel.Design.MenuCommandService> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Cuando se reemplaza <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnsureVerbs">
      <MemberSignature Language="C#" Value="protected void EnsureVerbs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureVerbs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.EnsureVerbs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub EnsureVerbs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void EnsureVerbs();" />
      <MemberSignature Language="F#" Value="member this.EnsureVerbs : unit -&gt; unit" Usage="menuCommandService.EnsureVerbs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantiza que se ha creado la lista de verbos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.MenuCommandService.EnsureVerbs%2A> método crea la lista de verbos si ya no se ha creado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindCommand">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Busca el <see cref="T:System.ComponentModel.Design.MenuCommand" /> asociado al identificador de comandos especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindCommand">
      <MemberSignature Language="C#" Value="public System.ComponentModel.Design.MenuCommand FindCommand (System.ComponentModel.Design.CommandID commandID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.Design.MenuCommand FindCommand(class System.ComponentModel.Design.CommandID commandID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.FindCommand(System.ComponentModel.Design.CommandID)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::Design::MenuCommand ^ FindCommand(System::ComponentModel::Design::CommandID ^ commandID);" />
      <MemberSignature Language="F#" Value="abstract member FindCommand : System.ComponentModel.Design.CommandID -&gt; System.ComponentModel.Design.MenuCommand&#xA;override this.FindCommand : System.ComponentModel.Design.CommandID -&gt; System.ComponentModel.Design.MenuCommand" Usage="menuCommandService.FindCommand commandID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.FindCommand(System.ComponentModel.Design.CommandID)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandID" Type="System.ComponentModel.Design.CommandID" />
      </Parameters>
      <Docs>
        <param name="commandID"><see cref="T:System.ComponentModel.Design.CommandID" /> que se va a buscar.</param>
        <summary>Busca el <see cref="T:System.ComponentModel.Design.MenuCommand" /> asociado al identificador de comandos especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.Design.MenuCommand" /> asociado al comando especificado; en caso contrario, si no se encuentra el comando, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="FindCommand">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.MenuCommand FindCommand (Guid guid, int id);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.ComponentModel.Design.MenuCommand FindCommand(valuetype System.Guid guid, int32 id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.FindCommand(System.Guid,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::ComponentModel::Design::MenuCommand ^ FindCommand(Guid guid, int id);" />
      <MemberSignature Language="F#" Value="member this.FindCommand : Guid * int -&gt; System.ComponentModel.Design.MenuCommand" Usage="menuCommandService.FindCommand (guid, id)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommand</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Guid" />
        <Parameter Name="id" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="guid">GUID del comando.</param>
        <param name="id">Identificador del comando.</param>
        <summary>Busca el <see cref="T:System.ComponentModel.Design.MenuCommand" /> asociado al comando especificado.</summary>
        <returns>Objeto <see cref="T:System.ComponentModel.Design.MenuCommand" /> asociado al comando especificado; en caso contrario, si no se encuentra el comando, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetCommandList">
      <MemberSignature Language="C#" Value="protected System.Collections.ICollection GetCommandList (Guid guid);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ICollection GetCommandList(valuetype System.Guid guid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GetCommandList(System.Guid)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Collections::ICollection ^ GetCommandList(Guid guid);" />
      <MemberSignature Language="F#" Value="member this.GetCommandList : Guid -&gt; System.Collections.ICollection" Usage="menuCommandService.GetCommandList guid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="guid">GUID de la lista de comandos.</param>
        <summary>Obtiene la lista de comandos para un GUID determinado.</summary>
        <returns><see cref="T:System.Collections.ICollection" /> de comandos.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="protected object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ GetService(Type ^ serviceType);" />
      <MemberSignature Language="F#" Value="member this.GetService : Type -&gt; obj" Usage="menuCommandService.GetService serviceType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType"><see cref="T:System.Type" /> del servicio que se va a recuperar.</param>
        <summary>Obtiene una referencia sobre el servicio solicitado.</summary>
        <returns>Referencia a <paramref name="serviceType" />; en caso contrario, si no se encuentra el servicio, <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="serviceType" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GlobalInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Invoca un comando del formulario local o del entorno global.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GlobalInvoke">
      <MemberSignature Language="C#" Value="public virtual bool GlobalInvoke (System.ComponentModel.Design.CommandID commandID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GlobalInvoke(class System.ComponentModel.Design.CommandID commandID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GlobalInvoke(System::ComponentModel::Design::CommandID ^ commandID);" />
      <MemberSignature Language="F#" Value="abstract member GlobalInvoke : System.ComponentModel.Design.CommandID -&gt; bool&#xA;override this.GlobalInvoke : System.ComponentModel.Design.CommandID -&gt; bool" Usage="menuCommandService.GlobalInvoke commandID" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandID" Type="System.ComponentModel.Design.CommandID" />
      </Parameters>
      <Docs>
        <param name="commandID">Comando al que se va a invocar.</param>
        <summary>Invoca al comando especificado en el formulario local o en el entorno global.</summary>
        <returns><see langword="true" /> si se encuentra el comando; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primero se busca en el formulario local para el identificador de comando especificado. Si se encuentra, se invoca. En caso contrario, el identificador de comando se pasa al controlador de comandos de entorno global, si está disponible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="GlobalInvoke">
      <MemberSignature Language="C#" Value="public virtual bool GlobalInvoke (System.ComponentModel.Design.CommandID commandId, object arg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GlobalInvoke(class System.ComponentModel.Design.CommandID commandId, object arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.GlobalInvoke(System.ComponentModel.Design.CommandID,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool GlobalInvoke(System::ComponentModel::Design::CommandID ^ commandId, System::Object ^ arg);" />
      <MemberSignature Language="F#" Value="abstract member GlobalInvoke : System.ComponentModel.Design.CommandID * obj -&gt; bool&#xA;override this.GlobalInvoke : System.ComponentModel.Design.CommandID * obj -&gt; bool" Usage="menuCommandService.GlobalInvoke (commandId, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="commandId" Type="System.ComponentModel.Design.CommandID" />
        <Parameter Name="arg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="commandId">Comando al que se va a invocar.</param>
        <param name="arg">Parámetro para la invocación.</param>
        <summary>Invoca al comando especificado con el parámetro igualmente especificado en el formulario local o en el entorno global.</summary>
        <returns><see langword="true" /> si se encuentra el comando; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primero se busca en el formulario local para el identificador de comando especificado. Si se encuentra, se invoca. En caso contrario, el identificador de comando se pasa al controlador de comandos de entorno global, si está disponible.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="MenuCommandsChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.MenuCommandsChangedEventHandler MenuCommandsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.MenuCommandsChangedEventHandler MenuCommandsChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.MenuCommandService.MenuCommandsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuCommandsChanged As MenuCommandsChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::MenuCommandsChangedEventHandler ^ MenuCommandsChanged;" />
      <MemberSignature Language="F#" Value="member this.MenuCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventHandler " Usage="member this.MenuCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.MenuCommandsChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el estado de un comando de menú.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de cómo controlar eventos, vea [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCommandsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCommandsChanged (System.ComponentModel.Design.MenuCommandsChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCommandsChanged(class System.ComponentModel.Design.MenuCommandsChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCommandsChanged (e As MenuCommandsChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCommandsChanged(System::ComponentModel::Design::MenuCommandsChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventArgs -&gt; unit&#xA;override this.OnCommandsChanged : System.ComponentModel.Design.MenuCommandsChangedEventArgs -&gt; unit" Usage="menuCommandService.OnCommandsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.MenuCommandsChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.ComponentModel.Design.MenuCommandsChangedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.MenuCommandService.MenuCommandsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged%2A> método se llama mediante un comando de menú cuando ha cambiado su estado.  
  
 Cuando se genera un evento, se invoca el controlador de eventos a través de un delegado. Para obtener más información, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).  
  
 El método <xref:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged%2A> también permite que las clases derivadas controlen el evento sin adjuntar ningún delegado. Ésta es la técnica preferida para controlar el evento en una clase derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.ComponentModel.Design.MenuCommandService.OnCommandsChanged(System.ComponentModel.Design.MenuCommandsChangedEventArgs)" /> método para que los delegados registrados reciban el evento.</para></block>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCommand">
      <MemberSignature Language="C#" Value="public virtual void RemoveCommand (System.ComponentModel.Design.MenuCommand command);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveCommand(class System.ComponentModel.Design.MenuCommand command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.RemoveCommand(System.ComponentModel.Design.MenuCommand)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveCommand (command As MenuCommand)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveCommand(System::ComponentModel::Design::MenuCommand ^ command);" />
      <MemberSignature Language="F#" Value="abstract member RemoveCommand : System.ComponentModel.Design.MenuCommand -&gt; unit&#xA;override this.RemoveCommand : System.ComponentModel.Design.MenuCommand -&gt; unit" Usage="menuCommandService.RemoveCommand command" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.RemoveCommand(System.ComponentModel.Design.MenuCommand)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.ComponentModel.Design.MenuCommand" />
      </Parameters>
      <Docs>
        <param name="command">Comando que se va a quitar.</param>
        <summary>Quita del documento el comando de menú especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no hay ningún comando más en el grupo de comandos, se quita el grupo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="command" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="RemoveVerb">
      <MemberSignature Language="C#" Value="public virtual void RemoveVerb (System.ComponentModel.Design.DesignerVerb verb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveVerb(class System.ComponentModel.Design.DesignerVerb verb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.RemoveVerb(System.ComponentModel.Design.DesignerVerb)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveVerb (verb As DesignerVerb)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveVerb(System::ComponentModel::Design::DesignerVerb ^ verb);" />
      <MemberSignature Language="F#" Value="abstract member RemoveVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit&#xA;override this.RemoveVerb : System.ComponentModel.Design.DesignerVerb -&gt; unit" Usage="menuCommandService.RemoveVerb verb" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.RemoveVerb(System.ComponentModel.Design.DesignerVerb)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verb" Type="System.ComponentModel.Design.DesignerVerb" />
      </Parameters>
      <Docs>
        <param name="verb">Verbo que se va a quitar.</param>
        <summary>Quita del documento el verbo especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="verb" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="ShowContextMenu">
      <MemberSignature Language="C#" Value="public virtual void ShowContextMenu (System.ComponentModel.Design.CommandID menuID, int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ShowContextMenu(class System.ComponentModel.Design.CommandID menuID, int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.MenuCommandService.ShowContextMenu(System.ComponentModel.Design.CommandID,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ShowContextMenu (menuID As CommandID, x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ShowContextMenu(System::ComponentModel::Design::CommandID ^ menuID, int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member ShowContextMenu : System.ComponentModel.Design.CommandID * int * int -&gt; unit&#xA;override this.ShowContextMenu : System.ComponentModel.Design.CommandID * int * int -&gt; unit" Usage="menuCommandService.ShowContextMenu (menuID, x, y)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.Design.IMenuCommandService.ShowContextMenu(System.ComponentModel.Design.CommandID,System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuID" Type="System.ComponentModel.Design.CommandID" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="menuID">Menú contextual que se va a mostrar.</param>
        <param name="x">Coordenada x de la ubicación del menú contextual.</param>
        <param name="y">Coordenada y de la ubicación del menú contextual.</param>
        <summary>Muestra el menú contextual con el identificador de comandos especificado en la ubicación indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada no hace nada.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName="Verbs">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.Design.DesignerVerbCollection Verbs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.DesignerVerbCollection Verbs" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.MenuCommandService.Verbs" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Verbs As DesignerVerbCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::Design::DesignerVerbCollection ^ Verbs { System::ComponentModel::Design::DesignerVerbCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Verbs : System.ComponentModel.Design.DesignerVerbCollection" Usage="System.ComponentModel.Design.MenuCommandService.Verbs" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.Design.IMenuCommandService.Verbs</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.DesignerVerbCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de los verbos de diseñador que están disponibles actualmente.</summary>
        <value>Objeto <see cref="T:System.ComponentModel.Design.DesignerVerbCollection" /> de los verbos de diseñador que están disponibles actualmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.MenuCommandService.Verbs%2A> propiedad proporciona una colección de verbos. Estos verbos proceden de dos lugares:  
  
-   Los verbos que se agregan mediante el <xref:System.ComponentModel.Design.MenuCommandService.AddVerb%2A> método <xref:System.ComponentModel.Design.MenuCommandService.Verbs%2A>.  
  
-   Verbos proporcionados por el diseñador actualmente seleccionado.  
  
 Verbos agregados a este servicio a través de la <xref:System.ComponentModel.Design.MenuCommandService.AddVerb%2A> verbos globales se llama al método porque son globales para este servicio, pero por lo general, hay una instancia de este servicio para cada ventana de herramientas o documento. Verbos de diseñador se obtienen consultando el proveedor de servicios para <xref:System.ComponentModel.Design.IDesignerHost> y <xref:System.ComponentModel.Design.ISelectionService>. Si el servicio de selección ofrece una selección primaria y se puede obtener un diseñador para esa selección desde <xref:System.ComponentModel.Design.IDesignerHost>, verbos del diseñador se agregan a esta lista. Si el nombre de un verbo global entra en conflicto con el nombre de un verbo de diseñador, el verbo de diseñador proporcionado por el diseñador tiene prioridad.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.MenuCommand" />
        <altmember cref="T:System.ComponentModel.Design.DesignerVerb" />
        <altmember cref="T:System.ComponentModel.Design.CommandID" />
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
  </Members>
</Type>