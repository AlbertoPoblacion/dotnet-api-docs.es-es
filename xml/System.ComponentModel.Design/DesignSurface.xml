<Type Name="DesignSurface" FullName="System.ComponentModel.Design.DesignSurface">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3aa7493e17750216c5342b1ee5e784080710e3a2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30370469" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DesignSurface : IDisposable, IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DesignSurface extends System.Object implements class System.IDisposable, class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.DesignSurface" />
  <TypeSignature Language="VB.NET" Value="Public Class DesignSurface&#xA;Implements IDisposable, IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class DesignSurface : IDisposable, IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Presenta una interfaz de usuario para el diseño de componentes.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.ComponentModel.Design.DesignSurface> clase implementa lo que el usuario percibe como un diseñador. <xref:System.ComponentModel.Design.DesignSurface> es que la interfaz de usuario del usuario manipula para cambiar las características en tiempo de diseño. <xref:System.ComponentModel.Design.DesignSurface> Proporciona una superficie de diseño completamente autónomo.  
  
 El <xref:System.ComponentModel.Design.DesignSurface> clase puede utilizarse como un diseñador independiente o lo puede conllevar la <xref:System.ComponentModel.Design.DesignSurfaceManager> clase para proporcionar una implementación común para una aplicación que hospeda varios <xref:System.ComponentModel.Design.DesignSurface> objetos.  
  
 La <xref:System.ComponentModel.Design.DesignSurface> clase puede usarse por sí mismo, o el usuario puede derivar una nueva clase y ampliar su comportamiento.  
  
 La <xref:System.ComponentModel.Design.DesignSurface> clase proporciona varios servicios en tiempo de diseño automáticamente. La <xref:System.ComponentModel.Design.DesignSurface> clase agrega todos sus servicios en su constructor. La mayoría de estos servicios puede reemplazarse por reemplazarlos en protegido <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> propiedad. Para reemplazar un servicio, reemplace el constructor, llame a la base y realice los cambios a través de la protegido <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> propiedad. Todos los servicios que se agregan al contenedor de servicios y que implementen <xref:System.IDisposable> se eliminan cuando se elimina la superficie de diseño. El conjunto predeterminado de reemplazables servicios a los que la <xref:System.ComponentModel.Design.DesignSurface> clase proporciona se muestra en la tabla siguiente.  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IExtenderProviderService>|Permite que los objetos que no forman parte de la colección de componentes del contenedor para proporcionar sus propios proveedores de extender.|  
|<xref:System.ComponentModel.Design.IExtenderListService>|Utilizado por <xref:System.ComponentModel.TypeDescriptor> para obtener una lista de proveedores extensores. Con este servicio, los proveedores extensores pueden residir fuera del contenedor.|  
|<xref:System.ComponentModel.Design.ITypeDescriptorFilterService>|Proporciona enlaces de metadatos del diseñador. Se trata de la interfaz principal para el filtrado de metadatos.|  
|<xref:System.ComponentModel.Design.ISelectionService>|Proporciona una manera para seleccionar componentes en el diseñador.|  
|<xref:System.ComponentModel.Design.IReferenceService>|Proporciona una manera de obtener un nombre para los objetos, incluso cuando no están ubicados los objetos.|  
|<xref:System.ComponentModel.Design.DesignSurface>|Ofrece la superficie de diseño como un servicio.|  
|<xref:System.ComponentModel.Design.DesignerOptionService>|Proporciona una clase base para obtener y establecer valores de opciones de un diseñador.|  
  
 La siguiente tabla muestra los servicios que no se pueden reemplazar proporcionados de forma predeterminada.  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IComponentChangeService>|Genera eventos cuando se realizan cambios en componentes.|  
|<xref:System.ComponentModel.Design.IDesignerHost>|Controla el acceso a los tipos, servicios y transacciones. Interfaz principal para los diseñadores.|  
|<xref:System.ComponentModel.IContainer>|Posee el conjunto de componentes que se está diseñando. Cada diseñador tiene una <xref:System.ComponentModel.IContainer> que posee los componentes.|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Se deriva de <xref:System.IServiceProvider> y proporciona una manera de agregar y quitar servicios del diseñador.|  
  
 Además de estos servicios, el <xref:System.ComponentModel.Design.DesignSurface> clase también proporciona un servicio único que está disponible a través del sitio de un componente. Este servicio es único para cada componente. La siguiente tabla muestra los servicios que no se puede reemplazar.  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IDictionaryService>|Un diccionario genérico de pares clave/valor que puede utilizarse para almacenar datos arbitrarios sobre un componente.|  
|<xref:System.ComponentModel.INestedContainer>|Un contenedor que permite que un componente agregar componentes secundarios adicionales al diseñador. Estos componentes formarán parte de la superficie de diseño, pero no participará en la serialización. Esto es útil cuando desea diseñar un control que es capaz de exponer una región de sí mismo en un diseñador, pero no desea que la región participe en la serialización.|  
  
 Además <xref:System.ComponentModel.ISite>, el sitio también implementa las interfaces siguientes.  
  
> [!CAUTION]
>  Comprobar la existencia de estas interfaces, en lugar de recurrir a una conversión, porque otras implementaciones de sitio no pueden implementarlos.  
  
|web de Office|Descripción|  
|-------------|-----------------|  
|<xref:System.ComponentModel.Design.IServiceContainer>|Proporciona una manera para obtener el contenedor de servicios específicos de sitio. Por ejemplo, <xref:System.ComponentModel.Design.IDictionaryService> es un servicio específico del sitio. Con este servicio, puede agregar servicios específicos de sitio adicionales.|  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valores de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Estado asociado:</permission>
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.IServiceProvider" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Proveedor de servicios primario o <see langword="null" /> si no se usa ningún elemento primario para resolver servicios.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando `parentProvide` está presente, diseñadores contenidos dentro de la superficie pueden recuperar servicios de la aplicación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(Type ^ rootComponentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Tipo de componente raíz que se va a crear.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> constructor, crea un cargador de diseñadores simple que, a su vez, se crea un componente del tipo especificado y, a continuación, finaliza el proceso de carga. Se trata de una manera sencilla para crear un diseñador, bajo el supuesto de que todos los almacenamiento de estado se realizará externamente. Internamente, se llama a <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> y pasa el tipo de componente raíz.  
  
> [!NOTE]
>  El <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> sobrecarga no se ve afectada por <xref:System.Windows.Forms.Design.DesignerOptions>. El <xref:System.Windows.Forms.Design.DesignerOptions> debe estar en el contenedor de servicio antes de la carga de la superficie de diseño. Si necesita acceso a <xref:System.Windows.Forms.Design.DesignerOptions>, llame al constructor vacío, agregue el <xref:System.Windows.Forms.Design.DesignerOptions> a la <xref:System.ComponentModel.Design.DesignSurface.ServiceContainer%2A> y llame a <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> con `rootComponentType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DesignSurface (IServiceProvider parentProvider, Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IServiceProvider parentProvider, class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.#ctor(System.IServiceProvider,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parentProvider As IServiceProvider, rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DesignSurface(IServiceProvider ^ parentProvider, Type ^ rootComponentType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parentProvider" Type="System.IServiceProvider" />
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parentProvider">Proveedor de servicios primario o <see langword="null" /> si no se usa ningún elemento primario para resolver servicios.</param>
        <param name="rootComponentType">Tipo de componente raíz que se va a crear.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mediante el <xref:System.ComponentModel.Design.DesignSurface.%23ctor%2A> constructor crea un cargador de diseñadores simple que se crea un componente del tipo especificado y, a continuación, finaliza el proceso de carga. Se trata de una manera sencilla para crear un diseñador, bajo el supuesto de que todos los almacenamiento de estado se realizará externamente. Internamente, se llama a <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> y pasa el tipo de componente raíz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponent" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
        <altmember cref="T:System.IServiceProvider" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginLoad">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza el proceso de carga.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (System.ComponentModel.Design.Serialization.DesignerLoader loader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.ComponentModel.Design.Serialization.DesignerLoader loader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.ComponentModel.Design.Serialization.DesignerLoader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (loader As DesignerLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(System::ComponentModel::Design::Serialization::DesignerLoader ^ loader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loader" Type="System.ComponentModel.Design.Serialization.DesignerLoader" />
      </Parameters>
      <Docs>
        <param name="loader">Cargador de diseñadores que se va a emplear para cargar el diseñador.</param>
        <summary>Comienza el proceso de carga con el cargador de diseñadores especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Carga del diseñador puede ser asincrónica, por lo que la carga puede continuar después de que se devuelva la llamada. Adjuntar un controlador de eventos para el <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventos para recibir una notificación cuando haya terminado de cargarse la superficie de diseño.  
  
 Después de <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> es llama, se puede obtener inmediatamente la vista para el diseñador, porque los cargadores de diseñadores deben proporcionar al menos el componente raíz al cargar de forma asincrónica.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="loader" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.DesignerLoader" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
      </Docs>
    </Member>
    <Member MemberName="BeginLoad">
      <MemberSignature Language="C#" Value="public void BeginLoad (Type rootComponentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoad(class System.Type rootComponentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.BeginLoad(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoad (rootComponentType As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoad(Type ^ rootComponentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootComponentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="rootComponentType">Tipo de componente que se va a crear en modo de diseño.</param>
        <summary>Comienza el proceso de carga.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando `rootComponentType` se especifica, un cargador de diseñadores predeterminado que simplemente crea una instancia de `rootComponentType` se usará. Carga del diseñador puede ser asincrónica, por lo que la carga puede continuar después de que se devuelva la llamada. Adjuntar un controlador de eventos para el <xref:System.ComponentModel.Design.IDesignerHost.LoadComplete> eventos para recibir una notificación cuando haya terminado de cargarse la superficie de diseño.  
  
 Después de <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> es llama, se puede obtener inmediatamente la vista para el diseñador, porque los cargadores de diseñadores deben proporcionar al menos el componente raíz al cargar de forma asincrónica.  
  
> [!NOTE]
>  El <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> método crea una instancia del tipo de componente e inicializa un diseñador para esta instancia. El <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento se desencadena antes de que este método devuelve.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rootComponentType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComponentContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.IContainer ComponentContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IContainer ComponentContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ComponentContainer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ComponentContainer As IContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::IContainer ^ ComponentContainer { System::ComponentModel::IContainer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la implementación de <see cref="T:System.ComponentModel.IContainer" /> en la superficie de diseño.</summary>
        <value>Implementación de <see cref="T:System.ComponentModel.IContainer" /> en la superficie de diseño.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A> propiedad contiene todos los objetos que están actualmente en modo de diseño. Cuando se agregan componentes a <xref:System.ComponentModel.Design.DesignSurface.ComponentContainer%2A>, su diseñador, si existe, está cargado. El componente está ubicado en un sitio que proporciona acceso completo a la superficie de diseño.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateComponent">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.IComponent CreateComponent (Type componentType);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.IComponent CreateComponent(class System.Type componentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateComponent(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateComponent (componentType As Type) As IComponent" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::IComponent ^ CreateComponent(Type ^ componentType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateComponent has been replaced by CreateInstance and will be removed after Beta2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="componentType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="componentType">Tipo de componente que se va a crear.</param>
        <summary>Crea una instancia de un componente.</summary>
        <returns>Componente recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.CreateComponent%2A> método llama a la superficie de diseño <xref:System.ComponentModel.Design.IDesignerHost.CreateComponent%2A> método para crear una instancia de un componente. El componente debe pueden crearse y agregarse al contenedor público en la superficie de diseño.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="componentType" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateDesigner">
      <MemberSignature Language="C#" Value="protected internal virtual System.ComponentModel.Design.IDesigner CreateDesigner (System.ComponentModel.IComponent component, bool rootDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.ComponentModel.Design.IDesigner CreateDesigner(class System.ComponentModel.IComponent component, bool rootDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateDesigner(System.ComponentModel.IComponent,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function CreateDesigner (component As IComponent, rootDesigner As Boolean) As IDesigner" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::ComponentModel::Design::IDesigner ^ CreateDesigner(System::ComponentModel::IComponent ^ component, bool rootDesigner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.IDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
        <Parameter Name="rootDesigner" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="component">Componente para el que se debe crear el diseñador.</param>
        <param name="rootDesigner">
          Es <see langword="true" /> para crear un diseñador raíz; es <see langword="false" /> para crear un diseñador normal.</param>
        <summary>Crea un diseñador cuando se agrega un componente al contenedor.</summary>
        <returns>Instancia del diseñador solicitado o <see langword="null" /> si no se encuentra ningún diseñador que coincida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> método llama a la superficie de diseño <xref:System.ComponentModel.IContainer> cuando se agrega un componente al contenedor. Este método crea un diseñador, pero no inicializa. Al regresar, se inicializa el diseñador con el contenedor.  
  
 <xref:System.ComponentModel.Design.DesignSurface.CreateDesigner%2A> puede crear dos tipos diferentes de diseñadores: diseñadores raíz y los diseñadores normales. Un diseñador raíz es un diseñador para el componente de raíz en la superficie de diseño que, por definición, es el primer componente es agregado al contenedor. Los diseñadores raíz difieren de los diseñadores normales porque son responsables de la interfaz de usuario que se presentan al usuario final. Diseñadores raíz normalmente se coordinan con el resto de los diseñadores en una superficie de diseño para proporcionar esta interfaz.  
  
 La implementación predeterminada de este método delega en <xref:System.ComponentModel.TypeDescriptor>, pasando <xref:System.ComponentModel.Design.IRootDesigner> como el tipo de diseñador para los diseñadores raíz, o <xref:System.ComponentModel.Design.IDesigner> para los diseñadores normales. Puede invalidar este método para solicitar un tipo específico de diseñador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="component" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected internal virtual object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ CreateInstance(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo que se va a crear.</param>
        <summary>Crea una instancia del tipo especificado.</summary>
        <returns>El objeto recién creado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `type` es un <xref:System.ComponentModel.IComponent>, <xref:System.ComponentModel.Design.DesignSurface.CreateInstance%2A> busca un constructor de tipo <xref:System.ComponentModel.IContainer> en primer lugar, seguido de un constructor vacío.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNestedContainer">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea un contenedor adecuado para anidar controles o componentes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Componente que administra el contenedor anidado.</param>
        <summary>Crea un contenedor adecuado para anidar controles o componentes.</summary>
        <returns>Contenedor anidado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agregar un componente a un contenedor anidado crea su diseñador y sea apto para todos los servicios disponibles en la superficie de diseño. Los componentes agregados a los contenedores anidados no participan en la serialización.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNestedContainer">
      <MemberSignature Language="C#" Value="public System.ComponentModel.INestedContainer CreateNestedContainer (System.ComponentModel.IComponent owningComponent, string containerName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.ComponentModel.INestedContainer CreateNestedContainer(class System.ComponentModel.IComponent owningComponent, string containerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.CreateNestedContainer(System.ComponentModel.IComponent,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateNestedContainer (owningComponent As IComponent, containerName As String) As INestedContainer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::ComponentModel::INestedContainer ^ CreateNestedContainer(System::ComponentModel::IComponent ^ owningComponent, System::String ^ containerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.INestedContainer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owningComponent" Type="System.ComponentModel.IComponent" />
        <Parameter Name="containerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owningComponent">Componente que administra el contenedor anidado.</param>
        <param name="containerName">Nombre adicional para el contenedor anidado.</param>
        <summary>Crea un contenedor adecuado para anidar controles o componentes.</summary>
        <returns>Contenedor anidado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Agregar un componente a un contenedor anidado crea su diseñador y sea apto para todos los servicios disponibles en la superficie de diseño. Los componentes agregados a los contenedores anidados no participan en la serialización.  
  
 Puede proporcionar un nombre adicional para el <xref:System.ComponentModel.Design.DesignSurface.CreateNestedContainer%2A> método pasando un valor en `containerName`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owningComponent" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Público <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> método sigue el estándar <xref:System.IDisposable> patrón. Llamar a este método destruye la superficie de diseño. La versión protegida de este método es `virtual` y sigue la normal <xref:System.IDisposable> patrón.  
  
> [!NOTE]
>  Dado que <xref:System.ComponentModel.Design.DesignSurface> no tiene ningún código nativo para limpiar, no tiene un finalizador que llama <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>. Si necesita llamar a <xref:System.ComponentModel.Design.DesignSurface.Dispose%28System.Boolean%29>, debe agregar un finalizador.  
  
 Llame a <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> cuando haya terminado de usar <xref:System.ComponentModel.Design.DesignSurface>. El método <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> deja el <xref:System.ComponentModel.Design.DesignSurface> en un estado no utilizable. Después de llamar a <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, debe liberar todas las referencias a la <xref:System.ComponentModel.Design.DesignSurface> para que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.ComponentModel.Design.DesignSurface> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.ComponentModel.Design.DesignSurface>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.ComponentModel.Design.DesignSurface> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</param>
        <summary>Libera los recursos que usa <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Público <xref:System.ComponentModel.Design.DesignSurface.Dispose> método sigue el estándar <xref:System.IDisposable> patrón. Llamar a este método destruye la superficie de diseño. La versión protegida de este método es `virtual` y sigue la normal <xref:System.IDisposable> patrón.  
  
> [!NOTE]
>  Dado que <xref:System.ComponentModel.Design.DesignSurface> no tiene ningún código nativo para limpiar, no tiene un finalizador que llama <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>. Si necesita llamar a <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A>, debe agregar un finalizador.  
  
 Se llama a este método público `Dispose()` método y <xref:System.Object.Finalize%2A> método. `Dispose()` se invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.  
  
 Cuando el `disposing` del parámetro es true, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.ComponentModel.Design.DesignSurface> referencias. Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos. Al reemplazar <see langword="Dispose(Boolean)" /> tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />. Para obtener más información sobre cómo implementar <see langword="Dispose(Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see langword="Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Disposed" />
      <MemberSignature Language="VB.NET" Value="Public Event Disposed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Disposed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se desecha la superficie de diseño.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La superficie es únicamente cuando desechado público <xref:System.ComponentModel.Design.DesignSurface.Dispose%2A> método en <xref:System.ComponentModel.Design.DesignSurface> se llama.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DtelLoading">
      <MemberSignature Language="C#" Value="public bool DtelLoading { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtelLoading" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.DtelLoading" />
      <MemberSignature Language="VB.NET" Value="Public Property DtelLoading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtelLoading { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se está cargando la **Lista de errores en tiempo de diseño**.</summary>
        <value>
          <see langword="true" /> Si el **lista de errores de tiempo de diseño** se está cargando; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Serializa los cambios en la superficie de diseño.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> método puede llamarse para insertar los cambios realizados en la superficie de diseño hacia abajo hasta el serializador. Esto garantiza que la superficie de diseño y su estado serializado están sincronizados. La implementación real de este método se reenvía al cargador de diseñadores asociado a la superficie de diseño. El cargador de diseñadores puede decidir aplazar los cambios hasta que <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> se llama, o puede optar por mantener al día con todos los cambios de usuario los datos serializados. El <xref:System.ComponentModel.Design.DesignSurface.Flush%2A> método garantiza que, independientemente del modelo elige usar el cargador de diseñadores, el estado serializado está sincronizado con la superficie de diseño real.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flushed">
      <MemberSignature Language="C#" Value="public event EventHandler Flushed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Flushed" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Flushed" />
      <MemberSignature Language="VB.NET" Value="Public Event Flushed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Flushed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se realiza una llamada al método <see cref="M:System.ComponentModel.Design.DesignSurface.Flush" /> de <see cref="T:System.ComponentModel.Design.DesignSurface" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cargador de diseñadores se vacía en primer lugar y, a continuación, el <xref:System.ComponentModel.Design.DesignSurface.Flushed> evento se desencadena.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetService">
      <MemberSignature Language="C#" Value="public object GetService (Type serviceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetService(class System.Type serviceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetService (serviceType As Type) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetService(Type ^ serviceType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="serviceType">Tipo de servicio que se va a recuperar.</param>
        <summary>Obtiene un servicio del contenedor de servicios.</summary>
        <returns>Objeto que implementa, o es una clase derivada de, <paramref name="serviceType" /> o <see langword="null" /> si el servicio no existe en el contenedor de servicios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.GetService%2A> método recupera un servicio en el contenedor de servicios de la superficie de diseño. Además, esto se reenvía a cualquier proveedor de servicios que se asignó a la superficie de diseño en tiempo de construcción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la superficie de diseño está cargada actualmente.</summary>
        <value>
          Es <see langword="true" /> si la superficie de diseño está cargada actualmente; de lo contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.Design.LoadedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.Design.LoadedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Loaded As LoadedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::Design::LoadedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.LoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se completa la carga del diseñador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.Loaded> evento se desencadena para las cargas correctas, así como que no lo son. Si este controlador de eventos produce una excepción, el diseñador se descarga.  
  
 La <xref:System.ComponentModel.Design.LoadedEventArgs> objeto puede utilizarse para determinar si la carga se ha realizado correctamente, y también puede proporcionar una lista de errores que se produjeron durante la carga.  
  
> [!NOTE]
>  Pueden producirse errores cargas correctas, siempre que el sistema de serialización puede tolerar errores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadErrors">
      <MemberSignature Language="C#" Value="public System.Collections.ICollection LoadErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection LoadErrors" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.LoadErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LoadErrors As ICollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ICollection ^ LoadErrors { System::Collections::ICollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una colección de errores de carga o una colección nula.</summary>
        <value>Objeto <see cref="T:System.Collections.ICollection" /> de errores de carga.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loading">
      <MemberSignature Language="C#" Value="public event EventHandler Loading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Loading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Loading" />
      <MemberSignature Language="VB.NET" Value="Public Event Loading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Loading;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el diseñador está a punto de cargarse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnLoaded (System.ComponentModel.Design.LoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoaded(class System.ComponentModel.Design.LoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoaded(System.ComponentModel.Design.LoadedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoaded (e As LoadedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoaded(System::ComponentModel::Design::LoadedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.Design.LoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.ComponentModel.Design.LoadedEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.DesignSurface.Loaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoading">
      <MemberSignature Language="C#" Value="protected virtual void OnLoading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnLoading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoading(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.DesignSurface.Loading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloaded">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloaded (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloaded(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloaded(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloaded (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloaded(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.DesignSurface.Unloaded" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnloading">
      <MemberSignature Language="C#" Value="protected virtual void OnUnloading (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnUnloading(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnUnloading(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnUnloading (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnUnloading(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.DesignSurface.Unloading" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnViewActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnViewActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnViewActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.DesignSurface.OnViewActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnViewActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnViewActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceContainer">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.Design.ServiceContainer ServiceContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ServiceContainer ServiceContainer" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.ServiceContainer" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceContainer As ServiceContainer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::ComponentModel::Design::ServiceContainer ^ ServiceContainer { System::ComponentModel::Design::ServiceContainer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ServiceContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contenedor de servicios.</summary>
        <value>Contenedor de servicios que proporciona todos los servicios a los diseñadores incluidos en la superficie de diseño.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En tiempo de construcción, <xref:System.ComponentModel.Design.DesignSurface> agrega servicios predeterminados a este contenedor de servicios. Puede dejar los servicios predeterminados en su estado actual, o puede quitarlos y reemplácelos por los suyos propios. Los servicios predeterminados son todos los creados para petición, así que no hay ninguna pérdida de rendimiento si se agregan en tiempo de construcción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event EventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloaded As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un diseñador ha finalizado la descarga.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event EventHandler Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unloading" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Event Unloading As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Unloading;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando un diseñador está a punto de descargarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se descarga un diseñador, se destruye todo el estado de ese diseñador, incluida la vista del diseñador. La vista debe tener un elemento primario en este momento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="View">
      <MemberSignature Language="C#" Value="public object View { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object View" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.DesignSurface.View" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property View As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ View { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la vista para el diseñador raíz.</summary>
        <value>Vista para el diseñador raíz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> método debe llamarse con antelación para iniciar el proceso de carga. Es posible devolver una vista antes de que el cargador de diseñadores finalice la carga porque el diseñador raíz, que proporciona la vista, es el primer objeto creado por el cargador de diseñadores. Si una vista no está disponible, <xref:System.ComponentModel.Design.DesignSurface.BeginLoad%2A> produce una excepción.  
  
 La noción de una tecnología de vista está obsoleta. Sin embargo, permanece en las interfaces para los diseñadores raíz para la compatibilidad con versiones anteriores. Su uso está oculta para cualquiera que use <xref:System.ComponentModel.Design.DesignSurface> objetos. El <xref:System.ComponentModel.Design.DesignSurface.View%2A> propiedad oculta las tecnologías de vista pasando las tecnologías compatibles en el diseñador raíz.  
  
   
  
## Examples  
 El siguiente ejemplo de código muestra cómo <xref:System.ComponentModel.Design.DesignSurface.View%2A> oculta Ver tecnologías.  
  
 ```csharp 
 IRootDesigner d;  
  
 ViewTechnology[] supported = d.SupportedTechnologies;  
  
 return d.GetView(supported[0]);
 ``` 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La superficie de diseño no se está cargando, el cargador de diseñadores todavía no ha creado un diseñador raíz o la superficie de diseño ha finalizado la carga pero con errores. Puede haber más información disponible en la propiedad <see cref="P:System.Exception.InnerException" />.</exception>
        <exception cref="T:System.NotSupportedException">El diseñador está cargado, pero no ofrece una vista compatible con esta superficie de diseño.</exception>
        <exception cref="T:System.ObjectDisposedException">La interfaz <see cref="T:System.ComponentModel.Design.IDesignerHost" /> asociada al objeto <see cref="T:System.ComponentModel.Design.DesignSurface" /> se ha desechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ViewActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ViewActivated" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.Design.DesignSurface.ViewActivated" />
      <MemberSignature Language="VB.NET" Value="Public Event ViewActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ViewActivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se ha llamado al método <see cref="M:System.ComponentModel.Design.IDesignerHost.Activate" /> en <see cref="T:System.ComponentModel.Design.IDesignerHost" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si desea admitir la <xref:System.ComponentModel.Design.IDesignerHost.Activate%2A> método, el controlador de eventos debe activar la ventana para esta superficie de diseño.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
      </Docs>
    </Member>
  </Members>
</Type>