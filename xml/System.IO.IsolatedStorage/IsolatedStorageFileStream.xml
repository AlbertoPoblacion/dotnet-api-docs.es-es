<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8eb05ccb12109231f5298b1737311d1a391259c9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30420479" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expone un archivo dentro del almacenamiento aislado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta clase para leer, escribir y crear archivos en almacenamiento aislado.  
  
 Puesto que esta clase extiende <xref:System.IO.FileStream>, puede utilizar una instancia de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> en la mayoría de las situaciones donde un <xref:System.IO.FileStream> si no se puede utilizar, como construir un <xref:System.IO.StreamReader> o <xref:System.IO.StreamWriter>.  
  
 Este tipo implementa la <xref:System.IDisposable> interfaz. Cuando haya terminado de utilizar el tipo, debe eliminar del mismo directa o indirectamente. Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque. Para deshacerse de él indirectamente, use una construcción de lenguaje como `using` (en C#) o `Using` (en Visual Basic). Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.  
  
> [!IMPORTANT]
>  El almacenamiento aislado no está disponible para las aplicaciones de la [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]. En su lugar, se pueden usar las clases de datos de la aplicación del espacio de nombres `Windows.Storage` incluidas en la API de [!INCLUDE[wrt](~/includes/wrt-md.md)] para almacenar archivos y datos locales. Para más información, vea [Datos de aplicación](http://go.microsoft.com/fwlink/?LinkId=229175) en el Centro de desarrollo de Windows.  
  
   
  
## Examples  
 La siguiente aplicación de consola demuestra cómo puede usar <xref:System.IO.IsolatedStorage.IsolatedStorageFile> y <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> para escribir datos en un archivo de almacenamiento aislado. Se pide al usuario para iniciar sesión. Si el usuario es un usuario nuevo, se registran una dirección URL de noticias y una dirección URL de deportes como preferencias personales en el almacenamiento aislado. Si el usuario es un usuario devolver, se muestran las preferencias del usuario actual. Los ejemplos de código que se utilizan a lo largo de este espacio de nombres se presentan en el contexto de esta aplicación de ejemplo. Puede usar el [Storeadm.exe (herramienta de almacenamiento aislado)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) utilidad para enumerar y quitar los archivos de almacenamiento aislado que se crean con esta aplicación de consola.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />. La única forma de abrir <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> es mediante uno de sus constructores.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <summary>Inicializa una nueva instancia de un objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> que proporciona acceso al archivo indicado por el parámetro <paramref name="path" /> en el parámetro <paramref name="mode" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El almacén aislado que se utiliza tiene un ámbito por la identidad del ensamblado ejecución actual y del dominio de aplicación en el que se está ejecutando. Este almacén permanecerá abierto solo para la duración de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar un ámbito de almacenamiento aislado distinto, o para permitir que el almacén permanezca abierto (por lo que varias <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos pueden abrirse desde el mismo), utilice el formulario del constructor que acepta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 El `mode` parámetro indica si debe crearse un nuevo archivo, uno existente que utiliza y así sucesivamente.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de <paramref name="path" /> no existe.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y el parámetro <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo designado por el parámetro <paramref name="path" />, de la manera especificada en <paramref name="mode" />, y con el tipo de parámetro <paramref name="access" /> solicitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El almacén aislado que se utiliza tiene un ámbito por la identidad del ensamblado ejecución actual y del dominio de aplicación en el que se está ejecutando. Este almacén permanecerá abierto solo para la duración de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar un ámbito de almacenamiento aislado distinto, o para permitir que el almacén permanezca abierto (por lo que varias <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos pueden abrirse desde el mismo), utilice el formulario del constructor que acepta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 El `mode` parámetro indica si debe crearse un archivo nuevo o uno existente que utiliza. El `access` parámetro incluye sólo lectura, lectura/escritura y de solo escritura.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> donde se va a abrir <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo designado por el parámetro <paramref name="path" />, de la manera especificada en <paramref name="mode" /> y en el contexto de <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> que defina el parámetro <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro indica si debe crearse un nuevo archivo, uno existente que utiliza y así sucesivamente.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este constructor. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> no tiene una cuota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinación bit a bit de los valores de <see cref="T:System.IO.FileShare" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo indicado por el parámetro <paramref name="path" /> en el parámetro <paramref name="mode" /> especificado, con el parámetro <paramref name="access" /> indicado y según el modo de uso compartido de archivos definido por el parámetro <paramref name="share" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El almacén aislado que se utiliza tiene un ámbito por la identidad del ensamblado ejecución actual y del dominio de aplicación en el que se está ejecutando. Este almacén permanecerá abierto solo para la duración de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar un ámbito de almacenamiento aislado distinto, o para permitir que el almacén permanezca abierto (por lo que varias <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos pueden abrirse desde el mismo), utilice el formulario del constructor que acepta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este constructor. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> donde se va a abrir <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo indicado por el parámetro <paramref name="path" /> en el parámetro <paramref name="mode" /> especificado, con el <paramref name="access" /> especificado y en el contexto de <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> que defina el parámetro <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro indica si debe crearse un archivo nuevo o uno existente que utiliza. El `access` parámetro incluye sólo lectura, lectura/escritura y de solo escritura.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este constructor. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Se cierra el almacén aislado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> se establece en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> no tiene una cuota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinación bit a bit de los valores de <see cref="T:System.IO.FileShare" />.</param>
        <param name="bufferSize">Tamaño de búfer de <see cref="T:System.IO.FileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo designado por el parámetro <paramref name="path" />, de la manera especificada en <paramref name="mode" />, con el parámetro <paramref name="access" /> especificado, con el modo de uso compartido de archivos definido por el parámetro <paramref name="share" /> y con el valor de <paramref name="buffersize" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El almacén aislado que se utiliza tiene un ámbito por la identidad del ensamblado ejecución actual y del dominio de aplicación en el que se está ejecutando. Este almacén permanecerá abierto solo para la duración de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar un ámbito de almacenamiento aislado distinto, o para permitir que el almacén permanezca abierto (por lo que varias <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos pueden abrirse desde el mismo), utilice el formulario del constructor que acepta un <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 El `mode` parámetro indica si debe crearse un archivo nuevo o uno existente que utiliza. El `access` parámetro incluye sólo lectura, lectura/escritura y de solo escritura.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinación bit a bit de los valores de <see cref="T:System.IO.FileShare" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> donde se va a abrir <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo designado por el parámetro <paramref name="path" />, de la manera especificada en <paramref name="mode" />, con el parámetro <paramref name="access" /> indicado, con el modo de uso compartido de archivos definido por el parámetro <paramref name="share" /> y en el contexto de <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> que especifique el parámetro <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro indica si debe crearse un archivo nuevo o uno existente que utiliza. El `access` parámetro incluye sólo lectura, lectura/escritura y de solo escritura.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este constructor. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> no tiene una cuota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso relativa del archivo dentro del almacenamiento aislado.</param>
        <param name="mode">Uno de los valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Combinación bit a bit de los valores de <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Combinación bit a bit de los valores de <see cref="T:System.IO.FileShare" />.</param>
        <param name="bufferSize">Tamaño de búfer de <see cref="T:System.IO.FileStream" />.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> donde se va a abrir <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y concede acceso al archivo designado por el parámetro <paramref name="path" />, de la manera especificada en <paramref name="mode" />, con el parámetro <paramref name="access" /> indicado, con el modo de uso compartido de archivos definido por el parámetro <paramref name="share" />, con el valor de <paramref name="buffersize" /> especificado y en el contexto de <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> que especifique el parámetro <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `mode` parámetro indica si debe crearse un archivo nuevo o uno existente que utiliza. El `access` parámetro incluye sólo lectura, lectura/escritura y de solo escritura.  
  
> [!CAUTION]
>  Cuando se compila un juego de caracteres con una configuración de referencia cultural concreta y se recuperan los mismos caracteres con una configuración cultural diferente, los caracteres no pueden interpretarse y pueden provocar que se produzca una excepción.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el uso de este constructor. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="path" /> tiene un formato incorrecto.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encontró ningún archivo y <paramref name="mode" /> está establecido en <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> no tiene una cuota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para el acceso de almacenamiento aislado</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer en el que se leen los datos.</param>
        <param name="offset">Desplazamiento de bytes de <c>buffer</c> donde se va a empezar a leer.</param>
        <param name="numBytes">Número máximo de bytes que se pueden leer.</param>
        <param name="userCallback">Método al que se va a llamar cuando finalice la lectura asincrónica. Este parámetro es opcional.</param>
        <param name="stateObject">Estado de la lectura asincrónica.</param>
        <summary>Comienza una lectura asincrónica.</summary>
        <returns>Un objeto <see cref="T:System.IAsyncResult" /> que representa la lectura asincrónica, que puede estar pendiente todavía. <see cref="T:System.IAsyncResult" /> debe pasarse al método <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> de esta secuencia para determinar el número de bytes que se leyeron. Esto puede hacerse mediante el mismo código con el que se llamó al método <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> o en una devolución de llamada que se pasa al método <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La posición actual en la secuencia se actualiza al emitir la lectura o escritura asincrónica, no cuando finaliza la operación de E/S.  
  
 Debe llamar a <xref:System.IO.Stream.EndRead%2A> a este <xref:System.IAsyncResult> para averiguar el número de bytes que se leyeron.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se intentó efectuar una lectura asincrónica más allá del final del archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer en el que se van a escribir datos.</param>
        <param name="offset">Desplazamiento de bytes de <c>buffer</c> donde se va a empezar a escribir.</param>
        <param name="numBytes">Número máximo de bytes que se pueden escribir.</param>
        <param name="userCallback">Método al que se va a llamar cuando finalice la escritura asincrónica. Este parámetro es opcional.</param>
        <param name="stateObject">Estado de la escritura asincrónica.</param>
        <summary>Comienza una escritura asincrónica.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que representa la escritura asincrónica, que puede estar todavía pendiente. <see cref="T:System.IAsyncResult" /> debe pasarse al método <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> de esta secuencia para garantizar que la operación de escritura finalice, y después libere los recursos como corresponde. Esto puede hacerse mediante el mismo código con el que se llamó al método <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> o en una devolución de llamada que se pasa al método <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto es grabable, escribir al final de la secuencia, ésta expande la secuencia.  
  
 La posición actual en la secuencia se actualiza al emitir la lectura o escritura asincrónica, no cuando finaliza la operación de E/S.  
  
 Debe llamar a <xref:System.IO.Stream.EndWrite%2A> con el <xref:System.IAsyncResult> objeto devuelto por este método para averiguar el número de bytes escrito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se intentó efectuar una escritura asincrónica más allá del final del archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si se puede leer el archivo.</summary>
        <value>
          Es <see langword="true" /> si un objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> admite lectura; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para determinar si el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> se puede leer el objeto.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo puede usar el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> propiedad, como una comprobación para ver si se puede leer una secuencia antes de llamar a la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> métodos. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si se admiten las operaciones de búsqueda.</summary>
        <value>
          Es <see langword="true" /> si un objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> admite operaciones de búsqueda; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para determinar si la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto admite operaciones de búsqueda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si se puede escribir en el archivo.</summary>
        <value>
          Es <see langword="true" /> si un objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> admite escritura; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para determinar si la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto se pueden escribir.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo puede usar el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> propiedad, como una comprobación para ver si se puede leer una secuencia antes de llamar a la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> métodos. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar tanto los recursos administrados como los no administrados; <see langword="false" /> para liberar únicamente los recursos no administrados.</param>
        <summary>Libera los recursos no administrados que usa <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y, de forma opcional, libera los recursos administrados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se llama a este método público <xref:System.IDisposable.Dispose%2A> método y <xref:System.Object.Finalize%2A> método. <xref:System.IDisposable.Dispose%2A> se invoca el protegido <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> método con el `disposing` parámetro establecido en true. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> con `disposing` establecido en false.  
  
 Cuando el `disposing` del parámetro es true, este método libera todos los recursos retenidos por los objetos administrados que este <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> referencias. Este método invoca al método <xref:System.IDisposable.Dispose%2A> de cada uno de los objetos a los que se hace referencia.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IDisposable.Dispose" /> puede recibir varias llamadas de otros objetos. Al invalidar <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see cref="M:System.IDisposable.Dispose" />. Para obtener más información sobre cómo implementar <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, consulte [implementa un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obtener más información acerca de <see cref="M:System.IDisposable.Dispose" /> y <see cref="M:System.Object.Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitud asincrónica pendiente.</param>
        <summary>Finaliza una solicitud de lectura asincrónica pendiente.</summary>
        <returns>Número de bytes leídos de la secuencia, que se encuentra entre cero y el número de bytes solicitado. Las secuencias sólo devolverán cero al final de la secuencia. En caso contrario, se bloquearán hasta que esté disponible un byte por lo menos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> se debe llamar exactamente una vez en cada <xref:System.IAsyncResult> objeto <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>y la llamada a <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> es la única manera de saber el número de bytes leído desde el <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> se bloqueará hasta que se complete la operación de E/S.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitud de E/S asincrónica pendiente que se va a finalizar.</param>
        <summary>Finaliza una escritura asincrónica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> se debe llamar exactamente una vez en cada <xref:System.IAsyncResult> de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> se bloqueará hasta que se complete la operación de E/S.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="asyncResult" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra los búferes de esta secuencia y hace que todos los datos almacenados en los búferes se escriban en el archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que se puede utilizar un búfer para leer o escribir, pero no ambos al mismo tiempo, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> realiza dos funciones. En primer lugar, los datos escritos anteriormente en el búfer se copian en el archivo y se borra el búfer. Segundo, si <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> es `true` y anteriormente se copiaron los datos del archivo en el búfer para leer, la posición actual dentro del archivo se reduce el número de bytes no leídos en el búfer. A continuación, se borra el búfer.  
  
 Use la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> sobrecarga de método cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escriben en el disco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> para vaciar todos los búferes de archivos intermedios; de lo contrario, <see langword="false" />.</param>
        <summary>Borra los búferes de esta secuencia, hace que todos los datos almacenados en los búferes se escriban en el archivo y borra también todos los búferes de archivos intermedios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta sobrecarga cuando desee asegurarse de que todos los datos almacenados en búfer en búferes de archivos intermedios se escribe en el disco.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el controlador de archivo para el archivo encapsulado por el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> actual. No se permite el acceso a esta propiedad en un objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> y se produce una excepción <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />.</summary>
        <value>Controlador de archivo para el archivo encapsulado por el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> propiedad.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">La propiedad <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> siempre genera esta excepción.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si se abrió el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> de forma sincrónica o asincrónica.</summary>
        <value>
          Es <see langword="true" /> si el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> admite el acceso asincrónico; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asincrónica <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> no se puede crear objetos, a diferencia <xref:System.IO.FileStream>. Sin embargo, el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, y <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> se admiten métodos en instancias sincrónicas, con algunas reducción de rendimiento.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo se puede utilizar el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> propiedad para comprobar que un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> es sincrónico. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la longitud del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</summary>
        <value>La longitud del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> en bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> representa el número de bytes actualmente en el archivo. No se ve afectado por la cuota de almacenamiento aislado.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> propiedad.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">La posición inicial del intervalo que se va a bloquear. El valor de este parámetro debe ser igual o mayor que cero (0).</param>
        <param name="length">Número de bytes que se van a bloquear.</param>
        <summary>Impide que otros procesos lean o escriban en la secuencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueo de un intervalo de una secuencia de archivos proporciona los subprocesos de al proceso bloqueo acceso exclusivo a ese intervalo de la secuencia de archivos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">El archivo se cierra.</exception>
        <exception cref="T:System.IO.IOException">El proceso no puede obtener acceso al archivo porque otro proceso ha bloqueado una parte de este.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición actual del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> actual.</summary>
        <value>La actual posición de este objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad funciona cuando la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> propiedad es `true`.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> propiedad que se va a escribir datos en un archivo.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">No se puede establecer la posición como un número negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer que se va a leer.</param>
        <param name="offset">Desplazamiento en el búfer donde debe comenzar la escritura.</param>
        <param name="count">Número máximo de bytes que se pueden leer.</param>
        <summary>Copia en una matriz bytes del actual objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> almacenado en el búfer.</summary>
        <returns>Número total de bytes leídos en el <paramref name="buffer" />. Puede ser menor que el número de bytes solicitado si dicho número de bytes no está disponible en la actualidad, o cero si se alcanza el final de la secuencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `buffer` parámetro puede ser una instancia de la <xref:System.Buffer> clase o una matriz de uno de los siguientes tipos: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>, <xref:System.Single>, o <xref:System.Double>. El `offset` parámetro indica el desplazamiento del byte en el búfer en el que se va a comenzar la escritura (índice de búfer) y el `count` parámetro proporciona el número máximo de bytes que se leerán desde esta secuencia. El valor devuelto es el número real de bytes leídos, o cero si se alcanza el final de la secuencia. Si la operación de lectura se realiza correctamente, la posición actual de la secuencia avanza por el número de bytes leídos. Si se produce una excepción, no se modifica la posición actual de la secuencia.  
  
 El <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> método trata el `buffer` parámetro como un bloque de bytes, con independencia de su tipo real. Del mismo modo, el `offset` y `count` parámetros siempre se especifican en bytes. Para `buffer` parámetros que no sean matrices de bytes, esto significa que el índice de un elemento debe ser multiplicado por el tamaño del elemento en bytes para obtener un valor correcto para `offset` o `count`.  
  
 El <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> método devolverá cero sólo si se alcanza el final de la secuencia. En todos los demás casos, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> siempre lee al menos un byte de la secuencia antes de devolver. Si no hay datos disponibles de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto con una llamada a <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, el método se bloqueará hasta que se puede devolver al menos un byte de datos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lee un único byte del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> en el almacenamiento aislado.</summary>
        <returns>Valor entero sin signo de 8 bits leído en el archivo de almacenamiento aislado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> método se puede utilizar para leer los datos de un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa el identificador de archivos del sistema operativo correspondiente al archivo que el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> actual encapsula.</summary>
        <value>Un objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa el identificador de archivos del sistema operativo correspondiente al archivo que el actual objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> encapsula.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> propiedad no se admite y siempre genera un <xref:System.IO.IsolatedStorage.IsolatedStorageException> excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">La propiedad <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> siempre genera esta excepción.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiere plena confianza para el llamador inmediato. Este miembro no puede usarse por código de confianza parcial o transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Nueva posición del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <param name="origin">Uno de los valores de <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Establece la actual posición de este objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> en el valor especificado.</summary>
        <returns>La nueva posición en el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Algunos <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos admiten la posición más allá de la longitud de la secuencia, otros usuarios en este caso, producirán una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El <paramref name="origin" /> debe ser uno de los valores de <see cref="T:System.IO.SeekOrigin" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">La nueva longitud del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Establece la longitud de este objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> en el parámetro <paramref name="value" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el especificado `value` es menor que la longitud actual de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> del objeto, la secuencia se truncará. Si el especificado `value` es mayor que la longitud actual de la secuencia, se expande la secuencia. Si la secuencia se expande, el contenido de la secuencia entre la antigua y la nueva longitud es indefinido. Para poder usar este método, un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto debe admitir operaciones de escritura y de búsqueda.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> es un número negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">La posición inicial del intervalo que se va a desbloquear. El valor de este parámetro debe ser igual o mayor que cero (0).</param>
        <param name="length">Número de bytes que se van a desbloquear.</param>
        <summary>Permite que otros procesos tengan acceso total o parcial a un archivo previamente bloqueado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> o <paramref name="length" /> es negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Búfer en el que se va a escribir.</param>
        <param name="offset">Desplazamiento de bytes en el búfer desde el que se va a empezar.</param>
        <param name="count">Número máximo de bytes que se pueden escribir.</param>
        <summary>Escribe un bloque de bytes en el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> usando los datos leídos de una matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `offset` parámetro indica el desplazamiento del byte en el `buffer` en el que se va a comenzar la lectura y el `count` parámetro proporciona el número de bytes que se escribirán en esto <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Si la operación de escritura se realiza correctamente, la posición actual de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto avanza por el número de bytes escritos. Si se produce una excepción, la posición actual de la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto se ha modificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">El intento de escritura supera la cuota del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Valor en bytes que se va a escribir en el archivo de almacenamiento aislado.</param>
        <summary>Escribe un único byte en el objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo el <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> método se puede utilizar para leer los datos de un <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para obtener el contexto completo de este ejemplo, vea la <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> información general.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">El intento de escritura supera la cuota del objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>