<Type Name="FileSystemProxy" FullName="Microsoft.VisualBasic.MyServices.FileSystemProxy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee00de463bf49d0a92e881ae498c690d8482c763" /><Meta Name="ms.sourcegitcommit" Value="95e24aee1283af2f120fc5da4b0bdc0712ab698f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65135837" /></Metadata><TypeSignature Language="C#" Value="public class FileSystemProxy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FileSystemProxy extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.MyServices.FileSystemProxy" />
  <TypeSignature Language="VB.NET" Value="Public Class FileSystemProxy" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystemProxy" />
  <TypeSignature Language="F#" Value="type FileSystemProxy = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona propiedades y métodos para trabajar con unidades, archivos y directorios.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem` objeto.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto|[Cómo: Leer de archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
|Leer de un archivo de texto delimitado|[Cómo: Leer archivos de texto delimitado por comas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: Leer archivos de texto de ancho fijo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: Leer archivos de texto con varios formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
|Leer de un archivo binario|[Cómo: Leer archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
|Leer de un archivo de texto con un <xref:System.IO.StreamReader>|[Cómo: Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
|Escribir en un archivo de texto|[Cómo: Escribir texto en archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar a un archivo de texto|[Cómo: Anexar a archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
|Escribir en un archivo binario|[Cómo: Escribir en archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
|Escribir en archivos de texto en el **MyDocuments** directorio|[Cómo: Escribir texto en archivos en el directorio Mis documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-in-the-my-documents-directory.md)|  
|Escribir en un archivo de texto con un `StreamWriter`|[Cómo: Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
|Copiar archivos con un patrón específico|[Cómo: Copiar archivos con un patrón específico en un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md)|  
|Copiar un archivo en el mismo directorio|[Cómo: Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente|[Cómo: Crear una copia de un archivo en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
|Cree un archivo|[Cómo: Cree un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-file.md)|  
|Eliminar un archivo|[Cómo: Eliminar un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
|Buscar archivos con un patrón específico|[Cómo: Buscar archivos con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
|Mover un archivo|[Cómo: Mover un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
|Cambiar el nombre de un archivo|[Cómo: Cambiar el nombre de un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
|Copiar un directorio en otro directorio|[Cómo: Copiar un directorio en otro](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
|Crear un directorio|[Cómo: Cree un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
|Buscar subdirectorios con un modelo concreto|[Cómo: Buscar subdirectorios con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
|Obtener la colección de archivos en un directorio|[Cómo: Obtener la colección de archivos de un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Leer desde el **MyDocuments** directorio|[Cómo: Recuperar el contenido del directorio Mis documentos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-retrieve-the-contents-of-the-my-documents-directory.md)|  
|Analizar una ruta de acceso de archivo|[Cómo: Analizar rutas de acceso a archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este ejemplo se comprueba para determinar si la carpeta `C:\backup\logs` existe y comprueba sus propiedades.  
  
 [!code-vb[VbVbcnMyFileSystem#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#23)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
    <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="CombinePath">
      <MemberSignature Language="C#" Value="public string CombinePath (string baseDirectory, string relativePath);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string CombinePath(string baseDirectory, string relativePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CombinePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CombinePath (baseDirectory As String, relativePath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ CombinePath(System::String ^ baseDirectory, System::String ^ relativePath);" />
      <MemberSignature Language="F#" Value="member this.CombinePath : string * string -&gt; string" Usage="fileSystemProxy.CombinePath (baseDirectory, relativePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseDirectory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="relativePath" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="baseDirectory"><see langword="String" />. Primera ruta de acceso que va a combinarse.</param>
        <param name="relativePath"><see langword="String" />. Segunda ruta de acceso que va a combinarse.</param>
        <summary>Combina dos rutas de acceso y devuelve una ruta de acceso con el formato correcto.</summary>
        <returns>La combinación de las rutas de acceso especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método recorta los caracteres de exceso de marca de barra diagonal para crear una ruta de acceso con el formato correcto.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CombinePath` método.  
  
|En|Vea|  
|--------|---------|  
|Combinar una ruta de acceso y nombre del directorio|[Cómo: Analizar rutas de acceso a archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 En este ejemplo combina un nombre de archivo y ruta del directorio para crear una ruta de acceso con el formato correcto.  
  
 [!code-vb[VbRefFile#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#3)]  
  
 En este ejemplo combina dos rutas de acceso para crear una ruta de acceso con el formato correcto.  
  
 [!code-vb[VbRefFile#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#4)]  
  
 Este ejemplo devuelve `C:\Dir1\Dir2\Dir4\Dir5\File.txt`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="baseDirectory" /> o <paramref name="relativePath" /> son rutas de acceso con formato incorrecto.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetParentPath(System.String)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un directorio en otro directorio.</summary>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">El directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">La ubicación a la que se debe copiar el directorio.</param>
        <summary>Copia un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio además del propio directorio. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Al copiar archivos en un directorio, se pueden producir excepciones están causados por un archivo específico. Cuando se producen dichas excepciones, se consolidan en una sola excepción cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreto está contenido en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un directorio|[Cómo: Copiar un directorio en otro](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 En el ejemplo siguiente se copia el directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que desea copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son los mismos.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un archivo de destino existe pero no es accesible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">El directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">La ubicación a la que se debe copiar el directorio.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio además del propio directorio. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Al copiar archivos en un directorio, se pueden producir excepciones están causados por un archivo específico. Cuando se producen dichas excepciones, se consolidan en una sola excepción cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreto está contenido en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un directorio|[Cómo: Copiar un directorio en otro](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 En el ejemplo siguiente se copia el directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que desea copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son los mismos.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un archivo de destino existe pero no es accesible.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> se establece en <see langword="UIOption.AllDialogs" /> y el usuario cancela la operación o no se puede copiar uno o varios archivos en el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">El directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">La ubicación a la que se debe copiar el directorio.</param>
        <param name="overwrite"><see langword="True" /> para sobrescribir archivos existentes; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Copia un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio además del propio directorio. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Al copiar archivos en un directorio, se puede producir excepciones producidos por un archivo específico, como un archivo existente durante una combinación mientras `overwrite` está establecido en `False`. Cuando se producen dichas excepciones, se consolidan en una sola excepción cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreto está contenido en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un directorio|[Cómo: Copiar un directorio en otro](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 En el ejemplo siguiente se copia el directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que desea copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son los mismos.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un archivo de destino existe pero no es accesible.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyDirectory">
      <MemberSignature Language="C#" Value="public void CopyDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">El directorio que se va a copiar.</param>
        <param name="destinationDirectoryName">La ubicación a la que se debe copiar el directorio.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica la acción que se va a realizar cuando el usuario haga clic en **Cancelar** durante la operación. El valor predeterminado es <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia un directorio en otro directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método copia el contenido del directorio además del propio directorio. Si el directorio de destino no existe, se crea. Si existe un directorio con el mismo nombre en la ubicación de destino, se combina el contenido de los dos directorios. Puede especificar un nuevo nombre para el directorio durante la operación.  
  
 Al copiar archivos en un directorio, se pueden producir excepciones están causados por un archivo específico. Cuando se producen dichas excepciones, se consolidan en una sola excepción cuya `Data` propiedad contiene entradas en forma de un <xref:System.Collections.IDictionary> en el que la ruta de acceso de archivo o directorio es la clave y el mensaje de excepción concreto está contenido en el valor correspondiente. Use `For…Each` para enumerar las entradas.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyDirectory` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un directorio|[Cómo: Copiar un directorio en otro](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md)|  
  
   
  
## Examples  
 En el ejemplo siguiente se copia el directorio `TestDirectory1` en `TestDirectory2`, sobrescribiendo los archivos existentes.  
  
 [!code-vb[VbVbcnMyFileSystem#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#49)]  
  
 Reemplace `C:\TestDirectory1` y `C:\TestDirectory2` con la ruta de acceso y el nombre del directorio que desea copiar y la ubicación a la que desea copiarlo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> o <paramref name="sourceDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio de origen no existe.</exception>
        <exception cref="T:System.IO.IOException">La ruta de acceso de origen y la ruta de acceso de destino son los mismos.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de carpeta en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Un archivo de destino existe pero no es accesible.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="ShowUI" /> se establece en <see langword="UIOption.AllDialogs" /> y el usuario cancela la operación o no se puede copiar uno o varios archivos en el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md">Procedimiento para copiar archivos con un modelo específico en un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedimiento para crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedimiento para copiar un directorio en otro directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedimiento para cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">El archivo que se va a copiar.</param>
        <param name="destinationFileName">La ubicación a la que se debe copiar el archivo.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no conserva las ACE (entradas de Control de acceso). El archivo recién creado hereda las ACE de forma predeterminada el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un archivo en el mismo directorio.|[Cómo: Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: Crear una copia de un archivo en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambia su nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">Un archivo en el directorio de destino con el mismo nombre está en uso.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md">Procedimiento para copiar archivos con un modelo específico en un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedimiento para crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedimiento para copiar un directorio en otro directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedimiento para cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">El archivo que se va a copiar.</param>
        <param name="destinationFileName">La ubicación a la que se debe copiar el archivo.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no conserva las ACE (entradas de Control de acceso). El archivo recién creado hereda las ACE de forma predeterminada el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un archivo en el mismo directorio.|[Cómo: Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: Crear una copia de un archivo en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambia su nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md">Procedimiento para copiar archivos con un modelo específico en un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedimiento para crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedimiento para copiar un directorio en otro directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedimiento para cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">El archivo que se va a copiar.</param>
        <param name="destinationFileName">La ubicación a la que se debe copiar el archivo.</param>
        <param name="overwrite"><see langword="True" /> Si se deben sobrescribir archivos existentes; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no conserva las ACE (entradas de Control de acceso). El archivo recién creado hereda las ACE de forma predeterminada el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un archivo en el mismo directorio.|[Cómo: Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: Crear una copia de un archivo en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambia su nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md">Procedimiento para copiar archivos con un modelo específico en un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedimiento para crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedimiento para copiar un directorio en otro directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedimiento para cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CopyFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.CopyFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">El archivo que se va a copiar.</param>
        <param name="destinationFileName">La ubicación a la que se debe copiar el archivo.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica la acción que se va a realizar cuando el usuario haga clic en **Cancelar** durante la operación. El valor predeterminado es <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</param>
        <summary>Copia un archivo en una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CopyFile` no conserva las ACE (entradas de Control de acceso). El archivo recién creado hereda las ACE de forma predeterminada el directorio en el que se crea.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CopyFile` método.  
  
|En|Vea|  
|--------|---------|  
|Copiar un archivo en el mismo directorio.|[Cómo: Crear una copia de un archivo en el mismo directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md)|  
|Copiar un archivo en un directorio diferente.|[Cómo: Crear una copia de un archivo en otro directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md)|  
  
   
  
## Examples  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` sin sobrescribir archivos existentes.  
  
 [!code-vb[VbRefFile#15](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#15)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 En este ejemplo se copia el archivo `Test.txt` en el directorio `TestFiles2` y cambia su nombre `NewFile.txt`.  
  
 [!code-vb[VbRefFile#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#16)]  
  
 Reemplazar las rutas de acceso de archivo con las rutas de acceso que desea usar en el código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationFileName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> o <paramref name="sourceFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo de destino existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="UICancelOption" /> se establece en <see langword="ThrowException" />y el usuario ha cancelado la operación o se produce un error de E/S no especificado.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-files-with-a-specific-pattern-to-a-directory.md">Procedimiento para copiar archivos con un modelo específico en un directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Procedimiento para crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Procedimiento para copiar un directorio en otro directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Procedimiento para cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void CreateDirectory(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (directory As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.CreateDirectory : string -&gt; unit" Usage="fileSystemProxy.CreateDirectory directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ubicación del directorio.</param>
        <summary>Crea un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el directorio ya existe, no se produce ninguna excepción.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.CreateDirectory` método.  
  
|En|Vea|  
|--------|---------|  
|Crear un directorio|[Cómo: Cree un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md)|  
  
   
  
## Examples  
 Este ejemplo crea el directorio, `NewDirectory`, en `C:\Documents and Settings\All Users\Documents`.  
  
 [!code-vb[VbVbcnMyFileSystem#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre del directorio es incorrecto. Por ejemplo, contiene caracteres no válidos o es solo espacios en blanco.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">El nombre del directorio es demasiado largo.</exception>
        <exception cref="T:System.NotSupportedException">El nombre del directorio es solo un signo de dos puntos (:).</exception>
        <exception cref="T:System.IO.IOException">El directorio principal del directorio que se va a crear es de solo lectura</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para crear el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:System.IO.Directory.CreateDirectory(System.String)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el directorio actual.</summary>
        <value>El directorio actual para las operaciones de E/S de archivos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CurrentDirectory` es una variable de entorno de todo el sistema.  
  
   
  
## Examples  
 Este ejemplo devuelve el directorio actual y lo muestra en un cuadro de mensaje.  
  
 [!code-vb[VbVbcnMyFileSystem#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#18)]  
  
 Este ejemplo establece el directorio actual en `C:\TestDirectory`.  
  
 [!code-vb[VbVbcnMyFileSystem#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.DirectoryNotFoundException">La ruta de acceso no es válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.DeleteDirectoryOption onDirectoryNotEmpty) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.DeleteDirectoryOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, onDirectoryNotEmpty As DeleteDirectoryOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::DeleteDirectoryOption onDirectoryNotEmpty);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.DeleteDirectoryOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, onDirectoryNotEmpty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onDirectoryNotEmpty" Type="Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="onDirectoryNotEmpty">Especifica qué se debe hacer cuando un directorio que se va a eliminar contiene archivos o directorios. El valor predeterminado es <see langword="DeleteDirectoryOption.DeleteAllContents" />.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacía.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, que pide al usuario que confirme la eliminación, pero no envía el contenido en el **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, está mal formado, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo en el directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre del directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.DeleteDirectoryOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI` y `recycle` parámetros no se admiten en las aplicaciones que no son interactivo, como los servicios de Windows del usuario.  
  
   
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacía.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, que pide al usuario que confirme la eliminación, pero no envía el contenido en el **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, está mal formado, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo en el directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre del directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string directory, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteDirectory(string directory, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteDirectory(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (directory As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ directory, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteDirectory (directory, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a eliminar.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica si se va a producir una excepción cuando el usuario haga clic en **Cancelar**.</param>
        <summary>Elimina un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI`, `recycle`, y `onUserCancel` parámetros no se admiten en las aplicaciones que no son interactivo, como los servicios de Windows del usuario.  
  
   
  
## Examples  
 En el ejemplo se elimina el directorio `OldDirectory` sólo si está vacía.  
  
 [!code-vb[VbVbcnMyFileSystem#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#56)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido.  
  
 [!code-vb[VbVbcnMyFileSystem#57](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#57)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, que pide al usuario que confirme la eliminación, pero no envía el contenido en el **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#58)]  
  
 En este ejemplo elimina el directorio `OldDirectory` y todo su contenido, enviarlos a la **Papelera de reciclaje**, pero no se muestra el progreso de la operación.  
  
 [!code-vb[VbVbcnMyFileSystem#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso es una cadena de longitud cero, está mal formado, contiene solo espacios en blanco o contiene caracteres no válidos (incluidos caracteres comodín). La ruta de acceso es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe o es un archivo.</exception>
        <exception cref="T:System.IO.IOException">Un archivo en el directorio o subdirectorio está en uso.</exception>
        <exception cref="T:System.NotSupportedException">El nombre del directorio contiene dos puntos (:).</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario cancela la operación o no se puede eliminar el directorio.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Elimina un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string -&gt; unit" Usage="fileSystemProxy.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo que se va a eliminar.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|--------|---------|  
|Para eliminar un archivo|[Cómo: Eliminar un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo que se va a eliminar.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI` y `recycle` parámetros no se admiten en las aplicaciones que no son interactivo, como los servicios de Windows del usuario.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|--------|---------|  
|Para eliminar un archivo|[Cómo: Eliminar un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.RecycleOption recycle, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void DeleteFile(string file, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.RecycleOption recycle, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DeleteFile(System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.RecycleOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String, showUI As UIOption, recycle As RecycleOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::RecycleOption recycle, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.RecycleOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.DeleteFile (file, showUI, recycle, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="recycle" Type="Microsoft.VisualBasic.FileIO.RecycleOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo que se va a eliminar.</param>
        <param name="showUI">Si va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="recycle">Especifica si el archivo eliminado se va a enviar o no a la **Papelera de reciclaje**. El valor predeterminado es <see langword="RecycleOption.DeletePermanently" />.</param>
        <param name="onUserCancel">Especifica si se produce una excepción cuando el usuario cancela la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Elimina un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `showUI`, `recycle`, y `onUserCancel` parámetros no se admiten en las aplicaciones que no son interactivo, como los servicios de Windows del usuario.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.DeleteFile` método.  
  
|En|Vea|  
|--------|---------|  
|Para eliminar un archivo|[Cómo: Eliminar un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo elimina el archivo `Test.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#3)]  
  
 Este ejemplo elimina el archivo `Test.txt` y permite al usuario que confirme que el archivo debe eliminarse.  
  
 [!code-vb[VbVbcnMyFileSystem#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#4)]  
  
 Este ejemplo elimina el archivo `Test.txt` y lo envía a la **Papelera de reciclaje**.  
  
 [!code-vb[VbVbcnMyFileSystem#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; tiene una barra diagonal final a partir de la cual se debe especificar un archivo; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene permiso para eliminar el archivo o el archivo es de solo lectura.</exception>
        <exception cref="T:System.OperationCanceledException">El usuario canceló la operación y <paramref name="onUserCancel" /> está establecido en <see cref="F:Microsoft.VisualBasic.FileIO.UICancelOption.ThrowException" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.RecycleOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-delete-a-file.md">Procedimiento para eliminar un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool DirectoryExists(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (directory As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.DirectoryExists : string -&gt; bool" Usage="fileSystemProxy.DirectoryExists directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Ruta de acceso del directorio.</param>
        <summary>Devuelve <see langword="True" /> si existe el directorio especificado.</summary>
        <returns><see langword="True" /> Si existe el directorio; en caso contrario <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo determina si el directorio `C:\backup\logs` existe y comprueba sus propiedades.  
  
 [!code-vb[VbRefFile#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Drives">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt; Drives { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.DriveInfo&gt; Drives" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Drives As ReadOnlyCollection(Of DriveInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ Drives { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::DriveInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Drives : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.Drives" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.DriveInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una colección de solo lectura de todos los nombres de unidad disponible.</summary>
        <value>Una colección de solo lectura de todas las unidades disponibles como <see cref="T:System.IO.DriveInfo" /> objetos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve todas las unidades lógicas.  
  
   
  
## Examples  
 En este ejemplo muestra los nombres de unidad disponible en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <altmember cref="T:System.IO.DriveInfo" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool FileExists(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (file As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.FileExists : string -&gt; bool" Usage="fileSystemProxy.FileExists file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo.</param>
        <summary>Devuelve <see langword="True" /> si existe el archivo especificado.</summary>
        <returns>Devuelve <see langword="True" /> si existe el archivo; en caso contrario, este método devuelve <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la aplicación no tiene permisos suficientes para leer el archivo especificado, el `FileExists` devuelve del método `False`, independientemente de la existencia de la ruta de acceso; el método no produce una excepción.  
  
   
  
## Examples  
 Este ejemplo se comprueba para ver si el archivo `Check.txt` existe y proporciona la información en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre del archivo finaliza con una barra diagonal inversa (\\).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FindInFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos que contiene el texto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="containsText" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">El directorio que se va a buscar.</param>
        <param name="containsText">El texto de búsqueda.</param>
        <param name="ignoreCase"><see langword="True" /> Si la búsqueda debe distinguir mayúsculas de minúsculas; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="True" />.</param>
        <param name="searchType">Si se debe incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos que contiene el texto especificado.</summary>
        <returns>Colección de solo lectura de los nombres de los archivos que contienen el texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.FindInFiles` método.  
  
|En|Vea|  
|--------|---------|  
|Buscar un directorio para archivos que contienen una cadena específica|[Tutorial: Manipulación de archivos y directorios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 En este ejemplo busca en el directorio `C:\TestDir` para todos los archivos que contiene la cadena `"sample string"` y muestra los resultados en `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para poder funcionar, el proyecto debe contener un `ListBox` denominado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero, solo contiene un espacio en blanco, contiene caracteres no válidos o es una ruta de acceso de dispositivo (empieza por <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso del directorio especificado contiene un signo de dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FindInFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; FindInFiles (string directory, string containsText, bool ignoreCase, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] fileWildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; FindInFiles(string directory, string containsText, bool ignoreCase, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] fileWildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.FindInFiles(System.String,System.String,System.Boolean,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function FindInFiles (directory As String, containsText As String, ignoreCase As Boolean, searchType As SearchOption, ParamArray fileWildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ FindInFiles(System::String ^ directory, System::String ^ containsText, bool ignoreCase, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ fileWildcards);" />
      <MemberSignature Language="F#" Value="member this.FindInFiles : string * string * bool * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.FindInFiles (directory, containsText, ignoreCase, searchType, fileWildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="containsText" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="fileWildcards" Type="System.String[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">El directorio que se va a buscar.</param>
        <param name="containsText">El texto de búsqueda.</param>
        <param name="ignoreCase"><see langword="True" /> Si la búsqueda debe distinguir mayúsculas de minúsculas; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="True" />.</param>
        <param name="searchType">Si se debe incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="fileWildcards">Patrón que se debe coincidir.</param>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos que contiene el texto especificado.</summary>
        <returns>Colección de solo lectura de los nombres de los archivos que contienen el texto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.FindInFiles` método.  
  
|En|Vea|  
|--------|---------|  
|Buscar un directorio para archivos que contienen una cadena específica|[Tutorial: Manipulación de archivos y directorios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)|  
  
   
  
## Examples  
 En este ejemplo busca en el directorio `C:\TestDir` para todos los archivos que contiene la cadena `"sample string"` y muestra los resultados en `ListBox1`.  
  
 [!code-vb[VbRefFile#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#12)]  
  
 Para poder funcionar, el proyecto debe contener un `ListBox` denominado `ListBox1`.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero, solo contiene un espacio en blanco, contiene caracteres no válidos o es una ruta de acceso de dispositivo (empieza por <c>\\.\</c>).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso del directorio especificado contiene un signo de dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectories">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de cadenas que representan los nombres de ruta de acceso de los subdirectorios de un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ruta de acceso del directorio.</param>
        <summary>Devuelve una colección de cadenas que representan los nombres de ruta de acceso de los subdirectorios de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de ruta de acceso de los subdirectorios dentro del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetDirectories` método.  
  
|En|Vea|  
|--------|---------|  
|Mostrar los subdirectorios con un modelo concreto|[Cómo: Buscar subdirectorios con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 El ejemplo siguiente devuelve todos los directorios en la estructura de directorios que contienen la palabra `Logs` en sus nombres y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetDirectories (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetDirectories(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectories(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectories (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetDirectories(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetDirectories : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetDirectories (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="wildcards" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Nombre y ruta de acceso del directorio.</param>
        <param name="searchType">Si se debe incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Patrón de coincidencia de nombres.</param>
        <summary>Devuelve una colección de cadenas que representan los nombres de ruta de acceso de los subdirectorios de un directorio.</summary>
        <returns>Colección de solo lectura de los nombres de ruta de acceso de los subdirectorios dentro del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el parámetro `wildcards` para especificar un patrón concreto. Si quiere incluir el contenido de subdirectorios en la búsqueda, establezca el parámetro `searchType` en `SearchAllSubDirectories`.  
  
 Se devuelve una colección vacía si no se encuentra ningún directorio que coincida con el modelo especificado.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetDirectories` método.  
  
|En|Vea|  
|--------|---------|  
|Mostrar los subdirectorios con un modelo concreto|[Cómo: Buscar subdirectorios con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-subdirectories-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 El ejemplo siguiente devuelve todos los directorios en la estructura de directorios que contienen la palabra `Logs` en sus nombres y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#10)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">Uno o varios de los caracteres comodín especificados están <see langword="Nothing" />, una cadena vacía, o contiene solo espacios en blanco.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio especificado no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio especificado apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryInfo">
      <MemberSignature Language="C#" Value="public System.IO.DirectoryInfo GetDirectoryInfo (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DirectoryInfo GetDirectoryInfo(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDirectoryInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryInfo (directory As String) As DirectoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DirectoryInfo ^ GetDirectoryInfo(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryInfo : string -&gt; System.IO.DirectoryInfo" Usage="fileSystemProxy.GetDirectoryInfo directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory"><see langword="String" />. Ruta de acceso del directorio.</param>
        <summary>Devuelve un <see cref="T:System.IO.DirectoryInfo" /> objeto para la ruta de acceso especificada.</summary>
        <returns><see cref="T:System.IO.DirectoryInfo" /> objeto para la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el directorio no existe, se produce una excepción no hasta la primera vez una propiedad el <xref:System.IO.DirectoryInfo> acceso al objeto.  
  
   
  
## Examples  
 Este ejemplo se obtiene un <xref:System.IO.DirectoryInfo> objeto para el directorio `C:\Documents and Settings` y muestra el directorio hora de creación, última hora de acceso y última hora de escritura.  
  
 [!code-vb[VbRefFile#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="directory" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso de directorio contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DirectoryInfo" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetDriveInfo">
      <MemberSignature Language="C#" Value="public System.IO.DriveInfo GetDriveInfo (string drive);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.DriveInfo GetDriveInfo(string drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetDriveInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDriveInfo (drive As String) As DriveInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::DriveInfo ^ GetDriveInfo(System::String ^ drive);" />
      <MemberSignature Language="F#" Value="member this.GetDriveInfo : string -&gt; System.IO.DriveInfo" Usage="fileSystemProxy.GetDriveInfo drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DriveInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drive" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drive">Unidad que se va a examinar.</param>
        <summary>Devuelve un <see cref="T:System.IO.DriveInfo" /> objeto para la unidad especificada.</summary>
        <returns><see cref="T:System.IO.DriveInfo" /> objeto de la unidad especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.IO.DriveInfo> clase modela una unidad y proporciona métodos y propiedades para consultar información de la unidad. Use <xref:System.IO.DriveInfo> para determinar qué unidades están disponibles y qué tipo de unidades son. También puede consultar la propiedad para determinar la capacidad y el espacio libre disponible en la unidad.  
  
   
  
## Examples  
 Este ejemplo se obtiene un <xref:System.IO.DriveInfo> objeto de la unidad C y se utiliza para mostrar información acerca de la unidad.  
  
 [!code-vb[VbRefFile#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#11)]  
  
 Para obtener información sobre los tipos de unidad diferente, consulte <xref:System.IO.DriveType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="drive" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.DriveInfo" />
        <altmember cref="T:System.IO.DriveType" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileInfo">
      <MemberSignature Language="C#" Value="public System.IO.FileInfo GetFileInfo (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.FileInfo GetFileInfo(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFileInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileInfo (file As String) As FileInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::FileInfo ^ GetFileInfo(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.GetFileInfo : string -&gt; System.IO.FileInfo" Usage="fileSystemProxy.GetFileInfo file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo.</param>
        <summary>Devuelve un <see cref="T:System.IO.FileInfo" /> objeto para el archivo especificado.</summary>
        <returns><see cref="T:System.IO.FileInfo" /> objeto para el archivo especificado</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se produce una excepción si no existe el archivo; en su lugar, se producirá la primera vez que se tiene acceso a las propiedades del objeto.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.GetFileInfo` método.  
  
|En|Vea|  
|--------|---------|  
|Determinar el nombre y la ruta de acceso de un archivo|[Cómo: Analizar rutas de acceso a archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 Este ejemplo se recupera un <xref:System.IO.FileInfo?displayProperty=nameWithType> objeto para el archivo `MyLogFile.log` y lo usa para notificar el nombre completo del archivo, hora del último acceso y longitud.  
  
 [!code-vb[VbRefFile#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de la ruta de acceso es incorrecto. Por ejemplo, contiene caracteres no válidos o es solo espacios en blanco. El nombre de archivo tiene una barra oblicua final.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="file" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.NotSupportedException">La ruta de acceso contiene dos puntos en el medio de la cadena.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso es demasiado largo.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene acceso ACL (lista de control de acceso) al archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.IO.FileInfo" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos en un directorio.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles directory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a buscar.</param>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos en un directorio.</summary>
        <returns>Colección de solo lectura de nombres de archivo del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetFiles` método.  
  
|En|Vea|  
|--------|---------|  
|Obtener la colección de archivos en un directorio|[Cómo: Obtener la colección de archivos de un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Buscar archivos con un patrón específico en un directorio|[Cómo: Buscar archivos con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 En el siguiente ejemplo se devuelven todos los archivos contenidos en el directorio y se agregan a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 En este ejemplo devuelve todos los archivos en el directorio con la extensión `.txt` y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="directory" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No existe el directorio de búsqueda.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md">Procedimiento para buscar archivos con un modelo concreto en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt; GetFiles (string directory, Microsoft.VisualBasic.FileIO.SearchOption searchType, params string[] wildcards);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;string&gt; GetFiles(string directory, valuetype Microsoft.VisualBasic.FileIO.SearchOption searchType, string[] wildcards) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetFiles(System.String,Microsoft.VisualBasic.FileIO.SearchOption,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFiles (directory As String, searchType As SearchOption, ParamArray wildcards As String()) As ReadOnlyCollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;System::String ^&gt; ^ GetFiles(System::String ^ directory, Microsoft::VisualBasic::FileIO::SearchOption searchType, ... cli::array &lt;System::String ^&gt; ^ wildcards);" />
      <MemberSignature Language="F#" Value="member this.GetFiles : string * Microsoft.VisualBasic.FileIO.SearchOption * string[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;string&gt;" Usage="fileSystemProxy.GetFiles (directory, searchType, wildcards)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="searchType" Type="Microsoft.VisualBasic.FileIO.SearchOption" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="wildcards" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="directory">Directorio que se va a buscar.</param>
        <param name="searchType">Si se debe incluir las subcarpetas. El valor predeterminado es <see langword="SearchOption.SearchTopLevelOnly" />.</param>
        <param name="wildcards">Patrón que se debe coincidir.</param>
        <summary>Devuelve una colección de solo lectura de cadenas que representan los nombres de archivos en un directorio.</summary>
        <returns>Colección de solo lectura de nombres de archivo del directorio especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentran archivos que coincidan con el patrón especificado, se devuelve una colección vacía.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetFiles` método.  
  
|En|Vea|  
|--------|---------|  
|Obtener la colección de archivos en un directorio|[Cómo: Obtener la colección de archivos de un directorio](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md)|  
|Buscar archivos con un patrón específico en un directorio|[Cómo: Buscar archivos con un modelo concreto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md)|  
  
   
  
## Examples  
 En el siguiente ejemplo se devuelven todos los archivos contenidos en el directorio y se agregan a `ListBox1`.  
  
 [!code-vb[VbRefFile#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#5)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 En este ejemplo devuelve todos los archivos en el directorio con la extensión `.txt` y los agrega a `ListBox1`.  
  
 [!code-vb[VbRefFile#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#6)]  
  
 En este ejemplo requiere que haya un `ListBox` denominado `ListBox1` en el formulario.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="None." />
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="directory" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">No existe el directorio de búsqueda.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="directory" /> apunta a un archivo existente.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los permisos necesarios.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SearchOption" />
        <altmember cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-find-files-with-a-specific-pattern.md">Procedimiento para buscar archivos con un modelo concreto en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-get-the-collection-of-files-in-a-directory.md">Procedimiento para obtener la colección de archivos de un directorio en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public string GetName (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetName(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetName (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetName(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetName : string -&gt; string" Usage="fileSystemProxy.GetName path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Obligatorio. Ruta de acceso se puede analizar. <see langword="String" />.</param>
        <summary>Analiza el nombre de archivo fuera de la ruta de acceso proporcionada.</summary>
        <returns>El nombre de archivo de la ruta de acceso especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una operación de cadena; el `FileSystem` no se examina.  
  
 El `GetName` método omite una barra diagonal que se producen al final de la ruta de acceso.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.GetFileName` método.  
  
|En|Vea|  
|--------|---------|  
|Analizar una ruta de acceso de archivo|[Cómo: Analizar rutas de acceso a archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md)|  
  
   
  
## Examples  
 El ejemplo siguiente analiza una ruta de acceso de archivo y devuelve el nombre del archivo.  
  
 [!code-vb[VbVbcnMyFileSystem#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#21)]  
  
 Reemplace la ruta de acceso `C:\Testdirectory\Testfile` con la ruta de acceso que desea analizar.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetParentPath">
      <MemberSignature Language="C#" Value="public string GetParentPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetParentPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetParentPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetParentPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetParentPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetParentPath : string -&gt; string" Usage="fileSystemProxy.GetParentPath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso se va a examinar.</param>
        <summary>Devuelve la ruta de acceso primaria de la ruta de acceso proporcionada.</summary>
        <returns>La ruta de acceso primaria de la ruta de acceso proporcionada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de una operación de cadena; no se examina el sistema de archivos.  
  
   
  
## Examples  
 En este ejemplo obtiene la ruta de acceso principal `C:\Backups\Tmp\Test`.  
  
 [!code-vb[VbRefFile#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ruta de acceso no tiene una ruta de acceso primaria porque es una ruta de acceso raíz.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetTempFileName">
      <MemberSignature Language="C#" Value="public string GetTempFileName ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance string GetTempFileName() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.GetTempFileName" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTempFileName () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTempFileName();" />
      <MemberSignature Language="F#" Value="member this.GetTempFileName : unit -&gt; string" Usage="fileSystemProxy.GetTempFileName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un archivo temporal de cero bytes con nombre único en el disco y devuelve la ruta de acceso completa de dicho archivo.</summary>
        <returns><see langword="String" /> que contiene la ruta de acceso completa del archivo temporal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede utilizarse para crear un archivo temporal.  
  
   
  
## Examples  
 En este ejemplo se crea un archivo temporal y devuelve su ruta de acceso.  
  
 [!code-vb[VbVbcnMyFileSystem#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveDirectory">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso del directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso del directorio al que se va a mover el directorio de origen.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se intenta mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El origen es un directorio raíz o la ruta de acceso de origen y la ruta de acceso de destino son iguales.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso del directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso del directorio al que se va a mover el directorio de origen.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se intenta mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio de destino ya existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso del directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso del directorio al que se va a mover el directorio de origen.</param>
        <param name="overwrite"><see langword="True" /> Si deben sobrescribirse los directorios existentes; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se intenta mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">El directorio de destino ya existe y <paramref name="overwrite" /> está establecido en <see langword="False" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveDirectory(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveDirectory (sourceDirectoryName, destinationDirectoryName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationDirectoryName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Ruta de acceso del directorio que se va a mover.</param>
        <param name="destinationDirectoryName">Ruta de acceso del directorio al que se va a mover el directorio de origen.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica si se produce una excepción cuando el usuario cancela la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Mueve un directorio de una ubicación a otra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se intenta mover un directorio dentro de un directorio que no existe, se creará la estructura de destino.  
  
   
  
## Examples  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`.  
  
 [!code-vb[VbVbcnMyFileSystem#81](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#81)]  
  
 Este ejemplo se mueve `Directory1` dentro de `Directory2`, sobrescribiendo el directorio si ya existe.  
  
 [!code-vb[VbVbcnMyFileSystem#82](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las siguientes razones: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> o <paramref name="destinationDirectoryName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="onUserCancel" /> se establece en <see langword="ThrowException" /> y no se puede copiar un subdirectorio del archivo.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> se establece en <see langword="ThrowException" />y el usuario cancela la operación o no se puede completar la operación.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">La operación es cíclica.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.CopyDirectory(System.String,System.String)" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveFile">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso del archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso del directorio en el que se debe mover el archivo.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva las ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando mueve (directo ACE tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|--------|---------|  
|Mover un archivo|[Cómo: Mover un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2` y cambia su nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso del archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso del directorio en el que se debe mover el archivo.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva las ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando mueve (directo ACE tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|--------|---------|  
|Mover un archivo|[Cómo: Mover un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2` y cambia su nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * bool -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="overwrite" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso del archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso del directorio en el que se debe mover el archivo.</param>
        <param name="overwrite"><see langword="True" /> para sobrescribir archivos existentes; en caso contrario <see langword="False" />. El valor predeterminado es <see langword="False" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva las ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando mueve (directo ACE tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|--------|---------|  
|Mover un archivo|[Cómo: Mover un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2` y cambia su nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName, Microsoft.VisualBasic.FileIO.UIOption showUI, Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void MoveFile(string sourceFileName, string destinationFileName, valuetype Microsoft.VisualBasic.FileIO.UIOption showUI, valuetype Microsoft.VisualBasic.FileIO.UICancelOption onUserCancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile(System.String,System.String,Microsoft.VisualBasic.FileIO.UIOption,Microsoft.VisualBasic.FileIO.UICancelOption)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String, showUI As UIOption, onUserCancel As UICancelOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName, Microsoft::VisualBasic::FileIO::UIOption showUI, Microsoft::VisualBasic::FileIO::UICancelOption onUserCancel);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string * Microsoft.VisualBasic.FileIO.UIOption * Microsoft.VisualBasic.FileIO.UICancelOption -&gt; unit" Usage="fileSystemProxy.MoveFile (sourceFileName, destinationFileName, showUI, onUserCancel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="destinationFileName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="showUI" Type="Microsoft.VisualBasic.FileIO.UIOption" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="onUserCancel" Type="Microsoft.VisualBasic.FileIO.UICancelOption" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Ruta de acceso del archivo que se va a mover.</param>
        <param name="destinationFileName">Ruta de acceso del directorio en el que se debe mover el archivo.</param>
        <param name="showUI">Especifica si se va a seguir visualmente el progreso de la operación. El valor predeterminado es <see langword="UIOption.OnlyErrorDialogs" />.</param>
        <param name="onUserCancel">Especifica si se produce una excepción cuando el usuario cancela la operación. El valor predeterminado es <see langword="UICancelOption.ThrowException" />.</param>
        <summary>Mueve un archivo a una nueva ubicación.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la estructura de destino no existe, se crea.  
  
 El `MoveFile` método conserva las ACE (entradas de Control de acceso) solo cuando se mueve el archivo dentro del mismo volumen. Esto incluye ACE heredadas, que se convierten en ACE directas cuando mueve (directo ACE tienen prioridad sobre las ACE heredadas). Si un archivo se mueve entre volúmenes, no se copiarán las ACE.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.MoveFile` método.  
  
|En|Vea|  
|--------|---------|  
|Mover un archivo|[Cómo: Mover un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-move-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2`.  
  
 [!code-vb[VbVbcnMyFileSystem#86](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#86)]  
  
 Este ejemplo mueve el archivo `Test.txt` desde `TestDir1` a `TestDir2` y cambia su nombre `Test2.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#87](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationFileName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de origen no es válido o no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="onUserCancel" /> se establece en <see langword="ThrowException" />y el usuario ha cancelado la operación o se produce un error de E/S no especificado.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Controla la capacidad para tener acceso a todas las variables de entorno. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Controla la capacidad para tener acceso a las variables del registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Controla los permisos relacionados con las interfaces de usuario y al Portapapeles. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UIOption" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.UICancelOption" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFieldParser">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>El <see langword="OpenTextFieldParser" /> método le permite crear un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> object, que proporciona una forma sencilla y eficaz analizar archivos de texto estructurados, como los registros. La <see langword="TextFieldParser" /> objeto puede utilizarse para leer archivos delimitados y ancho fijo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">El archivo que se abrirá con el <see langword="TextFieldParser" />.</param>
        <summary>El <see langword="OpenTextFieldParser" /> método le permite crear un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> object, que proporciona una forma sencilla y eficaz analizar archivos de texto estructurados, como los registros. La <see langword="TextFieldParser" /> objeto puede utilizarse para leer archivos delimitados y ancho fijo.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto delimitado|[Cómo: Leer archivos de texto delimitado por comas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: Leer archivos de texto de ancho fijo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: Leer archivos de texto con varios formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este ejemplo se abre el `TextFieldParser.reader` y lo usa para leer desde `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila utilizando el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md">Procedimiento para leer archivos de texto en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md">Procedimiento Leer archivos de texto delimitado por comas en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md">Procedimiento para leer archivos de texto con varios formatos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md">Analizar archivos de texto con el objeto TextFieldParser</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params int[] fieldWidths);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, int32[] fieldWidths) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray fieldWidths As Integer()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;int&gt; ^ fieldWidths);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * int[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, fieldWidths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="fieldWidths" Type="System.Int32[]" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">El archivo que se abrirá con el <see langword="TextFieldParser" />.</param>
        <param name="fieldWidths">Ancho de los campos.</param>
        <summary>El <see langword="OpenTextFieldParser" /> método le permite crear un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> object, que proporciona una forma sencilla y eficaz analizar archivos de texto estructurados, como los registros. La <see langword="TextFieldParser" /> objeto puede utilizarse para leer archivos delimitados y ancho fijo.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto delimitado|[Cómo: Leer archivos de texto delimitado por comas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: Leer archivos de texto de ancho fijo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: Leer archivos de texto con varios formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este ejemplo se abre el `TextFieldParser.reader` y lo usa para leer desde `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila utilizando el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md">Procedimiento para leer archivos de texto en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md">Procedimiento Leer archivos de texto delimitado por comas en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md">Procedimiento para leer archivos de texto con varios formatos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md">Analizar archivos de texto con el objeto TextFieldParser</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFieldParser">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser (string file, params string[] delimiters);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class Microsoft.VisualBasic.FileIO.TextFieldParser OpenTextFieldParser(string file, string[] delimiters) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFieldParser(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFieldParser (file As String, ParamArray delimiters As String()) As TextFieldParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::VisualBasic::FileIO::TextFieldParser ^ OpenTextFieldParser(System::String ^ file, ... cli::array &lt;System::String ^&gt; ^ delimiters);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFieldParser : string * string[] -&gt; Microsoft.VisualBasic.FileIO.TextFieldParser" Usage="fileSystemProxy.OpenTextFieldParser (file, delimiters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileIO.TextFieldParser</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="delimiters" Type="System.String[]" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="file">El archivo que se abrirá con el <see langword="TextFieldParser" />.</param>
        <param name="delimiters">Delimitadores de los campos.</param>
        <summary>El <see langword="OpenTextFieldParser" /> método le permite crear un <see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> object, que proporciona una forma sencilla y eficaz analizar archivos de texto estructurados, como los registros. La <see langword="TextFieldParser" /> objeto puede utilizarse para leer archivos delimitados y ancho fijo.</summary>
        <returns><see cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" /> para leer el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFieldParser` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto delimitado|[Cómo: Leer archivos de texto delimitado por comas](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md)|  
|Leer de un archivo de texto de ancho fijo|[Cómo: Leer archivos de texto de ancho fijo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-fixed-width-text-files.md)|  
|Leer de un archivo de texto con varios formatos|[Cómo: Leer archivos de texto con varios formatos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md)|  
  
   
  
## Examples  
 Este ejemplo se abre el `TextFieldParser.reader` y lo usa para leer desde `C:\TestFolder1\Test1.txt`.  
  
 [!code-vb[VbRefFile#18](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:Microsoft.VisualBasic.FileIO.MalformedLineException">No se puede analizar una fila utilizando el formato especificado. El mensaje de excepción especifica la línea que inicia la excepción, mientras que a la propiedad <see cref="P:Microsoft.VisualBasic.FileIO.TextFieldParser.ErrorLine" /> se le asigna el texto incluido en la línea.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Describe un conjunto de permisos de seguridad aplicados al código. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.TextFieldParser" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md">Procedimiento para leer archivos de texto en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-comma-delimited-text-files.md">Procedimiento Leer archivos de texto delimitado por comas en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files-with-multiple-formats.md">Procedimiento para leer archivos de texto con varios formatos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/parsing-text-files-with-the-textfieldparser-object.md">Analizar archivos de texto con el objeto TextFieldParser</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileReader">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se abre un <see cref="T:System.IO.StreamReader" /> objeto va a leer desde un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileReader (file As String) As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se leerá.</param>
        <summary>Se abre un <see cref="T:System.IO.StreamReader" /> objeto va a leer desde un archivo.</summary>
        <returns><see cref="T:System.IO.StreamReader" /> objeto que se va a leer el archivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Archivos de texto solo se pueden leer con un <xref:System.IO.StreamReader>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|En|Vea|  
|--------|---------|  
|Abrir un archivo con una <xref:System.IO.StreamReader>|[Cómo: Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Este ejemplo abre el archivo `Testfile.txt`, lee una línea y se muestra en la línea de un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para leer el archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md">Procedimiento para leer texto de archivos con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileReader">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader OpenTextFileReader (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamReader OpenTextFileReader(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileReader(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamReader ^ OpenTextFileReader(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="fileSystemProxy.OpenTextFileReader (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se leerá.</param>
        <param name="encoding">La codificación que se use para el contenido del archivo. El valor predeterminado es ASCII.</param>
        <summary>Se abre un <see cref="T:System.IO.StreamReader" /> objeto va a leer desde un archivo.</summary>
        <returns><see cref="T:System.IO.StreamReader" /> objeto que se va a leer el archivo</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Archivos de texto solo se pueden leer con un <xref:System.IO.StreamReader>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.OpenTextFileReader` método.  
  
|En|Vea|  
|--------|---------|  
|Abrir un archivo con una <xref:System.IO.StreamReader>|[Cómo: Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)|  
  
   
  
## Examples  
 Este ejemplo abre el archivo `Testfile.txt`, lee una línea y se muestra en la línea de un `MessageBox`.  
  
 [!code-vb[VbRefFile#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo especificado.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para leer el archivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamReader" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md">Procedimiento para leer texto de archivos con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenTextFileWriter">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se abre un <see cref="T:System.IO.StreamWriter" /> objeto para escribir en el archivo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenTextFileWriter (file As String, append As Boolean) As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="append" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se escriban en.</param>
        <param name="append"><see langword="True" /> Para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <summary>Se abre un <see cref="T:System.IO.StreamWriter" /> objeto para escribir en el archivo especificado.</summary>
        <returns><see cref="T:System.IO.StreamWriter" /> objeto que se va a escribir en el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `OpenTextFileWriter` método abre e Inicializa una secuencia para un archivo y, a continuación, devuelve el <xref:System.IO.StreamWriter> objeto para la secuencia. Puede escribir en la secuencia tantas veces como sea necesario y, a continuación, ciérrelo cuando haya terminado.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.IO.StreamWriter.Close%2A> método en el <xref:System.IO.StreamWriter> objeto para asegurarse de que todos los datos se escriben correctamente en la secuencia subyacente.  
  
 Si escribe sólo algunas cadenas en un archivo, es posible que sea más sencillo utilizar el <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> método.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|En|Vea|  
|--------|---------|  
|Escribir texto en un archivo con una `StreamWriter`|[Cómo: Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Este ejemplo se abre un <xref:System.IO.StreamWriter> con el `My.Computer.FileSystem.OpenTextFileWriter` método y se utiliza para escribir una cadena en un archivo de texto con el `WriteLine` método de la `StreamWriter` clase.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal final.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedimiento Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="OpenTextFileWriter">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter OpenTextFileWriter (string file, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.IO.StreamWriter OpenTextFileWriter(string file, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter(System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::StreamWriter ^ OpenTextFileWriter(System::String ^ file, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.OpenTextFileWriter : string * bool * System.Text.Encoding -&gt; System.IO.StreamWriter" Usage="fileSystemProxy.OpenTextFileWriter (file, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="append" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se escriban en.</param>
        <param name="append"><see langword="True" /> Para anexar el contenido en el archivo. <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <param name="encoding">Codificación que se usará en la escritura en el archivo. El valor predeterminado es ASCII.</param>
        <summary>Se abre un <see cref="T:System.IO.StreamWriter" /> para escribir en el archivo especificado.</summary>
        <returns><see cref="T:System.IO.StreamWriter" /> objeto que se va a escribir en el archivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `OpenTextFileWriter` método abre e Inicializa una secuencia para un archivo y, a continuación, devuelve el <xref:System.IO.StreamWriter> objeto para la secuencia. Puede escribir en la secuencia tantas veces como sea necesario y, a continuación, ciérrelo cuando haya terminado.  
  
> [!NOTE]
>  Debe llamar a la <xref:System.IO.StreamWriter.Close%2A> método en el <xref:System.IO.StreamWriter> objeto para asegurarse de que todos los datos se escriben correctamente en la secuencia subyacente.  
  
 Si escribe sólo algunas cadenas en un archivo, es posible que sea más sencillo utilizar el <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> método.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.OpenTextFileWriter` método.  
  
|En|Vea|  
|--------|---------|  
|Escribir texto en un archivo con una `StreamWriter`|[Cómo: Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)|  
  
   
  
## Examples  
 Este ejemplo se abre un <xref:System.IO.StreamWriter> con el `My.Computer.FileSystem.OpenTextFileWriter` método y se utiliza para escribir una cadena en un archivo de texto con el `WriteLine` método de la `StreamWriter` clase.  
  
 [!code-vb[VbRefFile#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El nombre de archivo finaliza con una barra diagonal final.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="T:System.IO.StreamWriter" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Procedimiento Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public byte[] ReadAllBytes (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance unsigned int8[] ReadAllBytes(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllBytes(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllBytes (file As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ReadAllBytes(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllBytes : string -&gt; byte[]" Usage="fileSystemProxy.ReadAllBytes file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se leerá.</param>
        <summary>Devuelve el contenido de un archivo como una matriz de bytes.</summary>
        <returns><see langword="Byte" /> matriz que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ReadAllBytes` método de la `My.Computer.FileSystem` objeto le permite leer de un archivo binario. El contenido del archivo se devuelve como una matriz de bytes.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.ReadAllBytes` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo binario|[Cómo: Leer archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-binary-files.md)|  
  
   
  
## Examples  
 En este ejemplo se lee del archivo `C:/Documents and Settings/selfportrait.jpg.`  
  
 [!code-vb[VbVbcnMyFileSystem#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el contenido de un archivo de texto como un <see langword="String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadAllText (file As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string -&gt; string" Usage="fileSystemProxy.ReadAllText file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo que se va a leer.</param>
        <summary>Devuelve el contenido de un archivo de texto como un <see langword="String" />.</summary>
        <returns><see langword="String" /> que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método `ReadAllText` del objeto `My.Computer.FileSystem` permite leer de un archivo de texto. El contenido del archivo se devuelve como una cadena.  
  
 La codificación del archivo se puede especificar si el contenido del archivo está en una codificación como ASCII o UTF-8. Si está leyendo desde un archivo con caracteres extendidos, deberá especificar la codificación del archivo con otra sobrecarga de la <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText%2A> método.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.ReadAllText` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto|[Cómo: Leer de archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 En este ejemplo lee el contenido de `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este ejemplo lee el contenido del archivo ASCII `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String)" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md">Procedimiento para leer texto de archivos con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/troubleshooting-reading-from-and-writing-to-text-files.md">Solución del problema: leer y escribir en archivos de texto</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-encodings.md">Codificaciones de archivos</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public string ReadAllText (string file, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance string ReadAllText(string file, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadAllText(System::String ^ file, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.ReadAllText : string * System.Text.Encoding -&gt; string" Usage="fileSystemProxy.ReadAllText (file, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Nombre y ruta de acceso del archivo que se va a leer.</param>
        <param name="encoding">Codificación de caracteres que usará al leer el archivo. El valor predeterminado es UTF-8.</param>
        <summary>Devuelve el contenido de un archivo de texto como un <see langword="String" />.</summary>
        <returns><see langword="String" /> que contiene el contenido del archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método `ReadAllText` del objeto `My.Computer.FileSystem` permite leer de un archivo de texto. El contenido del archivo se devuelve como una cadena.  
  
 La codificación del archivo se puede especificar si el contenido del archivo está en una codificación como ASCII o UTF-8. Si está leyendo desde un archivo con caracteres extendidos, deberá especificar la codificación del archivo.  
  
 No tome ninguna decisión sobre el contenido del archivo basándose en su nombre. Por ejemplo, es posible que el archivo Form1.vb no sea un archivo de código fuente de Visual Basic. Compruebe todas las entradas antes de utilizar los datos en la aplicación.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.ReadAllText` método.  
  
|En|Vea|  
|--------|---------|  
|Leer de un archivo de texto|[Cómo: Leer de archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-from-text-files.md)|  
  
   
  
## Examples  
 En este ejemplo lee el contenido de `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#8)]  
  
 Este ejemplo lee el contenido del archivo ASCII `Test.txt` en una cadena y, a continuación, se muestra en un cuadro de mensaje.  
  
 [!code-vb[VbRefFile#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md">Procedimiento para leer texto de archivos con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/troubleshooting-reading-from-and-writing-to-text-files.md">Solución del problema: leer y escribir en archivos de texto</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md">Tutorial: Manipular archivos y directorios en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-encodings.md">Codificaciones de archivos</related>
      </Docs>
    </Member>
    <Member MemberName="RenameDirectory">
      <MemberSignature Language="C#" Value="public void RenameDirectory (string directory, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameDirectory(string directory, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameDirectory (directory As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameDirectory(System::String ^ directory, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameDirectory : string * string -&gt; unit" Usage="fileSystemProxy.RenameDirectory (directory, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directory" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="directory">Ruta de acceso y nombre del directorio que se va a cambiar.</param>
        <param name="newName">Nuevo nombre de directorio.</param>
        <summary>Cambia el nombre de un directorio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede usar este método para mover un directorio; Utilice el `MoveDirectory` método para mover y cambiar el nombre del directorio.  
  
   
  
## Examples  
 Este ejemplo se cambia el `Test` en `SecondTest`.  
  
 [!code-vb[VbVbcnMyFileSystem#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> contiene información sobre la ruta de acceso.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="directory" /> es <see langword="Nothing" />.  
  
-o bien- 
 <paramref name="newName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">El directorio no existe.</exception>
        <exception cref="T:System.IO.IOException">Hay un archivo o directorio con el nombre especificado en <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Procedimiento para analizar rutas de acceso a archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="RenameFile">
      <MemberSignature Language="C#" Value="public void RenameFile (string file, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void RenameFile(string file, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.RenameFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RenameFile (file As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RenameFile(System::String ^ file, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="member this.RenameFile : string * string -&gt; unit" Usage="fileSystemProxy.RenameFile (file, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newName" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se va a cambiar.</param>
        <param name="newName">Nuevo nombre de archivo.</param>
        <summary>Cambia el nombre de un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede usar este método para mover un archivo. Use el método <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.MoveFile%2A> para mover y cambiar el nombre del archivo.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.RenameFile` método.  
  
|En|Vea|  
|--------|---------|  
|Cambiar el nombre de un archivo|[Cómo: Cambiar el nombre de un archivo](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md)|  
  
   
  
## Examples  
 Este ejemplo cambia el nombre del archivo `Test.txt` a `SecondTest.txt`.  
  
 [!code-vb[VbVbcnMyFileSystem#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#1)]  
  
 Cambie "`C:\Test.txt`" a la ruta de acceso y el nombre del archivo que desea cambiar el nombre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newName" /> contiene información de la ruta de acceso o finaliza con una barra diagonal inversa (\\).</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.  
  
-o bien- 
 <paramref name="newName" /> es <see langword="Nothing" /> o una cadena vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">Hay un archivo o directorio con el nombre especificado en <paramref name="newName" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene el permiso necesario.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SpecialDirectories">
      <MemberSignature Language="C#" Value="public Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy SpecialDirectories" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpecialDirectories As SpecialDirectoriesProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ SpecialDirectories { Microsoft::VisualBasic::MyServices::SpecialDirectoriesProxy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SpecialDirectories : Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy" Usage="Microsoft.VisualBasic.MyServices.FileSystemProxy.SpecialDirectories" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MyServices.SpecialDirectoriesProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que proporciona propiedades para tener acceso a normalmente hace referencia a directorios.</summary>
        <value>Esta propiedad devuelve el <see cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" /> objeto para el equipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo devuelve la ruta de acceso de directorio escritorio del usuario y lo muestra.  
  
 [!code-vb[VbVbcnMyFileSystem#80](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#80)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.FileIO.SpecialDirectories" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public void WriteAllBytes (string file, byte[] data, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllBytes(string file, unsigned int8[] data, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllBytes(System.String,System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllBytes (file As String, data As Byte(), append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllBytes(System::String ^ file, cli::array &lt;System::Byte&gt; ^ data, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllBytes : string * byte[] * bool -&gt; unit" Usage="fileSystemProxy.WriteAllBytes (file, data, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="append" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Ruta de acceso y nombre del archivo que se va a escribir en.</param>
        <param name="data">Datos se escriban en el archivo.</param>
        <param name="append"><see langword="True" /> Para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <summary>Escribe datos en un archivo binario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ruta de acceso especificada excepto el nombre de archivo, no es válido, un <xref:System.IO.DirectoryNotFoundException> se producirá la excepción. Si la ruta de acceso es válida pero el archivo no existe, se crea el archivo.  
  
> [!NOTE]
>  El `WriteAllBytes` método abre un archivo, escribe en ella y, a continuación, lo cierra. El código que usa el `WriteAllBytes` método es más sencillo que el código que usa un <xref:System.IO.BinaryWriter> objeto. Sin embargo, si va a agregar datos a un archivo mediante un bucle, un <xref:System.IO.BinaryWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez.  
  
 La tabla siguiente muestra un ejemplo de una tarea que implica la `My.Computer.FileSystem.WriteAllBytes` método.  
  
|En|Vea|  
|--------|---------|  
|Escribir en un archivo binario|[Cómo: Escribir en archivos binarios](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md)|  
  
   
  
## Examples  
 En este ejemplo se anexa la matriz de datos `CustomerData` al archivo `CollectedData`.  
  
 [!code-vb[VbVbcnMyFileSystem#50](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbcnMyFileSystem/VB/Class1.vb#50)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-to-binary-files.md">Procedimiento Escribir en un archivo binario en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteAllText">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe texto en un archivo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteAllText (file As String, text As String, append As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="text" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="append" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se escriban en.</param>
        <param name="text">Texto que se escriben en el archivo.</param>
        <param name="append"><see langword="True" /> Para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <summary>Escribe texto en un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La codificación UTF-8 se usa para escribir en el archivo. Para especificar una codificación distinta, use una sobrecarga diferente de la <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText%2A> método.  
  
 Si el archivo especificado no existe, se crea.  
  
 Si la codificación especificada no coincide con la codificación existente del archivo, se omite la codificación especificada.  
  
> [!NOTE]
>  El `WriteAllText` método abre un archivo, escribe en ella y, a continuación, lo cierra. El código que usa el `WriteAllText` método es más sencillo que el código que usa un <xref:System.IO.StreamWriter> objeto. Sin embargo, si va a agregar cadenas a un archivo mediante el uso de un bucle, un <xref:System.IO.StreamWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez. Para obtener más información, vea el método <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.WriteAllText` método.  
  
|En|Vea|  
|--------|---------|  
|Escribir texto en un archivo|[Cómo: Escribir texto en archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto a un archivo|[Cómo: Anexar a archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 En este ejemplo escribe la línea `"This is new text to be added."` al archivo `Test.txt`, sobrescribiendo cualquier texto existente en el archivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 En este ejemplo escribe los nombres de los archivos en el `Documents and Settings` carpeta `FileList.txt`, insertar un carro devuelve un valor entre cada uno de ellos para mejorar la legibilidad.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <altmember cref="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public void WriteAllText (string file, string text, bool append, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void WriteAllText(string file, string text, bool append, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.MyServices.FileSystemProxy.WriteAllText(System.String,System.String,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteAllText(System::String ^ file, System::String ^ text, bool append, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.WriteAllText : string * string * bool * System.Text.Encoding -&gt; unit" Usage="fileSystemProxy.WriteAllText (file, text, append, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="text" Type="System.String" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="append" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="file">Archivo que se escriban en.</param>
        <param name="text">Texto que se escriben en el archivo.</param>
        <param name="append"><see langword="True" /> Para anexar el contenido del archivo; <see langword="False" /> para sobrescribir el contenido del archivo. El valor predeterminado es <see langword="False" />.</param>
        <param name="encoding">Qué codificación se debe usar al escribir en el archivo. El valor predeterminado es UTF-8.</param>
        <summary>Escribe texto en un archivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo especificado no existe, se crea.  
  
 Si la codificación especificada no coincide con la codificación existente del archivo, se omite la codificación especificada.  
  
> [!NOTE]
>  El `WriteAllText` método abre un archivo, escribe en ella y, a continuación, lo cierra. El código que usa el `WriteAllText` método es más sencillo que el código que usa un <xref:System.IO.StreamWriter> objeto. Sin embargo, si va a agregar cadenas a un archivo mediante el uso de un bucle, un <xref:System.IO.StreamWriter> objeto puede proporcionar un mejor rendimiento porque sólo tiene que abrir y cerrar el archivo una vez. Para obtener más información, vea el método <xref:Microsoft.VisualBasic.MyServices.FileSystemProxy.OpenTextFileWriter%2A>.  
  
 En la tabla siguiente se muestra ejemplos de tareas que implican la `My.Computer.FileSystem.WriteAllText` método.  
  
|En|Vea|  
|--------|---------|  
|Escribir texto en un archivo|[Cómo: Escribir texto en archivos](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md)|  
|Anexar texto a un archivo|[Cómo: Anexar a archivos de texto](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-append-to-text-files.md)|  
  
   
  
## Examples  
 En este ejemplo escribe la línea `"This is new text to be added."` al archivo `Test.txt`, sobrescribiendo cualquier texto existente en el archivo.  
  
 [!code-vb[VbRefFile#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#21)]  
  
 En este ejemplo escribe los nombres de los archivos en el `Documents and Settings` carpeta `FileList.txt`, insertar un carro devuelve un valor entre cada uno de ellos para mejorar la legibilidad.  
  
 [!code-vb[VbRefFile#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbRefFile/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida por una de las razones siguientes: es una cadena de longitud cero; solo contiene un espacio en blanco; contiene caracteres no válidos; o es una ruta de acceso de dispositivo (empieza por \\\\.\\); finaliza con una barra diagonal final.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="file" /> es <see langword="Nothing" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo no existe.</exception>
        <exception cref="T:System.IO.IOException">El archivo está en uso por otro proceso o se produce un error de E/S.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">Un nombre de archivo o directorio en la ruta de acceso contiene dos puntos (:) o tiene un formato no válido.</exception>
        <exception cref="T:System.OutOfMemoryException">No hay suficiente memoria para escribir la cadena en el búfer.</exception>
        <exception cref="T:System.Security.SecurityException">El usuario no tiene los permisos necesarios para ver la ruta de acceso.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Controla la capacidad para tener acceso a archivos y carpetas. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/visual-basic/language-reference/objects/index.md">Objetos (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
  </Members>
</Type>