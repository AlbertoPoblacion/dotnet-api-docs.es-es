<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="84b5572cf9ba0ae76ee1c5c3bb7375f8ce499c04" /><Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="08/24/2018" /><Meta Name="ms.locfileid" Value="37521579" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona un conjunto estándar de comandos relacionados con la edición.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente tabla muestra los comandos de edición y el valor predeterminado asociado gestos claves (con nombres de clave desde el <xref:System.Windows.Input.Key> y <xref:System.Windows.Input.ModifierKeys> enumeraciones).  
  
|Comando de edición|Gesto de teclas predeterminado|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|ningún gesto de teclas predeterminado|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|ningún gesto de teclas predeterminado|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Comandos de movimiento de símbolo de intercalación y selección de expansión de los comandos comparten un conjunto común de movimientos de claves de forma predeterminada, la diferencia general que se va a la adición de la <xref:System.Windows.Input.ModifierKeys.Shift> clave para diferenciar los comandos de selección de los comandos de movimiento de símbolo de intercalación.  Por ejemplo, el <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> comando tiene un gesto de teclas predeterminado de <xref:System.Windows.Input.Key.Left>y la correspondiente <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> comando tiene un gesto de teclas predeterminado de <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 En general, las definiciones de comando proporcionan por el <xref:System.Windows.Documents.EditingCommands> clase no realice el uso de parámetros del comando (el `parameter` parámetro esperado por el <xref:System.Windows.Input.ICommand.Execute%2A> método).  
  
 Para obtener más información sobre los comandos y los comandos, consulte [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />, que solicita que se centre el párrafo actual o una selección de párrafos.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todo el contenido de cada párrafo que participa en la selección.  
  
 En la siguiente ilustración se muestra un ejemplo de contenido centrado.  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de Center](~/add/media/flowdoc-textalign-center.png "captura de pantalla: valor de propiedad TextAlign de Center")  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />, que solicita que se justifique el párrafo actual o una selección de párrafos.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todos los párrafos de la selección.  
  
 Cuando se justifica el contenido, el espaciado horizontal dentro de cada línea del contenido se ajusta para que las líneas justificadas son de ancho igual o casi igual.  Normalmente se justifica el contenido para crear bordes suavizados en los lados del contenido.  
  
 Dado que a menudo es más corto que el resto, la última línea de un párrafo puede quedarse sin justificar después de invoca este comando.  
  
 La siguiente ilustración muestra justificado contenido (alineados a la izquierda).  
  
 ![Captura de pantalla: El contenido no está justificado](~/add/media/content-unjustified.png "captura de pantalla: contenido no está justificado")  
  
 La siguiente ilustración muestra el mismo contenido una vez que se ha justificado.  
  
 ![Texto justificado a la captura de pantalla de contenido](~/add/media/content-justified.png "texto justificado a la captura de pantalla de contenido")  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />, que solicita que una selección de contenido se alinee a la izquierda.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todo el contenido de cada párrafo que participa en la selección.  
  
 En la siguiente ilustración se muestra un ejemplo de contenido alineado a la izquierda.  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de izquierda](~/add/media/flowdoc-textalign-left.png "captura de pantalla: valor de propiedad TextAlign de izquierda")  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" />, que solicita que una selección de contenido se alinee a la derecha.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todo el contenido de cada párrafo que participa en la selección.  
  
 En la siguiente ilustración se muestra un ejemplo de contenido alineado a la derecha.  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de derecha](~/add/media/flowdoc-textalign-right.png "captura de pantalla: valor de Right de propiedad TextAlign")  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.Backspace" />, que solicita que se aplique un retroceso en la posición actual o encima de la selección actual.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se invoca en una selección vacía, este comando elimina el carácter o separador de párrafo justo antes del símbolo de intercalación. Cuando se invoca en una selección no vacía, este comando elimina la selección.  
  
 Este comando mantiene el formato de la selección eliminada para el contenido que se inserte en la misma ubicación inmediatamente después de invoca este comando.  Compare con la <xref:System.Windows.Documents.EditingCommands.Delete%2A> comando, que no mantiene el formato anterior.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />, que solicita que se corrija cualquier palabra mal escrita en la posición actual.</summary>
        <value>Comando solicitado.  Este comando no tiene ningún gesto de teclas predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />, que solicita que se reduzca 1 punto el tamaño de fuente de la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se invoca este comando en una selección vacía donde el símbolo de intercalación está dentro de una palabra, la selección se expande automáticamente para aplicar el comando a la palabra completa.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />, que solicita que se reduzca una posición de tabulación la sangría del párrafo actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Este comando no tiene ningún efecto en un elemento de texto a menos que el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propiedad del elemento de texto se establece en `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.Delete" />, que solicita que se elimine la selección actual.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando descarta cualquier formato de la selección eliminada.  Compare con la <xref:System.Windows.Documents.EditingCommands.Backspace%2A> de comandos, que mantiene el formato de la selección eliminada para el contenido que se inserte en la misma ubicación inmediatamente después de invoca este comando.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />, que solicita que se elimine la palabra siguiente (respecto a la posición actual).</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, se elimina el resto de la palabra entre la posición actual y el final de la palabra.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />, que solicita que se elimine la palabra anterior (respecto a la posición actual).</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, se elimina el resto de la palabra entre la posición actual y el principio de la palabra.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />, que solicita que se inserte un salto de línea en la posición actual o encima de la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para los editores que admiten contenido dinámico, como <xref:System.Windows.Controls.RichTextBox>, este comando hace que un <xref:System.Windows.Documents.LineBreak> elemento va a insertar en la posición actual.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />, que solicita que se inserte un salto de párrafo en la posición actual o encima de la selección actual.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando es equivalente al usuario presionar la tecla ENTRAR.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox> (cuando el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> propiedad es `true`).  
  
> [!IMPORTANT]
>  Este comando no tiene ningún efecto en un elemento de texto a menos que el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> propiedad del elemento de texto se establece en `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />, que solicita que se omitan todas las instancias de palabras mal escritas en la posición actual o en la selección actual.</summary>
        <value>Comando solicitado.  Este comando no tiene ningún gesto de teclas predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />, que solicita que se aumente 1 punto el tamaño de fuente de la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se invoca este comando en una selección vacía donde el símbolo de intercalación está dentro de una palabra, la selección se expande para aplicar el comando a la palabra completa.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />, que solicita que se aumente una posición de tabulación la sangría del párrafo actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  Este comando no tiene ningún efecto en un elemento de texto a menos que el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propiedad del elemento de texto se establece en `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />, que solicita que el símbolo de intercalación se desplace a la línea inferior.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />, que solicita que el símbolo de intercalación se desplace a la página siguiente.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />, que solicita que el símbolo de intercalación se desplace al párrafo siguiente.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando coloca el símbolo de intercalación al principio del párrafo siguiente.  
  
 Este comando se comporta como <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> cuando se invoca en un <xref:System.Windows.Controls.TextBox>.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />, que solicita que el símbolo de intercalación se desplace un carácter a la izquierda.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />, que solicita que el símbolo de intercalación se desplace una palabra a la izquierda.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, este comando mueve el símbolo de intercalación al principio de esa palabra.  En caso contrario, este comando mueve el símbolo de intercalación al principio de la palabra anterior.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />, que solicita que el símbolo de intercalación se desplace un carácter a la derecha.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />, que solicita que el símbolo de intercalación se desplace una palabra a la derecha.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, este comando mueve el símbolo de intercalación hasta el final de esa palabra.  En caso contrario, este comando mueve el símbolo de intercalación al principio de la palabra siguiente.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />, que solicita que el símbolo de intercalación se mueva hasta el final del contenido.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *contenedor de texto* es el elemento que constituye el borde final del contenido en cuestión.  <xref:System.Windows.Controls.TextBlock> y <xref:System.Windows.Documents.FlowDocument> son ejemplos de los contenedores de texto.  El contenido incluido de forma colectiva en un contenedor de texto se conoce como un *documento*.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />, que solicita que el símbolo de intercalación se mueva hasta el principio del contenido.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *contenedor de texto* es el elemento que constituye el borde final del contenido en cuestión.  <xref:System.Windows.Controls.TextBlock> y <xref:System.Windows.Documents.FlowDocument> son ejemplos de los contenedores de texto.  El contenido incluido de forma colectiva en un contenedor de texto se conoce como un *documento*.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />, que solicita que el símbolo de intercalación se mueva hasta el final de la línea actual.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />, que solicita que el símbolo de intercalación se mueva hasta el principio de la línea actual.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />, que solicita que el símbolo de intercalación se desplace a la línea superior.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />, que solicita que el símbolo de intercalación se desplace a la página superior.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />, que solicita que el símbolo de intercalación se desplace al párrafo anterior.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando coloca el símbolo de intercalación al principio del párrafo siguiente.  
  
 Este comando se comporta como <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> cuando se invoca en un <xref:System.Windows.Controls.TextBox>.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />, que solicita que la selección actual se amplíe hasta la línea inferior.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />, que solicita que la selección actual se amplíe hasta la página siguiente.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />, que solicita que la selección actual se amplíe hasta el párrafo siguiente.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando amplía la selección hasta el principio del párrafo siguiente.  En caso contrario, este comando amplía la selección hasta el final del párrafo actual.  La selección ampliada incluye el salto de párrafo que marca el final del párrafo.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />, que solicita que la selección actual se amplíe hasta el carácter de la izquierda.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />, que solicita que la selección actual se amplíe hasta la palabra de la izquierda.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, este comando amplía la selección hasta el principio de esa palabra.  En caso contrario, este comando amplía la selección hasta el principio de la palabra anterior.  
  
 La selección ampliada no incluye el delimitador de palabra.  Compare con <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, que incluye el delimitador de palabra en la selección expandida.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />, que solicita que la selección actual se amplíe hasta el carácter de la derecha.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />, que solicita que la selección actual se amplíe hasta la palabra de la derecha.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está dentro de una palabra, este comando amplía la selección al final de esa palabra.  En caso contrario, este comando amplía la selección hasta el final de la palabra siguiente.  
  
 La selección ampliada incluye el delimitador de palabra.  Compare con <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> que no incluye el delimitador de palabra en la selección expandida.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />, que solicita que la selección actual se amplíe hasta el final del contenido.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *contenedor de texto* es el elemento que constituye el borde final del contenido en cuestión.  <xref:System.Windows.Controls.TextBlock> y <xref:System.Windows.Documents.FlowDocument> son ejemplos de los contenedores de texto.  El contenido incluido de forma colectiva en un contenedor de texto se conoce como un *documento*.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />, que solicita que la selección actual se amplíe hasta el principio del contenido.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *contenedor de texto* es el elemento que constituye el borde final del contenido en cuestión.  <xref:System.Windows.Controls.TextBlock> y <xref:System.Windows.Documents.FlowDocument> son ejemplos de los contenedores de texto.  El contenido incluido de forma colectiva en un contenedor de texto se conoce como un *documento*.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />, que solicita que la selección actual se amplíe hasta el final de la línea actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />, que solicita que la selección actual se amplíe hasta el principio de la línea actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />, que solicita que la selección actual se amplíe hasta la línea superior.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />, que solicita que la selección actual se expanda una página.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />, que solicita que la selección actual se amplíe hasta el párrafo anterior.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el símbolo de intercalación está al principio de un párrafo, este comando amplía la selección hasta el principio del párrafo anterior.  En caso contrario, este comando amplía la selección hasta el principio del párrafo actual.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" />.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de este comando depende de la selección actual. Si la selección no está vacío, este comando es equivalente a <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Si el símbolo de intercalación está en una celda de tabla (representado por la <xref:System.Windows.Documents.TableCell> elemento), este comando mueve el símbolo de intercalación a la celda anterior. En caso contrario, se inserta un carácter de tabulación en la posición actual.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox> (cuando el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propiedad es `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.TabForward" />.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento de este comando depende de la selección actual. Si la selección no está vacío o si la selección está vacía y la posición actual del símbolo de intercalación está al principio de un párrafo, este comando es equivalente a <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Si el símbolo de intercalación está en una celda de tabla (representado por la <xref:System.Windows.Documents.TableCell> elemento), este comando mueve el símbolo de intercalación a la celda siguiente. Si el símbolo de intercalación está en la última celda de una tabla, este comando hace que una nueva fila que se debe anexar a la tabla, con el símbolo de intercalación está situado en la primera celda de la nueva fila.  En caso contrario, se inserta un carácter de tabulación en la posición actual.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox> y <xref:System.Windows.Controls.TextBox> (cuando el <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> propiedad es `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />, que solicita que se alterne el formato <see cref="T:System.Windows.Documents.Bold" /> en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.FontWeight> para la selección actual está en el intervalo de <xref:System.Windows.FontWeights.Thin%2A> a <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> se aplica a la selección actual.  En caso contrario, <xref:System.Windows.FontWeights.Normal%2A> se aplica.  Para obtener una lista comparativa de <xref:System.Windows.FontWeight> valores, vea <xref:System.Windows.FontWeights>.  
  
 Cuando la selección está vacía y el símbolo de intercalación está dentro de una palabra, la selección se expande para incluir la palabra completa.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" />, que solicita que se alterne el formato de lista no ordenada (también conocida como lista con viñetas) en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todo el contenido de cada párrafo que participa en la selección.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" />, que alterna el modo de escritura entre Insertar y Sobrescribir.</summary>
        <value>Comando solicitado.  El gesto de tecla predeterminado para este comando es <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, y <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />, que solicita que se alterne el formato <see cref="T:System.Windows.Documents.Italic" /> en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.FontStyle> para la selección actual es <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> se aplica a la selección actual.  En caso contrario, <xref:System.Windows.FontStyles.Normal%2A> se aplica.  
  
 Cuando la selección está vacía y el símbolo de intercalación está dentro de una palabra, la selección se expande para incluir la palabra completa.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />, que solicita que se alterne el formato de lista ordenada (también conocida como lista numerada) en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando funciona en el <xref:System.Windows.Documents.Paragraph> nivel.  Si se invoca este comando en una selección parcial del contenido dentro de un párrafo (incluida una selección vacía donde el símbolo de intercalación está dentro de un párrafo), el efecto solicitado se aplica a todo el párrafo.  Si se invoca este comando en una selección que abarca varios párrafos, el efecto se aplica a todo el contenido de cada párrafo que participa en la selección.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />, que solicita que se alterne el formato de subíndice en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />, que solicita que se alterne el formato de superíndice en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa el comando <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />, que solicita que se alterne el formato <see cref="T:System.Windows.Documents.Underline" /> en la selección actual.</summary>
        <value>Comando solicitado.  El gesto de teclas predeterminado para este comando es <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando la selección está vacía y el símbolo de intercalación está dentro de una palabra, la selección se expande para incluir la palabra completa.  
  
 No hay necesariamente una implementación real que responda a este comando en un objeto dado; en muchos casos, la implementación que responde a un comando es responsabilidad del autor de la aplicación.  
  
 Este comando se admite de forma nativa <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invocar un comando de edición en un objeto que admite el comando.  
  
 En este ejemplo, un <xref:System.Windows.Controls.RichTextBox> actúa como el destino del comando.  Tenga en cuenta que <xref:System.Windows.Controls.RichTextBox> implementa el <xref:System.Windows.IInputElement> interfaz (se hereda de <xref:System.Windows.FrameworkElement>), y que incluye compatibilidad nativa con muchos comandos de edición.  
  
 El primer argumento para el <xref:System.Windows.Input.RoutedCommand.Execute%2A> método es un parámetro de comando.  Comandos de edición más omiten el parámetro de comando; en general, este parámetro debe ser `null` para comandos de edición.  
  
 El segundo argumento especifica el objeto al que se enrutará el comando.  Este objeto debe implementar la <xref:System.Windows.IInputElement> interfaz y debe incluir un controlador para el comando especificado.  Por lo general, un comando se omite cuando se invoca en un objeto que no controla el comando.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>