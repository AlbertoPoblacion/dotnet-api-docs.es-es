<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d374acbfa59bece9a23ff4841ba74263d0c6fa42" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630719" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa una posición dentro de un <see cref="T:System.Windows.Documents.FlowDocument" /> o <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Documents.TextPointer> clase presenta la siguiente terminología:  
  
-   Colocar - intrínsecamente, un <xref:System.Windows.Documents.TextPointer> siempre apunta a un *posición* en contenido.  Estas posiciones se encuentran entre caracteres en el contenido, o entre el flujo de contenido de etiquetas de los elementos que definen la estructura del contenido.  
  
-   Posición actual - porque un <xref:System.Windows.Documents.TextPointer> siempre indica una posición y dado que muchas de las operaciones que pueden realizarse a través de un <xref:System.Windows.Documents.TextPointer> son relativas a la posición actualmente señalada por el <xref:System.Windows.Documents.TextPointer>, tiene sentido simplemente hacen referencia a la posición indicada por un <xref:System.Windows.Documents.TextPointer> como el *posición actual*.  
  
-   Posición de inserción: una *posición de inserción* es una posición donde se puede agregar nuevo contenido sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
-   Símbolo - para los fines de <xref:System.Windows.Documents.TextPointer> las operaciones que implican símbolos, ninguno de los siguientes se considera un *símbolo*:  
  
    -   Una etiqueta inicial o final de un <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   A <xref:System.Windows.UIElement> elemento dentro de un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
    -   Cada uno de ellos de 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
-   Contenedor de texto - A *contenedor de texto* es el elemento que forma el verdadero límite del contenido dinámico en cuestión; la posición indicada por una <xref:System.Windows.Documents.TextPointer> siempre se encuentra dentro de un contenedor de texto.  Actualmente, un contenedor de texto debe ser un <xref:System.Windows.Documents.FlowDocument> o <xref:System.Windows.Controls.TextBlock>.  En general, las operaciones entre <xref:System.Windows.Documents.TextPointer> no se admiten instancias en contenedores de texto diferente.  
  
-   Documento: el contenido de un contenedor de texto se conoce como un *documento*, como en el <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método y <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> y <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propiedades.  
  
 El <xref:System.Windows.Documents.TextPointer> clase está diseñada para facilitar la exploración transversal y la manipulación de contenido que se representa mediante [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementos de contenido dinámico; por lo general, estos elementos se derivan de <xref:System.Windows.Documents.TextElement>.  Algunas de las operaciones que <xref:System.Windows.Documents.TextPointer> facilita incluyen lo siguiente:  
  
-   Realizar una comparación ordinal de la posición actual con una segunda posición especificada.  Consulte la <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método.  
  
-   Determinar el tipo de contenido adyacente a la posición actual en una dirección especificada.  Consulte la <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método y <xref:System.Windows.Documents.TextPointerContext> enumeración.  
  
-   Obtener el <xref:System.Windows.Documents.TextElement> que establece el ámbito o es adyacente a la posición actual.  Vea <xref:System.Windows.Documents.Paragraph> y <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> método.  
  
-   Obtener el contenedor de texto que abarca el documento actual.  Vea la propiedad <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obtener un número especificado de caracteres antes o después de la posición actual.  Consulte la <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método.  
  
-   Inserte una cadena de caracteres en la posición actual.  Consulte la <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> método.  
  
-   Buscar los límites de la línea de contenido.  Consulte la <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método y <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propiedad.  
  
-   Traducir entre <xref:System.Windows.Documents.TextPointer> posiciones y símbolos se desplaza en contenido.  Consulte la <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos.  
  
-   Realizar pruebas de posicionamiento visual mediante la traducción entre un <xref:System.Windows.Documents.TextPointer> posición y un <xref:System.Windows.Point> que representan coordenadas relativas.  
  
-   Buscar una posición de inserción cercana o comprobar si la posición actual es una posición de inserción.  Consulte la <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> métodos y <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propiedad.  
  
 La posición y <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicado por un <xref:System.Windows.Documents.TextPointer> objeto son inmutables.  Cuando el contenido está editado o modificado, la posición indicada por una <xref:System.Windows.Documents.TextPointer> no cambia en relación con el texto que lo rodea; en su lugar el desplazamiento de esa posición desde el principio del contenido se ajusta según corresponda para reflejar la nueva posición relativa en el contenido.  Por ejemplo, un <xref:System.Windows.Documents.TextPointer> que indica una posición al principio de un párrafo determinado continúa señalando al principio de ese párrafo incluso cuando el contenido se inserta o elimina antes o después del párrafo.  
  
 La <xref:System.Windows.Documents.TextPointer> clase no proporciona ningún constructor público.  Una instancia de <xref:System.Windows.Documents.TextPointer> se crea mediante el uso de propiedades o métodos de otros objetos (los incluidos <xref:System.Windows.Documents.TextPointer> objetos). La siguiente lista proporciona algunos ejemplos de métodos y propiedades que crear y devuelven un <xref:System.Windows.Documents.TextPointer>.  Esta lista no es exhaustiva:  
  
-   Desde un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> y <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Desde un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, y <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Desde un <xref:System.Windows.Controls.TextBlock> (contenedor de texto): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, y <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Desde un <xref:System.Windows.Documents.FlowDocument> (contenedor de texto): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, y <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Desde una existente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar un <xref:System.Windows.Documents.TextPointer> para buscar una posición justo dentro de la primera <xref:System.Windows.Documents.Run> elemento de un contenedor de texto especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 En el ejemplo siguiente se implementa un algoritmo de búsqueda sencillo utilizando <xref:System.Windows.Documents.TextPointer> instalaciones.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para comparar a la posición actual.</param>
        <summary>Realiza una comparación de ordinales entre las posiciones especificadas por el <see cref="T:System.Windows.Documents.TextPointer" /> actual y un segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>–1 si el <see cref="T:System.Windows.Documents.TextPointer" /> actual precede a <paramref name="position" />; 0 si las ubicaciones son las mismas; +1 si el <see cref="T:System.Windows.Documents.TextPointer" /> actual sigue a <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de – 1 indica que la posición especificada por el actual <xref:System.Windows.Documents.TextPointer> precede a la posición especificada por `position`.  Un valor de 0 indica que las posiciones indicadas son iguales.  Un valor de + 1 positivo indica que la posición especificada por el actual <xref:System.Windows.Documents.TextPointer> sigue a la posición especificada por `position`.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método.  En el ejemplo, el <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método se utiliza junto con la <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para comprobar si un determinado <xref:System.Windows.Documents.TextElement> está vacía.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> especifica una posición fuera del contenedor de texto asociado a la posición actual.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">El número de caracteres para eliminar, a partir de la posición actual. Especifique un valor positivo para eliminar caracteres que siguen a la posición actual y un valor negativo para eliminar caracteres que preceden a la posición actual.</param>
        <summary>Elimina el número de caracteres especificado de la posición indicada por el <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns>El número de caracteres eliminado realmente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique un valor positivo para eliminar caracteres que siguen a la posición actual (como en <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); Especifique un valor negativo para eliminar caracteres que preceden a la posición actual (como en <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 El número de caracteres eliminado realmente puede ser menor que el número especificado por `count`.  Esto sucede en casos donde `count` especifica más caracteres de los que existen para ser eliminados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha llamado al método en una posición en la que el texto no está permitido.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Documents.TextPointer" /> al final del contenido en el contenedor de texto asociado a la posición actual.</summary>
        <value>
          <see cref="T:System.Windows.Documents.TextPointer" /> al final del contenido en el contenedor de texto asociado a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Documents.TextPointer.Parent%2A> para el valor devuelto <xref:System.Windows.Documents.TextPointer> siempre es un contenedor de texto (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), en lugar de un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Documents.TextPointer" /> al principio del contenido en el contenedor de texto asociado a la posición actual.</summary>
        <value>
          <see cref="T:System.Windows.Documents.TextPointer" /> al principio del contenido en el contenedor de texto asociado a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la posición devuelta por esta propiedad como una posición de línea base desde la que se va a trabajar con desplazamientos relativos a otras posiciones.  El <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos proporcionan un medio para traducir entre las posiciones y posición desplazamientos.  
  
 El <xref:System.Windows.Documents.TextPointer.Parent%2A> para el valor devuelto <xref:System.Windows.Documents.TextPointer> siempre es un contenedor de texto (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), en lugar de un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar un elemento adyacente.</param>
        <summary>Devuelve el elemento, en caso de que exista, que limita al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>El elemento adyacente en la <paramref name="direction" /> especificada o <see langword="null" /> si no existe ningún elemento adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El elemento devuelto es normalmente un <xref:System.Windows.Documents.TextElement>.  A <xref:System.Windows.UIElement> puede devolver cuando la <xref:System.Windows.Documents.TextPointer> indica una posición dentro de un <xref:System.Windows.Documents.BlockUIContainer> elemento o un <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar un rectángulo de selección del contenido.</param>
        <summary>Devuelve un rectángulo de selección (<see cref="T:System.Windows.Rect" />) para el contenido que limita el <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Un rectángulo de selección para el contenido que limita el <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección especificada o <see cref="P:System.Windows.Rect.Empty" /> si no hay disponible información de presentación actual válida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> bordes no se consideran contenido para los fines de este método.  Si el <xref:System.Windows.Documents.TextPointer> se coloca antes un <xref:System.Windows.Documents.TextElement> borde, el valor devuelto es un cuadro de límite para los siguientes no son<xref:System.Windows.Documents.TextElement> contenido en la dirección especificada.  Si no hay ningún contenido en la dirección especificada, un ancho de cero <xref:System.Windows.Rect> se devuelve con un alto que coincide con el alto de los anteriores contenido.  
  
 La operación realizada por este método depende de un diseño válido.  Cuando sea necesario, este método intenta regenerar automáticamente un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Use la <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propiedad para comprobar un diseño válido antes de realizar operaciones que pueden regenerar el diseño.  Para obtener más información, consulte [diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar la posición de inserción más cercana.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción más cercana en la dirección lógica especificada.</summary>
        <returns>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción más cercana en la dirección especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una posición de inserción es una posición donde se puede agregar nuevo contenido sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
 Si el <xref:System.Windows.Documents.TextPointer> ya apunta a una posición de inserción válida, pero la etiqueta de cierre de una secuencia de formato no vacía sigue directamente a esa posición en la dirección dada, la <xref:System.Windows.Documents.TextPointer> devuelta por este método se ajusta para que apunte a la posición de inserción justo después del cierre de la secuencia de formato. Por ejemplo, considere la posibilidad de la secuencia de marcado `<Bold>a</Bold>b`. Tenga en cuenta que hay dos posiciones de inserción entre las letras `a` y `b` : uno que precede al punto final `Bold` etiqueta y uno justo después del cierre `Bold` etiqueta. Si <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> se llama en un <xref:System.Windows.Documents.TextPointer> a la posición directamente después de la letra `a` y antes del cierre `Bold` etiqueta y con un `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, el valor devuelto <xref:System.Windows.Documents.TextPointer> se ajusta para que señale a la posición justo antes de la letra `b`, tras el cierre `Bold` etiqueta. Se realiza un ajuste similar para formato de etiquetas de apertura cuando se trabaja en la dirección lógica opuesta. Este método está pensado para proporcionar un medio de la anulación de ambigüedades entre posiciones de inserción en casos similares.  
  
 Este método se puede utilizar también para ser selectivo acerca de los puntos de inserción cuando está implicada una secuencia de etiquetas estructurales. Por ejemplo, cuando en una posición entre etiquetas de párrafo de apertura y cierre, el parámetro de dirección se puede usar para seleccionar el punto de inserción más cercano al principio del párrafo siguiente (especificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) o al final del párrafo anterior (especificando <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Si el puntero ya está en la posición de inserción, y no hay ninguna etiqueta de formato adyacente de la manera especificada `direction`, el valor devuelto <xref:System.Windows.Documents.TextPointer> apunta a la misma posición que la llamada a <xref:System.Windows.Documents.TextPointer>.  
  
 Es posible que no exista ninguna posición de inserción válida con respecto a la posición que señala una <xref:System.Windows.Documents.TextPointer>.  Esto puede ocurrir si el contenido que se hace referencia está estructuralmente incompleto, como en una tabla vacía o una lista.  En tales casos, este método simplemente devuelve un <xref:System.Windows.Documents.TextPointer> a la misma posición que la <xref:System.Windows.Documents.TextPointer> desde que se llama a este método.  Este método devuelve siempre válido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Este ejemplo muestra cómo utilizar el <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para comprobar si un determinado <xref:System.Windows.Documents.TextElement> está vacío de contenido imprimible.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">El número de marcadores de inicio de línea que se omiten al determinar la línea para la que se devuelve la posición inicial. Los valores negativos especifican las líneas que preceden, 0 especifica la línea actual y los valores positivos, las líneas que siguen.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> que señala al principio de la línea especificada (con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> establecido en <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), o <see langword="null" /> si la línea especificada está fuera del intervalo o no se puede localizar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> señala a una posición ambigua, por ejemplo, entre dos líneas, la línea en la dirección especificada por <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> se selecciona como línea inicial relativa.  
  
 La operación realizada por este método depende de un diseño válido.  Cuando sea necesario, este método intenta regenerar automáticamente un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Utilice <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> para comprobar un diseño válido antes de realizar operaciones que pueden regenerar el diseño.  Para obtener más información, consulte [diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">El número de marcadores de inicio de línea que se omiten al determinar la línea para la que se devuelve la posición inicial. Los valores negativos especifican las líneas que preceden, 0 especifica la línea actual y los valores positivos, las líneas que siguen.</param>
        <param name="actualCount">Cuando se devuelve este método, contiene el número real de marcadores de inicio de línea omitidos al determinar la línea para la que se devuelve la posición inicial.  Este valor puede ser menor que <c>count</c> si se llega al principio o al final del contenido antes de omitir el número de líneas especificado. Este parámetro se pasa sin inicializar.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual e informa sobre el número de líneas omitidas.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> que señala al principio de la línea especificada (con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> establecido en <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) o al principio de la línea más cercana a la línea especificada si ésta está fuera del intervalo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> señala a una posición ambigua, por ejemplo, entre dos líneas, la línea en la dirección especificada por el <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad está seleccionada como la línea inicial relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar el símbolo siguiente.</param>
        <summary>Devuelve un puntero al símbolo siguiente en la dirección lógica especificada.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> al símbolo siguiente en la dirección solicitada o <see langword="null" /> si el <see cref="T:System.Windows.Documents.TextPointer" /> actual limita el inicio o el fin del contenido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes se considera un símbolo:  
  
-   Una etiqueta inicial o final de un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   A <xref:System.Windows.UIElement> los elementos en una <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 Si el símbolo siguiente se clasifica por categorías como <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, o <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (identificada por el <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método), la <xref:System.Windows.Documents.TextPointer> devuelta por este método avanza por exactamente un símbolo desde la posición actual.  
  
 Si el símbolo siguiente se clasifica por categorías como <xref:System.Windows.Documents.TextPointerContext.Text>, la <xref:System.Windows.Documents.TextPointer> devuelta por este método avanza más allá del texto para el siguiente símbolo no son de texto (es decir, la siguiente posición donde la <xref:System.Windows.Documents.TextPointerContext> no es <xref:System.Windows.Documents.TextPointerContext.Text>).  Se puede calcular el recuento exacto de símbolos cruzado de antemano mediante una llamada a la <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método.  El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> método junto con el <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para recorrer y extraer los símbolos en un determinado <xref:System.Windows.Documents.TextElement>.  
  
 Aunque el ejemplo se puede utilizar para extraer una [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] estructura para el contenido de una determinada <xref:System.Windows.Documents.TextElement>, que está pensado únicamente con fines ilustrativos y no debe usarse en código de producción.  Consulte la <xref:System.Xml> espacio de nombres para un amplio conjunto de tipos diseñados para trabajar con y procesar XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar la posición de inserción siguiente.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción siguiente en la dirección lógica especificada.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> que identifica la posición de inserción siguiente en la dirección solicitada o <see langword="null" /> si no se puede buscar ninguna posición de inserción siguiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *posición de inserción* es una posición donde se puede agregar nuevo contenido sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método. El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> método atraviesen los límites del elemento de contenido con el fin de contar el número de <xref:System.Windows.Documents.Paragraph> elementos presentes entre dos especificados <xref:System.Windows.Documents.TextPointer> instancias.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para buscar la distancia hasta ella (en símbolos).</param>
        <summary>Devuelve el recuento de símbolos entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y un segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>El número relativo de símbolos entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y <paramref name="position" />.  Un valor negativo indica que el <see cref="T:System.Windows.Documents.TextPointer" /> actual sigue a la posición especificada por <paramref name="position" />, 0 indica que las posiciones son iguales y un valor positivo, que el <see cref="T:System.Windows.Documents.TextPointer" /> actual precede a la posición especificada por <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes se considera un símbolo:  
  
-   Una etiqueta inicial o final de un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   A <xref:System.Windows.UIElement> los elementos en una <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método. El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> método para buscar los desplazamientos para dos <xref:System.Windows.Documents.TextPointer> instancias y, a continuación, utiliza esta información para guardar y restaurar la selección de un <xref:System.Windows.Controls.RichTextBox>.  En el ejemplo se da por supuesto que el contenido de la <xref:System.Windows.Controls.RichTextBox> no han cambiado entre una guardado de la selección y una restauración de la selección.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> especifica una posición fuera del contenedor de texto asociado a la posición actual.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que determinar la categoría para el contenido adyacente.</param>
        <summary>Devuelve un indicador de categoría para el contenido adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Documents.TextPointerContext" /> que indica la categoría para el contenido adyacente en la dirección lógica especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método. El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para implementar un algoritmo para calcular el saldo de apertura y cierre de las etiquetas de elemento entre dos especificados <xref:System.Windows.Documents.TextPointer> posiciones.  Cada etiqueta de elemento de apertura se cuenta como + 1 y cada etiqueta de elemento de cierre se cuenta como -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del contenido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Un desplazamiento, en símbolos, para el que calcular y devolver la posición.  Si el desplazamiento es negativo, la posición se calcula en la dirección lógica contraria a la indicada por la propiedad <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado o <see langword="null" /> si no se encuentra ninguna posición correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes se considera un símbolo:  
  
-   Una etiqueta inicial o final de la <xref:System.Windows.Documents.TextElement> elemento.  
  
-   A <xref:System.Windows.UIElement> los elementos en una <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método. El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> método para implementar un par de métodos, uno para calcular el desplazamiento a una posición especificada con respecto a cualquier párrafo de hospedaje y el otro para devolver un <xref:System.Windows.Documents.TextPointer> a un desplazamiento especificado en un párrafo especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Un desplazamiento, en símbolos, para el que calcular y devolver la posición.  Si el desplazamiento es negativo, el <see cref="T:System.Windows.Documents.TextPointer" /> devuelto precede al <see cref="T:System.Windows.Documents.TextPointer" /> actual; de lo contrario, le sigue.</param>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica del <see cref="T:System.Windows.Documents.TextPointer" /> devuelto.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del <see cref="T:System.Windows.Documents.TextPointer" /> actual y en la dirección especificada.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado o <see langword="null" /> si el desplazamiento se extiende más allá del final del contenido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes se considera un símbolo:  
  
-   Una etiqueta inicial o final de la <xref:System.Windows.Documents.TextElement> elemento.  
  
-   A <xref:System.Windows.UIElement> los elementos en una <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el texto adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar y devolver cualquier texto adyacente.</param>
        <summary>Devuelve una cadena que contiene cualquier texto adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Una cadena que contiene cualquier texto adyacente en la dirección lógica especificada o <see cref="F:System.String.Empty" /> si no se puede buscar ningún texto adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método sólo devuelve ejecuciones ininterrumpidas de texto.  No se devuelve nada si cualquier tipo de símbolos distinto de <xref:System.Windows.Documents.TextPointerContext.Text> es contiguo a actual <xref:System.Windows.Documents.TextPointer> en la dirección especificada.  De igual forma, se devuelve texto solo hasta el siguiente símbolo no son de texto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método. El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método para implementar un extractor de texto simple.  El método devuelve una concatenación de cadenas de todo el texto entre dos especificados <xref:System.Windows.Documents.TextPointer> instancias.  
  
 Aunque el ejemplo se puede utilizar para extraer cualquier texto comprendido entre dos <xref:System.Windows.Documents.TextPointer> instancias, está pensado únicamente con fines ilustrativos y no debe usarse en código de producción.  Utilice la propiedad <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> en su lugar.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar y copiar cualquier texto adyacente.</param>
        <param name="textBuffer">Un búfer en el que se copia texto.</param>
        <param name="startIndex">Índice de <c>textBuffer</c> donde se va a empezar a escribir texto copiado.</param>
        <param name="count">Número máximo de caracteres que se pueden copiar.</param>
        <summary>Copia el número de caracteres máximo especificado desde cualquier texto adyacente en la dirección especificada en una matriz de caracteres proporcionada por un llamador.</summary>
        <returns>Número de caracteres copiados realmente en <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método sólo devuelve ejecuciones ininterrumpidas de texto.  No se devuelve nada si cualquier tipo de símbolos distinto de <xref:System.Windows.Documents.TextPointerContext.Text> es contiguo a actual <xref:System.Windows.Documents.TextPointer> en la dirección especificada.  De igual forma, se devuelve texto solo hasta el siguiente símbolo no son de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> es menor que 0 o mayor que la propiedad <see cref="P:System.Array.Length" /> de <paramref name="textBuffer" />.  
  
 O bien  
  
 <paramref name="count" /> es menor que 0 o mayor que el espacio restante en <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> menus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que contar el número de caracteres.</param>
        <summary>Devuelve el número de caracteres Unicode entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y el símbolo de no texto siguiente, en la dirección lógica especificada.</summary>
        <returns>El número de caracteres Unicode entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y el símbolo de no texto siguiente.  Este número puede ser 0 si no hay texto adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes se considera un símbolo:  
  
-   Una etiqueta inicial o final de la <xref:System.Windows.Documents.TextElement> elemento.  
  
-   A <xref:System.Windows.UIElement> los elementos en una <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que este tipo una <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que contienen el <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el contenedor de texto asociado a la posición actual tiene un diseño válido (actualizado).</summary>
        <value>
          <see langword="true" /> si el diseño es actual y válido; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando sea necesario, las operaciones que dependen de un diseño válido (como el <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> (método), y <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propiedad) intenta regenerar automáticamente un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Utilice esta propiedad para comprobar un diseño válido antes de realizar operaciones que pueden regenerar el diseño.  Para obtener más información, consulte [diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta un salto de línea en la posición actual.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> colocado inmediatamente después del elemento <see cref="T:System.Windows.Documents.LineBreak" /> insertado por este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta un salto de párrafo en la posición actual.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> al principio (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) del nuevo párrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a este método cuando la posición actual está dentro de una existente <xref:System.Windows.Documents.Paragraph> elemento, el párrafo existente y cualquier contenido contiene se dividen en dos párrafos en la posición actual.  Si se llama a este método cuando la posición actual no está dentro de un párrafo existente, se inserta un párrafo nuevo y vacío.  Si se llama a este método en una posición no es adecuado para dividir o insertar un párrafo (por ejemplo, si la posición actual está dentro de un <xref:System.Windows.Documents.Hyperlink> elemento), se produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a este método en una posición que no se puede dividir para alojar un nuevo párrafo, como en el ámbito de <see cref="T:System.Windows.Documents.Hyperlink" /> o <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Texto que se va a insertar.</param>
        <summary>Inserta el texto especificado en el <see cref="T:System.Windows.Documents.Run" /> del texto en la posición actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> no tiene un ámbito por un <xref:System.Windows.Documents.Run> elemento, un <xref:System.Windows.Documents.Run> se inserta junto con la `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La posición actual no está dentro de un elemento <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la posición actual es una posición de inserción.</summary>
        <value>
          <see langword="true" /> si la posición actual es una posición de inserción; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una posición de inserción es una posición donde se puede agregar nuevo contenido sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la posición actual está al principio de una línea.</summary>
        <value>
          <see langword="true" /> si la posición actual está al principio de una línea; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> señala a una posición ambigua, por ejemplo, entre dos líneas, la línea en la dirección especificada por el <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad está seleccionada como la línea inicial relativa.  
  
 La operación realizada por esta propiedad depende de un diseño válido.  Cuando sea necesario, este método intenta regenerar automáticamente un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Use la <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propiedad para comprobar un diseño válido antes de realizar operaciones que pueden regenerar el diseño.  Para obtener más información, consulte [diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">
          <see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para comparar a la posición actual.</param>
        <summary>Indica si la posición especificada está en el mismo contenedor de texto que la posición actual.</summary>
        <returns>
          <see langword="true" /> si <paramref name="textPosition" /> indica una posición que está en el mismo contenedor de texto que la posición actual; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría de las operaciones que implican varios <xref:System.Windows.Documents.TextPointer> instancias solo son válidas si las instancias en cuestión indican posiciones que están en el mismo ámbito de contenedor de texto.  Por ejemplo la <xref:System.Windows.Documents.TextPointer.CompareTo%2A> y <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> métodos no se puede usar con un <xref:System.Windows.Documents.TextPointer> a una posición fuera del contenedor de texto asociado a la posición actual.  Utilice este método para comprobar que un determinado <xref:System.Windows.Documents.TextPointer> es compatible con la posición actual para estas operaciones.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un uso de este método.  El ejemplo se utiliza la <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método para comprobar si un determinado <xref:System.Windows.Documents.TextPointer> se coloca entre dos otros especificado <xref:System.Windows.Documents.TextPointer> instancias en una situación cuando no hay ninguna garantía de que las tres posiciones pertenezcan al mismo contenedor de texto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección lógica asociada a la posición actual que se utiliza para eliminar la ambigüedad del contenido asociado a la posición actual.</summary>
        <value>El valor <see cref="T:System.Windows.Documents.LogicalDirection" /> que se asocia a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como ejemplo de cómo se utiliza esta propiedad, el <xref:System.Windows.Documents.LogicalDirection> de la <xref:System.Windows.Documents.TextPointer> devuelto por una prueba de posicionamiento método ofrece un impacto en el que se encuentra entre dos caracteres de texto. La dirección lógica especifica cuál de los dos caracteres fue realmente, la izquierda o a la derecha.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el párrafo que establece el ámbito de la posición actual, si lo hay.</summary>
        <value>El <see cref="T:System.Windows.Documents.Paragraph" /> que establece el ámbito de la posición actual, o <see langword="null" /> si no hay ningún párrafo este tipo no existe.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento primario lógico que establece el ámbito de la posición actual.</summary>
        <value>El elemento primario lógico que establece el ámbito de la posición actual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este tipo o miembro es compatible con la infraestructura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está pensado para ser usado directamente desde su código.</summary>
        <returns>Cadena que representa el objeto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>