<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ef1fa4261a591f0ee0dbabc844bc1a0c4f26492" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227756" /></Metadata><TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <TypeSignature Language="F#" Value="type TextPointer = class&#xA;    inherit ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa una posición dentro de un <see cref="T:System.Windows.Documents.FlowDocument" /> o <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Documents.TextPointer> clase presenta la terminología siguiente:  
  
-   -Inherentemente, coloque un <xref:System.Windows.Documents.TextPointer> siempre apunta a un *posición* en contenido.  Estas posiciones se encuentran entre caracteres en el contenido, o entre el flujo de contenido de etiquetas de los elementos que definen la estructura del contenido.  
  
-   La posición actual - ya un <xref:System.Windows.Documents.TextPointer> siempre indica una posición y porque muchas de las operaciones que pueden realizarse a través de un <xref:System.Windows.Documents.TextPointer> son relativas a la posición que apunta actualmente el <xref:System.Windows.Documents.TextPointer>, tiene sentido simplemente hacer referencia a la posición indicada por una <xref:System.Windows.Documents.TextPointer> como el *posición actual*.  
  
-   Posición de inserción: una *posición de inserción* es una posición donde se puede agregar contenido nuevo sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
-   Símbolos - para los fines de <xref:System.Windows.Documents.TextPointer> las operaciones que implican los símbolos, cualquiera de las siguientes opciones se considera un *símbolo*:  
  
    -   Una etiqueta inicial o final para un <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Un <xref:System.Windows.UIElement> elemento dentro de un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
    -   Cada uno de ellos de 16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
-   Contenedor de texto - A *contenedor de texto* es el elemento que constituye el borde final para el contenido dinámico en cuestión; la posición indicada por una <xref:System.Windows.Documents.TextPointer> siempre se encuentra dentro de un contenedor de texto.  Actualmente, un contenedor de texto debe ser un <xref:System.Windows.Documents.FlowDocument> o <xref:System.Windows.Controls.TextBlock>.  En general, las operaciones entre <xref:System.Windows.Documents.TextPointer> no se admiten las instancias de los contenedores de texto diferente.  
  
-   Documento: el contenido de un contenedor de texto se conoce como un *documento*, como en el <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método y el <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> y <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propiedades.  
  
 El <xref:System.Windows.Documents.TextPointer> clase está diseñada para facilitar la exploración transversal y manipulación de contenido que se representa mediante [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementos de contenido dinámico; en general, estos elementos se derivan de <xref:System.Windows.Documents.TextElement>.  Algunas de las operaciones que <xref:System.Windows.Documents.TextPointer> facilita incluyen lo siguiente:  
  
-   Realizar una comparación ordinal de la posición actual con una segunda posición especificada.  Consulte la <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método.  
  
-   Determinar el tipo de contenido adyacente a la posición actual en una dirección especificada.  Consulte la <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método y <xref:System.Windows.Documents.TextPointerContext> enumeración.  
  
-   Obtener el <xref:System.Windows.Documents.TextElement> que establece el ámbito o es adyacente a la posición actual.  Consulte <xref:System.Windows.Documents.Paragraph> y <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> método.  
  
-   Obtener el contenedor de texto que establece el ámbito del documento actual.  Vea la propiedad <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obtener un número especificado de caracteres antes o después de la posición actual.  Consulte la <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método.  
  
-   Inserte una cadena de caracteres en la posición actual.  Consulte la <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> método.  
  
-   Buscar los límites de las líneas en el contenido.  Consulte la <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método y <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propiedad.  
  
-   Traducir entre <xref:System.Windows.Documents.TextPointer> las posiciones y el símbolo de desplazamientos en contenido.  Consulte la <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos.  
  
-   Realizar pruebas de posicionamiento visual mediante la traducción entre un <xref:System.Windows.Documents.TextPointer> posición y un <xref:System.Windows.Point> que representan coordenadas relativas.  
  
-   Buscar una posición de inserción cercanos o comprobar si la posición actual es una posición de inserción.  Consulte la <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> métodos y <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propiedad.  
  
 La posición y <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicado por un <xref:System.Windows.Documents.TextPointer> objeto son inmutables.  Cuando contenido editado o modificado, la posición indicada por una <xref:System.Windows.Documents.TextPointer> no cambia en relación con el texto adyacente; en su lugar el desplazamiento de esa posición desde el principio del contenido se ajusta proporcionalmente para reflejar la nueva posición relativa en contenido.  Por ejemplo, un <xref:System.Windows.Documents.TextPointer> que indica una posición al principio de un párrafo dado continúa apuntando al principio del párrafo, incluso cuando el contenido se inserta o elimina antes o después del párrafo.  
  
 La <xref:System.Windows.Documents.TextPointer> clase no proporciona ningún constructor público.  Una instancia de <xref:System.Windows.Documents.TextPointer> se crea mediante el uso de las propiedades o métodos de otros objetos (incluidos otros <xref:System.Windows.Documents.TextPointer> objetos). En la lista siguiente proporciona algunos ejemplos de métodos y propiedades que creación y devuelven un <xref:System.Windows.Documents.TextPointer>.  Esta lista no es exhaustiva:  
  
-   Desde un <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> y <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Desde un <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, y <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Desde un <xref:System.Windows.Controls.TextBlock> (contenedor de texto): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, y <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Desde un <xref:System.Windows.Documents.FlowDocument> (contenedor de texto): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, y <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Desde una existente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar un <xref:System.Windows.Documents.TextPointer> para buscar una posición justo dentro de la primera <xref:System.Windows.Documents.Run> elemento en un contenedor de texto especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 El ejemplo siguiente implementa un algoritmo de búsqueda sencillo utilizando <xref:System.Windows.Documents.TextPointer> instalaciones.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.CompareTo position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para comparar a la posición actual.</param>
        <summary>Realiza una comparación de ordinales entre las posiciones especificadas por el <see cref="T:System.Windows.Documents.TextPointer" /> actual y un segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>-1 si el <see cref="T:System.Windows.Documents.TextPointer" /> actual precede a <paramref name="position" />; 0 si las ubicaciones son las mismas; +1 si el <see cref="T:System.Windows.Documents.TextPointer" /> actual sigue a <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de -1 indica que la posición especificada por el actual <xref:System.Windows.Documents.TextPointer> precede a la posición especificada por `position`.  Un valor de 0 indica que las posiciones indicadas son iguales.  Un valor de + 1 positivo indica que la posición especificada por el actual <xref:System.Windows.Documents.TextPointer> sigue a la posición especificada por `position`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método.  En el ejemplo, el <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método se utiliza junto con el <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para comprobar si un determinado <xref:System.Windows.Documents.TextElement> está vacío.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> especifica una posición fuera del contenedor de texto asociado a la posición actual.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberSignature Language="F#" Value="member this.DeleteTextInRun : int -&gt; int" Usage="textPointer.DeleteTextInRun count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">El número de caracteres para eliminar, a partir de la posición actual. Especifique un valor positivo para eliminar caracteres que siguen a la posición actual y un valor negativo para eliminar caracteres que preceden a la posición actual.</param>
        <summary>Elimina el número de caracteres especificado de la posición indicada por el <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns>El número de caracteres eliminado realmente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique un valor positivo para eliminar caracteres que siguen a la posición actual (como en <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); Especifique un valor negativo para eliminar caracteres que preceden a la posición actual (como en <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 El número de caracteres eliminado realmente puede ser menor que el número especificado por `count`.  Esto sucede en casos donde `count` especifica más caracteres que existen para eliminarse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha llamado al método en una posición en la que el texto no está permitido.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentEnd : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Documents.TextPointer" /> al final del contenido en el contenedor de texto asociado a la posición actual.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> al final del contenido en el contenedor de texto asociado a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Documents.TextPointer.Parent%2A> para el valor devuelto <xref:System.Windows.Documents.TextPointer> siempre es un contenedor de texto (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), en lugar de un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentStart : System.Windows.Documents.TextPointer" Usage="System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Documents.TextPointer" /> al principio del contenido en el contenedor de texto asociado a la posición actual.</summary>
        <value><see cref="T:System.Windows.Documents.TextPointer" /> al principio del contenido en el contenedor de texto asociado a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la posición devuelta por esta propiedad como una posición de línea base desde la que se va a trabajar con desplazamientos relativos a otras posiciones.  El <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> y <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos proporcionan un medio para traducir entre las posiciones y posición desplazamientos.  
  
 El <xref:System.Windows.Documents.TextPointer.Parent%2A> para el valor devuelto <xref:System.Windows.Documents.TextPointer> siempre es un contenedor de texto (<xref:System.Windows.Controls.TextBlock> o <xref:System.Windows.Documents.FlowDocument>), en lugar de un <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetAdjacentElement : System.Windows.Documents.LogicalDirection -&gt; System.Windows.DependencyObject" Usage="textPointer.GetAdjacentElement direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar un elemento adyacente.</param>
        <summary>Devuelve el elemento, en caso de que exista, que limita al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>El elemento adyacente en la <paramref name="direction" /> especificada o <see langword="null" /> si no existe ningún elemento adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El elemento devuelto es normalmente un <xref:System.Windows.Documents.TextElement>.  Un <xref:System.Windows.UIElement> puede devolver cuando la <xref:System.Windows.Documents.TextPointer> indica una posición dentro de un <xref:System.Windows.Documents.BlockUIContainer> elemento o un <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetCharacterRect : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Rect" Usage="textPointer.GetCharacterRect direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar un rectángulo de selección del contenido.</param>
        <summary>Devuelve un rectángulo de selección (<see cref="T:System.Windows.Rect" />) para el contenido que limita el <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Un rectángulo de selección para el contenido que limita el <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección especificada o <see cref="P:System.Windows.Rect.Empty" /> si no hay disponible información de presentación actual válida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> los bordes no se consideran contenido para los fines de este método.  Si el <xref:System.Windows.Documents.TextPointer> se coloca antes un <xref:System.Windows.Documents.TextElement> edge, el valor devuelto es un cuadro de límite para el siguiente que no sean de<xref:System.Windows.Documents.TextElement> contenido en la dirección especificada.  Si no hay ningún contenido en la dirección especificada, un ancho de cero <xref:System.Windows.Rect> se devuelve con un alto que coincide con el alto de los anteriores contenido.  
  
 La operación realizada por este método depende de un diseño válido.  Cuando sea necesario, este método intenta automáticamente volver a generar un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Use el <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propiedad para comprobar un diseño válido antes de realizar las operaciones que se pueden regenerar el diseño.  Para obtener más información, vea [Diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar la posición de inserción más cercana.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción más cercana en la dirección lógica especificada.</summary>
        <returns>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción más cercana en la dirección especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una posición de inserción es una posición donde se puede agregar contenido nuevo sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
 Si el <xref:System.Windows.Documents.TextPointer> ya que apunta a una posición de inserción válido, pero la etiqueta de cierre para una secuencia de formato vacío sigue directamente a esa posición en la dirección especificada, el <xref:System.Windows.Documents.TextPointer> devuelta por este método se ajusta para que apunte a la inserción posición justo después del cierre de la secuencia de formato. Por ejemplo, considere la posibilidad de la secuencia de marcado `<Bold>a</Bold>b`. Tenga en cuenta que hay dos posiciones de inserción entre las letras `a` y `b` : uno que precede el `Bold` etiqueta y uno justo después del cierre `Bold` etiqueta. Si <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> se llama en un <xref:System.Windows.Documents.TextPointer> a la posición directamente después de la letra `a` y antes del cierre de `Bold` etiqueta y con un `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, el valor devuelto <xref:System.Windows.Documents.TextPointer> se ajusta para que apunte a la posición justo antes de la letra `b`, después del cierre `Bold` etiqueta. Se realiza un ajuste similar para el formato de etiquetas de apertura cuando se trabaja en la dirección lógica contraria. Este método está pensado para proporcionar un medio de anulación de ambigüedades entre posiciones de inserción en casos similares.  
  
 Este método puede utilizarse también para ser selectivo acerca de los puntos de inserción cuando está implicada en una secuencia de etiquetas estructurales. Por ejemplo, cuando en una posición entre etiquetas de párrafo de apertura y cierre, el parámetro de dirección puede usarse para seleccionar el punto de inserción más cercano al principio del párrafo siguiente (especificando <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) o al final de la anterior (párrafo mediante la especificación de <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Si el puntero ya está en la posición de inserción, y no hay ninguna etiqueta de formato adyacente en la instancia especificada `direction`, el valor devuelto <xref:System.Windows.Documents.TextPointer> apunta a la misma posición que realiza la llamada <xref:System.Windows.Documents.TextPointer>.  
  
 Es posible que no exista ninguna posición de inserción válido con respecto a la posición en la que apunta un <xref:System.Windows.Documents.TextPointer>.  Esto puede ocurrir si el contenido que se hace referencia es estructuralmente incompleto, como se muestra en una tabla vacía o una lista.  En tales casos, este método devuelve simplemente una <xref:System.Windows.Documents.TextPointer> a la misma posición que el <xref:System.Windows.Documents.TextPointer> desde que se llamó a este método.  Este método devuelve siempre válido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 En este ejemplo se muestra cómo usar el <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para comprobar si un <xref:System.Windows.Documents.TextElement> está vacía de contenido imprimible.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">El número de marcadores de inicio de línea que se omiten al determinar la línea para la que se devuelve la posición inicial. Los valores negativos especifican las líneas que preceden, 0 especifica la línea actual y los valores positivos, las líneas que siguen.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> que señala al principio de la línea especificada (con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> establecido en <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), o <see langword="null" /> si la línea especificada está fuera del intervalo o no se puede localizar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> apunta a una posición ambigua, por ejemplo, entre las dos líneas, la línea en la dirección especificada por <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> está seleccionada como la línea inicial relativa.  
  
 La operación realizada por este método depende de un diseño válido.  Cuando sea necesario, este método intenta automáticamente volver a generar un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Use <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> para comprobar un diseño válido antes de realizar las operaciones que se pueden regenerar el diseño.  Para obtener más información, vea [Diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberSignature Language="F#" Value="member this.GetLineStartPosition : int *  -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetLineStartPosition (count, actualCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">El número de marcadores de inicio de línea que se omiten al determinar la línea para la que se devuelve la posición inicial. Los valores negativos especifican las líneas que preceden, 0 especifica la línea actual y los valores positivos, las líneas que siguen.</param>
        <param name="actualCount">Cuando se devuelve este método, contiene el número real de marcadores de inicio de línea omitidos al determinar la línea para la que se devuelve la posición inicial.  Este valor puede ser menor que <paramref name="count" /> si se llega al principio o al fin del contenido antes de omitir el número de líneas especificado. Este parámetro se pasa sin inicializar.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> al principio de una línea que se especifica con respecto al <see cref="T:System.Windows.Documents.TextPointer" /> actual e informa sobre el número de líneas omitidas.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> que señala al principio de la línea especificada (con <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> establecido en <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />) o al principio de la línea más cercana a la línea especificada si ésta está fuera del intervalo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> apunta a una posición ambigua, por ejemplo, entre las dos líneas, la línea en la dirección especificada por el <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad está seleccionada como la línea inicial relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextContextPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextContextPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar el símbolo siguiente.</param>
        <summary>Devuelve un puntero al símbolo siguiente en la dirección lógica especificada.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> al símbolo siguiente en la dirección solicitada o <see langword="null" /> si el <see cref="T:System.Windows.Documents.TextPointer" /> actual limita el inicio o el fin del contenido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes acciones se considera un símbolo:  
  
-   Una etiqueta inicial o final para un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Un <xref:System.Windows.UIElement> elemento contenido en un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 Si el símbolo siguiente se clasifica por categorías como <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, o <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (identificada por el <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método), el <xref:System.Windows.Documents.TextPointer> devuelta por este método avanza por exactamente un símbolo desde la posición actual.  
  
 Si el símbolo siguiente se clasifica por categorías como <xref:System.Windows.Documents.TextPointerContext.Text>, el <xref:System.Windows.Documents.TextPointer> devuelto por este método avanza más allá del texto en el símbolo de no texto siguiente (es decir, la siguiente posición donde la <xref:System.Windows.Documents.TextPointerContext> no <xref:System.Windows.Documents.TextPointerContext.Text>).  El recuento exacto de símbolos cruzado se puede calcular de antemano mediante una llamada a la <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> método.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método.  El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> método junto con el <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para recorrer y extraer los símbolos en un determinado <xref:System.Windows.Documents.TextElement>.  
  
 Aunque el ejemplo se puede usar para extraer un [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] estructura para el contenido de un determinado <xref:System.Windows.Documents.TextElement>, que está pensado únicamente con fines ilustrativos y no debe usarse en código de producción.  Consulte la <xref:System.Xml> espacio de nombres para un amplio conjunto de tipos diseñados para trabajar con y procesamiento de XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetNextInsertionPosition : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetNextInsertionPosition direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar la posición de inserción siguiente.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición de inserción siguiente en la dirección lógica especificada.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> que identifica la posición de inserción siguiente en la dirección solicitada o <see langword="null" /> si no se puede buscar ninguna posición de inserción siguiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *posición de inserción* es una posición donde se puede agregar contenido nuevo sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método. El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> método atraviesen los límites del elemento de contenido con el fin de contar el número de <xref:System.Windows.Documents.Paragraph> elementos presentes entre dos especificados <xref:System.Windows.Documents.TextPointer> instancias.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberSignature Language="F#" Value="member this.GetOffsetToPosition : System.Windows.Documents.TextPointer -&gt; int" Usage="textPointer.GetOffsetToPosition position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position"><see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para buscar la distancia hasta ella (en símbolos).</param>
        <summary>Devuelve el recuento de símbolos entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y un segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>El número relativo de símbolos entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y <paramref name="position" />.  Un valor negativo indica que el <see cref="T:System.Windows.Documents.TextPointer" /> actual sigue a la posición especificada por <paramref name="position" />, 0 indica que las posiciones son iguales y un valor positivo, que el <see cref="T:System.Windows.Documents.TextPointer" /> actual precede a la posición especificada por <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes acciones se considera un símbolo:  
  
-   Una etiqueta inicial o final para un <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Un <xref:System.Windows.UIElement> elemento contenido en un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método. El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> método para buscar los desplazamientos para dos <xref:System.Windows.Documents.TextPointer> instancias y, a continuación, usa esta información para guardar y restaurar la selección en un <xref:System.Windows.Controls.RichTextBox>.  El ejemplo supone que el contenido de la <xref:System.Windows.Controls.RichTextBox> no han cambiado entre una selección de guardado y restauración de la selección.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="position" /> especifica una posición fuera del contenedor de texto asociado a la posición actual.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPointerContext : System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointerContext" Usage="textPointer.GetPointerContext direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que determinar la categoría para el contenido adyacente.</param>
        <summary>Devuelve un indicador de categoría para el contenido adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Uno de los valores de <see cref="T:System.Windows.Documents.TextPointerContext" /> que indica la categoría para el contenido adyacente en la dirección lógica especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra un uso de este método. El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para implementar un algoritmo para calcular el saldo de apertura y cierre de las etiquetas de elementos entre dos especificados <xref:System.Windows.Documents.TextPointer> posiciones.  Cada etiqueta de elemento de apertura se cuenta como + 1 y cada etiqueta de elemento de cierre se cuenta como -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del contenido.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Un desplazamiento, en símbolos, para el que calcular y devolver la posición.  Si el desplazamiento es negativo, la posición se calcula en la dirección lógica contraria a la indicada por la propiedad <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado o <see langword="null" /> si no se encuentra ninguna posición correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes acciones se considera un símbolo:  
  
-   Una etiqueta inicial o final para el <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Un <xref:System.Windows.UIElement> elemento contenido en un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método. El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> método para implementar un par de métodos, uno para calcular el desplazamiento a una posición especificada con respecto a cualquier párrafo de hospedaje y el otro para devolver un <xref:System.Windows.Documents.TextPointer> a un desplazamiento especificado en un párrafo especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetPositionAtOffset : int * System.Windows.Documents.LogicalDirection -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.GetPositionAtOffset (offset, direction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Un desplazamiento, en símbolos, para el que calcular y devolver la posición.  Si el desplazamiento es negativo, el <see cref="T:System.Windows.Documents.TextPointer" /> devuelto precede al <see cref="T:System.Windows.Documents.TextPointer" /> actual; de lo contrario, le sigue.</param>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica del <see cref="T:System.Windows.Documents.TextPointer" /> devuelto.</param>
        <summary>Devuelve <see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado, en símbolos, a partir del principio del <see cref="T:System.Windows.Documents.TextPointer" /> actual y en la dirección especificada.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> a la posición indicada por el desplazamiento especificado o <see langword="null" /> si el desplazamiento se extiende más allá del final del contenido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes acciones se considera un símbolo:  
  
-   Una etiqueta inicial o final para el <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Un <xref:System.Windows.UIElement> elemento contenido en un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el texto adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection -&gt; string" Usage="textPointer.GetTextInRun direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar y devolver cualquier texto adyacente.</param>
        <summary>Devuelve una cadena que contiene cualquier texto adyacente al <see cref="T:System.Windows.Documents.TextPointer" /> actual en la dirección lógica especificada.</summary>
        <returns>Una cadena que contiene cualquier texto adyacente en la dirección lógica especificada o <see cref="F:System.String.Empty" /> si no se puede buscar ningún texto adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve sólo ininterrumpidas ejecuciones de texto.  Se devuelve nada si cualquier tipo de símbolos distinto <xref:System.Windows.Documents.TextPointerContext.Text> es adyacente a la actual <xref:System.Windows.Documents.TextPointer> en la dirección especificada.  Del mismo modo, se devuelve texto solo hasta el siguiente símbolo que no sean de texto.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método. El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método para implementar un extractor de texto simple.  El método devuelve una concatenación de cadenas de todo el texto entre dos especificados <xref:System.Windows.Documents.TextPointer> instancias.  
  
 Aunque el ejemplo se puede usar para extraer cualquier texto comprendido entre dos <xref:System.Windows.Documents.TextPointer> instancias, está pensado únicamente con fines ilustrativos y no debe usarse en código de producción.  Utilice la propiedad <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> en su lugar.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.GetTextInRun : System.Windows.Documents.LogicalDirection * char[] * int * int -&gt; int" Usage="textPointer.GetTextInRun (direction, textBuffer, startIndex, count)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que buscar y copiar cualquier texto adyacente.</param>
        <param name="textBuffer">Un búfer en el que se copia texto.</param>
        <param name="startIndex">Un índice en <paramref name="textBuffer" /> en el que se comienza a escribir texto copiado.</param>
        <param name="count">Número máximo de caracteres que se pueden copiar.</param>
        <summary>Copia el número de caracteres máximo especificado desde cualquier texto adyacente en la dirección especificada en una matriz de caracteres proporcionada por un llamador.</summary>
        <returns>Número de caracteres copiados realmente en <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve sólo ininterrumpidas ejecuciones de texto.  Se devuelve nada si cualquier tipo de símbolos distinto <xref:System.Windows.Documents.TextPointerContext.Text> es adyacente a la actual <xref:System.Windows.Documents.TextPointer> en la dirección especificada.  Del mismo modo, se devuelve texto solo hasta el siguiente símbolo que no sean de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="startIndex" /> es menor que 0 o mayor que la propiedad <see cref="P:System.Array.Length" /> de <paramref name="textBuffer" />.  
  
O bien 
 <paramref name="count" /> es menor que 0 o mayor que el espacio restante en <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> menus <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberSignature Language="F#" Value="member this.GetTextRunLength : System.Windows.Documents.LogicalDirection -&gt; int" Usage="textPointer.GetTextRunLength direction" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uno de los valores de <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica la dirección lógica en la que contar el número de caracteres.</param>
        <summary>Devuelve el número de caracteres Unicode entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y el símbolo de no texto siguiente, en la dirección lógica especificada.</summary>
        <returns>El número de caracteres Unicode entre el <see cref="T:System.Windows.Documents.TextPointer" /> actual y el símbolo de no texto siguiente.  Este número puede ser 0 si no hay texto adyacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquiera de las siguientes acciones se considera un símbolo:  
  
-   Una etiqueta inicial o final para el <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Un <xref:System.Windows.UIElement> elemento contenido en un <xref:System.Windows.Documents.InlineUIContainer> o <xref:System.Windows.Documents.BlockUIContainer>.  Tenga en cuenta que tales un <xref:System.Windows.UIElement> siempre se cuentan como exactamente un símbolo; cualquier contenido adicional o elementos que forman parte del <xref:System.Windows.UIElement> no se cuentan como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] carácter dentro de un texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValidLayout : bool" Usage="System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el contenedor de texto asociado a la posición actual tiene un diseño válido (actualizado).</summary>
        <value><see langword="true" /> si el diseño es actual y válido; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando sea necesario, las operaciones que dependen de un diseño válido (como el <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> método, y <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propiedad) intenta automáticamente volver a generar un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Utilice esta propiedad para comprobar un diseño válido antes de realizar las operaciones que se pueden regenerar el diseño.  Para obtener más información, vea [Diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertLineBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertLineBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta un salto de línea en la posición actual.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> colocado inmediatamente después del elemento <see cref="T:System.Windows.Documents.LineBreak" /> insertado por este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberSignature Language="F#" Value="member this.InsertParagraphBreak : unit -&gt; System.Windows.Documents.TextPointer" Usage="textPointer.InsertParagraphBreak " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inserta un salto de párrafo en la posición actual.</summary>
        <returns><see cref="T:System.Windows.Documents.TextPointer" /> al principio (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) del nuevo párrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se llama a este método cuando la posición actual está dentro de una existente <xref:System.Windows.Documents.Paragraph> elemento, el párrafo existente y cualquier contenido que contiene se dividen en dos párrafos en la posición actual.  Si se llama a este método cuando la posición actual no está dentro de un párrafo existente, se inserta un párrafo nuevo y vacío.  Si se llama a este método en una posición no es adecuado para dividir o insertar un párrafo (por ejemplo, si la posición actual está dentro de un <xref:System.Windows.Documents.Hyperlink> elemento), se produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a este método en una posición que no se puede dividir para alojar un nuevo párrafo, como en el ámbito de <see cref="T:System.Windows.Documents.Hyperlink" /> o <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberSignature Language="F#" Value="member this.InsertTextInRun : string -&gt; unit" Usage="textPointer.InsertTextInRun textData" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Texto que se va a insertar.</param>
        <summary>Inserta el texto especificado en el <see cref="T:System.Windows.Documents.Run" /> del texto en la posición actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> no está dirigida por un <xref:System.Windows.Documents.Run> elemento, un <xref:System.Windows.Documents.Run> se inserta junto con el `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La posición actual no está dentro de un elemento <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="textData" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtInsertionPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la posición actual es una posición de inserción.</summary>
        <value><see langword="true" /> si la posición actual es una posición de inserción; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una posición de inserción es una posición donde se puede agregar contenido nuevo sin romper ninguna regla semántica para el contenido asociado.  En la práctica, una posición de inserción está en cualquier lugar en donde se puede colocar un símbolo de intercalación de contenido.  Un ejemplo de válido <xref:System.Windows.Documents.TextPointer> posición que no es una posición de inserción es la posición entre dos adyacentes <xref:System.Windows.Documents.Paragraph> etiquetas (es decir, entre la etiqueta de cierre del párrafo anterior y la etiqueta de apertura del párrafo siguiente).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAtLineStartPosition : bool" Usage="System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la posición actual está al principio de una línea.</summary>
        <value><see langword="true" /> si la posición actual está al principio de una línea; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Windows.Documents.TextPointer> apunta a una posición ambigua, por ejemplo, entre las dos líneas, la línea en la dirección especificada por el <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propiedad está seleccionada como la línea inicial relativa.  
  
 La operación realizada por esta propiedad depende de un diseño válido.  Cuando sea necesario, este método intenta automáticamente volver a generar un diseño válido antes de continuar con la operación.  Volver a generar un diseño puede ser una operación relativamente costosa.  Use el <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propiedad para comprobar un diseño válido antes de realizar las operaciones que se pueden regenerar el diseño.  Para obtener más información, vea [Diseño](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberSignature Language="F#" Value="member this.IsInSameDocument : System.Windows.Documents.TextPointer -&gt; bool" Usage="textPointer.IsInSameDocument textPosition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition"><see cref="T:System.Windows.Documents.TextPointer" /> que especifica una posición para comparar a la posición actual.</param>
        <summary>Indica si la posición especificada está en el mismo contenedor de texto que la posición actual.</summary>
        <returns><see langword="true" /> si <paramref name="textPosition" /> indica una posición que está en el mismo contenedor de texto que la posición actual; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría de las operaciones que implican varios <xref:System.Windows.Documents.TextPointer> instancias solo son válidas si las instancias en cuestión indican posiciones que se encuentran en el mismo ámbito contenedor de texto.  Por ejemplo el <xref:System.Windows.Documents.TextPointer.CompareTo%2A> y <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> métodos no se puede usar con un <xref:System.Windows.Documents.TextPointer> a una posición fuera del contenedor de texto asociado a la posición actual.  Use este método para comprobar que un determinado <xref:System.Windows.Documents.TextPointer> es compatible con la posición actual para estas operaciones.  
  
   
  
## Examples  
 El ejemplo siguiente muestra un uso de este método.  El ejemplo se usa el <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método para comprobar si un <xref:System.Windows.Documents.TextPointer> se sitúa entre dos otros especificado <xref:System.Windows.Documents.TextPointer> instancias en una situación cuando no hay ninguna garantía de que las tres posiciones pertenezcan al mismo contenedor de texto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="textPosition" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalDirection : System.Windows.Documents.LogicalDirection" Usage="System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección lógica asociada a la posición actual que se utiliza para eliminar la ambigüedad del contenido asociado a la posición actual.</summary>
        <value>El valor <see cref="T:System.Windows.Documents.LogicalDirection" /> que se asocia a la posición actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como ejemplo de cómo se usa esta propiedad, el <xref:System.Windows.Documents.LogicalDirection> de la <xref:System.Windows.Documents.TextPointer> devuelto por una prueba de posicionamiento método ofrece un impacto en el que se encuentra entre dos caracteres de texto. La dirección lógica especifica cuál de los dos caracteres fue realmente - la izquierda o a la derecha.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Paragraph : System.Windows.Documents.Paragraph" Usage="System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el párrafo que establece el ámbito de la posición actual, si lo hay.</summary>
        <value>El <see cref="T:System.Windows.Documents.Paragraph" /> que establece el ámbito de la posición actual, o <see langword="null" /> si no existe ningún párrafo de este tipo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento primario lógico que establece el ámbito de la posición actual.</summary>
        <value>El elemento primario lógico que establece el ámbito de la posición actual.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="textPointer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este tipo o miembro es compatible con la infraestructura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está pensado para ser usado directamente desde su código.</summary>
        <returns>Cadena que representa el objeto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>