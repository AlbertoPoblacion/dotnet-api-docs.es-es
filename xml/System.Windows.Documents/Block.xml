<Type Name="Block" FullName="System.Windows.Documents.Block">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d28f6b52a305eef97f14c74ce2303f9b93fe1a7d" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39806899" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Block : System.Windows.Documents.TextElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Block extends System.Windows.Documents.TextElement" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.Block" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Block&#xA;Inherits TextElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class Block abstract : System::Windows::Documents::TextElement" />
  <TypeSignature Language="F#" Value="type Block = class&#xA;    inherit TextElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.TextElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Clase abstracta que proporciona una base para los elementos de contenido dinámico de nivel de bloque.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los elementos que heredan de la <xref:System.Windows.Documents.Block> clase (como <xref:System.Windows.Documents.Section>) puede utilizarse para agrupar elementos bajo un elemento primario común o para aplicar atributos comunes a un grupo. Conceptualmente, esto es similar a cómo podría utilizar el \<DIV > etiquete en [!INCLUDE[TLA#tla_html](~/includes/tlasharptla-html-md.md)].  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.Run" />
    <altmember cref="T:System.Windows.Documents.Span" />
    <altmember cref="T:System.Windows.Documents.InlineUIContainer" />
    <altmember cref="T:System.Windows.Documents.Floater" />
    <altmember cref="T:System.Windows.Documents.Figure" />
    <altmember cref="T:System.Windows.Documents.LineBreak" />
    <altmember cref="T:System.Windows.Documents.FlowDocument" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Block ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Block();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa los valores de la clase base <see cref="T:System.Windows.Documents.Block" /> cuando es invocado por una clase derivada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.BorderBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ BorderBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BorderBrush : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.Block.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Windows.Media.Brush" /> que se va a usar para dibujar el borde del elemento.</summary>
        <value>Pincel que se usa para dibujar el borde del elemento. El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una tabla de muestras que se muestran los colores del pincel predefinido disponible, consulte <xref:System.Windows.Media.Brushes>.  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.BorderBrushProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.BorderBrush%2A> atributo de un <xref:System.Windows.Documents.Block> elemento (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  
  
 ![Captura de pantalla: Azul, 1&#47;4 pulgadas borde alrededor de un bloque](~/add/media/block-borders.png "captura de pantalla: borde azul, de 1/4 de pulgada alrededor de un bloque")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.BorderBrush%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.BorderThickness" />
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.BorderBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderBrushProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderBrushProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.BorderBrush" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.BorderThickness" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderThickness As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness BorderThickness { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.BorderThickness : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.Block.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el grosor del borde para el elemento.</summary>
        <value>Estructura <see cref="T:System.Windows.Thickness" /> que especifica la cantidad de borde que se aplicará, en píxeles independientes del dispositivo. El valor predeterminado es un grosor uniforme de cero (0,0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_BorderThickness"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object BorderThickness="uniformThickness"/>  
- or -  
<object BorderThickness="independentThickness"/>  
- or -  
<object BorderThickness="qualifiedUniformThickness"/>  
- or -  
<object BorderThickness="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_BorderThickness"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *uniformThickness*  
 Representación de cadena de una sola <xref:System.Double> valor que se aplica uniformemente a todas las dimensiones de grosor de cuatro.  Por ejemplo, un valor de `"10"` es equivalente a un valor de `"10,10,10,10"`.  Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente puntos decimales.  
  
 *independentThickness*  
 Representación de cadena de cuatro ordenados <xref:System.Double> los valores correspondientes a las dimensiones de grosor independiente para la izquierda, superior, derecha y abajo, en este orden.  Los cuatro valores deben estar separados con comas; no se permiten espacios.  Por ejemplo, "5,10,15,20 da como" resultado 5 píxeles del borde a la izquierda del contenido, 10 píxeles del borde sobre el contenido, 15 píxeles del borde a la derecha del contenido y 20 píxeles del borde debajo del contenido.  
  
 *qualifiedUniformThickness*  
 Un valor descrito por *uniformThickness* seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo, `"1in"` proporciona un borde uniforme de 1 pulgada en todas las direcciones.  
  
 *qualifiedIndependentThickness*  
 Un valor descrito por *independentThickness*, con cada valor independiente seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo: `"1.5in,0.8in,1.5in,0.8in"`.  Especificadores de unidades esté mixto o se omite de uno o más valores.  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.BorderThicknessProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.BorderThickness%2A> atributo de un <xref:System.Windows.Documents.Block> elemento (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  
  
 ![Captura de pantalla: Azul, 1&#47;4 pulgadas borde alrededor de un bloque](~/add/media/block-borders.png "captura de pantalla: borde azul, de 1/4 de pulgada alrededor de un bloque")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.BorderThickness%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.BorderBrush" />
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.BorderThicknessProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderThicknessProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderThicknessProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderThicknessProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.BorderThickness" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakColumnBefore">
      <MemberSignature Language="C#" Value="public bool BreakColumnBefore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakColumnBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.BreakColumnBefore" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakColumnBefore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakColumnBefore { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakColumnBefore : bool with get, set" Usage="System.Windows.Documents.Block.BreakColumnBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se inserta automáticamente un salto de columna antes de este elemento en los casos en que el elemento participa en una presentación basada en columnas.</summary>
        <value>
          <see langword="true" /> para insertar automáticamente un salto de columna antes de este elemento; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BreakColumnBefore"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.BreakColumnBeforeProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.BreakPageBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakColumnBeforeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BreakColumnBeforeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BreakColumnBeforeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.BreakColumnBeforeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BreakColumnBeforeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BreakColumnBeforeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BreakColumnBeforeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.BreakColumnBeforeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.BreakColumnBefore" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BreakPageBefore">
      <MemberSignature Language="C#" Value="public bool BreakPageBefore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakPageBefore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.BreakPageBefore" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakPageBefore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakPageBefore { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakPageBefore : bool with get, set" Usage="System.Windows.Documents.Block.BreakPageBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se inserta automáticamente un salto de página antes de este elemento.</summary>
        <value>
          <see langword="true" /> para insertar automáticamente un salto de página antes de este elemento; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BreakPageBefore"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.BreakColumnBeforeProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.BreakColumnBefore" />
      </Docs>
    </Member>
    <Member MemberName="BreakPageBeforeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BreakPageBeforeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BreakPageBeforeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.BreakPageBeforeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BreakPageBeforeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BreakPageBeforeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BreakPageBeforeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.BreakPageBeforeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.BreakPageBefore" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearFloaters">
      <MemberSignature Language="C#" Value="public System.Windows.WrapDirection ClearFloaters { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WrapDirection ClearFloaters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.ClearFloaters" />
      <MemberSignature Language="VB.NET" Value="Public Property ClearFloaters As WrapDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WrapDirection ClearFloaters { System::Windows::WrapDirection get(); void set(System::Windows::WrapDirection value); };" />
      <MemberSignature Language="F#" Value="member this.ClearFloaters : System.Windows.WrapDirection with get, set" Usage="System.Windows.Documents.Block.ClearFloaters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WrapDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la dirección en que se deben cambiar de posición los elementos <see cref="T:System.Windows.Documents.Floater" /> contenidos en un elemento <see cref="T:System.Windows.Documents.Block" />.</summary>
        <value>Uno de los valores <see cref="T:System.Windows.WrapDirection" /> que especifica la dirección en que se separan los elementos <see cref="T:System.Windows.Documents.Floater" /> de otro contenido incluido en el elemento <see cref="T:System.Windows.Documents.Block" />. El valor predeterminado es <see cref="F:System.Windows.WrapDirection.None" />, lo que indica que los elementos Floater deben representarse en su posición.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Documents.Block.ClearFloaters%2A> propiedad afecta a cómo está dispuesto contenido dentro de un <xref:System.Windows.Documents.Block> y está pensado para usarse para evitar <xref:System.Windows.Documents.Floater> elementos saturen el contenido de un <xref:System.Windows.Documents.Block> elemento.  Especificar una dirección para esta propiedad hace que los elementos Floater cambiar de posición en una dirección uniforme dentro de la <xref:System.Windows.Documents.Block> contenido.  Los elementos Floater no cambian de posición fuera de su elemento primario <xref:System.Windows.Documents.Block>.  
  
<a name="dependencyPropertyInfo_ClearFloaters"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.ClearFloatersProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearFloatersProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClearFloatersProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClearFloatersProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.ClearFloatersProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClearFloatersProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClearFloatersProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClearFloatersProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.ClearFloatersProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.ClearFloaters" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.Documents.Block.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la dirección relativa del flujo de contenido en un elemento <see cref="T:System.Windows.Documents.Block" />.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.FlowDirection" /> que especifica la dirección relativa del flujo. El valor predeterminado es <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La obtención de esta propiedad devuelve la dirección de flujo efectiva actual.  El establecimiento de esta propiedad hace que el flujo del contenido del elemento <xref:System.Windows.Documents.Block> vaya en la dirección indicada.  
  
 La dirección del flujo de contenido normalmente corresponde a la dirección del flujo innata del lenguaje que se va a representar.  Hebreo y árabe son ejemplos de idiomas que fluyen de derecha a izquierda.  Inglés, alemán y ruso son ejemplos de lenguajes que fluyen de izquierda a derecha.  
  
> [!NOTE]
>  **El valor de esta propiedad no se cambia automáticamente para que coincida con el idioma usado por el sistema operativo. Si tiene que usar otro valor th**un**n el valor predeterminado de** <xref:System.Windows.FlowDirection.LeftToRight> **, debe especificarlo manualmente.**  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.FlowDirectionProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.FlowDirection%2A> atributo de un <xref:System.Windows.Documents.Block> elemento (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_FlowDirectionXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_flowdirectionxaml)]  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.FlowDirection%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_FlowDirection](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_flowdirection)]
 [!code-vb[BlockSnippets#_Block_FlowDirection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_flowdirection)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.FlowDirection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public static bool GetIsHyphenationEnabled (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GetIsHyphenationEnabled(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.GetIsHyphenationEnabled(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIsHyphenationEnabled (element As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GetIsHyphenationEnabled(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetIsHyphenationEnabled : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Documents.Block.GetIsHyphenationEnabled element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" />.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.SetIsHyphenationEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineHeight">
      <MemberSignature Language="C#" Value="public static double GetLineHeight (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 GetLineHeight(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.GetLineHeight(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineHeight (element As DependencyObject) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double GetLineHeight(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineHeight : System.Windows.DependencyObject -&gt; double" Usage="System.Windows.Documents.Block.GetLineHeight element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Documents.Block.LineHeight" />.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.LineHeight" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Documents.Block.LineHeight" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static System.Windows.LineStackingStrategy GetLineStackingStrategy (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.LineStackingStrategy GetLineStackingStrategy(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLineStackingStrategy (element As DependencyObject) As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::LineStackingStrategy GetLineStackingStrategy(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetLineStackingStrategy : System.Windows.DependencyObject -&gt; System.Windows.LineStackingStrategy" Usage="System.Windows.Documents.Block.GetLineStackingStrategy element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" /> adjunta.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextAlignment">
      <MemberSignature Language="C#" Value="public static System.Windows.TextAlignment GetTextAlignment (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.TextAlignment GetTextAlignment(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.GetTextAlignment(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTextAlignment (element As DependencyObject) As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::TextAlignment GetTextAlignment(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTextAlignment : System.Windows.DependencyObject -&gt; System.Windows.TextAlignment" Usage="System.Windows.Documents.Block.GetTextAlignment element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia del que se recupera el valor de la propiedad <see cref="P:System.Windows.Documents.Block.TextAlignment" />.</param>
        <summary>Devuelve el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.TextAlignment" /> de un objeto de dependencia especificado.</summary>
        <returns>Valor actual de la propiedad asociada <see cref="P:System.Windows.Documents.Block.TextAlignment" /> del objeto de dependencia especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public bool IsHyphenationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHyphenationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.IsHyphenationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHyphenationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHyphenationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHyphenationEnabled : bool with get, set" Usage="System.Windows.Documents.Block.IsHyphenationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la división automática de palabras está habilitada o deshabilitada.</summary>
        <value>
          <see langword="true" /> si se habilitan la separación y la división de palabras; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La característica de división de palabras automática permite un <xref:System.Windows.Documents.Block> elemento separe y separar las palabras, automáticamente según las condiciones actuales de diseño.  Esto permite a esas palabras largas empezar en una sola línea y continuar en la siguiente y tiende a lograr una distribución más uniforme de espacio en blanco en texto justificado.  Las palabras se divide y guiones con según las reglas gramaticales estándar.  
  
<a name="dependencyPropertyInfo_IsHyphenationEnabled"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.IsHyphenationEnabledProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.IsHyphenationEnabled%2A> atributo de un <xref:System.Windows.Documents.Block> elemento.  
  
 [!code-xaml[BlockSnippets#_Block_HyphenateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_hyphenatexaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  
  
 ![Captura de pantalla: FlowDocument con guiones habilitados](~/add/media/flowdoc-hyphenenabled.png "captura de pantalla: FlowDocument con guiones habilitados")  
  
 En la siguiente ilustración se muestra cómo se representa el mismo ejemplo con el valor predeterminado de <xref:System.Windows.Documents.Block.IsHyphenationEnabled%2A> = `false`.  
  
 ![Captura de pantalla: FlowDocument con guiones deshabilitados](~/add/media/flowdoc-hyphendisabled.png "captura de pantalla: FlowDocument con guiones deshabilitados")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.IsHyphenationEnabled%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_Hyphenate](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_hyphenate)]
 [!code-vb[BlockSnippets#_Block_Hyphenate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_hyphenate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHyphenationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHyphenationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHyphenationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.IsHyphenationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHyphenationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHyphenationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHyphenationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.IsHyphenationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Documents.Block.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el alto de cada línea de contenido.</summary>
        <value>El alto de cada línea en píxeles independientes del dispositivo, en el intervalo de 0,0034 a 160000, o <see cref="F:System.Double.NaN" /> para determinar el alto automáticamente. El valor predeterminado es <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de <xref:System.Double.NaN?displayProperty=nameWithType> (equivalente a un valor de atributo `Auto`) indica que el alto de línea se determine automáticamente a partir de las características de la fuente actual.  
  
 Si cambia este valor no cambia el alto del texto asociado; en su lugar, cambia el alto de la línea que contiene el texto. Para cambiar el tamaño del texto, use la <xref:System.Windows.Documents.FlowDocument.FontSize%2A> propiedad.  
  
 Además de esta propiedad, el diseño de las líneas en un <xref:System.Windows.Documents.Block> se ve afectado por su <xref:System.Windows.Documents.Block.LineStackingStrategy%2A> propiedad.  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *double*  
 <xref:System.Double>  
  
 Representación de cadena de un <xref:System.Double> valor igual a o mayor que 0,0034 pero igual o inferior a 160000. Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente puntos decimales.  
  
 *qualifiedDouble*  
 Un *doble* valor tal como se describió anteriormente, (excepto `Auto`) seguido de uno de los siguientes especificadores de unidad: `px`, `in`, `cm`, `pt`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 `cm` es centímetros; 1cm==(96/2.54) px  
  
 `pt` puntos; 1pt==(96/72) px  
  
 Automático  
 Hace que el alto de línea se determine automáticamente a partir de las características de la fuente actual.  Equivalente a un valor de propiedad <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.LineHeightProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.LineHeight%2A> atributo de un <xref:System.Windows.Documents.Block> elemento.  
  
 [!code-xaml[BlockSnippets#_Block_LineHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_lineheightxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  
  
 ![Captura de pantalla: FlowDocument LineHeight](~/add/media/flowdocument-lineheight.png "captura de pantalla: LineHeight de FlowDocument")  
  
 La siguiente ilustración muestra cómo el mismo <xref:System.Windows.Documents.FlowDocument> se representa con la configuración predeterminada de <xref:System.Windows.Documents.FlowDocument.LineHeight%2A> = <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
 ![Captura de pantalla: LineHeight predeterminado de FlowDocument](~/add/media/flowdocument-lineheightdefault.png "captura de pantalla: LineHeight predeterminado de FlowDocument")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.LineHeight%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_LineHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_lineheight)]
 [!code-vb[BlockSnippets#_Block_LineHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_lineheight)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> se establece en un valor no positivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.LineHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Documents.Block.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece cómo se determina un cuadro de línea por cada línea de texto dentro del elemento de contenido del flujo de nivel de bloque.</summary>
        <value>Uno de los valores de <see cref="T:System.Windows.LineStackingStrategy" /> que especifica cómo se determina un cuadro de línea para cada línea de texto dentro del elemento de contenido dinámico de nivel de bloque. El valor predeterminado es <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad de dependencia también tiene un uso de la propiedad adjunta. En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], el uso es \< *objeto* <xref:System.Windows.Documents.Block.LineStackingStrategy%2A?displayProperty=nameWithType>= "*valor*"... / >, donde *objeto* es un elemento de objeto (normalmente un elemento de flujo) dentro de un <xref:System.Windows.Documents.Block> clase derivada, y *valor* es un valor de cadena de la <xref:System.Windows.LineStackingStrategy> enumeración. En el código, el uso de la propiedad adjunta es compatible con la <xref:System.Windows.Documents.Block.GetLineStackingStrategy%2A> y <xref:System.Windows.Documents.Block.SetLineStackingStrategy%2A> métodos. El uso de la propiedad adjunta no es habitual.  
  
<a name="dependencyPropertyInfo_LineStackingStrategy"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.LineStackingStrategyProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> propiedad para determinar cómo se crean los cuadros de línea para las líneas de texto de un <xref:System.Windows.Controls.TextBlock>. La primera <xref:System.Windows.Controls.TextBlock> tiene un <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> valor <xref:System.Windows.LineStackingStrategy.MaxHeight> y el segundo <xref:System.Windows.Controls.TextBlock> tiene un valor de <xref:System.Windows.LineStackingStrategy.BlockLineHeight>.  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 La siguiente ilustración muestra el resultado del código anterior.  
  
 ![Captura de pantalla: Comparar valores de LineStackingStrategy](~/add/media/flow-linestackingstrategy.gif "captura de pantalla: comparar LineStackingStrategy valores")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.Block.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el grosor del margen para el elemento.</summary>
        <value>Un <see cref="T:System.Windows.Thickness" /> estructura que especifica la cantidad de margen que se aplicará, en píxeles independientes del dispositivo. El valor predeterminado es un grosor uniforme de cero (0,0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.Block.Margin%2A> es el espacio de búfer que está fuera del área de contenido de un elemento, entre los bordes del área de contenido del elemento y los bordes del elemento primario.  Compare con <xref:System.Windows.Documents.Block.Padding%2A>, que es el espacio de búfer que se encuentre dentro del área de contenido de un elemento, entre el contenido del elemento y el borde interno del elemento.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object Margin="uniformThickness"/>  
- or -  
<object Margin="independentThickness"/>  
- or -  
<object Margin="qualifiedUniformThickness"/>  
- or -  
<object Margin="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *uniformThickness*  
 Representación de cadena de una sola <xref:System.Double> valor que se aplica uniformemente a todas las dimensiones de grosor de cuatro.  Por ejemplo, un valor de `"10"` es equivalente a un valor de `"10,10,10,10"`.  Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente puntos decimales.  
  
 *independentThickness*  
 Representación de cadena de cuatro ordenados <xref:System.Double> los valores correspondientes a las dimensiones de grosor independiente para la izquierda, superior, derecha y abajo, en este orden.  Los cuatro valores deben estar separados con comas; no se permiten espacios.  Por ejemplo, "5,10,15,20 da como" resultado 5 píxeles del margen a la izquierda del contenido, 10 píxeles del margen superior de contenido, 15 píxeles de margen situado a la derecha del contenido y 20 píxeles del margen debajo del contenido.  
  
 *qualifiedUniformThickness*  
 Un valor descrito por *uniformThickness* seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo, `"1in"` proporciona un margen uniforme de 1 pulgada en todas las direcciones.  
  
 *qualifiedIndependentThickness*  
 Un valor descrito por *independentThickness*, con cada valor independiente seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo: `"1.5in,0.8in,1.5in,0.8in"`.  Especificadores de unidades esté mixto o se omite de uno o más valores.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.MarginProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.Margin%2A> atributo de un <xref:System.Windows.Documents.Block> elemento (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  Se usan los colores y grosores exageradas fines ilustrativos.  
  
 ![Captura de pantalla: Párrafos con relleno y márgenes](~/add/media/block-marginpadding.png "captura de pantalla: párrafos con relleno y márgenes")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.Margin%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.Padding" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextBlock">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Block NextBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Block NextBlock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.NextBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextBlock As Block" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Block ^ NextBlock { System::Windows::Documents::Block ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextBlock : System.Windows.Documents.Block" Usage="System.Windows.Documents.Block.NextBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Block</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento <see cref="T:System.Windows.Documents.Block" /> relacionado que sigue directamente al elemento <see cref="T:System.Windows.Documents.Block" /> actual.</summary>
        <value>El elemento <see cref="T:System.Windows.Documents.Block" /> relacionado que sigue directamente al elemento <see cref="T:System.Windows.Documents.Block" /> actual, o <see langword="null" /> si no existe ningún elemento de este tipo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.Block.PreviousBlock" />
        <altmember cref="P:System.Windows.Documents.Block.SiblingBlocks" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.Block.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el grosor del relleno para el elemento.</summary>
        <value>Un <see cref="T:System.Windows.Thickness" /> estructura que especifica la cantidad de relleno que se aplicará, en píxeles independientes del dispositivo. El valor predeterminado es un grosor uniforme de cero (0,0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.Block.Padding%2A> es el espacio de búfer que se encuentre dentro del área de contenido de un elemento, entre el contenido del elemento y el borde interno del elemento.  Compare con <xref:System.Windows.Documents.Block.Margin%2A>, que es el espacio de búfer que está fuera del área de contenido de un elemento, entre los bordes del área de contenido del elemento y los bordes del elemento primario.  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *uniformThickness*  
 Representación de cadena de una sola <xref:System.Double> valor que se aplica uniformemente a todas las dimensiones de grosor de cuatro.  Por ejemplo, un valor de `"10"` es equivalente a un valor de `"10,10,10,10"`.  Un valor sin calificar se mide en píxeles independientes del dispositivo. Las cadenas no necesitan incluir explícitamente puntos decimales.  
  
 *independentThickness*  
 Representación de cadena de cuatro ordenados <xref:System.Double> los valores correspondientes a las dimensiones de grosor independiente para la izquierda, superior, derecha y abajo, en este orden.  Los cuatro valores deben estar separados con comas; no se permiten espacios.  Por ejemplo, "5,10,15,20 da como" resultado 5 píxeles de relleno a la izquierda del contenido, 10 píxeles de relleno encima de contenido, 15 píxeles de relleno a la derecha del contenido y 20 píxeles de relleno debajo del contenido.  
  
 *qualifiedUniformThickness*  
 Un valor descrito por *uniformThickness* seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo, `"1in"` proporciona un margen uniforme de 1 pulgada en todas las direcciones.  
  
 *qualifiedIndependentThickness*  
 Un valor descrito por *independentThickness*, con cada valor independiente seguido de uno de los siguientes especificadores de unidad: `px`, `in`.  
  
 `px` (valor predeterminado) es [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pulgadas; 1in == 96 px  
  
 Por ejemplo: `"1.5in,0.8in,1.5in,0.8in"`.  Especificadores de unidades esté mixto o se omite de uno o más valores.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.PaddingProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.Padding%2A> atributo de un <xref:System.Windows.Documents.Block> elemento (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior.  Se usan los colores y grosores exageradas fines ilustrativos.  
  
 ![Captura de pantalla: Párrafos con relleno y márgenes](~/add/media/block-marginpadding.png "captura de pantalla: párrafos con relleno y márgenes")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.Padding%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.Margin" />
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.Padding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousBlock">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Block PreviousBlock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Block PreviousBlock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.PreviousBlock" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousBlock As Block" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Block ^ PreviousBlock { System::Windows::Documents::Block ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousBlock : System.Windows.Documents.Block" Usage="System.Windows.Documents.Block.PreviousBlock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Block</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento <see cref="T:System.Windows.Documents.Block" /> relacionado que precede directamente al elemento <see cref="T:System.Windows.Documents.Block" /> actual.</summary>
        <value>El elemento <see cref="T:System.Windows.Documents.Block" /> relacionado que precede directamente al elemento <see cref="T:System.Windows.Documents.Block" /> actual, o <see langword="null" /> si no existe ningún elemento de este tipo.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.Block.NextBlock" />
        <altmember cref="P:System.Windows.Documents.Block.SiblingBlocks" />
      </Docs>
    </Member>
    <Member MemberName="SetIsHyphenationEnabled">
      <MemberSignature Language="C#" Value="public static void SetIsHyphenationEnabled (System.Windows.DependencyObject element, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIsHyphenationEnabled(class System.Windows.DependencyObject element, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.SetIsHyphenationEnabled(System.Windows.DependencyObject,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIsHyphenationEnabled (element As DependencyObject, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIsHyphenationEnabled(System::Windows::DependencyObject ^ element, bool value);" />
      <MemberSignature Language="F#" Value="static member SetIsHyphenationEnabled : System.Windows.DependencyObject * bool -&gt; unit" Usage="System.Windows.Documents.Block.SetIsHyphenationEnabled (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.IsHyphenationEnabled" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.GetIsHyphenationEnabled(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineHeight">
      <MemberSignature Language="C#" Value="public static void SetLineHeight (System.Windows.DependencyObject element, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineHeight(class System.Windows.DependencyObject element, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.SetLineHeight(System.Windows.DependencyObject,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineHeight (element As DependencyObject, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineHeight(System::Windows::DependencyObject ^ element, double value);" />
      <MemberSignature Language="F#" Value="static member SetLineHeight : System.Windows.DependencyObject * double -&gt; unit" Usage="System.Windows.Documents.Block.SetLineHeight (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Documents.Block.LineHeight" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.LineHeight" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> es negativo.</exception>
        <altmember cref="M:System.Windows.Documents.Block.GetLineHeight(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetLineStackingStrategy">
      <MemberSignature Language="C#" Value="public static void SetLineStackingStrategy (System.Windows.DependencyObject element, System.Windows.LineStackingStrategy value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLineStackingStrategy(class System.Windows.DependencyObject element, valuetype System.Windows.LineStackingStrategy value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.SetLineStackingStrategy(System.Windows.DependencyObject,System.Windows.LineStackingStrategy)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLineStackingStrategy (element As DependencyObject, value As LineStackingStrategy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLineStackingStrategy(System::Windows::DependencyObject ^ element, System::Windows::LineStackingStrategy value);" />
      <MemberSignature Language="F#" Value="static member SetLineStackingStrategy : System.Windows.DependencyObject * System.Windows.LineStackingStrategy -&gt; unit" Usage="System.Windows.Documents.Block.SetLineStackingStrategy (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.LineStackingStrategy" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.LineStackingStrategy" /> de un objeto de dependencia especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.Documents.Block.GetLineStackingStrategy(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="SetTextAlignment">
      <MemberSignature Language="C#" Value="public static void SetTextAlignment (System.Windows.DependencyObject element, System.Windows.TextAlignment value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTextAlignment(class System.Windows.DependencyObject element, valuetype System.Windows.TextAlignment value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.Block.SetTextAlignment(System.Windows.DependencyObject,System.Windows.TextAlignment)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTextAlignment (element As DependencyObject, value As TextAlignment)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTextAlignment(System::Windows::DependencyObject ^ element, System::Windows::TextAlignment value);" />
      <MemberSignature Language="F#" Value="static member SetTextAlignment : System.Windows.DependencyObject * System.Windows.TextAlignment -&gt; unit" Usage="System.Windows.Documents.Block.SetTextAlignment (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.TextAlignment" />
      </Parameters>
      <Docs>
        <param name="element">Objeto de dependencia en el que se establece el valor de la propiedad <see cref="P:System.Windows.Documents.Block.TextAlignment" />.</param>
        <param name="value">Nuevo valor en el que se va a establecer la propiedad.</param>
        <summary>Establece el valor de la propiedad adjunta <see cref="P:System.Windows.Documents.Block.TextAlignment" /> de un objeto de dependencia especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.Documents.Block.GetTextAlignment%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="element" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SiblingBlocks">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.BlockCollection SiblingBlocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.BlockCollection SiblingBlocks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.SiblingBlocks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SiblingBlocks As BlockCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::BlockCollection ^ SiblingBlocks { System::Windows::Documents::BlockCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SiblingBlocks : System.Windows.Documents.BlockCollection" Usage="System.Windows.Documents.Block.SiblingBlocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.BlockCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de elementos <see cref="T:System.Windows.Documents.Block" /> que están relacionados con el elemento <see cref="T:System.Windows.Documents.Block" /> actual.</summary>
        <value>Una <see cref="T:System.Windows.Documents.BlockCollection" /> que contiene los elementos <see cref="T:System.Windows.Documents.Block" /> secundarios hospedados directamente por el elemento primario del elemento <see cref="T:System.Windows.Documents.Block" /> actual, o <see langword="null" /> si el elemento <see cref="T:System.Windows.Documents.Block" /> actual no tiene ningún elemento primario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Documents.BlockCollection> devuelto por esta propiedad incluye la <xref:System.Windows.Documents.Block> elemento a través del cual se tiene acceso a la colección; es decir, el elemento que posee esta propiedad se considera su propio elemento relacionado con el fin de generar la colección de elementos del mismo nivel.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.Block.NextBlock" />
        <altmember cref="P:System.Windows.Documents.Block.PreviousBlock" />
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.Block.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Documents.Block.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la alineación horizontal del contenido de texto.</summary>
        <value>Uno de los valores <see cref="T:System.Windows.TextAlignment" /> que especifica la alineación deseada. El valor predeterminado es <see cref="F:System.Windows.TextAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Documents.Block.TextAlignmentProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.TextAlignment%2A> atributo de un <xref:System.Windows.Documents.Block> elemento.  
  
 [!code-xaml[BlockSnippets#_Block_TextAlignmentXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_textalignmentxaml)]  
  
 En la siguiente ilustración se muestra cómo se representa en el ejemplo anterior con <xref:System.Windows.TextAlignment.Left> alineación del texto (valor predeterminado).  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de izquierda](~/add/media/flowdoc-textalign-left.png "captura de pantalla: valor de propiedad TextAlign de izquierda")  
  
 En la siguiente ilustración se muestra cómo se representa el mismo ejemplo con <xref:System.Windows.TextAlignment.Right> alineación del texto.  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de derecha](~/add/media/flowdoc-textalign-right.png "captura de pantalla: valor de Right de propiedad TextAlign")  
  
 En la siguiente ilustración se muestra cómo se representa el mismo ejemplo con <xref:System.Windows.TextAlignment.Center> alineación del texto.  
  
 ![Captura de pantalla: Valor de propiedad TextAlign de Center](~/add/media/flowdoc-textalign-center.png "captura de pantalla: valor de propiedad TextAlign de Center")  
  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Documents.Block.TextAlignment%2A> propiedad mediante programación.  
  
 [!code-csharp[BlockSnippets#_Block_TextAlignment](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_textalignment)]
 [!code-vb[BlockSnippets#_Block_TextAlignment](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_textalignment)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.Block.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.Block.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Documents.Block.TextAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>