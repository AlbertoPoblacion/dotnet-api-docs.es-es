<Type Name="Condition" FullName="System.Windows.Condition">
  <Metadata><Meta Name="ms.openlocfilehash" Value="256beaf14ac149cabccdf1f49513d981bd92a970" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55333790" /></Metadata><TypeSignature Language="C#" Value="public sealed class Condition : System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Condition extends System.Object implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Condition" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Condition&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Condition sealed : System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Condition = class&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XamlSetMarkupExtension("ReceiveMarkupExtension")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XamlSetTypeConverter("ReceiveTypeConverter")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una condición para <see cref="T:System.Windows.MultiTrigger" /> y <see cref="T:System.Windows.MultiDataTrigger" />, que aplican cambios a los valores de propiedades según un conjunto de condiciones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s y <xref:System.Windows.MultiDataTrigger>s permiten establecer valores de propiedad basados en un conjunto de condiciones. Una condición se cumple cuando el valor de propiedad del elemento de datos o el elemento coincide con el especificado <xref:System.Windows.Condition.Value%2A> (comprobación de igualdad de referencia). Si se cumplen todas las condiciones especificadas, se aplica el desencadenador.  
  
 La siguiente es una lista de casos que se producirá una excepción:  
  
-   Para cada <xref:System.Windows.Condition>, solo se puede establecer el <xref:System.Windows.Condition.Property%2A> propiedad o el <xref:System.Windows.Condition.Binding%2A> propiedad. Si se establecen ambas propiedades, se produce una excepción.  
  
-   Si el <xref:System.Windows.Condition> es para un <xref:System.Windows.MultiTrigger>, el <xref:System.Windows.Condition.Property%2A> propiedad no puede ser null.  
  
-   Si el <xref:System.Windows.Condition> es para un <xref:System.Windows.MultiDataTrigger>, el <xref:System.Windows.Condition.Binding%2A> propiedad no puede ser null.  
  
-   Se produce una excepción si especificado <xref:System.Windows.Condition.Value%2A> no es válido para el tipo de la clase <xref:System.Windows.Condition.Property%2A>.  
  
 Observe que si el <xref:System.Windows.Condition> es para un <xref:System.Windows.MultiTrigger>, el <xref:System.Windows.Condition.Property%2A> y <xref:System.Windows.Condition.Value%2A> se deben establecer las propiedades. Si se trata de un <xref:System.Windows.MultiDataTrigger>, <xref:System.Windows.Condition.Binding%2A> y <xref:System.Windows.Condition.Value%2A> se deben establecer las propiedades.  
  
   
  
## Examples  
 En el siguiente ejemplo contiene dos <xref:System.Windows.MultiTrigger>s. Los primeros conjuntos el **MinWidth** valor de propiedad cuando la **HasItems** propiedad es false y el **ancho** propiedad es **automática**. La otra es similar, pero es para el **MinHeight** propiedad.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Consulte la <xref:System.Windows.Condition.Binding%2A> propiedad para obtener ejemplos de condiciones usadas en un <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Condition" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.Data.BindingBase binding, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Data.BindingBase binding, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.Data.BindingBase,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (binding As BindingBase, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::Data::BindingBase ^ binding, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.Data.BindingBase * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (binding, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="binding">Enlace que especifica la propiedad de la condición.</param>
        <param name="conditionValue">Valor de la condición.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Propiedad de la condición.</param>
        <param name="conditionValue">Valor de la condición.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Condition" /> con la propiedad y el valor especificados. Este constructor realiza la validación de parámetros.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Condition (System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty conditionProperty, object conditionValue, string sourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.#ctor(System.Windows.DependencyProperty,System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (conditionProperty As DependencyProperty, conditionValue As Object, sourceName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Condition(System::Windows::DependencyProperty ^ conditionProperty, System::Object ^ conditionValue, System::String ^ sourceName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Condition : System.Windows.DependencyProperty * obj * string -&gt; System.Windows.Condition" Usage="new System.Windows.Condition (conditionProperty, conditionValue, sourceName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="conditionProperty" Type="System.Windows.DependencyProperty" />
        <Parameter Name="conditionValue" Type="System.Object" />
        <Parameter Name="sourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="conditionProperty">Propiedad de la condición.</param>
        <param name="conditionValue">Valor de la condición.</param>
        <param name="sourceName"><c>x:Name</c> del objeto que tiene el parámetro <paramref name="conditionProperty" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Condition" /> con la propiedad, valor y nombre del objeto de origen especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Binding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingBase Binding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingBase Binding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Binding" />
      <MemberSignature Language="VB.NET" Value="Public Property Binding As BindingBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingBase ^ Binding { System::Windows::Data::BindingBase ^ get(); void set(System::Windows::Data::BindingBase ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Binding : System.Windows.Data.BindingBase with get, set" Usage="System.Windows.Condition.Binding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el enlace que especifica la propiedad de la condición. Esto solo es aplicable a los objetos <see cref="T:System.Windows.MultiDataTrigger" />.</summary>
        <value>El valor predeterminado es null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiDataTrigger>s permiten establecer valores de propiedad según los valores de los datos que se devuelven. Por ejemplo, si va a mostrar una lista de elementos de tarea, puede mostrar una tarea con un fondo rojo si es de alta prioridad y no se ha buscado en más de dos semanas.  
  
 Crear un enlace y use el <xref:System.Windows.Data.Binding.Path%2A> se va a enlazar una propiedad de un objeto determinado (el objeto de origen de enlace). Por ejemplo, puede enlazar a la *prioridad* propiedad de un *tarea*. Para obtener más información, consulte [Información general sobre el enlace de datos](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Tenga en cuenta que si es una condición para un <xref:System.Windows.MultiDataTrigger>, <xref:System.Windows.Condition.Binding%2A> y <xref:System.Windows.Condition.Value%2A> se deben establecer las propiedades. Establecer el <xref:System.Windows.Condition.Property%2A> valor generaría una excepción en ese caso.  
  
<a name="xamlAttributeUsage_PriorityBinding"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="{Binding  declaration}"/>  
```  
  
<a name="xamlPropertyElementUsage_Binding"></a>   
## <a name="xaml-property-element-usage"></a>Uso de elementos de propiedad XAML  
  
```  
<object>  
  <object.Binding>  
    <Binding …/>  
  </object.Binding>  
</object>  
```  
  
<a name="xamlValues_PriorityBinding"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *declaration*  
 Una declaración de enlace. Consulte [información general de declaraciones de enlace](~/docs/framework/wpf/data/binding-declarations-overview.md) para obtener más información.  
  
   
  
## Examples  
 En el ejemplo siguiente, la <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> de la <xref:System.Windows.Controls.ListBox> está enlazado a *lugares*, un <xref:System.Collections.ObjectModel.ObservableCollection%601> de *lugar* objetos. *Lugar* objetos tienen propiedades *nombre* y *estado*.  
  
 Cada <xref:System.Windows.Controls.ListBoxItem> de la <xref:System.Windows.Controls.ListBox> muestra un *lugar* objeto. El <xref:System.Windows.Style> en el ejemplo se aplica a cada <xref:System.Windows.Controls.ListBoxItem>. El <xref:System.Windows.Condition>s de la <xref:System.Windows.MultiDataTrigger> se especifican tal que si el *nombre* y *estado* de la *lugar* elemento de datos es "Portland" y "O", respectivamente, el en segundo plano de correspondiente <xref:System.Windows.Controls.ListBoxItem> está configurado en cian.  
  
 [!code-xaml[DataTrigger#1](~/samples/snippets/csharp/VS_Snippets_Wpf/DataTrigger/CSharp/Window1.xaml#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Property" />
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty Property { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty Property" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Property" />
      <MemberSignature Language="VB.NET" Value="Public Property Property As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ Property { System::Windows::DependencyProperty ^ get(); void set(System::Windows::DependencyProperty ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Property : System.Windows.DependencyProperty with get, set" Usage="System.Windows.Condition.Property" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la propiedad de la condición. Esto solo es aplicable a los objetos <see cref="T:System.Windows.MultiTrigger" />.</summary>
        <value><see cref="T:System.Windows.DependencyProperty" /> que especifica la propiedad de la condición. El valor predeterminado es null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s permiten establecer valores de propiedad basados en un conjunto de condiciones. Una condición se cumple cuando el valor de la propiedad (especificado por el <xref:System.Windows.Condition.Property%2A> propiedad) del elemento coincide con el especificado <xref:System.Windows.Condition.Value%2A> (comprobación de igualdad de referencia). Si se cumplen todas las condiciones especificadas, se aplica el desencadenador.  
  
 Si `TargetType` no está establecida en el estilo de la plantilla que contiene los desencadenadores. A continuación, se debe calificar el nombre de propiedad mediante la `ClassName.PropertyName` sintaxis.  
  
 Tenga en cuenta que si es una condición para un <xref:System.Windows.MultiTrigger>, <xref:System.Windows.Condition.Property%2A> y <xref:System.Windows.Condition.Value%2A> se deben establecer las propiedades. Establecer el <xref:System.Windows.Condition.Binding%2A> valor generaría una excepción en ese caso.  
  
 Para <xref:System.Windows.Condition>s en <xref:System.Windows.MultiDataTrigger>s, la <xref:System.Windows.Condition.Binding%2A> propiedad debe utilizarse en lugar de esta propiedad.  
  
   
  
## Examples  
 En el siguiente ejemplo contiene dos <xref:System.Windows.MultiTrigger>s. Los primeros conjuntos el **MinWidth** valor de propiedad cuando la **HasItems** propiedad es false y el **ancho** propiedad es **automática**. La otra es similar, pero es para el **MinHeight** propiedad.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Condition.Binding" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMarkupExtension">
      <MemberSignature Language="C#" Value="public static void ReceiveMarkupExtension (object targetObject, System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveMarkupExtension(object targetObject, class System.Windows.Markup.XamlSetMarkupExtensionEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveMarkupExtension(System.Object,System.Windows.Markup.XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveMarkupExtension (targetObject As Object, eventArgs As XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveMarkupExtension(System::Object ^ targetObject, System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveMarkupExtension : obj * System.Windows.Markup.XamlSetMarkupExtensionEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveMarkupExtension (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Objeto en el que la extensión de marcado establece el valor.</param>
        <param name="eventArgs">Datos que son pertinentes para el procesamiento de la extensión de marcado.</param>
        <summary>Administra los casos en los que una extensión de marcado proporciona un valor para una propiedad de un objeto <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este es el método al que hace referencia un aplicada <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute> atributo en el nivel de clase, lo que significa que este método procesa todos los intentos de establecer los valores de <xref:System.Windows.Condition> con una extensión de marcado. Se no suele llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetMarkupExtensionEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTypeConverter">
      <MemberSignature Language="C#" Value="public static void ReceiveTypeConverter (object targetObject, System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReceiveTypeConverter(object targetObject, class System.Windows.Markup.XamlSetTypeConverterEventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.ReceiveTypeConverter(System.Object,System.Windows.Markup.XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReceiveTypeConverter (targetObject As Object, eventArgs As XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReceiveTypeConverter(System::Object ^ targetObject, System::Windows::Markup::XamlSetTypeConverterEventArgs ^ eventArgs);" />
      <MemberSignature Language="F#" Value="static member ReceiveTypeConverter : obj * System.Windows.Markup.XamlSetTypeConverterEventArgs -&gt; unit" Usage="System.Windows.Condition.ReceiveTypeConverter (targetObject, eventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetObject" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Parameters>
      <Docs>
        <param name="targetObject">Objeto en el que el convertidor de tipos establece el valor.</param>
        <param name="eventArgs">Datos que son pertinentes para el procesamiento del convertidor de tipos.</param>
        <summary>Administra los casos en los que un convertidor de tipos proporciona un valor para una propiedad de un objeto <see cref="T:System.Windows.Condition" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este es el método al que hace referencia un aplicada <xref:System.Windows.Markup.XamlSetTypeConverterAttribute> atributo en el nivel de clase, lo que significa que este método procesa todos los intentos de establecer los valores de <xref:System.Windows.Condition> con un convertidor de tipos. Se no suele llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterAttribute" />
        <altmember cref="T:System.Windows.Markup.XamlSetTypeConverterEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SourceName">
      <MemberSignature Language="C#" Value="public string SourceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.SourceName" />
      <MemberSignature Language="VB.NET" Value="Public Property SourceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SourceName : string with get, set" Usage="System.Windows.Condition.SourceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del objeto con la propiedad que hace que se apliquen los establecedores asociados. Esto solo es aplicable a los objetos <see cref="T:System.Windows.MultiTrigger" />.</summary>
        <value>El valor predeterminado de la propiedad es <see langword="null" />. Si esta propiedad es <see langword="null" />, la propiedad del objeto al que se aplica un estilo hace que se apliquen los establecedores asociados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede establecer esta propiedad en el nombre de cualquier elemento dentro del ámbito donde se aplica la colección de desencadenadores (la colección que el desencadenador que contiene esta condición es parte de). Esto suele ser un elemento con nombre que se encuentra dentro de la plantilla que contiene el desencadenador.  
  
 Nombre de un objeto mediante el [x: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) sintaxis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Una vez que se usa <see cref="T:System.Windows.Condition" />, no se puede modificar.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al objeto que está comenzando la inicialización.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Windows.Condition> se convierte en una interfaz <xref:System.ComponentModel.ISupportInitialize>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Condition.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica al objeto que se ha completado la inicialización.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Windows.Condition> se convierte en una interfaz <xref:System.ComponentModel.ISupportInitialize>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public object Value { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Value" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Condition.Value" />
      <MemberSignature Language="VB.NET" Value="Public Property Value As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Value { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Value : obj with get, set" Usage="System.Windows.Condition.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Markup.SetterTriggerConditionValueConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de la condición.</summary>
        <value>La propiedad <see cref="P:System.Windows.Condition.Value" /> no puede ser null para un objeto <see cref="T:System.Windows.Condition" /> dado.  
  
Vea también la sección Excepciones. El valor predeterminado es null.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.MultiTrigger>s y <xref:System.Windows.MultiDataTrigger>s permiten establecer valores de propiedad basados en un conjunto de condiciones. Una condición se cumple cuando el valor de propiedad del elemento de datos o el elemento coincide con el especificado <xref:System.Windows.Condition.Value%2A>. Si se cumplen todas las condiciones especificadas, se aplica el desencadenador. Si se cumplen todas las condiciones especificadas, se aplica el desencadenador.  
  
   
  
## Examples  
 En el siguiente ejemplo contiene dos <xref:System.Windows.MultiTrigger>s. Los primeros conjuntos el **MinWidth** valor de propiedad cuando la **HasItems** propiedad es false y el **ancho** propiedad es **automática**. La otra es similar, pero es para el **MinHeight** propiedad.  
  
 [!code-xaml[ControlTemplateExamples_snip#MultiTriggerExample1](~/samples/snippets/csharp/VS_Snippets_Wpf/ControlTemplateExamples_snip/CS/Page1.xaml#multitriggerexample1)]  
  
 Consulte la <xref:System.Windows.Condition.Binding%2A> propiedad para obtener ejemplos de condiciones usadas en un <xref:System.Windows.MultiDataTrigger>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se admiten expresiones.</exception>
      </Docs>
    </Member>
  </Members>
</Type>