<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkContentElement.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b891ec5d-4b60-42d7-ac21-95eab9e3ef82615425e7a431643682b3286cc26cb17aa80cb9d4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">615425e7a431643682b3286cc26cb17aa80cb9d4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">058bfa0b75b777d3171411d35da8f11617fc06b0</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">05/04/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is the WPF framework-level implementation and expansion of the <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> base class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> es la implementación de nivel de marco de WPF y la expansión de la clase base <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> agrega compatibilidad para las API de entrada adicionales (incluye información sobre herramientas y menús contextuales), guiones gráficos, el contexto de datos para el enlace de datos, la compatibilidad de estilos y las API del auxiliar del árbol lógico.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> does not yet define its own rendering behavior; instantiating an actual <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> class instance in code or markup is possible but displays nothing in a <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> aún no define su propio comportamiento de representación; crear instancias de un real <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instancia de clase en el código o marcado es posible pero no muestra nada en una <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> aplicación <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Rendering logic must be provided by classes that take <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements as part of their content model, or in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes.</source>
          <target state="translated">Se debe proporcionar lógica de representación por clases que toman <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> los elementos secundarios como parte de su modelo de contenido o en <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> las clases derivadas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> deliberately parallels many of the same <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> as <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> se asemeja a muchas de estas mismas deliberadamente <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> como <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Note that certain <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> found on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> will not have a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalent.</source>
          <target state="translated">Tenga en cuenta que algunas <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> se encuentra en <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> no tendrán un <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalente.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Several of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> are for functionality such as geometry representation or layout, which are not relevant for a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Algunos de los <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> son funcionalidad como la representación en forma de geometría o de diseño, que no son relevantes para un <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>The majority of existing <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes will be found in the <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> namespace.</source>
          <target state="translated">La mayoría de las <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> las clases derivadas se encuentra en la <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> espacio de nombres.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Many of these derived classes implement elements for the flow document model.</source>
          <target state="translated">Muchas de estas clases derivadas implementan los elementos de modelo de documentos dinámicos.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Certain derived classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> have some control-like functionality, but are derived from <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> such that the control-like elements can still participate in the flow document model.</source>
          <target state="translated">Ciertas clases derivadas como <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> tienen alguna funcionalidad de tipo de control, pero se derivan <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> tal que los elementos de tipo de control pueden participar en el modelo de documentos dinámicos.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>The child element to be added.</source>
          <target state="translated">Elemento secundario que se va a agregar.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Adds the provided element as a child of this element.</source>
          <target state="translated">Agrega el elemento proporcionado como elemento secundario de este elemento.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>This method can throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated">Este método puede producir una excepción si se llama a la vez cuando el árbol lógico es que se recorren en iteración por otro proceso.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">La mayoría <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> en la <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> clase; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> en la <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> clase).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</source>
          <target state="translated">Normalmente, puede evitar cualquier necesidad de manipular directamente el árbol lógico si deriva de estas clases en su lugar.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that acts as the parent rendering element (content host).</source>
          <target state="translated">Trabajar con el árbol lógico de elementos de contenido es un escenario avanzado que puede requerir un analizador especializado o especializada <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> que actúa como el elemento de representación primario (host de contenido).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>For more information about how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo usar <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, consulte <bpt id="p1">[</bpt>árboles de WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Called before an element is initialized.</source>
          <target state="translated">Se llama antes de inicializar un elemento.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Override this method to provide special handling that should occur before your element is initialized during the element loading process.</source>
          <target state="translated">Invalide este método para proporcionar un control especial que debe aparecer antes de que el elemento se inicialice durante el proceso de carga de elemento.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Su implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to reaching <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</source>
          <target state="translated">La implementación base producirá una excepción si <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> se llama más de una vez en el mismo elemento antes de llegar a <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Empieza la secuencia de acciones contenidas en el guión gráfico proporcionado.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">Guión gráfico que se va a iniciar.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Empieza la secuencia de acciones contenidas en el guión gráfico proporcionado.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Para las firmas que no usan el <ph id="ph1">`isControllable`</ph>, parámetro, o cuando se especifica ese parámetro <ph id="ph2">`false`</ph>, se quitan los relojes de la escala de tiempo asociados a la animación en cuanto alcanza el período de "Relleno".</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Tenga en cuenta que también controlar una animación requiere que el guión gráfico sea accesible como una instancia en el código o con nombre.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">Guión gráfico que se va a iniciar.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Valor de la enumeración que describe el comportamiento que se va a usar si ya está animada una propiedad descrita en el guión gráfico.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</source>
          <target state="translated">Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con opciones especificadas para lo que debería ocurrir si la propiedad ya está animada.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Para las firmas que no usan el <ph id="ph1">`isControllable`</ph>, parámetro, o cuando se especifica ese parámetro <ph id="ph2">`false`</ph>, se quitan los relojes de la escala de tiempo asociados a la animación en cuanto alcanza el período de "Relleno".</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Tenga en cuenta que también controlar una animación requiere que el guión gráfico sea accesible como una instancia en el código o con nombre.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Mediante el campo Compose de HandoffBehavior</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">Al aplicar un <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> a una propiedad mediante el uso de la <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, cualquier <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita automáticamente los relojes.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Para evitar problemas de rendimiento al aplicar un gran número de relojes mediante <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Hay varias maneras de quitar un reloj:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Para quitar todos los relojes de una propiedad, utilice la <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> método del objeto animado.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Especifique la propiedad que se está animada como el primer parámetro, y <ph id="ph1">`null`</ph> como el segundo.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">Esto quita todos los relojes de animación de la propiedad.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Para quitar un determinado <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> en una lista de relojes, use la <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> propiedad de la <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> para recuperar un <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, a continuación, llame a la <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> método de la <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Esto se hace normalmente en el <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> controlador de eventos para un reloj.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; el <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> propiedad de un reloj secundario devuelve <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Tenga en cuenta también que la <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> no se produce el evento si la duración efectiva del reloj es para siempre.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">En ese caso, el usuario debe determinar cuándo se debe llamar a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los objetos de reloj, consulte <bpt id="p1">[</bpt>animación y temporización información general del sistema<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">Guión gráfico que se va a iniciar.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</source>
          <target state="translated">Valor de la enumeración que describe el comportamiento que se va a usar si ya está animada una propiedad descrita en el guión gráfico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">Declara si la animación se puede controlar (se puede pausar) después de que se ha iniciado.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con el estado especificado para el control de la animación una vez iniciado.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Para las firmas que no usan el <ph id="ph1">`isControllable`</ph>, parámetro, o cuando se especifica ese parámetro <ph id="ph2">`false`</ph>, se quitan los relojes de la escala de tiempo asociados a la animación en cuanto alcanza el período de "Relleno".</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Tenga en cuenta que también controlar una animación requiere que el guión gráfico sea accesible como una instancia en el código o con nombre.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Mediante el campo Compose de HandoffBehavior</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</source>
          <target state="translated">Al aplicar un <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> a una propiedad mediante el uso de la <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, cualquier <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de temporización no quita estos relojes automáticamente.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Para evitar problemas de rendimiento al aplicar un gran número de relojes mediante <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Hay varias maneras de quitar un reloj:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Para quitar todos los relojes de una propiedad, utilice la <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> método del objeto animado.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Especifique la propiedad que se está animada como el primer parámetro, y <ph id="ph1">`null`</ph> como el segundo.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">Esto quita todos los relojes de animación de la propiedad.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Para quitar un determinado <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> en una lista de relojes, use la <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> propiedad de la <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> para recuperar un <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, a continuación, llame a la <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> método de la <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Esto se hace normalmente en el <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> controlador de eventos para un reloj.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; el <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> propiedad de un reloj secundario devuelve <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Tenga en cuenta también que la <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> no se produce el evento si la duración efectiva del reloj es para siempre.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">En ese caso, el usuario debe determinar cuándo se debe llamar a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">Si un objeto se han recopilado, sus relojes también se desconectan y el recolector.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los objetos de reloj, consulte <bpt id="p1">[</bpt>animación y temporización información general del sistema<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Obtiene o establece el <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> que se usa para el elemento.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> que se usa para el elemento.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">Un <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> puede usarse para validar los valores de varias propiedades de un objeto.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">Por ejemplo, suponga que una aplicación solicita al usuario que escriba una dirección y, a continuación, rellena un objeto de tipo <ph id="ph1">`Address`</ph>, que tiene las propiedades <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, y <ph id="ph5">`Country`</ph>, con los valores que el usuario especificado.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">La aplicación tiene un panel que contiene cuatro <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controles, cada uno de los cuales se enlaza a una de las propiedades del objeto.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">Puede usar un <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> en un <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> para validar la <ph id="ph3">`Address`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> puede asegurarse de que el código postal es válido para el país de la dirección.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">Los elementos secundarios heredan la <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> de sus elementos principales, al igual que con cualquier otra propiedad heredable.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">Propiedades de metadatos establecidas <bpt id="p1">**</bpt>es true<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Intenta mostrar este elemento, en cualquier región desplazable que lo contenga.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>By calling this method, you effectively will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element (the parent may very well be a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, not a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</source>
          <target state="translated">Al llamar a este método, eficazmente llamará <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> en cualquier área desplazable primaria que contiene el elemento (el elemento primario puede ser muy bien un <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, no un <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</source>
          <target state="translated">Si este elemento no está contenida en un área desplazable, todavía se produce el evento, pero no habrá ningún efecto.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested via <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">Obtiene o establece el elemento de menú contextual que debería aparecer cuando se solicite el menú contextual a través de la <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> desde este elemento.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The context menu that this element uses.</source>
          <target state="translated">Menú contextual que este elemento utiliza.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The following example places a <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> on a <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">Los siguientes lugares de ejemplo un <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> en un <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">Se produce inmediatamente antes de que se cierre cualquier menú contextual en el elemento.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">Para suprimir el cierre menús contextuales, los controladores del evento deben marcarlo a como controlado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Para usar este evento como un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Se requiere este uso porque la implementación de eventos en <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> que expone el evento de servicio subyacente no se asignará correctamente el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identificador para su uso en desencadenadores).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">Propagación</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The following example implements a handler that changes the cursor over a named region <ph id="ph1">`DisplayArea`</ph> (not shown).</source>
          <target state="translated">En el ejemplo siguiente se implementa un controlador que cambia el cursor sobre un área denominada <ph id="ph1">`DisplayArea`</ph> (no se muestra).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The comment hints at a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> usage, but in fact this sample would be identical if <ph id="ph2">`DisplayArea`</ph> were a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Sugerencias de los comentarios en un <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> uso, pero en realidad este ejemplo sería idéntico si <ph id="ph2">`DisplayArea`</ph> eran un <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">Se produce cuando se abre cualquier menú contextual en el elemento.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Para abrir manualmente los menús contextuales, controladores de los eventos deben marcar el evento pertinente como controlado.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">En caso contrario, el valor existente de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> propiedad se utilizará para abrir automáticamente un menú contextual.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> propiedad y, a continuación, abra el nuevo <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">Sin embargo, hay un problema de tiempo que debe tener en cuenta.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">Para reemplazar completamente el menú contextual a través de un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> controlador, el menú contextual inicial no debe ser null o vacía.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">O bien, tendrá que controlar el evento y, a continuación, abrir manualmente un nuevo menú contextual.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Cómo: controlar el evento ContextMenuOpening<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Para usar este evento como un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Se requiere este uso porque la implementación de eventos en <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> que expone el evento de servicio subyacente no se asignará correctamente el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identificador para su uso en desencadenadores).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">Propagación</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">Obtiene o establece el cursor que aparecerá cuando el puntero del mouse se encuentre sobre este elemento.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">Cursor que se va a mostrar.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">El valor predeterminado se define como <ph id="ph1">&lt;see langword="null" /&gt;</ph> para esta propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">Sin embargo, el valor predeterminado en la práctica en tiempo de ejecución depende de diversos factores.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">Al establecer esta propiedad <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> procesador se basa en la conversión de tipos para la <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> clase para evaluar la cadena.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">La cadena proporcionada se debe evaluar como un <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> valor.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">Para obtener información más detallada, vea <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">Si el cursor según lo establecido por esta propiedad se o no se mostrará cuando el puntero del mouse está sobre este elemento también depende del valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">Además, las consideraciones relacionadas con el evento como un arrastre activo, captura del mouse, modos de controles y así sucesivamente, de edición de texto también afectará el cursor con prioridad más alta que el valor especificado en esta propiedad.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">Para revertir el comportamiento de establecer esta propiedad en el valor predeterminado eventual, establézcalo en <ph id="ph1">`null`</ph> nuevo.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated">El <ph id="ph1">`null`</ph> predeterminado en realidad significa que la determinación del valor de cursor viable se retarda aquí y debe obtenerse desde cualquier otro punto.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If presented with no programmatic values from any source, the default cursor over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">Si aparece sin valores mediante programación desde cualquier origen, el cursor predeterminado por un <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> aplicación será una flecha.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">Cada movimiento del mouse sobre un <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> aplicación genera una <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</source>
          <target state="translated">El evento se propaga y cualquier elemento en la ruta tiene la oportunidad de controlar el evento y para establecer el valor del cursor a través de los argumentos de este evento.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">Si esto sucede, el hecho de que el evento se controla y tenga un valor cambiado en los argumentos tiene prioridad sobre el valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> propiedad en cualquier nivel, a menos que <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> se establece.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If not creating a custom cursor, typically you set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">Si no crea un cursor personalizado, normalmente se establece esta propiedad en un valor de propiedad estática de la <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">Establecer el <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> no está habilitado en un valor personalizado en confianza parcial.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre los cursores personalizados, vea <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The following example sets the cursor to a custom value.</source>
          <target state="translated">En el ejemplo siguiente se establece el cursor en un valor personalizado.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">Obtiene o establece el contexto de datos para un elemento cuando participa en un enlace de datos.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">Objeto que se va a usar como contexto de datos.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>Contexto de datos<ept id="p1">*</ept> es un concepto que permite a los elementos heredar información de sus elementos principales sobre el origen de enlace que se usa para enlazar, así como otras características del enlace como la ruta de acceso.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">Contexto de datos se puede establecer directamente en un <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> objeto, con los enlaces que se evalúe como propiedades de ese objeto.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">Como alternativa, puede establecer el contexto de datos en un <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Esta propiedad de dependencia hereda los valores de propiedad.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Si hay elementos secundarios con ningún otro valor para <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> establecido a través de valores o estilos locales, el sistema de propiedad establecerá el valor sea el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> valor del elemento primario más próximo con este valor asignado.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">Como alternativa, puede usar una de las siguientes propiedades de la <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> clase para especificar explícitamente el origen de enlace: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, o <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Cómo: especificar el origen de enlace<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> is most commonly set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated">En <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> normalmente se establece como un <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaración.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">Puede usar la sintaxis de elemento de propiedad o la sintaxis de atributo.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">La sintaxis de atributo se muestra en el ejemplo de esta página.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can also set <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> in code.</source>
          <target state="translated">También puede establecer <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> en el código.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso de elementos de propiedad XAML</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">Un objeto directamente incrustado que actúa como contexto de datos para todos los enlaces dentro del elemento primario.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclass.</source>
          <target state="translated">Normalmente, este objeto es un <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> u otro <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclase.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">Como alternativa, los datos sin procesar de cualquier <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> diseñado para el enlace se puede colocar aquí, con los enlaces reales que defina más adelante el tipo de objeto.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">Uso de enlace que se evalúa como un contexto de datos adecuado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Binding (extensión de marcado)<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>One of the following: <ph id="ph1">`StaticResource`</ph>, or <ph id="ph2">`DynamicResource`</ph>.</source>
          <target state="translated">Uno de los siguientes: <ph id="ph1">`StaticResource`</ph>, o <ph id="ph2">`DynamicResource`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">Este uso se utiliza cuando se hace referencia a los datos sin procesar definidos como un objeto de recursos.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>recursos XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">El identificador de clave para el objeto que se solicita desde un <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">En el ejemplo siguiente se establece un enlace en un <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> elemento, creando un nuevo objeto de datos personalizados, establecer ese objeto como <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>y la configuración de la ruta de acceso de enlace a una propiedad dentro de ella.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>Occurs when this element's data context changes.</source>
          <target state="translated">Se produce cuando cambia el contexto de datos de este elemento.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Para obtener una explicación de los contextos de datos y el enlace de datos, vea <bpt id="p1">[</bpt>información general sobre el enlace de datos<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>When an element's <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">Cuando un elemento <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> cambios, todas las propiedades de enlace a datos en este elemento podrían verse afectados.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</source>
          <target state="translated">Esto se aplica a los elementos que son descendientes del elemento actual, que heredan el contexto de datos, y también el propio elemento actual.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>All such bindings re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> to reflect the new value in bindings.</source>
          <target state="translated">Todos los enlaces de este tipo vuelven a interpretan la nueva <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> para reflejar el nuevo valor en los enlaces.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>There is no guarantee made about the order of these changes relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">No hay ninguna garantía sobre el orden de estos cambios con respecto a la generación de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>The changes can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">Los cambios pueden producir antes el evento, después del evento, o en cualquier combinación.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Gets or sets the key to use to find the style template for this control in themes.</source>
          <target state="translated">Obtiene o establece la clave que se debe usar para buscar la plantilla de estilo de este control en los temas.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">La clave de estilo.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the element being styled.</source>
          <target state="translated">Se espera que este valor sea la clase <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> del elemento cuyo estilo se está creando para que funcione correctamente como parte de la búsqueda de estilo de tema.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is an accepted value for a certain case.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> es un valor aceptado para un caso determinado.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct setters.</source>
          <target state="translated">Esta propiedad no se establece normalmente a través de cualquiera de sus establecedores directos.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</source>
          <target state="translated">En su lugar, invalida los metadatos específicos del tipo de esta propiedad de dependencia cada vez que cree una nueva subclase.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>When you subclass, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control subclass.</source>
          <target state="translated">Cuando se deriva una subclase, llame a la <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> método con el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identificador dentro del constructor estático de la subclase de control.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>For instance, an inline class such as <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> actually has very little implementation beyond overriding the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadata in its static constructor, and exposing several instance constructors.</source>
          <target state="translated">Por ejemplo, una clase insertada como <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> realmente tiene muy poca implementación aparte de invalidar el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadatos en su constructor estático y exponer varios constructores de instancia.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The fact that elements surrounded by the <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tag gain a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> property of <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> is implemented within the theme style that was referenced by setting the default value of <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> to <ph id="ph5">`typeof(Bold)`</ph>.</source>
          <target state="translated">El hecho de que los elementos entre los <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> etiqueta ganancia un <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> propiedad de <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> se implementa en el estilo del tema que se hizo referencia al establecer el valor predeterminado de <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> a <ph id="ph5">`typeof(Bold)`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Si desea que el elemento o control no use deliberadamente estilos de tema, establezca la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> propiedad <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Called immediately after an element is initialized.</source>
          <target state="translated">Se llama inmediatamente después de que se inicialice un elemento.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</source>
          <target state="translated">Implemente este método para proporcionar un control especial que debe tener lugar cuando el elemento se inicialice durante el proceso de carga de elemento.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Su implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> event.</source>
          <target state="translated">Si <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> se ha llamado anteriormente, la base de implementación, se producirá la <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> eventos.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was called, the event is not raised.</source>
          <target state="translated">En caso contrario, si <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> no se llamó o no se pudo determinar si <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> era llama, el evento no se desencadena.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Name of the element to search for.</source>
          <target state="translated">Nombre del elemento que se va a buscar.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">Busca un elemento que tiene el nombre de identificador proporcionado.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">Elemento solicitado.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">Puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> si no se encontró ningún elemento coincidente.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>If this element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">Si este elemento tiene elementos secundarios, estos elementos secundarios son todas de forma recursiva búsqueda para el elemento con nombre solicitado.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The following example sets a property on an element found by name within a referenced <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> on a page.</source>
          <target state="translated">En el ejemplo siguiente se establece una propiedad en un elemento buscado por nombre dentro de una referencia <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> en una página.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Identificador de clave del recurso que se debe encontrar.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</source>
          <target state="translated">Busca un recurso con la clave especificada e inicia una excepción si no se encuentra el recurso solicitado.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching resource was found (but will also throw an exception if <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</source>
          <target state="translated">El recurso buscado o <ph id="ph1">&lt;see langword="null" /&gt;</ph> si no se encontró ningún recurso coincidente (pero también producirá una excepción si es <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">Si se llama a este método para una clave que no se encuentra, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions for this case, you should instead call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</source>
          <target state="translated">Si no desea controlar las excepciones producidas en este caso, se debe llamar en su lugar <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when no resource is found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> Devuelve <ph id="ph2">`null`</ph> cuando se encuentra ningún recurso y no produce una excepción.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</source>
          <target state="translated">Si no se encuentra el recurso en el elemento que realiza la llamada, se busca el árbol primario mediante el árbol lógico, de la misma manera que sería el árbol de la búsqueda si el recurso se solicitaron por clave en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">En el ejemplo siguiente se busca un recurso tal como se define en el marcado y lo aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The requested resource key was not found.</source>
          <target state="translated">No se encontró la clave de recurso solicitada.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">Obtiene o establece un objeto que habilita la personalización de apariencia, efectos u otras características de estilo que se aplicarán a este elemento cuando capture el foco del teclado.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">Estilo deseado que se aplicará en el foco.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado declarado en la propiedad de dependencia es un objeto <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph> estático vacío.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">Sin embargo, el valor efectivo en tiempo de ejecución suele ser (aunque no siempre) un estilo que la compatibilidad de tema proporciona para los controles.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</source>
          <target state="translated">Al establecer esta propiedad <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, estilos casi siempre se definen como un recurso, en lugar de en línea como un elemento, y normalmente es de recurso al que hace referencia como un <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Note that this property affects visual appearance but does not report so in metadata.</source>
          <target state="translated">Tenga en cuenta que esta propiedad afecta al aspecto visual pero no informa de esto en metadatos.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</source>
          <target state="translated">Esto es porque el cambio de apariencia visual está orientado a eventos y no se aplica en todo momento y, por tanto, no debe notificar generalmente de cualquier información visual o de diseño en los metadatos.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</source>
          <target state="translated">Conceptualmente, el comportamiento visual de foco aplicado a un control debe ser coherente de un elemento a.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">La manera más conveniente para exigir la coherencia es cambiar sólo el estilo visual del foco si está creando un tema completo.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">Al establecer esta propiedad en estilos individuales y no como parte de un tema, no es el uso previsto de esta propiedad, porque puede llevar a una experiencia de usuario confusa con respecto al foco de teclado.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">Si desea un comportamiento específico del elemento que, deliberadamente, no sea coherente en todo el tema, un enfoque mucho mejor es usar desencadenadores en los estilos para las propiedades de estado de entradas individuales, como <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>y para hacerlo de forma que no interfieran visualmente con cualquier estilo visual del foco existente.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre la intención de diseño de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> y alternativas centrarse propiedades, vea <bpt id="p1">[</bpt>aplicación de estilos para se centran en los controles y FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso de elementos de propiedad XAML</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">Uno de los siguientes:, o.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>recursos XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">La clave que identifica el estilo que se solicita.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">La clave hace referencia a un recurso existente en un <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>plantillas y estilos insertados<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Una referencia de enlace mediante o <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> también es posible, pero es poco común.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Gets or sets a value indicating whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by this instance's <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">Obtiene o establece un valor que indica si <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> debe forzar que la <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> represente el cursor declarado por la propiedad <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> de esta instancia.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para forzar la presentación del cursor mientras está sobre este elemento con el fin de usar la configuración de esta instancia para el cursor (incluso en todos los elementos secundarios); de lo contrario <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting this property to <ph id="ph1">`true`</ph> will override the cursor preferences established by child elements.</source>
          <target state="translated">Si se establece esta propiedad en <ph id="ph1">`true`</ph> invalidará las preferencias del cursor establecidas por los elementos secundarios.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">Al hacerlo así en general aplicación <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> puede resultar confuso para el usuario, especialmente si los elementos secundarios intentan especificar los cursores.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">Establecer <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> es más adecuado en escenarios de creación de subclases o la composición del control.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The following example forces the cursor while over the element.</source>
          <target state="translated">En el ejemplo siguiente se fuerza el cursor mientras se encuentra sobre el elemento.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> from which to get the binding.</source>
          <target state="translated">Objeto <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> de destino del que se obtiene el enlace.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> for the specified property's binding.</source>
          <target state="translated">Obtiene el objeto <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> para el enlace de la propiedad especificada.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target is data bound; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Devuelve <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> si el destino son los datos enlazados; de lo contrario, devuelve <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The following example retrieves a binding by querying a property.</source>
          <target state="translated">En el ejemplo siguiente se recupera un enlace consultando una propiedad.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">Devuelve a un elemento primario lógico alternativo para este elemento si no hay ningún elemento primario visual.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>In this case, a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> parent is always the same value as the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> property.</source>
          <target state="translated">En este caso, un elemento primario <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> tiene siempre el mismo valor que la propiedad <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">Devuelve un valor distinto de <ph id="ph1">&lt;see langword="null" /&gt;</ph> cada vez que una implementación de nivel de marco de WPF de este método tiene una conexión de elemento primario no visual.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>The default implementation returns the expected single visual parent.</source>
          <target state="translated">La implementación predeterminada devuelve al esperado único elemento primario visual.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Custom implementations might return alternate parent relationships.</source>
          <target state="translated">Las implementaciones personalizadas podrían devolver relaciones primarias alternativas.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is initialized.</source>
          <target state="translated">Se produce cuando se inicializa <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Este evento coincide con los casos donde el valor de la propiedad <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> cambia de <ph id="ph2">&lt;see langword="false" /&gt;</ph> (o no definida) a <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> methods are called.</source>
          <target state="translated">Este evento será genera cada vez que la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> se llaman a métodos.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Calls to these methods could have been made by deliberate code, or by the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> loading process.</source>
          <target state="translated">Llamadas a estos métodos pudieron haber realizado por código intencional o por el <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> proceso de carga.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece el contexto de entrada usado por este objeto <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">Ámbito de entrada, que modifica cómo se interpreta la entrada desde métodos de entrada alternativos.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="null" /&gt;</ph> (que tiene como resultado un control predeterminado de comandos).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Esta propiedad de dependencia hereda los valores de propiedad.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Si hay elementos secundarios con ningún otro valor para <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> establecido a través de valores o estilos locales, el sistema de propiedad establecerá el valor sea el <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> valor del elemento primario más próximo con este valor asignado.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">Aunque un <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> uso de sintaxis se muestra y se permite sintácticamente, establecer esta propiedad <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> no es muy común.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>Gets a value indicating whether this element has been initialized, either by being loaded as <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated">Obtiene un valor que indica si se ha inicializado este elemento, ya sea porque se ha cargado como <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> o porque se ha llamado explícitamente a su método <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned loading or method calls; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si las llamadas al método o la carga mencionados anteriormente inicializan el elemento; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">Esta propiedad también se pueden <ph id="ph1">`true`</ph> si este elemento se ha movido dentro del árbol de elementos, que tiene un nuevo elemento primario y, por lo tanto, se vuelve a cargar nuevo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>Gets a value indicating whether this element has been loaded for presentation.</source>
          <target state="translated">Obtiene un valor que indica si este elemento se ha cargado para la presentación.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree and has been rendered; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si el elemento actual está asociado a un árbol de elementos y se ha representado; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si el elemento nunca se ha asociado a un árbol de elementos cargado.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>From a newly constructed instance, this property starts off <ph id="ph1">`false`</ph>, and remains <ph id="ph2">`true`</ph> once it is set to <ph id="ph3">`true`</ph>, even if subsequently removed by  code.</source>
          <target state="translated">Desde una instancia recién construida, esta propiedad inicia <ph id="ph1">`false`</ph>y sigue siendo <ph id="ph2">`true`</ph> cuando se establece en <ph id="ph3">`true`</ph>, incluso si posteriormente se quitan mediante código.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>The following example code uses <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> as a conditional check to assure that a function <ph id="ph2">`displayData`</ph> (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</source>
          <target state="translated">El código de ejemplo siguiente usa <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> como una comprobación condicional para asegurarse de que una función <ph id="ph2">`displayData`</ph> (no mostrado) habrá elementos válidos cargado en la página para que funcione con, como parte de un controlador a petición.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>That same logic is run as an event handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</source>
          <target state="translated">Que la misma lógica se ejecuta como un controlador de eventos para <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an individual element.</source>
          <target state="translated">Obtiene o establece la información del idioma de localización o globalización que se aplica a un elemento individual.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The culture information for this element.</source>
          <target state="translated">Información de la referencia cultural de este elemento.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> instance with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">El valor predeterminado es una instancia de <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> con el valor <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> establecido en la cadena "en-US".</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">Los formatos de cadena siguen el estándar RFC 3066.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">Por ejemplo, EE. UU. Inglés es "en-US".</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> for more information on the values and format.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> para obtener más información sobre los valores y el formato.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Esta propiedad de dependencia hereda los valores de propiedad.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Si hay elementos secundarios con ningún otro valor para <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> establecido a través de valores o estilos locales, el sistema de propiedad establecerá el valor sea el <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> valor del elemento primario más próximo con este valor asignado.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">Se produce cuando el elemento se presenta, se representa y está listo para la interacción.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Dirigir los eventos enrutados admiten otro comportamiento de evento enrutado: admiten una colección de controladores accesible y se pueden usar como un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct</source>
          <target state="translated">Directa</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>Gets an enumerator for the logical child elements of this element.</source>
          <target state="translated">Obtiene un enumerador para los elementos secundarios lógicos de este elemento.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">Enumerador para los elementos secundarios lógicos de este elemento.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre cómo usar <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, consulte <bpt id="p1">[</bpt>árboles de WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">Dirección en la que se mueve el foco, como valor de la enumeración.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus from this element to another element.</source>
          <target state="translated">Mueve el foco del teclado de este elemento a otro elemento.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist.</source>
          <target state="translated">Devuelve <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se mueve el foco correctamente; <ph id="ph2">&lt;see langword="false" /&gt;</ph> si el elemento de destino no existe en la dirección especificada.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">Obtiene o establece el nombre de identificación del elemento.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">El nombre proporciona una referencia de la instancia para que el código subyacente de programación, por ejemplo el código de controlador de eventos, pueda hacer referencia a un elemento una vez construido durante el análisis de <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name of the element.</source>
          <target state="translated">Nombre del elemento.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The most common usage of this property is when specifying a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name in markup.</source>
          <target state="translated">El uso más común de esta propiedad es al especificar un <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> nombre del elemento de marcado.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">Básicamente, esta propiedad proporciona una propiedad de comodidad de nivel de marco WPF para establecer el <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>Directiva x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</source>
          <target state="translated">Obtener un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> desde el código no es común, porque si ya tiene la referencia adecuada en el código, simplemente puede llamar a métodos y propiedades en el elemento de referencia y generalmente no es necesario el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Una excepción es si la cadena tiene algún significado sobrecargado, por ejemplo si es útil mostrar el nombre en <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property will not change the object reference.</source>
          <target state="translated">Establecer un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> desde el código si la versión original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> era conjunto a partir de marcado también se recomienda no, y cambiar la propiedad no cambiará la referencia al objeto.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Such object references are created only when the underlying namescopes are explicitly created during <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> loading.</source>
          <target state="translated">Tales referencias de objeto se crean solo cuando los ámbitos de nombre subyacentes se crean explícitamente durante la <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> cargar.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> to make an effective change on the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">Debe llamar específicamente a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> para realizar un cambio efectivo en el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> propiedad de un elemento ya cargado.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from  code is important is for naming elements that storyboards will run against.</source>
          <target state="translated">Una notable es el caso de que el valor <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> desde el código es importante es para elementos de nomenclaturas que guiones gráficos will se ejecutarán.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">Para poder registrar un nombre, también deba crear una instancia y asignar un <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instancia.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Vea la sección ejemplo o <bpt id="p1">[</bpt>información general de guiones gráficos<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</source>
          <target state="translated">Establecer <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> de código tiene aplicaciones limitadas, pero buscar un elemento por su nombre es más común, especialmente si emplea un modelo de navegación donde se recargan las páginas en la aplicación y el código de tiempo de ejecución no es necesariamente el código subyacente de esa página respectiva.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in that element's logical tree recursively.</source>
          <target state="translated">El método de utilidad <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, que está disponible desde cualquier <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, puede buscar cualquier elemento por <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> de forma recursiva del árbol lógico de ese elemento.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">O bien puede usar el <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> método estático de <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, que también toma la <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> cadena como argumento.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Commonly used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Usadas elementos raíz (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> por ejemplo) implementan la interfaz <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">Las implementaciones de esta interfaz se deben exigir que los nombres sean inequívocos en su ámbito.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Proporciona datos sobre el evento.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Se invoca cada vez que el evento enrutado <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> llega a esta clase en su ruta.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente este método a fin de agregar el control de clases para este evento.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Este método no tiene ninguna implementación predeterminada.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Todavía debe llamar a la implementación base en caso de que una clase intermedia en la herencia ha implementado este método.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">El propósito de este método es algo similar a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">En este caso el evento correspondiente es un evento enrutado.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</source>
          <target state="translated">El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha generado el evento enrutado por un elemento secundario, no necesariamente el elemento que se va a invocar los controladores.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Por lo tanto, la implementación tendrá que tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Las subclases de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> puede llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Un escenario potencial es tomar los argumentos del evento y marcar deliberadamente el evento como administrado para acortar la ruta.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Datos del evento.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Se invoca cada vez que el evento enrutado <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> llega a esta clase en su ruta.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente este método a fin de agregar el control de clases para este evento.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Este método no tiene ninguna implementación predeterminada.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Todavía debe llamar a base() en caso de que una clase intermedia en la herencia ha implementado este método.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">El propósito de este método es algo similar a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">En este caso el evento correspondiente es un evento enrutado.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha generado el evento enrutado por un elemento secundario, no necesariamente el elemento que se va a invocar controladores, por lo que su implementación debe tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Las subclases de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> puede llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Un escenario potencial es tomar los argumentos del evento y marcar deliberadamente el evento como administrado para acortar la ruta.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Datos del evento.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Class handler for the <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated">Controlador de clases para el evento <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This class handler sets appropriate focus behavior on this element if the event originated from this element.</source>
          <target state="translated">Este controlador de clases establece el comportamiento de foco adecuado en este elemento si el evento se ha originado este elemento.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree, the handler does nothing.</source>
          <target state="translated">Si el origen del evento fuera otro elemento en el árbol, el controlador no hace nada.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Override this method in order to change these default focusing behavior on your element.</source>
          <target state="translated">Invalide este método para modificar el comportamiento de enfoque en el elemento predeterminado.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Datos del evento.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated">Genera el evento <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Este método se invoca siempre que <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> se establece en <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described earlier in this topic.</source>
          <target state="translated">La implementación predeterminada de este método virtual genera el evento como se describió anteriormente en este tema.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call base() to preserve this behavior.</source>
          <target state="translated">Las invalidaciones deben llamar a base () para conservar este comportamiento.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> property is read-only.</source>
          <target state="translated">Tenga en cuenta que el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> propiedad es de solo lectura.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Therefore, you cannot set it to force initialization behavior that way.</source>
          <target state="translated">Por lo tanto, no puede establecerlo para forzar el comportamiento de inicialización de este modo.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Initialization setting is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">Valor de inicialización está diseñada para realizarse únicamente por el <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, including the old and new values.</source>
          <target state="translated">Datos del evento que describen la propiedad que cambió, incluidos los valores antiguos y nuevos.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> has been updated.</source>
          <target state="translated">Se invoca cada vez que se actualiza el valor efectivo de una propiedad de dependencia de este control <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">Propiedad de dependencia concreta que cambió se notifica en el parámetro de argumentos.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated">Invalida <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">Este método no está pensado para detectar generalmente cambios de propiedad o invalidaciones.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">En su lugar, está diseñado para que las modificaciones del modelo de invalidación general si se conoce cierta información sobre amplias clasificaciones de propiedades.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">Este método se invoca posiblemente muchas veces durante la vida de un objeto.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">Por lo tanto, puede lograr un mejor rendimiento si invalida los metadatos de propiedades concretas y, a continuación, adjuntar <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> funciones para las propiedades individuales.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">Sin embargo, use este método si un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como el comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">Tenga en cuenta que hay una con el mismo nombre <ph id="ph1">`OnPropertyChanged`</ph> método con una firma diferente (el tipo de parámetro es <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) que pueden aparecer en una serie de clases.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated">Que <ph id="ph1">`OnPropertyChanged`</ph> se usa para las notificaciones del objeto de datos y forma parte del contrato para <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">Llame siempre a la implementación base, como la primera operación en la implementación.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">Si no es así, se deshabilitará significativamente toda la matriz <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> sistema de propiedades, lo que produce valores incorrectos que se notificarán.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">El estilo anterior.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">El nuevo estilo.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style that is in use on this element changes.</source>
          <target state="translated">Se invoca cuando cambia el estilo que está en uso en este elemento.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag noting the style changed condition.</source>
          <target state="translated">Este método tiene una implementación predeterminada que establece un marcador interno teniendo en cuenta la condición de estilo que ha cambiado.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Always call the base implementation, otherwise styles cannot be applied.</source>
          <target state="translated">Llame siempre a la implementación base, en caso contrario, no se puede aplicar estilos.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</source>
          <target state="translated">Escenarios para invalidar este método pueden incluir si la clase derivada tiene un selector de estilo especializadas o almacena en caché los valores de estilo.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Theme changes will potentially invoke this method.</source>
          <target state="translated">Cambios de tema podrían invocar este método.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Proporciona datos sobre el evento.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Se invoca cada vez que el evento enrutado <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> llega a esta clase en su ruta.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente este método a fin de agregar el control de clases para este evento.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Este método no tiene ninguna implementación predeterminada.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Todavía debe llamar a base() en caso de que una clase intermedia en la herencia ha implementado este método.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">El propósito de este método es algo similar a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">En este caso el evento correspondiente es un evento enrutado.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha generado el evento enrutado por un elemento secundario, no necesariamente el elemento que se va a invocar controladores, por lo que su implementación debe tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos).</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Las subclases de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> puede llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Un escenario potencial es tomar los argumentos del evento y marcar deliberadamente el evento como administrado para acortar la ruta.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Proporciona datos sobre el evento.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Se invoca cada vez que el evento enrutado <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> llega a esta clase en su ruta.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Implemente este método a fin de agregar el control de clases para este evento.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">Este método no tiene ninguna implementación predeterminada.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Todavía debe llamar a base() en caso de que una clase intermedia en la herencia ha implementado este método.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">El propósito de este método es algo similar a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">En este caso el evento correspondiente es un evento enrutado.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha generado el evento enrutado por un elemento secundario, no necesariamente el elemento que se va a invocar controladores, por lo que la implementación deberá tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Las subclases de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> puede llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Un escenario potencial es tomar los argumentos del evento y marcar deliberadamente el evento como administrado para acortar la ruta.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Gets or sets a value indicating whether this element incorporates style properties from theme styles.</source>
          <target state="translated">Obtiene o establece un valor que indica si este elemento incorpora las propiedades de estilo de los estilos de tema.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si este elemento no utiliza las propiedades de estilo de tema; todas las propiedades que originan un estilo provienen de los estilos de aplicación locales y las propiedades de estilo de tema no se aplican.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph> si primero se aplican los estilos de aplicación y, a continuación, se aplican los estilos de tema para las propiedades que no se establecieron específicamente en estilos de aplicación.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">El uso más común de esta propiedad es un uso indirecto dentro del establecedor de un estilo que se suministra un estilo con temas.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Gets the parent in the logical tree for this element.</source>
          <target state="translated">Obtiene el elemento primario del árbol lógico de este elemento.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The logical parent for this element.</source>
          <target state="translated">Elemento primario lógico de este elemento.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">Tenga en cuenta que el elemento primario lógico de un elemento puede cambiar según la funcionalidad de la aplicación, y mantener el valor de esta propiedad no reflejarán dicho cambio.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">Normalmente, debe obtener el valor inmediatamente antes de que lo necesite.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>árboles de WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> para obtener más información acerca de cómo recorrer árboles lógicos y los escenarios donde es adecuado al adoptar este enfoque hacia la detección del elemento.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">El sistema de propiedades vuelve a calcular potencialmente todos los valores de propiedad de un elemento cuando cambia de elemento primario, porque algunas propiedades heredan los valores a través del árbol lógico.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> que se aplica a los enlaces también pueden cambiar cuando los elementos cambian de elemento primario.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">Cambiar primario de un elemento solo se realiza normalmente mediante la manipulación de colecciones, mediante dedicado agregar o quitar métodos, o a través de establecer propiedades de contenido de elementos.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property values from the parent.</source>
          <target state="translated">El escenario más típico para usar el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> propiedad consiste en obtener una referencia y, a continuación, obtener diversos <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> valores de propiedad del elemento primario.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Para las plantillas, el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> de la plantilla finalmente será <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">Para obtener más allá de este punto y ampliar en el árbol lógico donde se aplica realmente la plantilla, utilice <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The following example checks to see whether the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is of a particular type.</source>
          <target state="translated">En el ejemplo siguiente se comprueba para ver si el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> de un <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> es de un tipo determinado.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">Dirección para la que se debe determinar un cambio de foco probable.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">Determina el elemento siguiente que recibiría el foco relativo a este elemento para una dirección de movimiento de foco proporcionada, pero realmente no mueve el foco.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">Este método está sellado y no se puede invalidar.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">Elemento siguiente al que el foco se movería si se atravesara el foco realmente.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">Puede devolver <ph id="ph1">&lt;see langword="null" /&gt;</ph> si el foco no se puede mover en relación con este elemento para la dirección proporcionada.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> es el método relacionado que realmente mueve el foco.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated">Especificó una de las direcciones siguientes en <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">Estas direcciones no son válidas para <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (pero son válidas para <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">Nombre que se debe usar para la asignación de objeto y nombre especificada.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">Objeto para la asignación.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated">Proporciona un descriptor de acceso que simplifica el acceso al método de registro <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">Este método es un método útil para llamar a <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">La implementación comprobará los elementos primarios sucesivos hasta que encuentra el aplicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementación, que se encuentra mediante la búsqueda de un elemento que implementa <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de los ámbitos de nombres, vea <bpt id="p1">[</bpt>ámbitos de nombres de XAML de WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">Una llamada a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> es necesario para enlazar correctamente los guiones gráficos de animación de aplicaciones cuando se crean en el código.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">Esto es porque una de la clave de guión gráfico propiedades, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, usa una búsqueda de nombre de tiempo de ejecución en lugar de poder tomar una referencia a un elemento de destino.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">Esto ocurre incluso si el elemento es accesible por referencia desde el código.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre por qué necesita registrar los nombres para los destinos de guión gráfico, vea <bpt id="p1">[</bpt>información general de guiones gráficos<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Animations for content elements are less common than animations on controls, the <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> concentrates on control scenarios.</source>
          <target state="translated">Las animaciones para los elementos de contenido son menos común que animaciones en los controles, el <bpt id="p1">[</bpt>información general de guiones gráficos<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> se concentra en escenarios de control.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">Elemento que se va a quitar.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Removes the specified element from the logical tree for this element.</source>
          <target state="translated">Quita el elemento especificado del árbol lógico de este elemento.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>This <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is mainly relevant for class deriving scenarios, when adding support for child collections.</source>
          <target state="translated">Esto <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> es principalmente relevante para la clase que deriva de escenarios, al agregar compatibilidad con las colecciones secundarias.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">La mayoría <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> en la <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> clase; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> en la <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> clase).</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</source>
          <target state="translated">Derivar de tales clases normalmente puede evitar cualquier necesidad de manipular directamente el árbol lógico.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Gets or sets the current locally-defined resource dictionary.</source>
          <target state="translated">Obtiene o establece el diccionario de recursos actuales definidos localmente.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The current locally-defined resources.</source>
          <target state="translated">Recursos actuales definidos localmente.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is a dictionary of resources, where resources within the dictionary are accessed by key.</source>
          <target state="translated">Éste es un diccionario de recursos, donde se tiene acceso a los recursos dentro del diccionario por clave.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">Los diccionarios de recursos que se pueden definir por completo o parcial en <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> normalmente se crean como un elemento de propiedad y suelen encontrarse en el elemento raíz de cualquier página individual o de la aplicación.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">Colocar el diccionario de recursos en este nivel resulta más fácil encontrar desde los elementos secundarios individuales de la página (o desde cualquier página, en el caso de la aplicación).</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">En la mayoría de los escenarios de aplicación, recomendamos que se defina estilos como elementos de objeto dentro de un diccionario de recursos, o se define como recursos externos para que el recurso de estilo completo pueda ser autónomo (este enfoque ayuda a separar diseñadores responsabilidades de responsabilidades del programador separando los archivos físicos que deben modificarse).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">Tenga en cuenta que esta propiedad devuelve el diccionario de recursos declarado directamente dentro de ese elemento.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">Esto es diferente que el proceso de búsqueda de recurso real, donde un elemento secundario puede tener acceso a cualquiera de los recursos definidos en cada elemento primario, buscar hacia arriba de forma recursiva.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">También puede hacer referencia a código desde dentro de la colección de recursos, pero tenga en cuenta que los recursos se crean en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> definitivamente no será accesible hasta después de <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> se genera mediante el elemento que declara el diccionario.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In fact, resources are parsed asynchronously, and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">De hecho, los recursos se analizan de forma asincrónica y ni siquiera el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> evento es una garantía de que puede hacer referencia a un <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> recurso definido.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">Por esta razón debe generalmente solo se acceder a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> define recursos como parte del código en tiempo de ejecución o a través de otra <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> técnicas como estilos o referencias de extensión de recursos para los valores de atributo.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Cuando tiene acceso a recursos a través del código, es básicamente equivalente a una referencia de <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove, or query resources from within the collection by using code.</source>
          <target state="translated">Subyacente <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> es compatible con los métodos necesarios para agregar, quitar o consultar recursos desde dentro de la colección mediante código.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> propiedad es configurable para admitir el escenario de reemplazar completamente la colección de recursos de un elemento que se va a ser un nuevo o diferente <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Tenga en cuenta que la <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxis que se muestra no incluyen un elemento para el <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">Este es un ejemplo de sintaxis de colección implícita; se puede omitir una etiqueta que representa el elemento de la colección.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">En su lugar, se especifican los elementos que se agregan como elementos a la colección.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Para obtener más información acerca de colecciones implícitas y <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, consulte <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Un caso donde un <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> todavía está especificada explícitamente como un elemento es si se introduce un diccionario combinado, en cuyo caso normalmente no hay ningún elemento secundario para que <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>combinado los diccionarios de recursos<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso de elementos de propiedad XAML</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">Uno o más elementos de objeto, cada uno de los cuales define un recurso.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Cada elemento de propiedad de recurso dentro de cada <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> debe tener un valor único para la <bpt id="p1">[</bpt>x: Key (directiva)<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, que actúa como clave única cuando se recuperan valores de la <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element.</source>
          <target state="translated">El ejemplo siguiente se establece un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> colección en un <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> elemento raíz.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> is a typical choice because it is one of the few <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> es una opción típica porque es una de las pocas ocasiones <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> clases que tengan sentido como un elemento raíz y los recursos se almacenan normalmente en la raíz de la página o en niveles aún más altos como en la aplicación.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">Asocia un enlace a este elemento para la propiedad de dependencia especificada.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the bound property.</source>
          <target state="translated">Identifica la propiedad enlazada.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">Nombre de la propiedad de origen o de la ruta de acceso a la propiedad que se va a usar para el enlace.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">Asocia un enlace a este elemento, basado en el nombre de propiedad de origen proporcionado como calificación de la ruta de acceso al origen de datos.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Registra las condiciones del enlace.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Este valor devuelto puede ser útil para la comprobación de errores.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">Este método es un método útil para llamar a <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, que pasa la instancia actual como el <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>y crea un nuevo <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> tomando como base proporcionado <ph id="ph4">`path`</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">Esta firma es más conveniente si va a establecer un enlace simple predeterminado.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">Si tiene que especificar ninguna propiedad de enlace para condiciones no predeterminadas o desea usar un <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> o <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, debe utilizar el <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> firma.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">En el ejemplo siguiente se establece un enlace en un <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> elemento, creando un nuevo objeto de datos personalizados, establecer ese objeto como <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>y la configuración de la ruta de acceso de enlace a una propiedad dentro de ella.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the bound property.</source>
          <target state="translated">Identifica la propiedad enlazada.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents a data binding.</source>
          <target state="translated">Representa un enlace de datos.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">Asocia un enlace a este elemento, basado en el objeto de enlace ofrecido.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Registra las condiciones del enlace.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Este valor devuelto puede ser útil para la comprobación de errores.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">Este método es un método útil para llamar a <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, que pasa la instancia actual como el <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> and setting the source to a newly built <ph id="ph3">`DateTime`</ph> object.</source>
          <target state="translated">En el ejemplo siguiente se establece un enlace en un <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> elemento, creando un nuevo <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> y establezca el origen en un recién creado <ph id="ph3">`DateTime`</ph> objeto.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">Propiedad a la que está enlazado el recurso.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">Nombre del recurso.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">Busca un recurso con el nombre especificado y establece en él una referencia de recurso para la propiedad especificada.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">Una referencia de recurso es similar al uso de un <bpt id="p1">[</bpt>extensión de marcado DynamicResource<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> en el marcado.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">La referencia de recurso crea una expresión interna que proporciona el valor de la propiedad especificada en diferido de tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">La expresión se evaluará volver a cada vez que el diccionario de recursos indica un valor cambiado a través de los eventos internos o cada vez que se cambia de elemento primario del elemento actual (un cambio de elemento primario cambiaría la ruta de acceso de búsqueda de diccionario).</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Devuelve un valor que indica si los procesos de serialización deben serializar el contenido de la propiedad <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> en las instancias de esta clase.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el valor de propiedad <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> debe serializarse; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> so long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">El valor devuelto será <ph id="ph1">`true`</ph> siempre y cuando hay al menos un recurso con clave local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Devuelve un valor que indica si los procesos de serialización deben serializar el contenido de la propiedad <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> en las instancias de esta clase.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el valor de propiedad <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> debe serializarse; en caso contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">El valor devuelto será <ph id="ph1">`true`</ph> si el <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> se establece localmente.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>Occurs when any associated data source participating in a binding on this element changes.</source>
          <target state="translated">Se produce cuando cambia cualquier origen de datos asociado que participa en un enlace en este elemento.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Este evento emerge la <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> eventos que se generan mediante cualquier <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> asociado a este elemento.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Gets or sets the style to be used by this element.</source>
          <target state="translated">Obtiene o establece el estilo que se va a usar por este elemento.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">Estilo aplicado, no predeterminado para el elemento, si está presente.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">En caso contrario, es <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado para un objeto <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> construido de forma predeterminada es <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">El estilo actual a menudo se proporciona mediante un estilo predeterminado de temas o de estilos que generalmente se aplican a los objetos de ese tipo por los recursos en el nivel de página o de aplicación (un estilo implícito).</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</source>
          <target state="translated">Esta propiedad no predeterminada establece o devuelve estilos (tema), sino que devuelve el estilo implícito o explícito.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</source>
          <target state="translated">En el caso de los estilos implícitos o explícitos, no importa si el estilo se puede obtener acceso como un recurso o se define localmente.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">Establecer los estilos tiene algunas restricciones.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">Puede restablecer todo el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> propiedad a una nueva <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> en cualquier momento, lo que forzará una recomposición del diseño.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">Sin embargo, tan pronto como un elemento cargado, coloca ese estilo en uso el <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> debe considerarse sellado.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">Intento de realizar un cambio en cualquier propiedad individual de un estilo en uso (como cualquier elemento dentro de la colección de <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) hace que se produzca una excepción.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">Un estilo que se define en el marcado se considera que están en uso en cuanto se carga desde un diccionario de recursos (para los recursos) o se carga la página se encuentra en (para los estilos insertados).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> es una propiedad de dependencia con prioridad especial.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">Establecida localmente estilo suele funciona con la prioridad más alta en el sistema de propiedades.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</source>
          <target state="translated">Si la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> es null en este momento, durante la carga el sistema de propiedades comprueba los estilos implícita como recursos definidos que especifican ese tipo.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">Si el estilo todavía es nulo después de este paso, a continuación, el estilo procede el estilo predeterminado (tema), pero el estilo predeterminado no se devuelve en la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> valor de propiedad.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">Uno de los siguientes:, o.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>recursos XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">La clave que identifica el estilo que se solicita.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">La clave hace referencia a un recurso existente en un <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">Vea <bpt id="p1">[</bpt>plantillas y estilos insertados<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Una referencia de enlace mediante o <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> también es posible, pero es poco común.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element and then references it as a resource as a specific style for a <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">El ejemplo siguiente se establece un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> colección en un <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> elemento raíz y, a continuación, hace referencia a él como un recurso como un estilo específico para una <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">Nombre de la propiedad de ambiente solicitada.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">Para obtener una descripción de este miembro, vea el método <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> está disponible; de lo contrario, es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este miembro es una implementación explícita de un miembro de interfaz.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated">Solo se puede utilizar cuando la instancia de <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> se convierte en una interfaz <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">Obtiene o establece un valor de objeto arbitrario que se puede usar para almacenar información personalizada sobre este elemento.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>The intended value.</source>
          <target state="translated">Valor deseado.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">Esta propiedad no tiene ningún valor predeterminado.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</source>
          <target state="translated">Esta propiedad es análoga a las propiedades de etiqueta en otros modelos de programación de Microsoft, como Visual Basic para aplicaciones o Windows Forms.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</source>
          <target state="translated">Está diseñado para proporcionar un lugar preexistente para almacenar información personalizada básica sobre cualquier elemento sin obligar a los programadores de aplicaciones para crear una subclase.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Because this property takes an object, you need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">Dado que esta propiedad toma un objeto, debe usar el uso de elementos de propiedad para establecer el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> propiedad en XAML a algo distinto de un objeto con un convertidor de tipos conocidos e integradas, como una cadena.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</source>
          <target state="translated">Objetos que se usan en este modo normalmente no están dentro de los espacios de nombres estándar de WPF y, por tanto, pueden requerir la asignación de espacio de nombres al espacio de nombres externo con el fin de introducirán como elementos XAML.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>Occurs when any associated target property participating in a binding on this element changes.</source>
          <target state="translated">Se produce cuando cambia cualquier propiedad de destino asociada que participa en un enlace de este elemento.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Este evento emerge la <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> eventos que se generan mediante cualquier <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> asociado a este elemento.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</source>
          <target state="translated">Normalmente, esto significa que el enlace en cuestión es un enlace bidireccional y que la propiedad de dependencia enlazada afirma una invalidación del valor de propiedad anterior por cualquier validación o esquema de almacenamiento en caché que admita la propiedad.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>The event arguments of this event will inform you which bound property was changed.</source>
          <target state="translated">Los argumentos de evento de este evento le informará de qué propiedad enlazada cambió.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">Obtiene una referencia a la plantilla primaria de este elemento.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">Esta propiedad no es relevante si el elemento no se creó mediante una plantilla.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">El elemento cuyo <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph> <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> produjo este elemento que se va a crear.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Este valor suele <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">Las plantillas son realmente objetos compartidos, donde el contenido de la plantilla se crea una sola vez.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">Por lo tanto, si obtiene una referencia de objeto a un elemento que proviene de una plantilla, es posible que el árbol lógico aparente no llega a la raíz de la página.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">Para conectar una referencia de plantilla al árbol lógico de la página, debe obtener el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> valor y continuar navegar por el árbol de elementos como desee.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> will frequently be <ph id="ph2">`null`</ph> for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> a menudo será <ph id="ph2">`null`</ph> para objetos comunes, porque si ha obtenido una referencia de objeto de una página en la aplicación a través de medios típicos, ese elemento probablemente no se creó desde una plantilla.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</source>
          <target state="translated">Casos donde <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> podría no ser <ph id="ph2">`null`</ph> incluye operaciones como la prueba de posicionamiento, eventos de control para ciertos eventos de entrada de bajo nivel, o para trabajar con los enumeradores, que pueden haber devuelto elementos proceden de las plantillas.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Obtiene o establece el objeto de información sobre herramientas que se muestra para este elemento en la <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">Objeto de información sobre herramientas.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Si el valor de esta propiedad es de tipo <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, a continuación, que es la información sobre herramientas que se utilizarán en la <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">Si el valor es de cualquier otro tipo, ese valor se usará como el <bpt id="p1">*</bpt>contenido<ept id="p1">*</ept> para un <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> proporcionado (generada) por el sistema.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a tool-tip.</source>
          <target state="translated">La clase de servicio proporciona las propiedades adjuntas que pueden usarse para personalizar aún más una información sobre herramientas.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">Uso de atributos XAML</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">Uso de elementos de propiedad XAML</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">Valores XAML</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">Una cadena que se convierte en el texto para mostrar el <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</source>
          <target state="translated">Algún objeto, proporcionado en el formulario de elemento de objeto, que debe usarse como el contenido de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">Por lo general, esto sería un <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> o algún otro elemento que crea la composición de diseño para el <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, que finalmente contiene contenido de texto dentro de la composición.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">En este uso, el <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> elemento se crea implícitamente desde el objeto analizado <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>y el <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> contenido está establecido como su <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> propiedad.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> ... / &gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">Vea <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">Información sobre propiedades de dependencia</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Propiedades de metadatos establecidos en <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>None</source>
          <target state="translated">None</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The following example sets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property directly to a string.</source>
          <target state="translated">En el ejemplo siguiente se establece el valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> propiedad directamente en una cadena.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">Se produce inmediatamente antes de que se cierre cualquier información sobre herramientas en el elemento.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>To suppress closing the tooltip, handlers of the event should mark it as handled.</source>
          <target state="translated">Para suprimir el cierre de la información sobre herramientas, los controladores del evento deben marcarlo a como controlado.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Este evento no puede ser un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Esto es porque el campo de identificador de este evento vuelve a utiliza una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">Directa</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">Se produce cuando se abre cualquier información sobre herramientas en el elemento.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>To manually open tooltips, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Para abrir manualmente la información sobre herramientas, controladores de los eventos deben marcar el evento pertinente como controlado.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Otherwise, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">En caso contrario, el valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> propiedad se utilizará para abrir automáticamente un menú contextual.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> propiedad y, a continuación, abra el nuevo <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Note that this event will not be raised if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> is a null reference or otherwise unset.</source>
          <target state="translated">Tenga en cuenta que este evento no se producen si <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> es una referencia nula o de otro modo sin establecer.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Este evento no puede ser un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Esto es porque el campo de identificador de este evento vuelve a utiliza una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">Directa</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated">Identifica la propiedad de dependencia <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Identificador de clave del recurso que se debe encontrar.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">Busca un recurso con la clave especificada y lo devuelve si lo encuentra.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The found resource.</source>
          <target state="translated">Recurso encontrado.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If no resource was found, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Si no se encuentra ningún recurso, se devuelve <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</source>
          <target state="translated">Si no se encuentra el recurso en el elemento que realiza la llamada, se busca en el árbol primario mediante el árbol lógico, de la misma manera que el árbol se buscan si se solicitara una referencia de recurso dinámico por clave en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> método tiene un comportamiento similar, salvo que iniciará una excepción en el caso de no encontrar un recurso con la clave proporcionada.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">En el ejemplo siguiente se busca un recurso tal como se define en el marcado y lo aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Occurs when the element is removed from an element tree of loaded elements.</source>
          <target state="translated">Se produce cuando el elemento se quita desde un árbol de elementos cargados.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Dirigir los eventos enrutados admiten otro comportamiento de evento enrutado: admiten una colección de controladores accesible y se pueden usar como un <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> en un estilo.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">Información sobre eventos enrutados</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">Campo identificador</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">Estrategia de enrutamiento</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct</source>
          <target state="translated">Directa</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">delegado</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Identifica la <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>información general de eventos enrutados<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) y, a continuación, se puede utilizar para agregar controladores de clases (vea <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios del evento.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">Nombre del par de objeto y nombre que se debe quitar del ámbito actual.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated">Simplifica el acceso al método de anulación de registro de <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">Basta con nombres de anular el registro si va a volver a registrar otro elemento con el mismo nombre.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Vuelve a aplicar el estilo predeterminado al <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> actual.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>