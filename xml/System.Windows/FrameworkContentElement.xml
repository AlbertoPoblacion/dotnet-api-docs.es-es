<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e289eb77e4ff85ab443d61345dc83cbcff35de7" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52733387" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> es la implementación de nivel de marco de WPF y la expansión de la clase base <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> agrega compatibilidad para las API de entrada adicionales (incluye información sobre herramientas y menús contextuales), guiones gráficos, el contexto de datos para el enlace de datos, la compatibilidad de estilos y las API del asistente del árbol lógico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> aún no define su propio comportamiento de representación; creación de instancias reales <xref:System.Windows.FrameworkContentElement> instancia de la clase en código o marcado es posible, pero no muestra nada en una [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicación [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Lógica de representación debe proporcionarse mediante las clases que toman <xref:System.Windows.FrameworkContentElement> elementos secundarios como parte de su modelo de contenido, o en <xref:System.Windows.FrameworkContentElement> las clases derivadas.  
  
 <xref:System.Windows.FrameworkContentElement> muchos de los mismos es semejante deliberadamente [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] como <xref:System.Windows.FrameworkElement>. Tenga en cuenta que ciertos [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] se encuentra en <xref:System.Windows.FrameworkElement> no tendrán un <xref:System.Windows.FrameworkContentElement> equivalente. Algunos de los <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] tienen funcionalidad como la representación de geometría o de diseño, que no son relevantes para un <xref:System.Windows.FrameworkContentElement>.  
  
 La mayoría de los existentes <xref:System.Windows.FrameworkContentElement> las clases derivadas se encuentra en la <xref:System.Windows.Documents> espacio de nombres. Muchas de estas clases derivadas implementan elementos para el modelo de documentos dinámicos. Ciertas clases derivadas como <xref:System.Windows.Documents.Hyperlink> tiene algunas funcionalidades tipo control, pero se derivan <xref:System.Windows.FrameworkContentElement> tal que los elementos de tipo de control pueden participar en el modelo de documentos dinámicos.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Elemento secundario que se va a agregar.</param>
        <summary>Agrega el elemento proporcionado como elemento secundario de este elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método puede producir una excepción si se llama a la vez cuando el árbol lógico es que se recorre en otro proceso.  
  
 La mayoría <xref:System.Windows.FrameworkContentElement> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <xref:System.Windows.Documents.Span.Inlines%2A> en el <xref:System.Windows.Documents.Span> clase; <xref:System.Windows.Documents.Section.Blocks%2A> en el <xref:System.Windows.Documents.Section> clase). Normalmente, puede evitar cualquier necesidad de manipular directamente el árbol lógico si deriva de estas clases en su lugar. Trabajar con el árbol lógico para elementos de contenido es un escenario avanzado que puede requerir un analizador especializado o un especializado <xref:System.Windows.FrameworkElement> que actúa como el elemento de representación primario (host de contenido).  
  
 Para obtener más información sobre cómo usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> y <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se llama antes de inicializar un elemento.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Invalide este método para proporcionar un control especial que debe producirse antes de que el elemento se inicializa durante el proceso de carga.  
  
La implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.  
  
La implementación base producirá una excepción si <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> se llama más de una vez en el mismo elemento antes de llegar a <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">El guión gráfico para comenzar.</param>
        <summary>Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno". Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez. Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">El guión gráfico para comenzar.</param>
        <param name="handoffBehavior">Un valor de enumeración que describe el comportamiento que se utiliza si ya está animada una propiedad descrita en el guión gráfico.</param>
        <summary>Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con opciones especificadas para lo que debería ocurrir si la propiedad ya está animada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno". Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez. Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el uso de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de control de tiempo no no quita automáticamente los relojes.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante el uso de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj:  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> evento no se produce si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">El guión gráfico para comenzar.</param>
        <param name="handoffBehavior">Valor de la enumeración que describe el comportamiento que se va a usar si ya está animada una propiedad descrita en el guión gráfico.</param>
        <param name="isControllable">Declara si la animación se puede controlar (se puede pausar) después de iniciarse.</param>
        <summary>Comienza la secuencia de acciones contenidas en el guión gráfico proporcionado, con el estado especificado para el control de la animación una vez que se inició.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para las firmas que no usan el `isControllable`, parámetro, o cuando se especifica ese parámetro `false`, se quitan los relojes de escala de tiempo asociados con la animación en cuanto alcanza el período de "Relleno". Por lo tanto, la animación no se puede reiniciar después de que se va a ejecutar una vez. Tenga en cuenta que controlar una animación también requiere que el guión gráfico con nombre o accesible como una instancia en el código.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mediante el campo Compose de HandoffBehavior  
 Al aplicar un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, o <xref:System.Windows.Media.Animation.AnimationClock> a una propiedad mediante el uso de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, cualquier <xref:System.Windows.Media.Animation.Clock> objetos asociados anteriormente a esa propiedad siguen consumiendo recursos del sistema; el sistema de control de tiempo no no quita estos relojes automáticamente.  
  
 Para evitar problemas de rendimiento cuando aplique muchos relojes mediante el uso de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, debe quitar los relojes de composición de la propiedad animada cuando se hayan completado. Hay varias formas de quitar un reloj:  
  
-   Para quitar todos los relojes de una propiedad, utilice el <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método del objeto animado. Especifique la propiedad animada como primer parámetro, y `null` como el segundo. Esto quita todos los relojes de animación de la propiedad.  
  
-   Para quitar un determinado <xref:System.Windows.Media.Animation.AnimationClock> desde una lista de relojes, utilice la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propiedad de la <xref:System.Windows.Media.Animation.AnimationClock> para recuperar un <xref:System.Windows.Media.Animation.ClockController>, a continuación, llame a la <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método de la <xref:System.Windows.Media.Animation.ClockController>. Esto se hace normalmente el <xref:System.Windows.Media.Animation.Clock.Completed> controlador de eventos de un reloj. Tenga en cuenta que los relojes de raíz única pueden controlarse mediante una <xref:System.Windows.Media.Animation.ClockController>; el <xref:System.Windows.Media.Animation.Clock.Controller%2A> devuelve la propiedad de un reloj secundario `null`. Tenga en cuenta también que el <xref:System.Windows.Media.Animation.Clock.Completed> evento no se produce si la duración efectiva del reloj es para siempre.  En ese caso, el usuario debe determinar cuándo llamar a <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Este problema se produce principalmente en las animaciones de objetos que tienen un período de duración prolongado.  Cuando un objeto se recolecta, sus relojes también se desconectan y el recolector.  
  
 Para obtener más información acerca de los objetos de reloj, consulte [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="T:System.Windows.Data.BindingGroup" /> que se usa para el elemento.</summary>
        <value>El <see cref="T:System.Windows.Data.BindingGroup" /> que se usa para el elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Data.BindingGroup> puede usarse para validar los valores de varias propiedades de un objeto. Por ejemplo, suponga que una aplicación solicita al usuario que escriba una dirección y, a continuación, rellena un objeto de tipo `Address`, que tiene las propiedades `Street`, `City`, `ZipCode`, y `Country`, con los valores que el usuario proporcionado. La aplicación tiene un panel que contiene cuatro <xref:System.Windows.Controls.TextBox> controles, cada uno de los cuales está enlazado a una de las propiedades del objeto. Puede usar un <xref:System.Windows.Controls.ValidationRule> en un <xref:System.Windows.Data.BindingGroup> para validar la `Address` objeto. Por ejemplo, el <xref:System.Windows.Controls.ValidationRule> puede asegurarse de que el código postal es válido para el país de la dirección.  
  
 Los elementos secundarios heredan la <xref:System.Windows.Data.BindingGroup> de sus elementos primarios, al igual que con cualquier otra propiedad heredable.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Intenta mostrar este elemento, en cualquier región desplazable que está dentro de.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al llamar a este método, de hecho a <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> en cualquier área desplazable primaria que contiene el elemento (el elemento primario puede ser muy bien un <xref:System.Windows.FrameworkElement>, no un <xref:System.Windows.FrameworkContentElement>). Si este elemento no está contenida en un área desplazable, todavía se provoca el evento, pero no habrá ningún efecto.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Cómo: crear un control ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el elemento de menú contextual que debería aparecer cuando se solicita el menú contextual a través de [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] desde dentro de este elemento.</summary>
        <value>El menú contextual que usa este elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
   
  
## Examples  
 Los siguientes lugares de ejemplo una <xref:System.Windows.Controls.ContextMenu> en un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce justo antes de cerrar cualquier menú contextual en el elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para suprimir el cierre menús contextuales, los controladores del evento deben marcará como controlado.  
  
 Para usar este evento como un <xref:System.Windows.EventTrigger> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Este uso es necesario porque la implementación de eventos en <xref:System.Windows.FrameworkContentElement> que expone el evento de servicio subyacente no asigna correctamente el <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificador para su uso en desencadenadores).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 El ejemplo siguiente implementa un controlador que cambia el cursor sobre una región con nombre `DisplayArea` (no mostrado). El comentario de forma sugerente un <xref:System.Windows.UIElement> uso, pero en realidad en este ejemplo sería idéntico si `DisplayArea` eran un <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se abre cualquier menú contextual en el elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para abrir manualmente los menús contextuales, controladores de los eventos deben marcar el evento pertinente como controlado. En caso contrario, el valor existente de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propiedad se usará para abrir automáticamente un menú contextual. Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propiedad y, a continuación, abra el nuevo <xref:System.Windows.Controls.ContextMenu>. Sin embargo, hay un problema de tiempo que debe tener en cuenta. Para reemplazar completamente el menú contextual a través de un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> controlador, el menú contextual inicial no debe ser null o están vacías. Como alternativa, deberá controlar el evento y, a continuación, abra manualmente un nuevo menú contextual. Para obtener más información, consulte [Cómo: controlar el evento ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Para usar este evento como un <xref:System.Windows.EventTrigger> en un estilo, debe hacer referencia el identificador de evento de servicio subyacente:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Este uso es necesario porque la implementación de eventos en <xref:System.Windows.FrameworkContentElement> que expone el evento de servicio subyacente no asigna correctamente el <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificador para su uso en desencadenadores).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el cursor que aparecerá cuando el puntero del mouse se encuentre sobre este elemento.</summary>
        <value>Cursor que se va a mostrar. El valor predeterminado se define como <see langword="null" /> por esta propiedad de dependencia. Sin embargo, el valor predeterminado en la práctica en tiempo de ejecución depende de diversos factores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] procesador se basa en la conversión de tipos para el <xref:System.Windows.Input.Cursor> clase para evaluar la cadena. La cadena proporcionada se debe evaluar como un <xref:System.Windows.Input.CursorType> valor. Para obtener información más detallada, vea <xref:System.Windows.Input.Cursor>.  
  
 Si el cursor según lo establecido por esta propiedad se o no se mostrará cuando el puntero del mouse está sobre este elemento también es dependiente del valor de la <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> propiedad. Además, las consideraciones relacionadas con eventos como un arrastre activo, la captura del mouse, modos dentro de los controles etc., de edición de texto también afectará el cursor con prioridad más alta que el valor especificado en esta propiedad.  
  
 Para revertir el comportamiento de establecer esta propiedad en el valor predeterminado eventual, establézcalo en `null` nuevo.  
  
 El `null` predeterminado realmente significa que determinación del valor de cursor viable se aplaza aquí y debe obtenerse desde cualquier parte. Si aparece sin valores de cualquier origen, el cursor predeterminado mediante programación a través de un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] aplicación será una flecha.  
  
 Cada movimiento del mouse sobre un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] aplicación genera un <xref:System.Windows.ContentElement.QueryCursor> eventos. El evento se propaga y cualquier elemento en la ruta tiene la oportunidad de controlar el evento y establecer el valor del cursor a través de los argumentos de este evento. Si esto sucede, el hecho de que el evento se controla y tiene un valor modificado en los argumentos tiene prioridad sobre el valor de la <xref:System.Windows.FrameworkContentElement.Cursor%2A> propiedad en cualquier nivel, a menos que <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> está establecido.  
  
 Si no crea un cursor personalizado, normalmente se establece esta propiedad en un valor de propiedad estática de la <xref:System.Windows.Input.Cursors> clase.  
  
 Establecer el <xref:System.Windows.Input.Cursor> en un valor personalizado no está habilitado en confianza parcial. Para obtener más información sobre los cursores personalizados, vea [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
   
  
## Examples  
 El ejemplo siguiente establece el cursor en un valor personalizado.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contexto de datos para un elemento cuando participa en un enlace de datos.</summary>
        <value>Objeto que se va a usar como contexto de datos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Contexto de datos* es un concepto que permite que los elementos heredar información de sus elementos primarios sobre el origen de enlace que se usa para el enlace, así como otras características del enlace, como la ruta de acceso.  
  
 Contexto de datos se puede establecer directamente en un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objeto, con los enlaces que se evalúe como propiedades de ese objeto. Como alternativa, puede establecer el contexto de datos en un <xref:System.Windows.Data.DataSourceProvider> objeto.  
  
 Esta propiedad de dependencia hereda los valores de propiedad. Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkContentElement.DataContext%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkContentElement.DataContext%2A> valor del elemento primario más cercano con este valor asignado.  
  
 Como alternativa, puede usar una de las siguientes propiedades de la <xref:System.Windows.Data.Binding> clase para especificar explícitamente el origen de enlace: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, o <xref:System.Windows.Data.Binding.RelativeSource%2A>. Para obtener más información, consulte [Cómo: especificar el origen de enlace](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 En [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> con más frecuencia se establece como un <xref:System.Windows.Data.Binding> declaración. Puede usar la sintaxis de elemento de propiedad o la sintaxis de atributo. Sintaxis de atributo se muestra en el ejemplo de esta página. También puede establecer <xref:System.Windows.FrameworkContentElement.DataContext%2A> en el código.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Uso de elementos de propiedad XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *dataContextObject*  
 Un objeto directamente incrustado que actúa como contexto de datos para todos los enlaces dentro del elemento primario. Normalmente, este objeto es un <xref:System.Windows.Data.Binding> u otro <xref:System.Windows.Data.BindingBase> subclase. Como alternativa, los datos sin procesar de cualquier [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] diseñado para el enlace se puede colocar aquí, con los enlaces reales definidos después del tipo de objeto.  
  
 *bindingUsage*  
 Uso de enlace que se evalúa como un contexto de datos adecuado. Para obtener más información, consulte [Binding (extensión de marcado)](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *ResourceExtension*  
 Uno de los siguientes: `StaticResource`, o `DynamicResource`. Esto se usa cuando se hace referencia a datos sin procesar que se define como un objeto en los recursos. Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 El identificador de clave para el objeto que se solicita desde un <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo objeto de datos personalizado, Establece el objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>y establecer la ruta de acceso de enlace a una propiedad dentro de él.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el contexto de datos de este elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una explicación de los contextos de datos y el enlace de datos, vea [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Cuando un elemento <xref:System.Windows.FrameworkContentElement.DataContext%2A> cambios, todas las propiedades enlazadas a datos de este elemento podrían verse afectados. Esto se aplica a los elementos que son descendientes del elemento actual, que heredan el contexto de datos, y también el propio elemento actual. Todos los enlaces de este tipo, volver a interpretan el nuevo <xref:System.Windows.FrameworkContentElement.DataContext%2A> para reflejar el nuevo valor en los enlaces. No hay ninguna garantía sobre el orden de estos cambios con respecto a la generación de la <xref:System.Windows.FrameworkContentElement.DataContextChanged> eventos.  Los cambios pueden producir antes del evento, después del evento, o ambos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la clave que se usará para buscar la plantilla de estilo de este control en los temas.</summary>
        <value>La clave de estilo. Para que funcione correctamente como parte de la búsqueda de estilo de tema, se espera que este valor sea el <see cref="T:System.Type" /> del elemento que se va a un estilo. <see langword="null" /> es un valor aceptado para un caso determinado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad no se establece normalmente a través de cualquiera de sus establecedores directos. En su lugar, invalida los metadatos específicos del tipo de esta propiedad de dependencia cada vez que crea una nueva subclase. Cuando se subclase, llame a la <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> método con el <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificador dentro del constructor estático de la subclase de control.  
  
 Por ejemplo, una clase insertada como <xref:System.Windows.Documents.Bold> realmente no tiene una implementación muy poco más allá de reemplazar el <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadatos en su constructor estático y exponer varios constructores de instancia. El hecho de que los elementos rodeados por el <xref:System.Windows.Documents.Bold> etiqueta ganancia un <xref:System.Windows.Documents.TextElement.FontWeight%2A> propiedad de <xref:System.Windows.FontWeights.Bold%2A> se implementa dentro del estilo de tema que se hizo referencia estableciendo el valor predeterminado de <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> a `typeof(Bold)`.  
  
 Si desea que el elemento o el control no use deliberadamente estilos de tema, establezca el <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> propiedad `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se llama inmediatamente después de que se inicialice un elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implemente este método para proporcionar un control especial que debe producirse cuando el elemento se inicializa durante el proceso de carga.  
  
 La implementación debe llamar a la implementación base, porque la implementación base (valor predeterminado) establece algunos marcadores internos para realizar un seguimiento de la inicialización.  
  
 Si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> se llamaba anteriormente, la base de implementación, se producirá la <xref:System.Windows.FrameworkContentElement.Initialized> eventos. En caso contrario, si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> no se llamó al o no se pudo determinar si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> era llama, el evento no se genera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del elemento que se va a buscar.</param>
        <summary>Busca un elemento que tiene el nombre de identificador proporcionado.</summary>
        <returns>Elemento solicitado. Puede ser <see langword="null" /> si no se encontró ningún elemento coincidente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este elemento tiene elementos secundarios, estos elementos secundarios son todos buscada de forma recursiva el elemento con nombre solicitado.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece una propiedad en un elemento se encuentra por nombre dentro de una referencia <xref:System.Windows.Documents.FlowDocument> en una página.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificador de clave del recurso que se debe encontrar.</param>
        <summary>Busca un recurso con la clave especificada e inicia una excepción si no se encuentra el recurso solicitado.</summary>
        <returns>Recurso encontrado, o <see langword="null" /> si no se encontró ningún recurso coincidente (pero también se iniciará una excepción si <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Si se llama a este método para una clave que no se encuentra, se produce una excepción. Si no desea controlar las excepciones para este caso, debe llamar en su lugar <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Devuelve `null` cuando se encuentra ningún recurso y no produce una excepción.  
  
 Si no se encuentra el recurso en el elemento que realiza la llamada, se busca en el árbol primario mediante el árbol lógico, de la misma manera que sería el árbol se solicitaron si busca un recurso por clave en tiempo de ejecución.  
  
 Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.  
  
   
  
## Examples  
 El ejemplo siguiente busca un recurso, tal como se define en el marcado y aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">No se encontró la clave de recurso solicitada.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="resourceKey" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto que habilita la personalización de apariencia, efectos u otras características de estilo que se aplicarán a este elemento cuando capture el foco del teclado.</summary>
        <value>Estilo deseado que se aplicará en el foco. El valor predeterminado declarado en la propiedad de dependencia es un elemento <see cref="T:System.Windows.Style" /> vacío estático. Sin embargo, el valor efectivo en tiempo de ejecución suele ser (aunque no siempre) un estilo que la compatibilidad de tema proporciona para los controles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]estilos casi siempre se definen como un recurso, en lugar de en línea como un elemento y que suele recurso al que hace referencia como un <xref:System.Windows.StaticResourceExtension>.  
  
 Tenga en cuenta que esta propiedad afecta a la apariencia visual, pero no lo notifica en los metadatos. Esto es porque el cambio de apariencia visual está controlada por eventos y no se puede aplicar en todo momento y, por tanto, no debe notificar generalmente de cualquier información visual o de diseño en los metadatos.  
  
 Conceptualmente, el comportamiento visual de foco aplicado a un control debe ser coherente desde un elemento a otro. La manera más conveniente para exigir la coherencia es cambiar sólo el estilo visual de foco si se está creando un tema completo. Establecer esta propiedad en estilos individuales y no como parte de un tema no es el uso previsto de esta propiedad, porque puede llevar a una experiencia de usuario confusa con respecto al foco de teclado. Si desea un comportamiento específico del elemento que deliberadamente no sea coherente en un tema, un enfoque mucho mejor es usar desencadenadores en estilos para las propiedades de estado de entrada individuales, como <xref:System.Windows.UIElement.IsFocused%2A> o <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>y hacerlo de manera que no lo hace visualmente, interferir con cualquier estilo visual de foco existente. Para obtener más información sobre la intención de diseño <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> y alternativas centrarse en las propiedades, vea [aplicar estilo a controles y FocusVisualStyle foco](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Uso de elementos de propiedad XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *ResourceExtension*  
 Uno de los siguientes:, o. Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clave que identifica el estilo que se solicita. La clave hace referencia a un recurso existente en un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda. Consulte [plantillas y estilos alineados](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Una referencia de enlace mediante o <xref:System.Windows.Data.Binding> también es posible, pero es poco común.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si este <see cref="T:System.Windows.FrameworkContentElement" /> debería forzar el [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] represente el cursor declarado por esta instancia <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> propiedad.</summary>
        <value><see langword="true" /> Para forzar la presentación del cursor mientras está sobre este elemento para usar esta instancia de la configuración para el cursor (incluidos todos los elementos secundarios); en caso contrario <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer esta propiedad en `true` invalidará las preferencias del cursor establecidas por los elementos secundarios. Al hacerlo así que en general aplicación [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] puede resultar confuso para el usuario, especialmente si los elementos secundarios se intentan especificar cursores. Establecer <xref:System.Windows.FrameworkElement.ForceCursor%2A> es más adecuado en escenarios de composición o de creación de subclases de control.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
   
  
## Examples  
 El ejemplo siguiente fuerza el cursor mientras está sobre el elemento.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">El destino <see cref="T:System.Windows.DependencyProperty" /> desde que se va a obtener el enlace.</param>
        <summary>Obtiene el <see cref="T:System.Windows.Data.BindingExpression" /> para el enlace de la propiedad especificada.</summary>
        <returns>Devuelve un <see cref="T:System.Windows.Data.BindingExpression" /> si el destino está enlazado a datos; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente recupera un enlace consultando una propiedad.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve a un elemento primario lógico alternativo para este elemento si no hay ningún elemento primario visual. En este caso, un <see cref="T:System.Windows.FrameworkContentElement" /> primario es siempre el mismo valor que el <see cref="P:System.Windows.FrameworkContentElement.Parent" /> propiedad.</summary>
        <returns>Devuelve un valor distinto de <see langword="null" /> cada vez que una implementación de nivel de marco de WPF de este método tiene una conexión de elemento primario no visual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve al esperado único elemento primario visual. Las implementaciones personalizadas podrían devolver relaciones primarias alternativas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando este <see cref="T:System.Windows.FrameworkContentElement" /> se ha inicializado. Esto coincide con los casos donde el valor de la <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> propiedad cambia de <see langword="false" /> (o sin definir) a <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Será este evento se provoca cuando la <xref:System.Windows.FrameworkContentElement.EndInit%2A> o <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> se llama a métodos. Las llamadas a estos métodos podrían haber realizado mediante código intencional o a través del [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] proceso de carga.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el contexto de la entrada usada por este elemento <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Ámbito de entrada, que modifica cómo se interpreta la entrada desde métodos de entrada alternativos. El valor predeterminado es <see langword="null" /> (que da como resultado el control predeterminado de comandos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad de dependencia hereda los valores de propiedad. Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkElement.InputScope%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkElement.InputScope%2A> valor del elemento primario más cercano con este valor asignado.  
  
 Aunque un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] el uso de sintaxis se muestra y se permite sintácticamente, establecer esta propiedad [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] no es habitual.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se ha inicializado este elemento, ya sea porque se ha cargado como [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], o por tener explícitamente su <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> método llamado.</summary>
        <value><see langword="true" /> Si el elemento se inicializa por las llamadas de método o la carga mencionados anteriormente; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad también puede ser `true` si este elemento se ha movido dentro del árbol de elementos que tiene un nuevo elemento primario y, por lo tanto, se carga de nuevo.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si este elemento se ha cargado para la presentación.</summary>
        <value><see langword="true" /> Si el elemento actual está asociado a un árbol de elementos y se ha representado; <see langword="false" /> si el elemento nunca se ha vinculado a un árbol de elementos cargado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desde una instancia recién creada, esta propiedad comienza `false`y sigue siendo `true` una vez que se establece en `true`, incluso si quita posteriormente mediante código.  
  
   
  
## Examples  
 El código de ejemplo siguiente usa <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> como una comprobación condicional para garantizar que una función `displayData` elementos válidos (no mostrado) habrá cargado en la página que funciona, como parte de un controlador y a petición. Que la misma lógica se ejecuta como un controlador de eventos <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la información del idioma de localización o globalización que se aplica a un elemento individual.</summary>
        <value>Información de la referencia cultural de este elemento. El valor predeterminado es una instancia <see cref="T:System.Windows.Markup.XmlLanguage" /> con su valor <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> establecido en la cadena "en-US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los formatos de cadena siguen el estándar RFC 3066. Por ejemplo, EE. UU. Inglés es "en-US". Consulte <xref:System.Windows.Markup.XmlLanguage> para obtener más información sobre los valores y formato.  
  
 Esta propiedad de dependencia hereda los valores de propiedad. Si hay elementos secundarios con ningún otro valor para <xref:System.Windows.FrameworkElement.Language%2A> establecido a través de valores o estilos locales, el sistema de propiedades establecerá el valor sea el <xref:System.Windows.FrameworkElement.Language%2A> valor del elemento primario más cercano con este valor asignado.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando el elemento se presenta, se representa y está listo para la interacción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan. Dirigir los eventos enrutados admiten otro comportamiento del evento enrutado: admiten una colección de controladores accesible y puede usarse como un <xref:System.Windows.EventTrigger> en un estilo.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Estrategia de enrutamiento|Directa|  
|delegado|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un enumerador para el elemento secundario lógico de los elementos de este elemento.</summary>
        <value>Un enumerador para los elementos secundarios lógicos de este elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre cómo usar <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> y <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">La dirección que está el foco se mueva, como un valor de la enumeración.</param>
        <summary>Mueve el foco de teclado de este elemento a otro elemento.</summary>
        <returns>Devuelve <see langword="true" /> si el foco se mueve correctamente; <see langword="false" /> si el elemento de destino en la dirección especificada no existe.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre de identificación del elemento. El nombre proporciona una referencia de instancia para que el código subyacente de programación, como el código del controlador de eventos, puede hacer referencia a un elemento una vez construido durante el análisis de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nombre del elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El uso más común de esta propiedad es al especificar un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nombre de elemento de marcado.  
  
 Básicamente, esta propiedad proporciona una propiedad de conveniencia de nivel de marco WPF para establecer el [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x: Name Directive](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Obtener un <xref:System.Windows.FrameworkContentElement.Name%2A> desde código no es común, porque si ya tiene la referencia adecuada en el código, simplemente puede llamar a métodos y propiedades en el elemento de referencia y por lo general no es necesario el <xref:System.Windows.FrameworkContentElement.Name%2A>. Una excepción es si la cadena tiene algún significado sobrecargado, por ejemplo si es útil mostrar el nombre en [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Establecer un <xref:System.Windows.FrameworkContentElement.Name%2A> desde el código si la versión original <xref:System.Windows.FrameworkContentElement.Name%2A> era conjunto a partir de marcado no se recomienda también y cambiar la propiedad no cambiará la referencia de objeto. Estas referencias de objeto se crean solo cuando se crean explícitamente los ámbitos de nombres subyacentes durante [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] cargando.  
  
 Debe llamar específicamente a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> para realizar un cambio efectivo en el <xref:System.Windows.FrameworkContentElement.Name%2A> propiedad de un elemento ya cargado.  
  
 Un notables caso de que el valor <xref:System.Windows.FrameworkContentElement.Name%2A> desde el código es importante es para la nomenclatura de los elementos que guiones gráficos will ejecutan. Para poder registrar un nombre, también tendrá que crear una instancia y asignar un <xref:System.Windows.NameScope> instancia. Vea la sección de ejemplo o [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Establecer <xref:System.Windows.FrameworkContentElement.Name%2A> de código tiene aplicaciones limitadas, pero buscar un elemento por su nombre es más común, especialmente si se emplea un modelo de navegación donde se recargan las páginas en la aplicación y el código de tiempo de ejecución no es necesariamente el código subyacente de la que página correspondiente. El método de utilidad <xref:System.Windows.FrameworkContentElement.FindName%2A>, que está disponible desde cualquier <xref:System.Windows.FrameworkContentElement>, puede buscar cualquier elemento por <xref:System.Windows.FrameworkContentElement.Name%2A> de forma recursiva del árbol lógico de ese elemento. O bien puede usar el <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> método estático de <xref:System.Windows.LogicalTreeHelper>, que también toma la <xref:System.Windows.FrameworkContentElement.Name%2A> cadena como argumento.  
  
 Elementos raíz de uso frecuente (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> por ejemplo) implementan la interfaz <xref:System.Windows.Markup.INameScope>. Se esperan las implementaciones de esta interfaz para exigir que los nombres de ser inequívoco dentro de su ámbito.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que el <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> evento enrutado alcanza esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Todavía debe llamar a la implementación base en caso de una clase intermedia en la herencia ha implementado este método.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha desencadenado el evento enrutado por un elemento secundario, no necesariamente el elemento que va a invocar los controladores. Por lo tanto, la implementación tendrá que tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta. Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos de evento para el evento.</param>
        <summary>Se invoca siempre que el <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> evento enrutado alcanza esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación tendrá que tomar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta. Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos de evento para el evento.</param>
        <summary>Controlador de clase para el <see cref="E:System.Windows.ContentElement.GotFocus" /> eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este controlador de clase establece el comportamiento de foco adecuado en este elemento si se originó el evento de este elemento. Si el origen del evento fuera otro elemento en el árbol, el controlador no hace nada.  
  
 Invalide este método para cambiar el comportamiento de enfoque en el elemento predeterminado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos de evento para el evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.FrameworkContentElement.Initialized" />. Este método se invoca cada vez que <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> está establecido en <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método virtual genera el evento como se describe anteriormente en este tema. Las invalidaciones deben llamar base () para conservar este comportamiento.  
  
 Tenga en cuenta que el <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> propiedad es de solo lectura. Por lo tanto, no se puede establecer para forzar el comportamiento de inicialización de este modo. Valor de inicialización está pensado para realizarse únicamente por la [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento que describen la propiedad que cambió, incluidos los valores antiguos y nuevos.</param>
        <summary>Se invoca cuando se actualiza el valor efectivo de alguna propiedad de dependencia en este <see cref="T:System.Windows.FrameworkContentElement" />. Propiedad de dependencia concreta que cambió se notifica en el parámetro de argumentos. Invalida <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no está pensado para detectar generalmente los cambios de propiedad o invalidaciones. En su lugar se está diseñado para las modificaciones del modelo de invalidación general si se conoce cierta información sobre las clasificaciones de anchas de las propiedades.  
  
 Este método se invoca posiblemente muchas veces durante la vida de un objeto. Por lo tanto, puede lograr un mejor rendimiento si invalida los metadatos de las propiedades específicas y, a continuación, adjuntar <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones para las propiedades individuales. Sin embargo, podría utilizar este método si un <xref:System.Windows.FrameworkContentElement> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.  
  
 Tenga en cuenta que hay una con el mismo nombre `OnPropertyChanged` método con una firma diferente (es el tipo de parámetro <xref:System.ComponentModel.PropertyChangedEventArgs>) que pueden aparecer en una serie de clases. Que `OnPropertyChanged` se usa para las notificaciones del objeto de datos, y forma parte del contrato para <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Llame siempre a la implementación base, como la primera operación en la implementación. Si no lo hace mucho, se deshabilitará todo el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades, lo que hace que los valores incorrectos que se notificarán.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">El estilo anterior.</param>
        <param name="newStyle">El nuevo estilo.</param>
        <summary>Se invoca cuando el estilo que está en uso en este elemento cambia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método tiene una implementación predeterminada que establece un marcador interno, teniendo en cuenta la condición de estilo que ha cambiado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Llame siempre a la implementación base, en caso contrario, no se puede aplicar estilos. Podrían incluir escenarios para invalidar este método si la clase derivada tiene un selector de estilo especializado o almacena en caché los valores de estilo. Cambios de tema podrían invocar este método.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que el <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> evento enrutado alcanza esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación tendrá que tomar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta. Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que el <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> evento enrutado alcanza esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Todavía debe llamar a base() en caso de una clase intermedia en la herencia ha implementado este método.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: proporciona los medios para controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque un elemento secundario, no necesariamente el elemento que va a invocar los controladores, por lo que la implementación deberá desconectar el origen de los argumentos de evento, puede provocar el evento enrutado propiedades de cuenta (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.FrameworkContentElement> podría optar por llamar a métodos de controlador de clase privada cuando se recibe el evento a lo largo de la ruta. Un posible escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado para acortar la ruta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si este elemento incorpora las propiedades de estilo de los estilos de tema.</summary>
        <value><see langword="true" /> Si este elemento no utiliza las propiedades de estilo de tema; todas las propiedades que originan un estilo provienen de los estilos de aplicación local y no se aplican las propiedades de estilo de tema. <see langword="false" /> Si se aplican los estilos de aplicación en primer lugar y, a continuación, se aplican los estilos de tema para las propiedades que no se establecieron específicamente en estilos de aplicación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El uso más común de esta propiedad es un uso indirecto dentro del establecedor de un estilo que se suministra un estilo con temas.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el elemento primario del árbol lógico de este elemento.</summary>
        <value>Elemento primario lógico de este elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que el elemento primario lógico de un elemento puede cambiar según la funcionalidad de la aplicación y mantener el valor de esta propiedad no se reflejará dicho cambio. Normalmente, debe obtener el valor inmediatamente antes de necesitarla.  
  
 Consulte [árboles en WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) para obtener más información sobre cómo atravesar árboles lógicos y los escenarios donde es apropiado este enfoque hacia la detección del elemento.  
  
 El sistema de propiedades vuelve a calcular potencialmente todos los valores de propiedad de un elemento cuando cambia de elemento primario, porque algunas propiedades heredan los valores a través del árbol lógico. El <xref:System.Windows.FrameworkContentElement.DataContext%2A> que se aplica para los enlaces también pueden cambiar cuando los elementos cambian de elemento primario.  
  
 Cambiar primario de un elemento solo se realiza normalmente mediante la manipulación de colecciones, mediante el uso de dedicado agregar o quitar métodos, o a través de propiedades de contenido de elementos.  
  
 El escenario más típico para usar el <xref:System.Windows.FrameworkContentElement.Parent%2A> propiedad consiste en obtener una referencia y, a continuación, obtener diversos <xref:System.Windows.FrameworkContentElement> los valores de propiedad del elemento primario. Para las plantillas, el <xref:System.Windows.FrameworkContentElement.Parent%2A> de la plantilla finalmente estará `null`. Para obtener más allá de este punto y ampliar en el árbol lógico donde realmente se aplica la plantilla, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 El ejemplo siguiente se comprueba para ver si el <xref:System.Windows.FrameworkContentElement.Parent%2A> de un <xref:System.Windows.Documents.TextPointer> es de un tipo determinado.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">La dirección para el que se debe determinar un cambio de foco probable.</param>
        <summary>Determina el elemento siguiente que recibiría el foco relativo a este elemento para una dirección de movimiento de foco proporcionada, pero realmente no mueve el foco. Este método está sellado y no se puede invalidar.</summary>
        <returns>El siguiente elemento que se centran movería si realmente se recorrieron foco. Puede devolver <see langword="null" /> si no se puede mover el foco relativo a este elemento para la dirección proporcionada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> es el método relacionado que realmente mueve el foco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Especificar una de las instrucciones siguientes en el <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Estas instrucciones no son válidas para <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (pero son válidas para <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se usará para la asignación de nombre de objeto especificada.</param>
        <param name="scopedElement">Objeto para la asignación.</param>
        <summary>Proporciona un descriptor de acceso que simplifica el acceso a la <see cref="T:System.Windows.NameScope" /> método de registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es un método de conveniencia para llamar a <xref:System.Windows.NameScope.RegisterName%2A>. La implementación comprobará los elementos primarios sucesivos hasta que encuentra aplicable <xref:System.Windows.NameScope> implementación, que se encuentra al buscar un elemento que implementa <xref:System.Windows.Markup.INameScope>. Para obtener más información sobre los ámbitos de nombres, vea [ámbitos de nombres de XAML de WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Una llamada a <xref:System.Windows.FrameworkContentElement.RegisterName%2A> es necesario para enlazar correctamente guiones gráficos de animación para aplicaciones cuando se crean en el código. Esto es porque una de las claves de propiedades, guión gráfico <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utiliza una búsqueda de nombre de tiempo de ejecución en lugar de ser capaz de hacer referencia a un elemento de destino. Esto es cierto incluso si ese elemento sea accesible por referencia desde el código. Para obtener más información sobre por qué necesita registrar los nombres para los destinos de guión gráfico, vea [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Las animaciones para los elementos de contenido son menos frecuentes que las animaciones en los controles, el [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) se concentra en escenarios de control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Elemento que se va a quitar.</param>
        <summary>Quita el elemento especificado del árbol lógico de este elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] es principalmente relevante para la clase que deriva de escenarios, al agregar compatibilidad con las colecciones secundarias.  
  
 La mayoría <xref:System.Windows.FrameworkContentElement> las clases derivadas exponen colecciones dedicadas que son responsables de contención (por ejemplo, <xref:System.Windows.Documents.Span.Inlines%2A> en el <xref:System.Windows.Documents.Span> clase; <xref:System.Windows.Documents.Section.Blocks%2A> en el <xref:System.Windows.Documents.Section> clase). Derivar de tales clases normalmente puede evitar la necesidad de manipular directamente el árbol lógico.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el diccionario de recursos definido localmente actual.</summary>
        <value>Los recursos actuales definidos localmente. Se trata de un diccionario de recursos, donde se tiene acceso a recursos dentro del diccionario por clave.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los diccionarios de recursos que se pueden definir por completo o parcialmente en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] normalmente se crean como un elemento de propiedad y suelen estar en el elemento raíz de cualquier página individual o de la aplicación. Colocar el diccionario de recursos en este nivel hace que sea más fácil encontrar desde los elementos secundarios individuales en la página (o desde cualquier página, en el caso de la aplicación). En la mayoría de los escenarios de aplicación, se recomienda que los estilos se definen como elementos de objeto dentro de un diccionario de recursos, o se definen como recursos externos para que el recurso de estilo completo puede ser independiente (este enfoque ayuda a diseñador independiente responsabilidades de responsabilidades del programador separando los archivos físicos que tienen que modificarse).  
  
 Tenga en cuenta que esta propiedad devuelve solo el diccionario de recursos que se declara directamente dentro de ese elemento. Esto es diferente que el proceso de búsqueda de recursos real, donde un elemento secundario puede tener acceso a cualquiera de los recursos definidos en cada elemento primario, buscando hacia arriba de forma recursiva.  
  
 También puede hacer referencia a código desde dentro de la colección de recursos, pero tenga en cuenta que los recursos crean en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] definitivamente no será accesible hasta después de <xref:System.Windows.FrameworkContentElement.Loaded> generado por el elemento que se declara el diccionario. De hecho, los recursos se analizan de forma asincrónica y ni siquiera el <xref:System.Windows.FrameworkContentElement.Loaded> eventos es una garantía de que puede hacer referencia a un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] recurso definido. Por esta razón se debe generalmente sólo tener acceso [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] define los recursos como parte de código en tiempo de ejecución, o a través de otras [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] técnicas como los estilos o las referencias de extensión de recursos para los valores de atributo. Cuando tenga acceso a los recursos a través del código, es esencialmente equivalente a una referencia realizada desde [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Subyacente <xref:System.Windows.ResourceDictionary> es compatible con los métodos necesarios para agregar, quitar o consultar recursos desde dentro de la colección mediante el uso de código. El <xref:System.Windows.FrameworkContentElement.Resources%2A> propiedad es configurable para admitir el escenario de reemplazar completamente la colección de recursos de un elemento que se va a ser un nuevo o diferente <xref:System.Windows.ResourceDictionary>.  
  
 Tenga en cuenta que el [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis que se muestra no incluyen un elemento para el <xref:System.Windows.ResourceDictionary>. Este es un ejemplo de sintaxis de colección implícito; se puede omitir una etiqueta que representa el elemento de la colección. En su lugar, se especifican los elementos que se agregan como elementos a la colección. Para obtener más información acerca de las colecciones implícitas y [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consulte [XAML detalles de la sintaxis](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Un caso donde un <xref:System.Windows.ResourceDictionary> todavía se especifica explícitamente como un elemento es si va a introducir un diccionario combinado, en cuyo caso normalmente hay ningún elemento secundario para que <xref:System.Windows.ResourceDictionary>. Para obtener más información, consulte [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Uso de elementos de propiedad XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreResourceElements*  
 Uno o varios elementos de objeto, cada uno de los cuales define un recurso. Cada elemento de propiedad de recurso dentro de cada <xref:System.Windows.ResourceDictionary> debe tener un valor único para el [Directiva x: Key](~/docs/framework/xaml-services/x-key-directive.md), que actúa como clave única cuando se recuperan valores de la <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 El siguiente ejemplo se establece un <xref:System.Windows.FrameworkContentElement.Resources%2A> colección en un <xref:System.Windows.Documents.FlowDocument> elemento raíz. <xref:System.Windows.Documents.FlowDocument> es una opción habitual porque es uno de los pocos <xref:System.Windows.FrameworkContentElement> clases que tengan sentido como un elemento raíz y los recursos se almacenan normalmente en la raíz de la página o en niveles superiores incluso, tales como se muestra en la aplicación.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asocia un enlace a este elemento para la propiedad de dependencia especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifica la propiedad enlazada.</param>
        <param name="path">El nombre de propiedad de origen o la ruta de acceso a la propiedad usada para el enlace.</param>
        <summary>Asocia un enlace a este elemento, basado en el nombre de propiedad de origen proporcionado como una calificación de ruta de acceso al origen de datos.</summary>
        <returns>Registra las condiciones del enlace. Este valor devuelto puede ser útil para la comprobación de errores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es un método de conveniencia para llamar a <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que pasa la instancia actual como el <xref:System.Windows.DependencyObject>y crea un nuevo <xref:System.Windows.Data.Binding> según proporcionado `path` parámetro. Esta firma es más conveniente si va a establecer un enlace simple de forma predeterminada. Si necesita especificar ninguna propiedad de enlace a las condiciones no predeterminado, o desea usar un <xref:System.Windows.Data.MultiBinding> o <xref:System.Windows.Data.PriorityBinding>, debe usar el <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> firma.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo objeto de datos personalizado, Establece el objeto como <xref:System.Windows.FrameworkContentElement.DataContext%2A>y establecer la ruta de acceso de enlace a una propiedad dentro de él.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identifica la propiedad enlazada.</param>
        <param name="binding">Representa un enlace de datos.</param>
        <summary>Asocia un enlace a este elemento, basado en el objeto de enlace ofrecido.</summary>
        <returns>Registra las condiciones del enlace. Este valor devuelto puede ser útil para la comprobación de errores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es un método de conveniencia para llamar a <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, que pasa la instancia actual como el <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece un enlace en un <xref:System.Windows.Documents.Paragraph> elemento, creando un nuevo <xref:System.Windows.Data.Binding> y establezca el origen en recién compilado `DateTime` objeto.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">La propiedad a la que está enlazado el recurso.</param>
        <param name="name">Nombre del recurso.</param>
        <summary>Busca un recurso con el nombre especificado y establece una referencia a él de recurso para la propiedad especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una referencia de recurso es similar al uso de un [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) en el marcado. La referencia de recurso crea una expresión interna que proporciona el valor de la propiedad especificada en tiempo de ejecución diferido. La expresión se reevalúa cada vez que el diccionario de recursos indica un valor ha cambiado a través de eventos internos, o cada vez que se cambia de elemento primario del elemento actual (un cambio primario cambiaría la ruta de acceso de búsqueda de diccionario).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve si los procesos de serialización deben serializar el contenido de la <see cref="P:System.Windows.FrameworkContentElement.Resources" /> propiedad en las instancias de esta clase.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.Windows.FrameworkContentElement.Resources" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto devolverá `true` , siempre hay al menos un recurso con clave local <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve si los procesos de serialización deben serializar el contenido de la <see cref="P:System.Windows.FrameworkContentElement.Style" /> propiedad en las instancias de esta clase.</summary>
        <returns>Es <see langword="true" /> si el valor de propiedad <see cref="P:System.Windows.FrameworkContentElement.Style" /> debe serializarse; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esto devolverá `true` si el <xref:System.Windows.Style> se establece localmente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cualquier asociado que participa en un enlace de este elemento cambia el origen de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento emerge la <xref:System.Windows.Data.Binding.SourceUpdated> evento generado por cualquier <xref:System.Windows.Data.Binding> asociado a este elemento.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el estilo que se va a usar por este elemento.</summary>
        <value>Estilo aplicado, no predeterminado para el elemento, si está presente. En caso contrario, es <see langword="null" />. El valor predeterminado para un objeto <see cref="T:System.Windows.FrameworkContentElement" /> construido de forma predeterminada es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El estilo actual a menudo se proporciona un estilo predeterminado de temas, o de estilos, por lo general se aplican a los objetos de ese tipo por los recursos en el nivel de página o aplicación (un estilo implícito). Esta propiedad no predeterminada establece o devuelve estilos (tema), sino devuelve el estilo implícito o explícito. En el caso de los estilos implícitos o explícitos, no importa si el estilo se puede obtener acceso como un recurso o no definido localmente.  
  
 Establecer los estilos tiene algunas restricciones. Puede restablecer toda la <xref:System.Windows.FrameworkContentElement.Style%2A> propiedad a un nuevo <xref:System.Windows.Style> en cualquier momento, lo que forzará una recomposición del diseño. Sin embargo, tan pronto como ese estilo se coloca en uso por un elemento cargado, el <xref:System.Windows.Style> debe considerarse sellado. Intento de realizar un cambio en cualquier propiedad individual de un estilo en uso (como cualquier elemento dentro de la colección de <xref:System.Windows.Style.Setters%2A>) hace que se produzca una excepción. Un estilo que se define en el marcado se considera que están en uso en cuanto se carga desde un diccionario de recursos (para los recursos) o se carga la página que está dentro de (para los estilos en línea).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> es una propiedad de dependencia con prioridad especial. Establecida localmente estilo suele funciona con la prioridad más alta en el sistema de propiedades. Si la <xref:System.Windows.FrameworkContentElement.Style%2A> es null en este momento, durante la carga el sistema de propiedades busca los estilos implícitos como recursos definidos que especifican ese tipo. Si el estilo todavía es nulo después de este paso, a continuación, el estilo procede del estilo predeterminado (tema), pero no se devuelve el estilo predeterminado en el <xref:System.Windows.FrameworkContentElement.Style%2A> valor de propiedad. Consulte [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *ResourceExtension*  
 Uno de los siguientes:, o. Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clave que identifica el estilo que se solicita. La clave hace referencia a un recurso existente en un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Sintaxis de elemento de propiedad es técnicamente posible, pero no se recomienda. Consulte [plantillas y estilos alineados](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Una referencia de enlace mediante o <xref:System.Windows.Data.Binding> también es posible, pero es poco común.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 El siguiente ejemplo se establece un <xref:System.Windows.FrameworkContentElement.Resources%2A> colección en un <xref:System.Windows.Documents.FlowDocument> elemento raíz y, a continuación, hace referencia a él como un recurso como un estilo específico para un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">El nombre de la propiedad de ambiente solicitada.</param>
        <summary>Para obtener una descripción de este miembro, vea el método <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns><see langword="true" /> Si <paramref name="propertyName" /> está disponible; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Windows.FrameworkContentElement> se convierte en una interfaz <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor de objeto arbitrario que se puede usar para almacenar información personalizada sobre este elemento.</summary>
        <value>El valor deseado. Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es análoga a las propiedades de etiqueta en otros modelos de programación de Microsoft, como Visual Basic para aplicaciones o Windows Forms. Se está diseñado para proporcionar un lugar para almacenar información personalizada básica sobre cualquier elemento sin obligar a los programadores de aplicaciones para crear una subclase preexistente.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Valores XAML  
 Dado que esta propiedad toma un objeto, deberá usar el uso del elemento de propiedad para establecer el <xref:System.Windows.FrameworkContentElement.Tag%2A> propiedad en XAML para algo distinto de un objeto con un convertidor de tipos conocido e integrado, como una cadena. Los objetos utilizados en este modo no están normalmente dentro de los espacios de nombres estándar de WPF y, por tanto, pueden requerir la asignación de espacio de nombres al espacio de nombres externo con el fin se introdujo como elementos XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia cualquier propiedad de destino asociada que participa en un enlace de este elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento emerge la <xref:System.Windows.Data.Binding.TargetUpdated> evento generado por cualquier <xref:System.Windows.Data.Binding> asociado a este elemento. Normalmente, esto significa que el enlace en cuestión es un enlace bidireccional, y que la propiedad de dependencia enlazada afirma una invalidación del valor de propiedad anterior por ninguna validación o esquema de almacenamiento en caché que admite la propiedad.  
  
 Los argumentos de evento de este evento le informará que enlaza la propiedad cambió.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la plantilla primaria de este elemento. Esta propiedad no es relevante si el elemento no se creó mediante una plantilla.</summary>
        <value>El elemento cuyo <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> provocó que se creó este elemento. Este valor suele <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las plantillas son realmente objetos compartidos, donde el contenido de la plantilla se crea una sola vez. Por lo tanto, si obtiene una referencia de objeto a un elemento que proviene de una plantilla, es posible que el árbol lógico aparente no llega a la raíz de la página. Para poder conectarse a dicha referencia de plantilla al árbol lógico de la página, debe obtener el <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valor y continuar explorando el árbol de elementos como desee.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> a menudo será `null` para objetos comunes, porque si ha obtenido una referencia de objeto fuera de una página en la aplicación a través de medios típicos, ese elemento probablemente no se creó desde una plantilla. Casos donde <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> podría no ser `null` incluyen operaciones como evento de prueba de posicionamiento, para ciertos eventos de entrada de bajo nivel de control, o para trabajar con los enumeradores, que pueden haber devuelto elementos que provienen de las plantillas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto de información sobre herramientas que se muestra para este elemento en el [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>El objeto de información sobre herramientas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el valor de esta propiedad es de tipo <xref:System.Windows.Controls.ToolTip>, a continuación, que es la información sobre herramientas que se usará en el [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Si el valor es de cualquier otro tipo, a continuación, ese valor se usará como el *contenido* para un <xref:System.Windows.Controls.ToolTip> proporcionado (generada) por el sistema. Para obtener más información, vea <xref:System.Windows.Controls.ToolTipService>. La clase de servicio proporciona las propiedades adjuntas que pueden usarse para personalizar aún más una información sobre herramientas.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Uso de elementos de propiedad XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *toolTipContent*  
 Una cadena que se convierte en texto para mostrar el <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Algún objeto, proporcionado en el formulario de elemento de objeto, que debe usarse como el contenido de la <xref:System.Windows.FrameworkContentElement> . Normalmente, esto sería un <xref:System.Windows.FrameworkElement> o algún otro elemento que crea la composición de diseño para el <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, finalmente, que contiene el contenido de texto dentro de la composición. En este uso, el <xref:System.Windows.Controls.ToolTip> elemento se crea implícitamente desde el objeto analizado [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]y el *toolTipObjectContent* contenido está establecido como su <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propiedad.  
  
 <`ToolTip` … / >  
 Vea <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|Establecen las propiedades de metadatos en `true`|Ninguna|  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el valor de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propiedad directamente en una cadena.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce justo antes de cerrar cualquier información sobre herramientas en el elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para suprimir el cierre de la información sobre herramientas, los controladores del evento deben marcará como controlado.  
  
 Este evento no puede ser un <xref:System.Windows.EventTrigger> en un estilo. Esto es porque el campo de identificador de este evento vuelve a usa una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Estrategia de enrutamiento|Directa|  
|delegado|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se abre cualquier información sobre herramientas en el elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para abrir manualmente la información sobre herramientas, los controladores de los eventos deben marcar el evento pertinente como controlado. En caso contrario, el valor de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propiedad se usará para abrir automáticamente un menú contextual. Marcar el evento como controlado eficazmente cancelará la acción predeterminada y podría ser una oportunidad para restablecer el valor de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propiedad y, a continuación, abra el nuevo <xref:System.Windows.Controls.ContextMenu>. Tenga en cuenta que no se producirá este evento si <xref:System.Windows.FrameworkContentElement.ToolTip%2A> es una referencia nula o de otro modo no establecido.  
  
 Este evento no puede ser un <xref:System.Windows.EventTrigger> en un estilo. Esto es porque el campo de identificador de este evento vuelve a usa una implementación de un servicio que no expone los métodos de agregar o quitar en el evento.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Estrategia de enrutamiento|Directa|  
|delegado|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificador de clave del recurso que se debe encontrar.</param>
        <summary>Busca un recurso con la clave especificada y lo devuelve si lo encuentra.</summary>
        <returns>Recurso encontrado. Si no se encuentra ningún recurso, se devuelve <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentra el recurso en el elemento que realiza la llamada, se busca en el árbol primario mediante el árbol lógico, de la misma manera que el árbol se buscan si se solicitara una referencia de recurso dinámico por clave en tiempo de ejecución.  
  
 Normalmente, convertiría inmediatamente el valor devuelto al tipo de la propiedad que se ha intentado establecer con el valor de recurso devuelto.  
  
 El <xref:System.Windows.FrameworkContentElement.FindResource%2A> método tiene un comportamiento similar, salvo que generará una excepción en el caso de no encontrar un recurso con la clave proporcionada.  
  
   
  
## Examples  
 El ejemplo siguiente busca un recurso, tal como se define en el marcado y aplica a una determinada propiedad de un elemento en respuesta a un evento enrutado.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se quita el elemento de un árbol de elementos cargados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos enrutados directos no siguen una ruta, sólo se controlan dentro del mismo elemento en el que se generan. Dirigir los eventos enrutados admiten otro comportamiento del evento enrutado: admiten una colección de controladores accesible y puede usarse como un <xref:System.Windows.EventTrigger> en un estilo.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Estrategia de enrutamiento|Directa|  
|delegado|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [información general de eventos enrutados](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se crean objetos de identificador de evento cuando se registran eventos enrutados (vea <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) y, a continuación, se puede usar para agregar controladores de clases (vea <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objetos de identificador contienen un nombre de identificación, tipo de propietario, tipo de controlador, estrategia de enrutamiento y un método de utilidad para agregar propietarios al evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del par de nombre de objeto para quitar del ámbito actual.</param>
        <summary>Simplifica el acceso a la <see cref="T:System.Windows.NameScope" /> método la eliminación del registro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solo deberá anular el registro de nombres si piensa volver a registrar otro elemento con el mismo nombre.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vuelve a aplicar el estilo predeterminado para el actual <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>