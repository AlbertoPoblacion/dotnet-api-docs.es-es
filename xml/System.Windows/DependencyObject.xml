<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c5652ff55f90cc72dcdbf7f830e6d730953e6168" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37550075" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an object that participates in the dependency property system.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.DependencyObject> clase permite [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] servicios del sistema de propiedades en sus clases derivadas.  
  
 Función principal del sistema de propiedades es para calcular los valores de propiedades y para proporcionar una notificación del sistema acerca de los valores que han cambiado. Otra clase clave que participa en el sistema de propiedades es <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> habilita el registro de las propiedades de dependencia en el sistema de propiedades y proporciona identificación e información sobre cada propiedad de dependencia, mientras que <xref:System.Windows.DependencyObject> como una clase base permite a los objetos usar las propiedades de dependencia.  
  
 <xref:System.Windows.DependencyObject> servicios y características incluyen lo siguiente:  
  
-   Compatibilidad con el host la propiedad de dependencia. Registrar una propiedad de dependencia mediante una llamada a la <xref:System.Windows.DependencyProperty.Register%2A> método y almacenar el valor devuelto del método como un campo estático público en su clase.  
  
-   Compatibilidad con el hospedaje de propiedad adjunta. Registrar una propiedad adjunta mediante una llamada a la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método y almacenar el valor devuelto del método como un campo de solo lectura público estático en la clase. (También hay requisitos de miembro adicionales; tenga en cuenta que esto representa un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementación específica para las propiedades adjuntas. Para obtener más información, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).) A continuación, se puede establecer la propiedad adjunta en cualquier clase que deriva de <xref:System.Windows.DependencyObject>.  
  
-   Get, set y desactive los métodos de utilidad para los valores de las propiedades de dependencia que existen en el <xref:System.Windows.DependencyObject>.  
  
-   Los metadatos, compatibilidad con valores de notificación de cambio de propiedad y las devoluciones de llamada de invalidación para las propiedades de dependencia de coerción o las propiedades adjuntas. Además, el <xref:System.Windows.DependencyObject> clase facilita los metadatos de propiedad por propietario para una propiedad de dependencia.  
  
-   Una clase base común para las clases derivadas de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, o <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, otra clase de elemento base, tiene una jerarquía de clases que incluye <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 En el siguiente ejemplo se deriva de <xref:System.Windows.DependencyObject> para crear una nueva clase abstracta. La clase, a continuación, registra una propiedad adjunta e incluye compatibilidad con miembros de esa propiedad asociada.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.DependencyObject" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Clears the local value of a property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The dependency property to be cleared, identified by a <see cref="T:System.Windows.DependencyProperty" /> object reference.</param>
        <summary>Clears the local value of a property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyProperty" /> identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Borrar el valor de propiedad mediante una llamada a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar la propiedad solo borra específicamente cualquier valor local se han aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 El ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama a <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">The key for the dependency property to be cleared.</param>
        <summary>Clears the local value of a read-only property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyPropertyKey> identifica una propiedad de dependencia de solo lectura para las operaciones de sistema de propiedades. Las clases que definen las propiedades de dependencia de solo lectura no deben exponer esta clave con acceso público. Una clave expuesta públicamente proporcionaría una ruta de código público que niega el carácter de solo lectura de la propiedad, si los métodos como <xref:System.Windows.DependencyObject.ClearValue%2A> o <xref:System.Windows.DependencyObject.SetValue%2A> podría denominarse fuera de la clase o el ensamblado, que hacen referencia a la clave.  
  
 Borrar el valor de propiedad mediante una llamada a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar el valor solo borra específicamente cualquier valor local se han aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property to coerce.</param>
        <summary>Coerces the value of the specified dependency property. This is accomplished by invoking any <see cref="T:System.Windows.CoerceValueCallback" /> function specified in property metadata for the dependency property as it exists on the calling <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de que se va a invocar explícitamente llamando a <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> en una dependencia de propiedad también se invoca internamente cada vez que el valor de propiedad de dependencia se reevalúa el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades.  
  
 Cuando se invoca el <xref:System.Windows.DependencyObject.CoerceValue%2A> método, en última instancia, se invoca la devolución de llamada de valor forzado para la propiedad que especifique. Normalmente, invocará <xref:System.Windows.DependencyObject.CoerceValue%2A> solo si sabe que existe una devolución de llamada de valor de coerción, y si sabe que los criterios de la devolución de llamada para la conversión.  
  
 El escenario más común para llamar a <xref:System.Windows.DependencyObject.CoerceValue%2A> está dentro de la clase control o la propiedad cambio las devoluciones de llamada de propiedades relacionadas que influyen en los valores de los demás de forma dependiente. Para obtener más información, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.CoerceValue%2A> dentro de un <xref:System.Windows.PropertyChangedCallback> implementación que se utiliza como el <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> un diferentes propiedades de dependencia en la misma clase. Se trata de un patrón común para introducir un valor true dependencias entre las propiedades de dependencia.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value were invalid or do not exist.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.DependencyObjectType" /> that wraps the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] type of this instance.</summary>
        <value>Un <see cref="T:System.Windows.DependencyObjectType" /> que ajusta el [! Tipo de include[TLA2#tla_clr](~/includes/tla2sharptla-CLR-MD.MD)] de esta instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es útil si un objeto que se devuelve desde un método tiene un tipo de valor devuelto de <xref:System.Windows.DependencyObject> y desea realizar la propiedad del sistema en él operaciones específicas según su tipo. Por ejemplo es más eficaz llamar a <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> utilizando el <xref:System.Windows.DependencyObjectType> en lugar de [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita la búsqueda rápida.  
  
   
  
## Examples  
 En el siguiente ejemplo de pseudocódigo `MySubClass` prevé que las clases derivadas adicionales pueden cambiar el valor predeterminado de la `MyCustom` propiedad de dependencia. La clase implementa un constructor predeterminado que se puede determinar la clase derivada real aprovechando las ventajas de polimorfismo el <xref:System.Windows.DependencyObjectType> valor cada vez que el constructor se utiliza como un creador de instancias de clase derivada.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Windows.DependencyObject" /> to compare to the current instance.</param>
        <summary>Determines whether a provided <see cref="T:System.Windows.DependencyObject" /> is equivalent to the current <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" /> if the two instances are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación es sólo la igualdad de referencia y no intenta evaluar la igualdad de valores de las propiedades contenidas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos basic <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que resulta en un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que se intenta definir una igualdad de valores para las clases derivadas un <see cref="T:System.Windows.DependencyObject" />. Valor de igualdades para <see cref="T:System.Windows.DependencyObject" /> nunca serán precisos debido a las funcionalidades de cambio de valor de propiedad innata de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [! Características de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)] como el enlace de datos y el [! Sistema de propiedades include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a hash code for this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A signed 32-bit integer hash code.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que resulta en un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que se intenta definir una igualdad de valores para las clases derivadas un <see cref="T:System.Windows.DependencyObject" />. Valor de igualdades para <see cref="T:System.Windows.DependencyObject" /> nunca serán precisos debido a las funcionalidades de cambio de valor de propiedad innata de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [! Características de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)] como el enlace de datos y el [! Sistema de propiedades include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a specialized enumerator for determining which dependency properties have locally set values on this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A specialized local value enumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un *valor local* es cualquier valor de propiedad de dependencia que se ha establecido mediante <xref:System.Windows.DependencyObject.SetValue%2A>, en contraposición a otros aspectos del sistema de propiedades.  
  
 El <xref:System.Windows.LocalValueEnumerator> obtenido mediante una llamada a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> puede utilizarse para enumerar las propiedades que tienen establecido localmente el valor en un <xref:System.Windows.DependencyObject> instancia. Cada propiedad de este tipo se representa en el enumerador por un <xref:System.Windows.LocalValueEntry> objeto, que tiene propiedades que hacen referencia las específicas <xref:System.Windows.DependencyProperty> y sus valores. Esta técnica de enumerar sobre establecido localmente los valores pueden utilizarse para la optimización o para otro control de valores locales, por ejemplo, para determinar qué valores de propiedad de un <xref:System.Windows.DependencyObject> podría cambiar si han borrado.  
  
> [!IMPORTANT]
>  El valor devuelto <xref:System.Windows.LocalValueEnumerator> podría contener <xref:System.Windows.LocalValueEntry> registros de las propiedades de dependencia que son de solo lectura o de las propiedades de dependencia donde los valores se calculan por el sistema de propiedades. Por ejemplo, un elemento de marco visual que tiene un ancho establecido a través de diseño informará de un valor local para <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Si va a obtener los valores locales para restablecerlos, compruebe el <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor en el identificador de propiedad de cada <xref:System.Windows.LocalValueEntry> para comprobar que la <xref:System.Windows.DependencyProperty> en cuestión no es de solo lectura.  
  
   
  
## Examples  
 El ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama a <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the current effective value of a dependency property on this instance of a <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Returns the current effective value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El *valor efectivo* es el valor de la propiedad que es devuelto por el sistema de propiedades para cualquier llamador que solicita el valor. El valor efectivo es el resultado del sistema de propiedades evalúe todas las entradas posibles que participan en la precedencia de valores de propiedad del sistema. Esto incluye la conversión y animación. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Este método nunca devuelve <xref:System.Windows.DependencyProperty.UnsetValue>. El <xref:System.Windows.DependencyProperty.UnsetValue> es un valor de Centinela para el sistema de propiedades que se usa en varias capacidades internamente y, ocasionalmente, también se exponen a través de las devoluciones de llamada de conversión.  
  
 Si no está seguro de cuál debe ser el tipo de propiedad, puede consultar el identificador de la propiedad de dependencia solicitada para determinar si hay un determinado más <xref:System.Windows.DependencyProperty.PropertyType%2A> que el valor devuelto puede convertirse en.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value was invalid, or the specified <paramref name="dp" /> does not exist.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to invalidate.</param>
        <summary>Re-evaluates the effective value for the specified dependency property</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, cualquier asociado y aplicable <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones registrado para esa propiedad de dependencia podría ser invocada.  
  
 Una llamada a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad que tiene a su valor local establecido no tendrá ningún efecto, porque el valor local tiene prioridad sobre otras entradas del sistema de propiedad, excepto las animaciones. Sin embargo, podría llamar a <xref:System.Windows.DependencyObject.ClearValue%2A>, a continuación, llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Una llamada a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> no es necesariamente aplicable a muchos escenarios de propiedad de dependencia. Si una propiedad de dependencia se invalida debido a cambios de valor en cualquiera de los componentes, el sistema de propiedades invalida y vuelve a evaluar la propiedad de dependencia de forma automática. Sin embargo, todavía hay algunos escenarios adecuados donde <xref:System.Windows.DependencyObject.InvalidateProperty%2A> es útil. En concreto, puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dentro de la propiedad o valor de coerción cambió la devolución de llamada para una propiedad de dependencia distinta. También puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> para forzar la reevaluación de un enlace con un origen de datos que no es capaz de implementar la recomendada <xref:System.ComponentModel.INotifyPropertyChanged> mecanismo de notificación (quizás si consume las clases de datos que no se pueden derivar o donde los datos están estático miembro).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad personalizada, siempre que cambian las propiedades que están implicadas en los cálculos de la propiedad invalidada. Se trata de una técnica alternativa a llamar a la <xref:System.Windows.DependencyObject.CoerceValue%2A> método, porque la propiedad que se invalide también llamará a cualquier registrado <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this instance is currently sealed (read-only).</summary>
        <value>
          <see langword="true" /> Si esta instancia está sellada; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se establece internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that will contain the dependency property identifier of interest, the property metadata for the type, and old and new values.</param>
        <summary>Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.DependencyObject" /> has been updated. The specific dependency property that changed is reported in the event data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no está pensado para detectar generalmente los cambios de propiedad individual o realizar invalidaciones de las propiedades por caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> en su lugar, está pensado para las modificaciones del modelo de invalidación general, si se conoce cierta información sobre las clasificaciones de anchas de propiedades. Por ejemplo, los cambios en un <xref:System.Windows.Freezable> posible que haya cambios en los tipos de valor de la <xref:System.Windows.Freezable>, o podría ser subpropiedades, donde los cambios están dentro de otros <xref:System.Windows.Freezable> referencias. El <xref:System.Windows.Freezable> invalidar la implementación de <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> información interna se utiliza para determinar si las propiedades son subpropiedades y proporciona la lógica de la clase base adecuada para cualquiera de los casos.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> se invoca posiblemente muchas veces durante la vida de un objeto. Por lo tanto, puede lograr un mejor rendimiento para el sistema de propiedades general si invalida los metadatos de las propiedades específicas y, a continuación, adjuntar <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones para las propiedades individuales. Sin embargo, podría utilizar este método si un <xref:System.Windows.DependencyObject> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Llame siempre a la implementación base. Si no lo hace, se deshabilitará considerablemente toda la [! Sistema de propiedades include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)], valores incorrectos que se notificarán.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the local value of a dependency property, if it exists.</summary>
        <returns>Returns the local value, or returns the sentinel value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> if no local value is set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe usar <xref:System.Windows.DependencyObject.GetValue%2A> para las operaciones más habituales para una propiedad de dependencia "get". <xref:System.Windows.DependencyObject.ReadLocalValue%2A> no devuelve el valor efectivo para una variedad de circunstancias donde el valor no se ha establecido localmente.  
  
 Los valores que se establecen mediante los estilos, temas, plantillas, el valor predeterminado de los metadatos o la herencia de valores de propiedad no se consideran valores locales. Sin embargo, los enlaces y otras expresiones se consideran valores locales, una vez que se han evaluado.  
  
 Cuando se establece ningún valor local, este método devuelve <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Si el valor devuelto es distinto <xref:System.Windows.DependencyProperty.UnsetValue>, puede consultar los metadatos de la propiedad de dependencia solicitada para determinar si hay un tipo más específico que el valor devuelto puede convertirse en.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the value of a dependency property without changing its value source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa un componente que se establece mediante programación el valor de uno de sus propias propiedades sin deshabilitar el uso declarado de la aplicación de la propiedad. El <xref:System.Windows.DependencyObject.SetCurrentValue%2A> método cambia el valor efectivo de la propiedad, pero los desencadenadores existentes, los enlaces de datos y estilos seguirán funcionando.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the local value of a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a dependency property, specified by its dependency property identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal como se registró originalmente, se produce una excepción. El `value` siempre se deben proporcionar los parámetros como el tipo adecuado.  
  
 Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de propiedad de dependencia de la propiedad de dependencia que se va a establecer. En caso contrario, el valor proporcionado podría no ser correcta condiciones generales de comprobación de tipos (por ejemplo, pasando una cadena al tipo nativo es Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a read-only dependency property, specified by the <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the dependency property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma se usa generalmente al establecer los valores para las propiedades de dependencia de solo lectura que se definen por las clases personalizadas. Por lo general, <xref:System.Windows.DependencyObject.SetValue%2A> solo se llama desde el tipo que registra esa propiedad de dependencia, que implementa la lógica interna que proporciona el valor determinado para la propiedad de dependencia. Para obtener más información, consulte [Propiedades de dependencia de solo lectura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal como se registró originalmente, se produce una excepción. El `value` siempre se deben proporcionar los parámetros como el tipo adecuado. Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de propiedad de dependencia de la propiedad de dependencia que se va a establecer.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una propiedad de dependencia de solo lectura, junto con un `public static readonly` <xref:System.Windows.DependencyProperty> que proporciona la exposición de solo lectura es necesaria para los consumidores de propiedad y el descriptor de acceso get de la [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedor.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property that should be serialized.</param>
        <summary>Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.</summary>
        <returns>
          <see langword="true" /> if the dependency property that is supplied should be value-serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `true` para todos los casos en que una propiedad de dependencia tenía un valor local establecido en el <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Invalidaciones de este método podrían controlar las propiedades de dependencia concreta forma diferente.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>