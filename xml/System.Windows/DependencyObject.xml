<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="93e067f8bf97d79f7e4525a57db08a4a8d5109c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680319" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un objeto que forma parte del sistema de propiedades de dependencia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.DependencyObject> clase permite [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] servicios del sistema de propiedades en sus numerosas clases derivadas.  
  
 Función principal del sistema de propiedades es para calcular los valores de propiedades y para proporcionar una notificación del sistema acerca de los valores que han cambiado. Otra clase clave que participa en el sistema de propiedades es <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> habilita el registro de propiedades de dependencia en el sistema de propiedades y proporciona identificación e información sobre cada propiedad de dependencia, mientras que <xref:System.Windows.DependencyObject> como una clase base permite a los objetos usar las propiedades de dependencia.  
  
 <xref:System.Windows.DependencyObject> servicios y características son los siguientes:  
  
-   Compatibilidad con el host la propiedad de dependencia. Registrar una propiedad de dependencia mediante una llamada a la <xref:System.Windows.DependencyProperty.Register%2A> método y almacenar el valor devuelto del método como un campo estático público en la clase.  
  
-   Compatibilidad con el host de propiedad adjunta. Registrar una propiedad adjunta mediante una llamada a la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método y almacenar el valor devuelto del método como un campo de solo lectura público estático en la clase. (También existen requisitos de miembro adicionales, tenga en cuenta que esto representa un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementación específica para las propiedades asociadas. Para obtener más información, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).) A continuación, se puede establecer la propiedad adjunta en cualquier clase que deriva de <xref:System.Windows.DependencyObject>.  
  
-   Get, set y desactive los métodos de utilidad para los valores de las propiedades de dependencia que existen en el <xref:System.Windows.DependencyObject>.  
  
-   Metadatos, convertir el valor compatibilidad, notificación de cambio de propiedad y las devoluciones de llamada de invalidación para propiedades de dependencia o propiedades adjuntas. Además, la <xref:System.Windows.DependencyObject> clase facilita los metadatos de propiedad por propietario para una propiedad de dependencia.  
  
-   Una clase base común para las clases derivadas de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, o <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, otra clase de elemento base, tiene una jerarquía de clases que incluye <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 En el ejemplo siguiente se deriva de <xref:System.Windows.DependencyObject> para crear una nueva clase abstracta. La clase, a continuación, registra una propiedad adjunta e incluye miembros compatibles con la propiedad asociada.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Borra el valor local de una propiedad.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad de dependencia que se va a borrar, identificada con una referencia de objeto <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Borra el valor local de una propiedad. La propiedad que se va a borrar se especifica mediante un identificador <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Borrar el valor de propiedad llamando a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar la propiedad solo borra específicamente cualquier valor local se hayan aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó llamar a <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> en un <see cref="T:System.Windows.DependencyObject" /> sellado.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Clave de la propiedad de dependencia que se va a borrar.</param>
        <summary>Borra el valor local de una propiedad de solo lectura. La propiedad que se va a borrar se especifica mediante un <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyPropertyKey> identifica una propiedad de dependencia de solo lectura para las operaciones de sistema de propiedades. Las clases que definen las propiedades de dependencia de solo lectura no deben exponer esta clave con acceso público. Una clave públicamente expuesta proporcionaría una ruta de código pública que niega el carácter de solo lectura de la propiedad, si métodos como <xref:System.Windows.DependencyObject.ClearValue%2A> o <xref:System.Windows.DependencyObject.SetValue%2A> se podría llamar fuera de la clase o un ensamblado, que hacen referencia a la clave.  
  
 Borrar el valor de propiedad llamando a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar el valor solo borra específicamente cualquier valor local se hayan aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó llamar a <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> en un <see cref="T:System.Windows.DependencyObject" /> sellado.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de la propiedad de dependencia que se va a convertir.</param>
        <summary>Convierte el valor de la propiedad de dependencia especificada. Esto se logra invocando cualquier función <see cref="T:System.Windows.CoerceValueCallback" /> especificada en los metadatos de la propiedad de dependencia tal como existe en la clase <see cref="T:System.Windows.DependencyObject" /> que llama.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de que se va a invocar explícitamente llamando a <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> de una dependencia de propiedad también se invoca internamente cuando el valor de propiedad de dependencia es que se vuelve a evaluar el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades.  
  
 Cuando se invoca el <xref:System.Windows.DependencyObject.CoerceValue%2A> método, en última instancia que se está invocando la devolución de llamada de valor forzado de la propiedad que especifique. Normalmente invocará <xref:System.Windows.DependencyObject.CoerceValue%2A> solo si sabe que existe una devolución de llamada de valor forzado, y si conoce los criterios de la devolución de llamada de conversión.  
  
 El escenario más común para llamar a <xref:System.Windows.DependencyObject.CoerceValue%2A> está dentro de la clase control o una propiedad cambio las devoluciones de llamada de propiedades relacionadas que influyen en los valores de todas las demás de forma dependiente. Para obtener más información, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.CoerceValue%2A> dentro de un <xref:System.Windows.PropertyChangedCallback> implementación que se utiliza como el <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> un diferentes propiedades de dependencia en la misma clase. Se trata de un modelo común para introducir las dependencias de valor true entre las propiedades de dependencia.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El parámetro <paramref name="dp" /> especificado o su valor no eran válidos o no existían.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Windows.DependencyObjectType" /> que ajusta el tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] de esta instancia.</summary>
        <value>
          <see cref="T:System.Windows.DependencyObjectType" /> que ajusta el tipo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] de esta instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es útil si un objeto que se devuelve desde un método tiene un tipo de valor devuelto de <xref:System.Windows.DependencyObject> y desea realizar la propiedad operaciones específicas del sistema en él según su tipo. Por ejemplo es más eficaz llamar a <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> mediante la <xref:System.Windows.DependencyObjectType> en lugar del [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita la búsqueda rápida.  
  
   
  
## Examples  
 En el siguiente ejemplo de pseudocódigo `MySubClass` prevé que las clases derivadas adicionales pueden cambiar el valor predeterminado de la `MyCustom` propiedad de dependencia. La clase implementa un constructor predeterminado que se puede determinar la clase derivada real aprovechando las ventajas de polimorfismo el <xref:System.Windows.DependencyObjectType> valor cada vez que se utiliza este constructor como creador de instancias de una clase derivada.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.DependencyObject" /> que se va a comparar con la instancia actual.</param>
        <summary>Determina si un objeto <see cref="T:System.Windows.DependencyObject" /> proporcionado es equivalente al objeto <see cref="T:System.Windows.DependencyObject" /> actual.</summary>
        <returns>
          Es <see langword="true" /> si las dos instancias son iguales; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación es únicamente la igualdad de referencia y no intenta evaluar la igualdad de valores de las propiedades contenidas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos basic <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que da lugar a un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que las clases derivadas intenten definir una igualdad de valor para un <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> no, nunca será preciso debido a las capacidades de cambio de valor de propiedad natural de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] características como el enlace de datos y el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un código hash de este objeto <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Código hash entero de 32 bits con signo.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que da lugar a un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que las clases derivadas intenten definir una igualdad de valor para un <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> no, nunca será preciso debido a las capacidades de cambio de valor de propiedad natural de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] características como el enlace de datos y el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un enumerador especializado para determinar qué propiedades de dependencia han establecido localmente los valores en <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Enumerador de valor local especializado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *valor local* es cualquier valor de propiedad de dependencia que estableció <xref:System.Windows.DependencyObject.SetValue%2A>, en lugar de a otros aspectos del sistema de propiedades.  
  
 El <xref:System.Windows.LocalValueEnumerator> obtenido mediante una llamada a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> puede utilizar para enumerar propiedades que tienen establecida localmente un valor en un <xref:System.Windows.DependencyObject> instancia. Cada propiedad de este tipo se representa en el enumerador mediante un <xref:System.Windows.LocalValueEntry> objeto, que tiene propiedades que hacen referencia a específico del <xref:System.Windows.DependencyProperty> y sus valores. Esta técnica de enumerar sobre establecida localmente valores pueden utilizarse para la optimización o para otro control de valores locales, como por ejemplo, para determinar qué valores de propiedad de un <xref:System.Windows.DependencyObject> podría cambiar si borraron.  
  
> [!IMPORTANT]
>  El valor devuelto <xref:System.Windows.LocalValueEnumerator> podría contener <xref:System.Windows.LocalValueEntry> registros para las propiedades de dependencia que son de solo lectura o las propiedades de dependencia que se calculan los valores por el sistema de propiedades. Por ejemplo, un elemento de marco visual que tiene un ancho establecido a través del diseño informará de un valor local para <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Si va a obtener valores locales para restablecerlos, compruebe el <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor en el identificador de la propiedad de cada <xref:System.Windows.LocalValueEntry> para comprobar que la <xref:System.Windows.DependencyProperty> en cuestión no es de solo lectura.  
  
   
  
## Examples  
 En el ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de <see cref="T:System.Windows.DependencyProperty" /> de la propiedad para la que se recupera el valor.</param>
        <summary>Devuelve el valor efectivo actual de una propiedad de dependencia en esta instancia de un <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Devuelve el valor efectivo actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El *valor efectivo* es el valor de la propiedad que es devuelto por el sistema de propiedades a cualquier llamador que solicita el valor. El valor efectivo es el resultado del sistema de propiedades evalúe todas las entradas posibles que participan en la prioridad de valores de sistema de propiedad. Esto incluye conversión y animación. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Este método nunca devolverá <xref:System.Windows.DependencyProperty.UnsetValue>. El <xref:System.Windows.DependencyProperty.UnsetValue> es un valor centinela para el sistema de propiedades que se usa en varias capacidades internamente y en ocasiones también se exponen a través de las devoluciones de llamada de conversión.  
  
 Si no está seguro de cuál debe ser el tipo de propiedad, puede consultar el identificador de la propiedad de dependencia solicitada para determinar si hay un determinado más <xref:System.Windows.DependencyProperty.PropertyType%2A> que el valor devuelto se puede convertir en.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El parámetro <paramref name="dp" /> especificado o su valor no eran válidos o el parámetro <paramref name="dp" /> especificado no existe.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de <see cref="T:System.Windows.DependencyProperty" /> de la propiedad que se debe invalidar.</param>
        <summary>Vuelve a evaluar el valor efectivo para la propiedad de dependencia especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, cualquier asociado y es aplicable <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones registrados para esa propiedad de dependencia puede invocarse.  
  
 Al llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad que tiene establecido su valor local no tiene ningún efecto, porque el valor local tiene prioridad sobre otras entradas del sistema de propiedades, excepto las animaciones. Sin embargo, podría llamar a <xref:System.Windows.DependencyObject.ClearValue%2A>, a continuación, llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Al llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> no es necesariamente aplicable a muchos escenarios de propiedad de dependencia. Si una propiedad de dependencia se invalida debido a los cambios de valor en cualquiera de los componentes, el sistema de propiedades invalida y vuelve a evaluar la propiedad de dependencia automáticamente. Sin embargo, todavía hay algunos escenarios adecuados donde <xref:System.Windows.DependencyObject.InvalidateProperty%2A> es útil. En concreto, puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dentro de la propiedad o valor forzado cambiado devolución de llamada para una propiedad de dependencia diferente. También puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> para forzar la reevaluación de un enlace con un origen de datos que no es capaz de implementar tal como se recomienda <xref:System.ComponentModel.INotifyPropertyChanged> mecanismo de notificación (quizás si clases de datos que no se puede derivar o donde los datos están un miembro estático).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad personalizada, siempre que cambian las propiedades que están implicadas en los cálculos de la propiedad invalidada. Se trata de una técnica alternativa a llamar a la <xref:System.Windows.DependencyObject.CoerceValue%2A> método, porque lo que invalida la propiedad también se llama a cualquier registrado <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si esta instancia está actualmente sellada (es de solo lectura).</summary>
        <value>
          <see langword="true" /> si se sella esta instancia; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se establece internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos de evento que contendrán el identificador de propiedad de dependencia de interés, los metadatos del tipo de propiedad, y valores antiguos y nuevos.</param>
        <summary>Se invoca cada vez que se actualiza el valor efectivo de una propiedad de dependencia de este control <see cref="T:System.Windows.DependencyObject" />. La propiedad de dependencia específica que cambió se notifica en los datos de evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no está pensado para detectar generalmente cambios de propiedad individual o realizar invalidaciones de las propiedades por caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> en su lugar se está diseñado para que las modificaciones del modelo de invalidación general, si se conoce cierta información sobre amplias clasificaciones de propiedades. Por ejemplo, se cambia en una <xref:System.Windows.Freezable> pueden producirse cambios en los tipos de valor de la <xref:System.Windows.Freezable>, o podrían ser subpropiedades, donde los cambios están dentro de otros <xref:System.Windows.Freezable> referencias. El <xref:System.Windows.Freezable> invalidar la implementación de <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> información interna se utiliza para determinar si las propiedades son subpropiedades y proporciona la lógica de la clase base adecuada para cualquiera de los casos.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> se invoca posiblemente muchas veces durante la vida de un objeto. Por lo tanto, puede lograr un mejor rendimiento para el sistema de propiedades general si invalida los metadatos de propiedades concretas y, a continuación, adjuntar <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones para las propiedades individuales. Sin embargo, use este método si un <xref:System.Windows.DependencyObject> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como el comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Llame siempre a la implementación base. Si no es así, se deshabilitará significativamente toda la matriz [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades, que produce valores incorrectos que se notificarán.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de <see cref="T:System.Windows.DependencyProperty" /> de la propiedad para la que se recupera el valor.</param>
        <summary>Devuelve el valor local de una propiedad de dependencia, si existe.</summary>
        <returns>Devuelve el valor local o devuelve el campo <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> del valor centinela si no se establece ningún valor local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe usar <xref:System.Windows.DependencyObject.GetValue%2A> para las operaciones más comunes para una propiedad de dependencia "get". <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Devuelve el valor efectivo para una variedad de circunstancias donde localmente no se estableció el valor.  
  
 Valores establecidos por estilos, temas, plantillas, el valor predeterminado de los metadatos o la herencia del valor de propiedad no se consideran valores locales. Sin embargo, los enlaces y otras expresiones se consideran valores locales, una vez que se han evaluado.  
  
 Cuando se establece ningún valor local, este método devuelve <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Si el valor devuelto es distinto de <xref:System.Windows.DependencyProperty.UnsetValue>, puede consultar los metadatos de la propiedad de dependencia solicitada para determinar si hay un tipo más específico que el valor devuelto se puede convertir en.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de la propiedad de dependencia que se va a establecer.</param>
        <param name="value">Nuevo valor local.</param>
        <summary>Establece el valor de una propiedad de dependencia sin cambiar el origen de su valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa un componente que se establece mediante programación el valor de uno de sus propias propiedades sin necesidad de deshabilitar el uso declarado de una aplicación de la propiedad. El <xref:System.Windows.DependencyObject.SetCurrentValue%2A> método cambia el valor efectivo de la propiedad, pero los desencadenadores existentes, los enlaces de datos y estilos continuarán funcionando.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó modificar una propiedad de dependencia de sólo lectura o una propiedad en un <see cref="T:System.Windows.DependencyObject" /> sellado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no era el tipo correcto registrado para la propiedad <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve el valor local de una propiedad de dependencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Identificador de la propiedad de dependencia que se va a establecer.</param>
        <param name="value">Nuevo valor local.</param>
        <summary>Establece el valor local de una propiedad de dependencia, especificado por su identificador de propiedad de dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal y como se registró originalmente, se produce una excepción. El `value` siempre deben proporcionar parámetros como el tipo adecuado.  
  
 Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de la propiedad de dependencia de la propiedad de dependencia que se va a establecer. En caso contrario, el valor proporcionado podría producir un error generales condiciones de comprobación de tipos (por ejemplo, si se pasa una cadena al tipo nativo es Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentó modificar una propiedad de dependencia de sólo lectura o una propiedad en un <see cref="T:System.Windows.DependencyObject" /> sellado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no era el tipo correcto registrado para la propiedad <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Identificador <see cref="T:System.Windows.DependencyPropertyKey" /> de la propiedad que se va a establecer.</param>
        <param name="value">Nuevo valor local.</param>
        <summary>Establece el valor local de una propiedad de dependencia de solo lectura, especificado por el identificador <see cref="T:System.Windows.DependencyPropertyKey" /> de la propiedad de dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma se utiliza generalmente al establecer los valores para las propiedades de dependencia de solo lectura que se definen mediante las clases personalizadas. Por lo general, <xref:System.Windows.DependencyObject.SetValue%2A> solo se llama desde el tipo que registró esa propiedad de dependencia, que implementa la lógica interna que proporciona el valor determinado para la propiedad de dependencia. Para obtener más información, consulte [Propiedades de dependencia de solo lectura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal y como se registró originalmente, se produce una excepción. El `value` siempre deben proporcionar parámetros como el tipo adecuado. Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de la propiedad de dependencia de la propiedad de dependencia que se va a establecer.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una propiedad de dependencia de solo lectura, junto con un `public static readonly` <xref:System.Windows.DependencyProperty> que proporciona la exposición de solo lectura es necesaria para los consumidores de propiedad y el descriptor de acceso get el [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedor.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">El identificador de la propiedad de dependencia que se debe serializar.</param>
        <summary>Devuelve un valor que indica si los procesos de serialización deben serializar el valor de la propiedad de dependencia suministrada.</summary>
        <returns>
          <see langword="true" /> si la propiedad de dependencia que se proporciona debe serializarse por valor; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `true` para todos los casos en que una propiedad de dependencia tenía un valor local establecido en el <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Invalidaciones de este método pueden administrar las propiedades de dependencia específica de manera diferente.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>