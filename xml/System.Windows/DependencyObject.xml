<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b20096950e5ef29b8ab06fba5406a44bbc3ff7f2" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461260" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type DependencyObject = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an object that participates in the dependency property system.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.DependencyObject> clase permite [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] servicios del sistema de propiedades en sus numerosas clases derivadas.  
  
 Función principal del sistema de propiedades es para calcular los valores de propiedades y para proporcionar una notificación del sistema acerca de los valores que han cambiado. Otra clase clave que participa en el sistema de propiedades es <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> habilita el registro de propiedades de dependencia en el sistema de propiedades y proporciona identificación e información sobre cada propiedad de dependencia, mientras que <xref:System.Windows.DependencyObject> como una clase base permite a los objetos usar las propiedades de dependencia.  
  
 <xref:System.Windows.DependencyObject> servicios y características son los siguientes:  
  
-   Compatibilidad con el host la propiedad de dependencia. Registrar una propiedad de dependencia mediante una llamada a la <xref:System.Windows.DependencyProperty.Register%2A> método y almacenar el valor devuelto del método como un campo estático público en la clase.  
  
-   Compatibilidad con el host de propiedad adjunta. Registrar una propiedad adjunta mediante una llamada a la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método y almacenar el valor devuelto del método como un campo de solo lectura público estático en la clase. (También existen requisitos de miembro adicionales, tenga en cuenta que esto representa un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementación específica para las propiedades asociadas. Para obtener más información, consulte [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).) A continuación, se puede establecer la propiedad adjunta en cualquier clase que deriva de <xref:System.Windows.DependencyObject>.  
  
-   Get, set y desactive los métodos de utilidad para los valores de las propiedades de dependencia que existen en el <xref:System.Windows.DependencyObject>.  
  
-   Metadatos, convertir el valor compatibilidad, notificación de cambio de propiedad y las devoluciones de llamada de invalidación para propiedades de dependencia o propiedades adjuntas. Además, la <xref:System.Windows.DependencyObject> clase facilita los metadatos de propiedad por propietario para una propiedad de dependencia.  
  
-   Una clase base común para las clases derivadas de <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, o <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, otra clase de elemento base, tiene una jerarquía de clases que incluye <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 En el ejemplo siguiente se deriva de <xref:System.Windows.DependencyObject> para crear una nueva clase abstracta. La clase, a continuación, registra una propiedad adjunta e incluye miembros compatibles con la propiedad asociada.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.DependencyObject" /> class.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Clears the local value of a property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.ClearValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The dependency property to be cleared, identified by a <see cref="T:System.Windows.DependencyProperty" /> object reference.</param>
        <summary>Clears the local value of a property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyProperty" /> identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Borrar el valor de propiedad llamando a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar la propiedad solo borra específicamente cualquier valor local se hayan aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.ClearValue : System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyObject.ClearValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">The key for the dependency property to be cleared.</param>
        <summary>Clears the local value of a read-only property. The property to be cleared is specified by a <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyPropertyKey> identifica una propiedad de dependencia de solo lectura para las operaciones de sistema de propiedades. Las clases que definen las propiedades de dependencia de solo lectura no deben exponer esta clave con acceso público. Una clave públicamente expuesta proporcionaría una ruta de código pública que niega el carácter de solo lectura de la propiedad, si métodos como <xref:System.Windows.DependencyObject.ClearValue%2A> o <xref:System.Windows.DependencyObject.SetValue%2A> se podría llamar fuera de la clase o un ensamblado, que hacen referencia a la clave.  
  
 Borrar el valor de propiedad llamando a <xref:System.Windows.DependencyObject.ClearValue%2A> no necesariamente a una propiedad de dependencia el valor predeterminado que se especifica en los metadatos de propiedad de dependencia. Al borrar el valor solo borra específicamente cualquier valor local se hayan aplicado. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to call <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.CoerceValue : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.CoerceValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property to coerce.</param>
        <summary>Coerces the value of the specified dependency property. This is accomplished by invoking any <see cref="T:System.Windows.CoerceValueCallback" /> function specified in property metadata for the dependency property as it exists on the calling <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Además de que se va a invocar explícitamente llamando a <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> de una dependencia de propiedad también se invoca internamente cuando el valor de propiedad de dependencia es que se vuelve a evaluar el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades.  
  
 Cuando se invoca el <xref:System.Windows.DependencyObject.CoerceValue%2A> método, en última instancia que se está invocando la devolución de llamada de valor forzado de la propiedad que especifique. Normalmente invocará <xref:System.Windows.DependencyObject.CoerceValue%2A> solo si sabe que existe una devolución de llamada de valor forzado, y si conoce los criterios de la devolución de llamada de conversión.  
  
 El escenario más común para llamar a <xref:System.Windows.DependencyObject.CoerceValue%2A> está dentro de la clase control o una propiedad cambio las devoluciones de llamada de propiedades relacionadas que influyen en los valores de todas las demás de forma dependiente. Para obtener más información, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.CoerceValue%2A> dentro de un <xref:System.Windows.PropertyChangedCallback> implementación que se utiliza como el <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> un diferentes propiedades de dependencia en la misma clase. Se trata de un modelo común para introducir las dependencias de valor true entre las propiedades de dependencia.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value were invalid or do not exist.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependencyObjectType : System.Windows.DependencyObjectType" Usage="System.Windows.DependencyObject.DependencyObjectType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Windows.DependencyObjectType" /> that wraps the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] type of this instance.</summary>
        <value>Un <see cref="T:System.Windows.DependencyObjectType" /> que ajusta la [! Tipo de include[TLA2#tla_clr](~/includes/tla2sharptla-CLR-MD.MD)] de esta instancia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es útil si un objeto que se devuelve desde un método tiene un tipo de valor devuelto de <xref:System.Windows.DependencyObject> y desea realizar la propiedad operaciones específicas del sistema en él según su tipo. Por ejemplo es más eficaz llamar a <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> mediante la <xref:System.Windows.DependencyObjectType> en lugar del [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] tipo. <xref:System.Windows.DependencyObjectType> facilita la búsqueda rápida.  
  
   
  
## Examples  
 En el siguiente ejemplo de pseudocódigo `MySubClass` prevé que las clases derivadas adicionales pueden cambiar el valor predeterminado de la `MyCustom` propiedad de dependencia. La clase implementa un constructor predeterminado que se puede determinar la clase derivada real aprovechando las ventajas de polimorfismo el <xref:System.Windows.DependencyObjectType> valor cada vez que se utiliza este constructor como creador de instancias de una clase derivada.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="dependencyObject.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Windows.DependencyObject" /> to compare to the current instance.</param>
        <summary>Determines whether a provided <see cref="T:System.Windows.DependencyObject" /> is equivalent to the current <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" /> if the two instances are the same; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación es únicamente la igualdad de referencia y no intenta evaluar la igualdad de valores de las propiedades contenidas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos basic <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que da lugar a un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que las clases derivadas intenten definir una igualdad de valor para un <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> no, nunca será preciso debido a las capacidades de cambio de valor de propiedad natural de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [! Características de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)], como el enlace de datos y la [! Sistema de propiedades de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyObject.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a hash code for this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A signed 32-bit integer hash code.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> invalida y, a continuación, sella dos <see cref="T:System.Object" /> métodos: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> y <see cref="M:System.Windows.DependencyObject.GetHashCode" />. La llamada de invalidaciones del <see cref="T:System.Object" /> implementaciones, lo que da lugar a un comportamiento de igualdad de objetos. El propósito de estas invalidaciones deliberadas es impedir que las clases derivadas intenten definir una igualdad de valor para un <see cref="T:System.Windows.DependencyObject" />. Valor igualdades para <see cref="T:System.Windows.DependencyObject" /> no, nunca será preciso debido a las capacidades de cambio de valor de propiedad natural de un <see cref="T:System.Windows.DependencyObject" /> y sus propiedades de dependencia. Esto incluye fundamentales [! Características de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)], como el enlace de datos y la [! Sistema de propiedades de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)].</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetLocalValueEnumerator : unit -&gt; System.Windows.LocalValueEnumerator" Usage="dependencyObject.GetLocalValueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a specialized enumerator for determining which dependency properties have locally set values on this <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>A specialized local value enumerator.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *valor local* es cualquier valor de propiedad de dependencia que estableció <xref:System.Windows.DependencyObject.SetValue%2A>, en lugar de a otros aspectos del sistema de propiedades.  
  
 El <xref:System.Windows.LocalValueEnumerator> obtenido mediante una llamada a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> puede utilizar para enumerar propiedades que tienen establecida localmente un valor en un <xref:System.Windows.DependencyObject> instancia. Cada propiedad de este tipo se representa en el enumerador mediante un <xref:System.Windows.LocalValueEntry> objeto, que tiene propiedades que hacen referencia a específico del <xref:System.Windows.DependencyProperty> y sus valores. Esta técnica de enumerar sobre establecida localmente valores pueden utilizarse para la optimización o para otro control de valores locales, como por ejemplo, para determinar qué valores de propiedad de un <xref:System.Windows.DependencyObject> podría cambiar si borraron.  
  
> [!IMPORTANT]
>  El valor devuelto <xref:System.Windows.LocalValueEnumerator> podría contener <xref:System.Windows.LocalValueEntry> registros para las propiedades de dependencia que son de solo lectura o las propiedades de dependencia que se calculan los valores por el sistema de propiedades. Por ejemplo, un elemento de marco visual que tiene un ancho establecido a través del diseño informará de un valor local para <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Si va a obtener valores locales para restablecerlos, compruebe el <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor en el identificador de la propiedad de cada <xref:System.Windows.LocalValueEntry> para comprobar que la <xref:System.Windows.DependencyProperty> en cuestión no es de solo lectura.  
  
   
  
## Examples  
 En el ejemplo siguiente se recorre en iteración todas las propiedades que tienen valores locales establecidos en un objeto, a continuación, llama <xref:System.Windows.DependencyObject.ClearValue%2A> para borrar los valores de cada propiedad de este tipo.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.GetValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the current effective value of a dependency property on this instance of a <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Returns the current effective value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El *valor efectivo* es el valor de la propiedad que es devuelto por el sistema de propiedades a cualquier llamador que solicita el valor. El valor efectivo es el resultado del sistema de propiedades evalúe todas las entradas posibles que participan en la prioridad de valores de sistema de propiedad. Esto incluye conversión y animación. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Este método nunca devolverá <xref:System.Windows.DependencyProperty.UnsetValue>. El <xref:System.Windows.DependencyProperty.UnsetValue> es un valor centinela para el sistema de propiedades que se usa en varias capacidades internamente y en ocasiones también se exponen a través de las devoluciones de llamada de conversión.  
  
 Si no está seguro de cuál debe ser el tipo de propiedad, puede consultar el identificador de la propiedad de dependencia solicitada para determinar si hay un determinado más <xref:System.Windows.DependencyProperty.PropertyType%2A> que el valor devuelto se puede convertir en.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The specified <paramref name="dp" /> or its value was invalid, or the specified <paramref name="dp" /> does not exist.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.InvalidateProperty : System.Windows.DependencyProperty -&gt; unit" Usage="dependencyObject.InvalidateProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to invalidate.</param>
        <summary>Re-evaluates the effective value for the specified dependency property</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se llama a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, cualquier asociado y es aplicable <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones registrados para esa propiedad de dependencia puede invocarse.  
  
 Al llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad que tiene establecido su valor local no tiene ningún efecto, porque el valor local tiene prioridad sobre otras entradas del sistema de propiedades, excepto las animaciones. Sin embargo, podría llamar a <xref:System.Windows.DependencyObject.ClearValue%2A>, a continuación, llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Al llamar a <xref:System.Windows.DependencyObject.InvalidateProperty%2A> no es necesariamente aplicable a muchos escenarios de propiedad de dependencia. Si una propiedad de dependencia se invalida debido a los cambios de valor en cualquiera de los componentes, el sistema de propiedades invalida y vuelve a evaluar la propiedad de dependencia automáticamente. Sin embargo, todavía hay algunos escenarios adecuados donde <xref:System.Windows.DependencyObject.InvalidateProperty%2A> es útil. En concreto, puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> dentro de la propiedad o valor forzado cambiado devolución de llamada para una propiedad de dependencia diferente. También puede usar <xref:System.Windows.DependencyObject.InvalidateProperty%2A> para forzar la reevaluación de un enlace con un origen de datos que no es capaz de implementar tal como se recomienda <xref:System.ComponentModel.INotifyPropertyChanged> mecanismo de notificación (quizás si clases de datos que no se puede derivar o donde los datos están una variable static miembro).  
  
   
  
## Examples  
 El ejemplo siguiente se llama <xref:System.Windows.DependencyObject.InvalidateProperty%2A> en una propiedad personalizada, siempre que cambian las propiedades que están implicadas en los cálculos de la propiedad invalidada. Se trata de una técnica alternativa a llamar a la <xref:System.Windows.DependencyObject.CoerceValue%2A> método, porque lo que invalida la propiedad también se llama a cualquier registrado <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Windows.DependencyObject.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether this instance is currently sealed (read-only).</summary>
        <value>
          <see langword="true" /> Si esta instancia está sellada; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se establece internamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="dependencyObject.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Event data that will contain the dependency property identifier of interest, the property metadata for the type, and old and new values.</param>
        <summary>Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.DependencyObject" /> has been updated. The specific dependency property that changed is reported in the event data.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no está pensado para detectar generalmente cambios de propiedad individual o realizar invalidaciones de las propiedades por caso. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> en su lugar se está diseñado para que las modificaciones del modelo de invalidación general, si se conoce cierta información sobre amplias clasificaciones de propiedades. Por ejemplo, se cambia en una <xref:System.Windows.Freezable> pueden producirse cambios en los tipos de valor de la <xref:System.Windows.Freezable>, o podrían ser subpropiedades, donde los cambios están dentro de otros <xref:System.Windows.Freezable> referencias. El <xref:System.Windows.Freezable> invalidar la implementación de <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> información interna se utiliza para determinar si las propiedades son subpropiedades y proporciona la lógica de la clase base adecuada para cualquiera de los casos.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> se invoca posiblemente muchas veces durante la vida de un objeto. Por lo tanto, puede lograr un mejor rendimiento para el sistema de propiedades general si invalida los metadatos de propiedades concretas y, a continuación, adjuntar <xref:System.Windows.CoerceValueCallback> o <xref:System.Windows.PropertyChangedCallback> funciones para las propiedades individuales. Sin embargo, use este método si un <xref:System.Windows.DependencyObject> incluye un número significativo de propiedades de dependencia interrelacionadas por valor, o si incluye lógica como el comportamiento de representación que se debe volver a ejecutar para varios casos de invalidaciones de propiedad relacionados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Llame siempre a la implementación base. Si no es así, se deshabilitará significativamente toda la matriz [! Sistema de propiedades de include[TLA2#tla_winclient](~/includes/tla2sharptla-WinClient-MD.MD)], que produce valores incorrectos que se notificarán.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.ReadLocalValue : System.Windows.DependencyProperty -&gt; obj" Usage="dependencyObject.ReadLocalValue dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The <see cref="T:System.Windows.DependencyProperty" /> identifier of the property to retrieve the value for.</param>
        <summary>Returns the local value of a dependency property, if it exists.</summary>
        <returns>Returns the local value, or returns the sentinel value <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> if no local value is set.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe usar <xref:System.Windows.DependencyObject.GetValue%2A> para las operaciones más comunes para una propiedad de dependencia "get". <xref:System.Windows.DependencyObject.ReadLocalValue%2A> Devuelve el valor efectivo para una variedad de circunstancias donde localmente no se estableció el valor.  
  
 Valores establecidos por estilos, temas, plantillas, el valor predeterminado de los metadatos o la herencia del valor de propiedad no se consideran valores locales. Sin embargo, los enlaces y otras expresiones se consideran valores locales, una vez que se han evaluado.  
  
 Cuando se establece ningún valor local, este método devuelve <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Si el valor devuelto es distinto de <xref:System.Windows.DependencyProperty.UnsetValue>, puede consultar los metadatos de la propiedad de dependencia solicitada para determinar si hay un tipo más específico que el valor devuelto se puede convertir en.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetCurrentValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetCurrentValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the value of a dependency property without changing its value source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa un componente que se establece mediante programación el valor de uno de sus propias propiedades sin necesidad de deshabilitar el uso declarado de una aplicación de la propiedad. El <xref:System.Windows.DependencyObject.SetCurrentValue%2A> método cambia el valor efectivo de la propiedad, pero los desencadenadores existentes, los enlaces de datos y estilos continuarán funcionando.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sets the local value of a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyProperty * obj -&gt; unit" Usage="dependencyObject.SetValue (dp, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier of the dependency property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a dependency property, specified by its dependency property identifier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal y como se registró originalmente, se produce una excepción. El `value` siempre deben proporcionar parámetros como el tipo adecuado.  
  
 Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de la propiedad de dependencia de la propiedad de dependencia que se va a establecer. En caso contrario, el valor proporcionado podría producir un error generales condiciones de comprobación de tipos (por ejemplo, si se pasa una cadena al tipo nativo es Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Attempted to modify a read-only dependency property, or a property on a sealed <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> was not the correct type as registered for the <paramref name="dp" /> property.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetValue : System.Windows.DependencyPropertyKey * obj -&gt; unit" Usage="dependencyObject.SetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">The <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the property to set.</param>
        <param name="value">The new local value.</param>
        <summary>Sets the local value of a read-only dependency property, specified by the <see cref="T:System.Windows.DependencyPropertyKey" /> identifier of the dependency property.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma se utiliza generalmente al establecer los valores para las propiedades de dependencia de solo lectura que se definen mediante las clases personalizadas. Por lo general, <xref:System.Windows.DependencyObject.SetValue%2A> solo se llama desde el tipo que registró esa propiedad de dependencia, que implementa la lógica interna que proporciona el valor determinado para la propiedad de dependencia. Para obtener más información, consulte [Propiedades de dependencia de solo lectura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Si el tipo proporcionado no coincide con el tipo declarado de la propiedad de dependencia tal y como se registró originalmente, se produce una excepción. El `value` siempre deben proporcionar parámetros como el tipo adecuado. Las condiciones de excepción potencialmente se ven afectadas por la <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> devolución de llamada que existe en el identificador de la propiedad de dependencia de la propiedad de dependencia que se va a establecer.  
  
   
  
## Examples  
 En el ejemplo siguiente se define una propiedad de dependencia de solo lectura, junto con un `public static readonly` <xref:System.Windows.DependencyProperty> que proporciona la exposición de solo lectura es necesaria para los consumidores de propiedad y el descriptor de acceso get el [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedor.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool&#xA;override this.ShouldSerializeProperty : System.Windows.DependencyProperty -&gt; bool" Usage="dependencyObject.ShouldSerializeProperty dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">The identifier for the dependency property that should be serialized.</param>
        <summary>Returns a value that indicates whether serialization processes should serialize the value for the provided dependency property.</summary>
        <returns>
          <see langword="true" /> if the dependency property that is supplied should be value-serialized; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada devuelve `true` para todos los casos en que una propiedad de dependencia tenía un valor local establecido en el <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Invalidaciones de este método pueden administrar las propiedades de dependencia específica de manera diferente.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>