<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b4daa92282153a35abd2da928e1de70dd1be505d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680009" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Administra estados y la lógica para la transición entre estados de los controles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.VisualStateManager> le permite especificar los Estados para un control, la apariencia de un control cuando se encuentra en un estado determinado, y cuando un control cambia de estado. Por ejemplo, un <xref:System.Windows.Controls.Button> podría tener un aspecto ligeramente diferente cuando se presiona que cuando no está presionado. Dos Estados que el <xref:System.Windows.Controls.Button> define corresponden a cuando se presiona (`"Pressed"`) y cuando no es (`"Normal"`). La apariencia de un control cuando se encuentra en un estado se define mediante un <xref:System.Windows.VisualState>. A <xref:System.Windows.VisualState> contiene una colección de <xref:System.Windows.Media.Animation.Storyboard> objetos que especifican cómo se cambia la apariencia del control cuando el control está en ese estado. Agregar estados visuales a un control estableciendo la `VisualStateManager.VisualStateGroups` propiedad adjunta en el control. Cada <xref:System.Windows.VisualStateGroup> contiene una colección de <xref:System.Windows.VisualState> objetos que se excluyen mutuamente. Es decir, el control siempre está en exactamente un estado de en cada <xref:System.Windows.VisualStateGroup>.  
  
 El <xref:System.Windows.VisualStateManager> también le permite especificar cuándo un control entra en un estado específico. El método que se debe llamar al cambiar estados depende de su escenario. Si crea un control que usa el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>, llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método. Para obtener más información sobre cómo crear controles que usan el <xref:System.Windows.VisualStateManager>, consulte [crear un Control que tiene una apariencia personalizable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md). Si usa el <xref:System.Windows.VisualStateManager> fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si utiliza un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.Controls.UserControl> o en un único elemento), llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método. En cualquier caso, el <xref:System.Windows.VisualStateManager> ejecuta la lógica necesaria para iniciar y detener los guiones gráficos que están asociados con el estado implicado apropiadamente. Por ejemplo, suponga que un control define los Estados, `State1` y `State2`, cada uno de los cuales tiene un guión gráfico asociado. Si el control está en `State1` y pasa `State2` a <xref:System.Windows.VisualStateManager.GoToState%2A> o <xref:System.Windows.VisualStateManager.GoToElementState%2A>, <xref:System.Windows.VisualStateManager> inicia el guión gráfico en `State2` y detiene el guión gráfico de `State1`.  
  
 Controles que se incluyen con [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] usar el <xref:System.Windows.VisualStateManager> para cambiar los estados visuales. Cuando se crea un <xref:System.Windows.Controls.ControlTemplate> para un control que se incluye con [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], puede agregar <xref:System.Windows.VisualState> objetos para el control <xref:System.Windows.Controls.ControlTemplate> para especificar la apariencia del control en un estado determinado. Para buscar los nombres de los estados visuales para los controles que se incluyen con [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], consulte [plantillas y estilos de Control](~/docs/framework/wpf/controls/control-styles-and-templates.md). Administra la lógica del control transición entre Estados, por lo que no es necesario hacer nada más que define la <xref:System.Windows.VisualState> objetos en el nuevo <xref:System.Windows.Controls.ControlTemplate>. Para obtener más información acerca de cómo crear plantillas de control para los controles existentes, vea [personalizar la apariencia de un Control existente mediante la creación de un elemento ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
 Si desea implementar su propia lógica para realizar la transición entre Estados, debe heredar de <xref:System.Windows.VisualStateManager>, invalidar la <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método y establezca la <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> propiedad adjunta en el control que utiliza la lógica personalizada.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Windows.Shapes.Rectangle> y agrega un <xref:System.Windows.VisualStateGroup> denominado `CommonStates` a la `VisualStateManager.VisualStatesGroups` propiedad adjunta. En el ejemplo se define la `MouseOver` y `Normal` <xref:System.Windows.VisualState> objetos en el `CommonStates` <xref:System.Windows.VisualStateGroup>. Cuando el usuario mueve el puntero del mouse sobre la <xref:System.Windows.Shapes.Rectangle>, cambia de rojo a verde durante medio segundo. Cuando el usuario mueve el mouse fuera del rectángulo, el <xref:System.Windows.Controls.Grid> inmediatamente cambios de vuelta a rojo. Tenga en cuenta que la `Normal` estado no define una <xref:System.Windows.Media.Animation.Storyboard>. A <xref:System.Windows.Media.Animation.Storyboard> no es necesario porque cuando el <xref:System.Windows.Shapes.Rectangle> realiza la transición de la `MouseOver` estado para la `Normal` estado, el <xref:System.Windows.Media.Animation.Storyboard> para `MouseOver` se detiene y la <xref:System.Windows.Media.SolidColorBrush.Color%2A> propiedad para el <xref:System.Windows.Media.SolidColorBrush> devuelve en rojo.  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 En el ejemplo siguiente se muestra el controlador de eventos que se define en el ejemplo anterior y llama el <xref:System.Windows.VisualStateManager.GoToElementState%2A> método para realizar la transición entre Estados. Si el rectángulo en el ejemplo anterior formaba parte de un <xref:System.Windows.Controls.ControlTemplate>, el ejemplo tendría que llamar a la <xref:System.Windows.VisualStateManager.GoToState%2A> método.  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.VisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Elemento cuya propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> se va a obtener.</param>
        <summary>Obtiene la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <returns>Administrador de estado visual que realiza la transición entre los estados de un control.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Elemento cuya propiedad adjunta <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" /> se va a obtener.</param>
        <summary>Obtiene la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <returns>Colección de objetos <see cref="T:System.Windows.VisualStateGroup" /> asociada al objeto especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">El estado al que se realiza la transición.</param>
        <param name="useTransitions">
          Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición del elemento entre dos estados. Utilice este método para la transición de estados definidos por una aplicación, en lugar de definidos por un control.</summary>
        <returns>
          <see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método para cambiar estados en un elemento fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si utiliza un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.DataTemplate> o <xref:System.Windows.Window>). Llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método si va a cambiar estados en un control que usa el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una aplicación que pide al usuario que adivine un número entre 1 y 100.  Cuando el usuario escriba un número, la aplicación indica si la estimación es demasiado alto, correcto o demasiado bajo.  El siguiente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] crea la interfaz de usuario para la aplicación y define los 4 estados: `TooLow`, `TooHigh`, `Correct`, y `Guessing`. Cuando la aplicación se inicia, se encuentra en la `Guessing` estado. .  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 El código siguiente muestra la lógica de la aplicación.  Cuando el usuario entra en un número y haga clic en el botón, la aplicación llama a <xref:System.Windows.VisualStateManager.GoToElementState%2A> para realizar la transición a `TooHigh`, `TooLow`, o `Correct` para proporcionar comentarios al usuario acerca de la estimación.  Para probar este ejemplo, llame a la `GenerateNumber` método cuando se inicia la aplicación.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="stateName" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Control del que se va a realizar la transición entre estados.</param>
        <param name="stateName">El estado al que se realiza la transición.</param>
        <param name="useTransitions">
          Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición del control entre dos estados. Use este método para pasar de un estado a otro los controles que tengan <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns>
          <see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método si va a cambiar estados en un control que usa el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>. Llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método para cambiar estados en un elemento fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si utiliza un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.Controls.UserControl> o en un único elemento).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un control que usa el <xref:System.Windows.VisualStateManager.GoToState%2A> método para realizar la transición entre Estados. Para obtener el ejemplo completo, vea [crear un Control que tiene una apariencia personalizable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="stateName" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Control del que se va a realizar la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">Nombre del estado al que se realiza la transición.</param>
        <param name="group">
          <see cref="T:System.Windows.VisualStateGroup" /> al que pertenece el estado.</param>
        <param name="state">Representación del estado al que se va a realizar la transición.</param>
        <param name="useTransitions">
          Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición de un control entre estados.</summary>
        <returns>
          <see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método realiza la lógica necesaria para iniciar y detener los guiones gráficos que están asociados a una transición de forma adecuada. Cuando un control llama <xref:System.Windows.VisualStateManager.GoToState%2A> para cambiar su estado, el <xref:System.Windows.VisualStateManager> hace lo siguiente:  
  
-   Primero tiene lugar, si la <xref:System.Windows.VisualState> que está pasando el control tiene un <xref:System.Windows.Media.Animation.Storyboard>, comienza el guión gráfico. A continuación, si la <xref:System.Windows.VisualState> tiene que el control procede de un <xref:System.Windows.Media.Animation.Storyboard>, los extremos de guión gráfico.  
  
-   Si el control ya está en el `stateName` estado, <xref:System.Windows.VisualStateManager.GoToState%2A> no realiza ninguna acción y devuelve `true`.  
  
-   Si `stateName` no existe en el <xref:System.Windows.Controls.ControlTemplate> de `control`, <xref:System.Windows.VisualStateManager.GoToState%2A> no realiza ninguna acción y devuelve `false`.  
  
 Puede implementar su propia <xref:System.Windows.VisualStateManager> para proporcionar una lógica diferente para realizar la transición entre Estados. Por ejemplo, puede cambiar la lógica que se ha descrito anteriormente, o pueden proporcionar lógica para la transición entre tipos de animaciones personalizadas.  Para implementar un <xref:System.Windows.VisualStateManager>, cree una clase que hereda de <xref:System.Windows.VisualStateManager> e invalide el <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método. Para usar la clase personalizada, establezca la <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> propiedad a un objeto de su tipo personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objeto en el que se produjo el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">Estado del que el control está realizando la transición.</param>
        <param name="newState">Estado al que el control está realizando la transición.</param>
        <param name="control">Control que está realizando la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Genera el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> en el objeto <see cref="T:System.Windows.VisualStateGroup" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.VisualStateGroup> está establecido en el <xref:System.Windows.Controls.ControlTemplate> de un control, el `control` parámetro se establece en el control que posee <xref:System.Windows.Controls.ControlTemplate>.  Cuando el <xref:System.Windows.VisualStateGroup> se establece en un <xref:System.Windows.FrameworkElement>, `control` es `null` y debe usar el `stateGroupsRoot` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="newState" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objeto en el que se produjo el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">Estado del que el control está realizando la transición.</param>
        <param name="newState">Estado al que el control está realizando la transición.</param>
        <param name="control">Control que está realizando la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Genera el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> en el objeto <see cref="T:System.Windows.VisualStateGroup" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.VisualStateGroup> está establecido en el <xref:System.Windows.Controls.ControlTemplate> de un control, el `control` parámetro se establece en el control que posee <xref:System.Windows.Controls.ControlTemplate>.  Cuando el <xref:System.Windows.VisualStateGroup> se establece en un <xref:System.Windows.FrameworkElement>, `control` es `null` y debe usar el `stateGroupsRoot` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
 O bien  
  
 <paramref name="newState" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Al reemplazar <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a establecer la propiedad.</param>
        <param name="value">Administrador de estado visual que realiza la transición entre los estados de un control.</param>
        <summary>Establece la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>