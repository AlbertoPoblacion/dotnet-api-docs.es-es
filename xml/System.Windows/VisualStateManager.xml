<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fdf6939baf9f6829fba034b5c7ae0428da81c32f" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/18/2019" /><Meta Name="ms.locfileid" Value="59503572" /></Metadata><TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Administra estados y la lógica para la transición entre estados de los controles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.VisualStateManager> le permite especificar los Estados para un control, la apariencia de un control cuando se encuentra en un estado determinado, y cuando un control cambia de estado. Por ejemplo, un <xref:System.Windows.Controls.Button> podría tener un aspecto ligeramente diferente cuando se presiona que cuando no está presionado. Dos Estados que el <xref:System.Windows.Controls.Button> define corresponden a cuando se presiona (`"Pressed"`) y cuando no lo es (`"Normal"`). La apariencia de un control cuando se encuentra en un estado se define mediante un <xref:System.Windows.VisualState>. Un <xref:System.Windows.VisualState> contiene una colección de <xref:System.Windows.Media.Animation.Storyboard> objetos que especifican cómo se cambia la apariencia del control cuando el control está en ese estado. Agregar estados visuales a un control estableciendo la `VisualStateManager.VisualStateGroups` propiedad adjunta en el control. Cada <xref:System.Windows.VisualStateGroup> contiene una colección de <xref:System.Windows.VisualState> objetos que son mutuamente excluyentes. Es decir, el control siempre está en exactamente un estado de en cada <xref:System.Windows.VisualStateGroup>.  
  
 El <xref:System.Windows.VisualStateManager> también le permite especificar cuándo un control entra en un estado específico. El método que se debe llamar para cambiar los Estados depende de su escenario. Si crea un control que utiliza el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>, llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método. Para obtener más información sobre cómo crear controles que usan el <xref:System.Windows.VisualStateManager>, consulte [crear un Control que tiene una apariencia personalizable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md). Si usa el <xref:System.Windows.VisualStateManager> fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si usa un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.Controls.UserControl> o en un único elemento), llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método. En cualquier caso, el <xref:System.Windows.VisualStateManager> lleva a cabo la lógica necesaria para iniciar y detener los guiones gráficos que están asociados con el estado relacionado apropiadamente. Por ejemplo, suponga que un control define los Estados, `State1` y `State2`, cada uno de los cuales tiene un guión gráfico asociado con él. Si el control está en `State1` y pasar `State2` a <xref:System.Windows.VisualStateManager.GoToState%2A> o <xref:System.Windows.VisualStateManager.GoToElementState%2A>, <xref:System.Windows.VisualStateManager> inicia el guión gráfico `State2` y detiene el guión gráfico en `State1`.  
  
 Los controles que se incluyen con [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] usar el <xref:System.Windows.VisualStateManager> para cambiar los estados visuales. Cuando creas un <xref:System.Windows.Controls.ControlTemplate> para un control que se incluye con [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], puede agregar <xref:System.Windows.VisualState> objetos para el control <xref:System.Windows.Controls.ControlTemplate> para especificar la apariencia del control en un estado determinado. Para buscar los nombres de los estados visuales para los controles que se incluyen con [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], consulte [estilos y plantillas](~/docs/framework/wpf/controls/control-styles-and-templates.md). Definen controladores de lógica del control realizando la transición entre Estados, por lo que no es necesario hacer nada más que el <xref:System.Windows.VisualState> objetos en el nuevo <xref:System.Windows.Controls.ControlTemplate>. Para obtener más información sobre cómo crear plantillas de control para los controles existentes, vea [personalizar la apariencia de un Control existente creando una clase ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
 Si desea implementar su propia lógica para realizar la transición entre Estados, debe heredar de <xref:System.Windows.VisualStateManager>, invalidar el <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método y establezca el <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> propiedad adjunta en el control que utiliza la lógica personalizada.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Windows.Shapes.Rectangle> y agrega un <xref:System.Windows.VisualStateGroup> denominado `CommonStates` a la `VisualStateManager.VisualStatesGroups` propiedad adjunta. El ejemplo se define la `MouseOver` y `Normal` <xref:System.Windows.VisualState> objetos en el `CommonStates` <xref:System.Windows.VisualStateGroup>. Cuando el usuario mueve el puntero del mouse sobre el <xref:System.Windows.Shapes.Rectangle>, cambia de rojo a verde durante medio segundo. Cuando el usuario mueve el mouse fuera del rectángulo, el <xref:System.Windows.Controls.Grid> inmediatamente cambios de vuelta a rojo. Tenga en cuenta que el `Normal` estado no define una <xref:System.Windows.Media.Animation.Storyboard>. Un <xref:System.Windows.Media.Animation.Storyboard> no es necesario porque cuando el <xref:System.Windows.Shapes.Rectangle> realiza la transición desde el `MouseOver` estado el `Normal` estado, el <xref:System.Windows.Media.Animation.Storyboard> para `MouseOver` se detiene y la <xref:System.Windows.Media.SolidColorBrush.Color%2A> propiedad para el <xref:System.Windows.Media.SolidColorBrush> devuelve en rojo.  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 El ejemplo siguiente muestra el controlador de eventos que se define en el ejemplo anterior y llama el <xref:System.Windows.VisualStateManager.GoToElementState%2A> método para realizar la transición entre Estados. Si el rectángulo en el ejemplo anterior formaba parte de un <xref:System.Windows.Controls.ControlTemplate>, el ejemplo tendría que llamar a la <xref:System.Windows.VisualStateManager.GoToState%2A> método.  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.VisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Windows.VisualStateManager" /> que realiza la transición entre los estados de un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> es `null`, el <xref:System.Windows.VisualStateManager> utiliza su propia lógica para realizar la transición entre Estados. Si desea implementar su propia lógica para realizar la transición entre Estados, crear una clase que hereda de <xref:System.Windows.VisualStateManager> e invalidar la <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método. Para usar la clase personalizada, establezca la <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> propiedad a un objeto del tipo personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Elemento cuya propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" /> se va a obtener.</param>
        <summary>Obtiene la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <returns>Administrador de estado visual que realiza la transición entre los estados de un control.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Elemento cuya propiedad adjunta <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" /> se va a obtener.</param>
        <summary>Obtiene la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <returns>Colección de objetos <see cref="T:System.Windows.VisualStateGroup" /> asociada al objeto especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">El estado al que se realiza la transición.</param>
        <param name="useTransitions">Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición del elemento entre dos estados. Utilice este método para la transición de estados definidos por una aplicación, en lugar de definidos por un control.</summary>
        <returns><see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método cambiar estados en un elemento fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si usa un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.DataTemplate> o <xref:System.Windows.Window>). Llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método si va a cambiar estados en un control que usa el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>.  
  
   
  
## Examples  
 El ejemplo siguiente crea una aplicación que solicita al usuario que adivine un número entre 1 y 100.  Cuando el usuario escribe un número, la aplicación indica si el intento es correcto, demasiado alto o demasiado bajo.  La siguiente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] crea la interfaz de usuario para la aplicación y define 4 estados: `TooLow`, `TooHigh`, `Correct`, y `Guessing`. Cuando se inicia la aplicación, está en el `Guessing` estado. .  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 El código siguiente muestra la lógica de la aplicación.  Cuando el usuario escribe un número y hace clic en el botón, la aplicación llama a <xref:System.Windows.VisualStateManager.GoToElementState%2A> para realizar la transición a `TooHigh`, `TooLow`, o `Correct` para proporcionar comentarios al usuario sobre la estimación.  Para probar este ejemplo, llamar a la `GenerateNumber` método cuando se inicia la aplicación.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
O bien 
 <paramref name="stateName" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Control del que se va a realizar la transición entre estados.</param>
        <param name="stateName">El estado al que se realiza la transición.</param>
        <param name="useTransitions">Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición del control entre dos estados. Use este método para pasar de un estado a otro los controles que tengan <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns><see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.VisualStateManager.GoToState%2A> método si va a cambiar estados en un control que usa el <xref:System.Windows.VisualStateManager> en su <xref:System.Windows.Controls.ControlTemplate>. Llame a la <xref:System.Windows.VisualStateManager.GoToElementState%2A> método cambiar estados en un elemento fuera de un <xref:System.Windows.Controls.ControlTemplate> (por ejemplo, si usa un <xref:System.Windows.VisualStateManager> en un <xref:System.Windows.Controls.UserControl> o en un solo elemento).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un control que utiliza el <xref:System.Windows.VisualStateManager.GoToState%2A> método para realizar la transición entre Estados. Para el ejemplo completo, vea [crear un Control que tiene una apariencia personalizable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> es <see langword="null" />.  
  
O bien 
 <paramref name="stateName" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Control del que se va a realizar la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">Nombre del estado al que se realiza la transición.</param>
        <param name="group"><see cref="T:System.Windows.VisualStateGroup" /> al que pertenece el estado.</param>
        <param name="state">Representación del estado al que se va a realizar la transición.</param>
        <param name="useTransitions">Es <see langword="true" /> para usar un objeto <see cref="T:System.Windows.VisualTransition" /> en la transición entre estados; de lo contrario, es <see langword="false" />.</param>
        <summary>Realiza la transición de un control entre estados.</summary>
        <returns><see langword="true" /> si el control ha realizado correctamente la transición al nuevo estado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método realiza la lógica necesaria para iniciar y detener los guiones gráficos que están asociados con una transición de forma adecuada. Cuando llama un control <xref:System.Windows.VisualStateManager.GoToState%2A> para cambiar su estado, el <xref:System.Windows.VisualStateManager> hace lo siguiente:  
  
-   Primero tiene lugar, si la <xref:System.Windows.VisualState> que está pasando el control tiene un <xref:System.Windows.Media.Animation.Storyboard>, comienza el guión gráfico. A continuación, si la <xref:System.Windows.VisualState> tiene que el control procede de un <xref:System.Windows.Media.Animation.Storyboard>, los extremos de guión gráfico.  
  
-   Si el control ya está en el `stateName` estado, <xref:System.Windows.VisualStateManager.GoToState%2A> no realiza ninguna acción y devuelve `true`.  
  
-   Si `stateName` no existe en el <xref:System.Windows.Controls.ControlTemplate> de `control`, <xref:System.Windows.VisualStateManager.GoToState%2A> no realiza ninguna acción y devuelve `false`.  
  
 Puede implementar su propia <xref:System.Windows.VisualStateManager> para proporcionar una lógica diferente para la transición entre Estados. Por ejemplo, puede cambiar la lógica descrita anteriormente, o puede proporcionar lógica para realizar la transición entre los tipos de animación personalizada.  Para implementar un <xref:System.Windows.VisualStateManager>, cree una clase que hereda de <xref:System.Windows.VisualStateManager> e invalidar la <xref:System.Windows.VisualStateManager.GoToStateCore%2A> método. Para usar la clase personalizada, establezca la <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> propiedad a un objeto del tipo personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objeto en el que se produjo el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">Estado del que el control está realizando la transición.</param>
        <param name="newState">Estado al que el control está realizando la transición.</param>
        <param name="control">Control que está realizando la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Genera el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> en el objeto <see cref="T:System.Windows.VisualStateGroup" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.VisualStateGroup> se establece en el <xref:System.Windows.Controls.ControlTemplate> de un control, el `control` parámetro se establece en el control que posee <xref:System.Windows.Controls.ControlTemplate>.  Cuando el <xref:System.Windows.VisualStateGroup> se establece en un <xref:System.Windows.FrameworkElement>, `control` es `null` y debe usar el `stateGroupsRoot` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
O bien 
 <paramref name="newState" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> método para que los delegados registrados reciban el evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objeto en el que se produjo el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">Estado del que el control está realizando la transición.</param>
        <param name="newState">Estado al que el control está realizando la transición.</param>
        <param name="control">Control que está realizando la transición entre estados.</param>
        <param name="stateGroupsRoot">Elemento raíz que contiene <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Genera el evento <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> en el objeto <see cref="T:System.Windows.VisualStateGroup" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.VisualStateGroup> se establece en el <xref:System.Windows.Controls.ControlTemplate> de un control, el `control` parámetro se establece en el control que posee <xref:System.Windows.Controls.ControlTemplate>.  Cuando el <xref:System.Windows.VisualStateGroup> se establece en un <xref:System.Windows.FrameworkElement>, `control` es `null` y debe usar el `stateGroupsRoot` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> es <see langword="null" />.  
  
O bien 
 <paramref name="newState" /> es <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Cuando se reemplaza <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> método para que los delegados registrados reciban el evento.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Objeto en el que se va a establecer la propiedad.</param>
        <param name="value">Administrador de estado visual que realiza la transición entre los estados de un control.</param>
        <summary>Establece la propiedad adjunta <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroups">
      <MemberSignature Language="C#" Value="see GetVisualStateGroups" />
      <MemberSignature Language="ILAsm" Value="see GetVisualStateGroups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.VisualStateGroups" />
      <MemberSignature Language="VB.NET" Value="see GetVisualStateGroups" />
      <MemberSignature Language="F#" Value="see GetVisualStateGroups" Usage="see GetVisualStateGroups" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene o establece una colección de objetos <see cref="T:System.Windows.VisualStateGroup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks  
 Cada <xref:System.Windows.VisualStateGroup> contiene una colección de <xref:System.Windows.VisualState> objetos. Un <xref:System.Windows.VisualState> contiene una colección de <xref:System.Windows.Media.Animation.Storyboard> objetos que especifican cómo se cambia la apariencia del control cuando el control está en un estado determinado. Por ejemplo, un <xref:System.Windows.Controls.Button> podría tener un aspecto ligeramente diferente cuando se presiona que cuando no está presionado. Dos Estados que el <xref:System.Windows.Controls.Button> define corresponden a cuando se presiona (`"Pressed"`) y cuando no lo es (`"Normal"`).  
  
 Agregar <xref:System.Windows.VisualState> a un control estableciendo la <xref:System.Windows.VisualStateManager.VisualStateGroups%2A> propiedad adjunta en el control. Coloca los Estados que son mutuamente excluyentes entre sí en el mismo <xref:System.Windows.VisualStateGroup>. Por ejemplo, el <xref:System.Windows.Controls.CheckBox> tiene dos <xref:System.Windows.VisualStateGroup> objetos. Uno contiene los Estados, `Normal`, `MouseOver`, `Pressed`, y `Disabled`. El otro contiene los Estados, `Checked`, `UnChecked`, y `Indeterminate`. El <xref:System.Windows.Controls.CheckBox> pueden estar en Estados `MouseOver` y `UnChecked` al mismo tiempo, pero no puede ser el `MouseOver` y `Pressed` Estados al mismo tiempo.  
  
 Aunque puede agregar <xref:System.Windows.VisualState> objetos a cualquier elemento, son especialmente útiles para que otros usuarios puedan volver a definir el comportamiento visual de un <xref:System.Windows.Controls.Control>. Si crea un control personalizado que utiliza un <xref:System.Windows.Controls.ControlTemplate>, puede especificar que indica que el control puede estar en agregando un <xref:System.Windows.TemplateVisualStateAttribute> en su definición de clase. A continuación, cualquier persona que crea un nuevo <xref:System.Windows.Controls.ControlTemplate> para el control se puede agregar <xref:System.Windows.VisualState> objetos a la plantilla. Los Estados con el mismo <xref:System.Windows.TemplateVisualStateAttribute.GroupName%2A?displayProperty=fullName> pertenecen al mismo <xref:System.Windows.VisualStateGroup>.  
  
 Para obtener más información sobre cómo usar <xref:System.Windows.VisualStateGroup> objetos en un <xref:System.Windows.Controls.ControlTemplate>, consulte [personalizar la apariencia de un Control existente creando una clase ControlTemplate](/dotnet/framework/wpf/controls/customizing-the-appearance-of-an-existing-control). Para obtener más información sobre cómo crear controles que usan el <xref:System.Windows.VisualStateManager>, consulte [crear un Control que tiene una apariencia personalizable](/dotnet/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance).  
     
## Examples  
 En el ejemplo siguiente se crea una sencilla <xref:System.Windows.Controls.ControlTemplate> para un <xref:System.Windows.Controls.Button> que contiene un <xref:System.Windows.Controls.Grid>. También contiene un <xref:System.Windows.VisualStateGroup> denominado `CommonStates`, que define el `MouseOver` y `Normal` Estados. El <xref:System.Windows.VisualStateGroup> también tiene un <xref:System.Windows.VisualTransition> que especifica que se tarda medio segundo la <xref:System.Windows.Controls.Grid> para cambiar de verde a rojo cuando el usuario mueve el puntero del mouse sobre el <xref:System.Windows.Controls.Button>.  
  
 [!code-xaml[VSMButtonTemplate#11](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmbuttontemplate/csharp/window1.xaml#11)]
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>