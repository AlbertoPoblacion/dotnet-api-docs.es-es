<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de09d337e79e341ade969dc527e1b9b6c0b3d7c6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36461429" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.DependencyProperty> admite las siguientes capacidades de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La propiedad puede establecerse en un estilo. Para obtener más información, consulte [Aplicar estilos y plantillas](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La propiedad puede establecerse a través del enlace de datos. Para obtener más información sobre las propiedades de dependencia de enlace de datos, vea [Cómo: enlazar las propiedades de dos controles](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La propiedad puede establecerse con una referencia de recurso dinámico. Para obtener más información, consulte [Recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La propiedad puede heredar automáticamente su valor de un elemento primario en el árbol de elementos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   La propiedad se puede animar. Para obtener más información, consulte [Información general sobre animaciones](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La propiedad puede notificar cuando se ha cambiado el valor anterior de la propiedad y se puede convertir el valor de propiedad. Para obtener más información, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La propiedad notifica información a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], como si al cambiar un valor de propiedad debe requieren que el sistema de diseño para volver a componer los objetos visuales de un elemento.  
  
-   La propiedad recibe soporte técnico en el [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Por ejemplo, la propiedad se puede editar en el **propiedades** ventana.  
  
 Para obtener más información sobre propiedades de dependencia, vea [información general sobre propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Si desea propiedades en sus tipos personalizados para admitir las capacidades de la lista anterior, debe crear una propiedad de dependencia.  Para obtener información sobre cómo crear propiedades de dependencia personalizadas, vea [propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una propiedad adjunta es una propiedad que permite a cualquier objeto que se proporcionará información para el tipo que define la propiedad adjunta. En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], cualquier tipo que hereda de <xref:System.Windows.DependencyObject> puede usar una propiedad, independientemente de si el tipo hereda del tipo que define la propiedad adjunta. Una propiedad adjunta es una característica de la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] idioma.  Para establecer una propiedad adjunta en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], use la *ownerType*.* propertyName* sintaxis. Un ejemplo de una propiedad adjunta es la <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propiedad. Si desea crear una propiedad que se puede usar en todos los <xref:System.Windows.DependencyObject> tipos, a continuación, debe crear una propiedad adjunta. Para obtener más información sobre propiedades adjuntas, incluido cómo crearlos, vea [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valores XAML  
 `dependencyPropertyName`  
 Una cadena que especifica la <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> de la propiedad de dependencia deseada. Puede ir precedido por un prefijo de espacio de nombres XML si la propiedad no está en el espacio de nombres XML (para obtener más información, consulte [XAML Namespaces and Namespace Mapping para XAML de WPF](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Una cadena que especifica un tipo de propietario de una propiedad de dependencia, un punto (.), el <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` También puede ir precedido por un prefijo de espacio de nombres XML. Este uso es específico de estilos de tiempo de ejecución y las plantillas, donde se debe especificar el propietario de la propiedad de dependencia para el análisis de contexto porque el `TargetType` todavía no se conoce. Para obtener más información, consulte [Aplicar estilos y plantillas](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Una cadena que especifica el propietario de una propiedad adjunta, un punto (.) y el nombre de la propiedad adjunta. `attachedPropertyOwnerType` También puede ir precedido por un prefijo de espacio de nombres XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds another type as an owner of a dependency property that has already been registered to a type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as an owner of this dependency property.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no registró esa propiedad de dependencia concreta inicialmente.  
  
 Por lo general, <xref:System.Windows.DependencyProperty.AddOwner%2A> se utiliza para agregar propiedades de dependencia para las clases que ya no exponen esa propiedad de dependencia a través de la herencia de clase administrada (la herencia de clases provocaría que las propiedades del contenedor ser heredadas por la clase derivada y, por tanto, proporciona acceso a las tablas de miembros general para la propiedad de dependencia ya). <xref:System.Windows.DependencyProperty.AddOwner%2A> permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no registró esa propiedad de dependencia inicialmente.  
  
 Esta firma no permite especificar metadatos.  Cuando utiliza este método, los metadatos se generan automáticamente para el nuevo <xref:System.Windows.DependencyProperty> y su tipo de propietario. Los metadatos generados automáticamente son el resultado de los metadatos combinados de todos los tipos base que tienen esta propiedad establecida. Si no hay metadatos combinados están disponible, se utilizan los metadatos predeterminados para la propiedad. Si la propiedad se registra mediante la <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método y, a continuación, los metadatos predeterminados es el mismo que los metadatos que se crean cuando <xref:System.Windows.DependencyProperty.RegisterAttached%2A> se llamó. En caso contrario, el <xref:System.Windows.PropertyMetadata> objeto se crea con el <xref:System.Windows.PropertyMetadata.DefaultValue%2A> propiedad establecida en el valor predeterminado del tipo de propiedad y todas las demás propiedades de la <xref:System.Windows.PropertyMetadata> está establecido en `null`. Use la <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> firma si desea proporcionar metadatos para la versión de la propiedad de dependencia tal y como se agrega al tipo proporcionado.  
  
 El valor devuelto de este método se utiliza normalmente para declarar y exponer la propiedad de dependencia mediante el almacenamiento de un identificador de la propiedad de dependencia. El identificador proporciona acceso a la propiedad de dependencia si desea llamar al sistema de propiedades [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] con respecto a la propiedad de dependencia, especialmente porque existe en la adición de la clase propietario. El mismo nombre de propiedad para el propietario original y propietario agregado debe usarse para indicar una funcionalidad similar. Debe utilizar el <xref:System.Windows.DependencyProperty> valor devuelto de la <xref:System.Windows.DependencyProperty.AddOwner%2A> método para definir el identificador de la propiedad de dependencia y también para declarar [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad para las propiedades de dependencia que se agregan a los tipos con <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 El <xref:System.Windows.DependencyProperty.AddOwner%2A> metodología recomendada anteriormente se utiliza para crear las propiedades de dependencia que se declaran dentro de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Por ejemplo, ambos <xref:System.Windows.Controls.Border> y <xref:System.Windows.Controls.Control> definir un `BorderBrush` propiedad de dependencia, que tienen una funcionalidad similar. <xref:System.Windows.Controls.Control> define su `BorderBrush` propiedad para el sistema de propiedades mediante una llamada a <xref:System.Windows.DependencyProperty.AddOwner%2A> tomando como base el propietario original <xref:System.Windows.Controls.Border> y su registrados <xref:System.Windows.Controls.Border.BorderBrushProperty> identificador de propiedad de dependencia. El <xref:System.Windows.DependencyProperty.AddOwner%2A> devolver el valor, a continuación, se utiliza para establecer un nuevo estático <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para esa propiedad en el propietario agregado y un `BorderBrush` también se declara el contenedor de propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as owner of this dependency property.</param>
        <param name="typeMetadata">The metadata that qualifies the dependency property as it exists on the provided type.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no registró esa propiedad de dependencia concreta inicialmente.  
  
 El valor devuelto de este método se utiliza para declarar y exponer la propiedad de dependencia, especialmente tal como existe en la adición de la clase propietario. Por lo general, debe usarse el mismo nombre de propiedad para el propietario original y propietario agregado para indicar una funcionalidad similar. Es recomendable para exponer los identificadores, así como nuevos [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad para las propiedades de dependencia que se agregan a los tipos con <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 El <xref:System.Windows.DependencyProperty.AddOwner%2A> metodología recomendada anteriormente se utiliza al crear [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] declarado en [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Por ejemplo, ambos <xref:System.Windows.Controls.Border> y <xref:System.Windows.Controls.Control> definir un `BorderBrush` propiedad de dependencia, que tienen una funcionalidad similar. <xref:System.Windows.Controls.Control> define su `BorderBrush` propiedad para el sistema de propiedades mediante una llamada a <xref:System.Windows.DependencyProperty.AddOwner%2A> en el propietario original <xref:System.Windows.Controls.Border> y su registrados <xref:System.Windows.Controls.Border.BorderBrushProperty> identificador de propiedad de dependencia. El <xref:System.Windows.DependencyProperty.AddOwner%2A> devolver el valor, a continuación, se utiliza para establecer una variable static <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para esa propiedad en el propietario agregado y un `BorderBrush` también se declara el contenedor de propiedad.  
  
 Identificador de propiedad de dependencia del propietario agregado se debe utilizar para operaciones como <xref:System.Windows.DependencyObject.GetValue%2A>. Sin embargo, operaciones específicas del tipo que implican tipos o instancias de la clase que se ha agregado como propietario con distintos metadatos seguirá devolverán el incluso si los resultados esperados original (no del propietario agregado) se especifica el identificador de la propiedad de dependencia en las llamadas a métodos como <xref:System.Windows.DependencyObject.GetValue%2A> o <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Los metadatos para el propietario agregado se perpetúan por la <xref:System.Windows.DependencyProperty.AddOwner%2A> llama a sí mismo, no necesariamente al que hace referencia exclusivamente el campo de identificador de clase de propietario agregar. No obstante, es recomendable para exponer el identificador, así como nuevo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad para las propiedades de dependencia que se agregan a los tipos con <xref:System.Windows.DependencyProperty.AddOwner%2A>, ya que de lo crea discrepancia entre el [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] y [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representaciones de sus propiedades.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base originales. Sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características, como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, se reemplazan si se especifican en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. En última instancia, el comportamiento de la combinación depende el tipo de metadatos de propiedad que se usa para la invalidación, por lo que el comportamiento descrito aquí es para las clases de metadatos de propiedad existentes utilizadas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propiedades de dependencia. Para obtener más información, consulte [metadatos de la propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default metadata of the dependency property.</summary>
        <value>Los metadatos predeterminados de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los metadatos predeterminados son los metadatos de propiedad que están disponible para ese objeto concreto o un objeto de un tipo derivado donde no hay metadatos alternativos proporcionó explícito <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamar.  
  
 Si el propietario original aplicó metadatos a la primera <xref:System.Windows.DependencyProperty.Register%2A> llamada que establece la propiedad de dependencia, a continuación, los metadatos se devuelven como <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Si no hay metadatos se ha aplicado la versión original <xref:System.Windows.DependencyProperty.Register%2A> llamar, a continuación, se generan los metadatos desde el <xref:System.Windows.DependencyProperty.Register%2A> llamada y este valor se devuelve como el <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 El propósito principal de tener los metadatos predeterminados asociados a una <xref:System.Windows.DependencyProperty> consiste en proporcionar un valor predeterminado para esta propiedad en cualquier <xref:System.Windows.DependencyObject> o un tipo derivado.  
  
 Para las propiedades, no se puede convertir el tipo de metadatos devuelto por esta propiedad para los tipos derivados de <xref:System.Windows.PropertyMetadata> escribe, incluso si la propiedad se registró originalmente con un tipo de metadatos derivados. Si desea que los metadatos registrados originalmente, incluido su tipo de metadatos derivados posiblemente original, llame a <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> en su lugar, pasando el registro original tipo como parámetro.  
  
 Para las propiedades asociadas, el tipo de los metadatos devueltos por esta propiedad coincidirá con el tipo especificado en la versión original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método de registro.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema de propiedades utiliza su propio identificador único <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, y devuelve el valor de esa propiedad <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the metadata associated with this dependency property as it exists for a particular type. This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">The specific type from which to retrieve the dependency property metadata.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified existing type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar el tipo o una referencia de objeto para utilizar como tipo es necesaria porque los metadatos pueden variar del registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamadas que modifican los metadatos de la propiedad de dependencia tal como existe en un tipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene metadatos para una propiedad de dependencia basada en su tipo. El tipo se obtiene mediante una `typeof` operador.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</param>
        <summary>Returns the metadata for this dependency property as it exists on the specified object instance.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar el tipo o una referencia de objeto es necesaria porque los metadatos de cualquier propiedad de dependencia determinado pueden variar del registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamadas que pueden refinar los metadatos de propiedad tal y como existe en un tipo.  
  
 Cuando se solicitan metadatos de propiedad basados en una instancia, que está pasando simplemente la instancia para que se puede evaluar su tipo internamente. Metadatos de la propiedad de dependencia no varían por instancia; siempre son coherente para cualquier combinación de propiedades de tipo especificada.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene los metadatos de una propiedad de dependencia basada en un determinado <xref:System.Windows.DependencyObject> instancia.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">A specific object that records the dependency object type from which the dependency property metadata is desired.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar el tipo o una referencia de objeto es necesaria porque los metadatos de cualquier propiedad de dependencia determinado pueden variar del registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamadas que pueden refinar los metadatos de propiedad tal y como existe en un tipo.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene los metadatos de una propiedad de dependencia basada en su <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an internally generated value that uniquely identifies the dependency property.</summary>
        <value>Identificador numérico único.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor es un entero, no un identificador único global (GUID). En general, no es necesario usar este valor de índice y no hay ningún acceso del índice a las tablas de todas las propiedades de dependencia. En su lugar los campos de identificador deben hacer referencia a las propiedades de dependencia.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> se usa internamente para un acceso más rápido a las estructuras de datos que usan el <xref:System.Windows.DependencyProperty.GlobalIndex%2A> como un índice de base cero de la matriz. Un uso similar que haya aplicaciones de diseñadores o herramientas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</summary>
        <returns>
          <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de `null` es un tipo válido para las propiedades de dependencia de tipo de referencia, o para un <xref:System.Nullable%601> propiedad de dependencia y devolvería `true` para estos casos. En casos donde la propiedad de dependencia es ni una referencia ni un <xref:System.Nullable%601> tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A> devolverá `false` para un valor null en lugar de generar una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Windows.DependencyProperty.IsValidType%2A> como una comprobación antes de llamar a <xref:System.Windows.DependencyObject.SetValue%2A> en la propiedad de dependencia.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</summary>
        <returns>
          <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una propiedad de dependencia, se puede especificar un intervalo de valores para ese tipo a través de un <xref:System.Windows.ValidateValueCallback> que se proporciona en el registro de la propiedad de dependencia.  
  
 Este método llama <xref:System.Windows.DependencyProperty.IsValidType%2A> internamente. Si la propiedad de dependencia en cuestión no tiene ningún <xref:System.Windows.ValidateValueCallback>, a continuación, llamar a este método es realmente el equivalente a llamar a <xref:System.Windows.DependencyProperty.IsValidType%2A>. Si la propiedad de dependencia tiene un <xref:System.Windows.ValidateValueCallback>y si <xref:System.Windows.DependencyProperty.IsValidType%2A> habría devuelto `true`, a continuación, el valor devuelto será como se implementa en la devolución de llamada.  
  
 Un valor null es un valor válido para las propiedades de dependencia de tipo de referencia, o para un <xref:System.Nullable%601> propiedad de dependencia y devolvería `true` para estos casos. En casos donde la propiedad de dependencia es ni una referencia ni un <xref:System.Nullable%601> tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A> devolverá `false` para un valor null en lugar de generar una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se utiliza <xref:System.Windows.DependencyProperty.IsValidValue%2A> como una comprobación antes de llamar a <xref:System.Windows.DependencyObject.SetValue%2A> en la propiedad de dependencia.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the dependency property.</summary>
        <value>Nombre de la propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad obtiene el nombre proporcionado como el `name` parámetro durante el registro de la propiedad de dependencia. Este nombre es inmutable y no puede ser `null` o una cadena vacía. Registros de nombre duplicado en el mismo tipo de propietario no se permiten e inician una excepción al intentar registrar el duplicado.  
  
> [!IMPORTANT]
>  El <xref:System.Windows.DependencyProperty.Name%2A> de una dependencia de propiedad debe seguir la convención de que coincida con el nombre de su identificador de la propiedad de dependencia menos el sufijo "Property". Para obtener más información, consulte [Propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se consulta varias características de un identificador de la propiedad de dependencia, incluida la <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <summary>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadatos de la propiedad de dependencia se deben invalidar antes de que el sistema de propiedad utiliza la propiedad de dependencia. Esto equivale a la vez que se crean instancias específicas mediante la clase que registra la propiedad de dependencia. Las llamadas a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sólo debe realizarse dentro de los constructores estáticos del tipo que se proporciona como el `forType` parámetro de este método, o a través de la creación de instancias similar. Al intentar cambiar los metadatos después de que existan instancias del tipo de propietario no se producirán excepciones, pero se provocarán comportamientos incoherentes en el sistema de propiedades.  
  
 Después de metadatos para un reemplazo de la clase derivada determinada se establece con este método, intenta reemplazar los metadatos en esta misma clase derivada, producirá una excepción.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base originales; sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se reemplazan si se especifica en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. En última instancia, el comportamiento de la combinación depende el tipo de metadatos de propiedad que se usa para la invalidación, por lo que el comportamiento descrito aquí es para las clases de metadatos de propiedad existentes utilizadas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propiedades de dependencia. Para obtener más información, consulte [metadatos de la propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</exception>
        <exception cref="T:System.ArgumentException">Metadata was already established for the dependency property as it exists on the provided type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <param name="key">The access key for a read-only dependency property.</param>
        <summary>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration. You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma proporciona la implementación subyacente para un identificador de la propiedad de dependencia de solo lectura (<xref:System.Windows.DependencyPropertyKey>) método. Si reemplaza los metadatos para una propiedad de dependencia de lectura y escritura, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Metadatos de la propiedad de dependencia se deben invalidar antes de que el sistema de propiedad utiliza la propiedad de dependencia. Esto equivale a la vez que se crean objetos específicos de la clase que registra la propiedad de dependencia. Las llamadas a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> sólo debe realizarse dentro de los constructores estáticos del tipo que se proporciona como el `forType` parámetro de este método, o a través de la creación de instancias similar. Al intentar cambiar los metadatos después de que existan instancias del tipo de propietario no se producirán excepciones, pero se provocarán comportamientos incoherentes en el sistema de propiedades.  
  
 Después de metadatos para un reemplazo de la clase derivada determinada se establece con este método, intenta reemplazar los metadatos en esta misma clase derivada, producirá una excepción.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base originales; sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se reemplazan si se especifica en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. El comportamiento de combinación depende el tipo de metadatos de propiedad que se usa para la invalidación. Para obtener más información, consulte [metadatos de la propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [Framework Property Metadata](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</summary>
        <value>Tipo del objeto que registró la propiedad o se agregó a sí mismo como su propietario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se proporcionó durante el registro de la propiedad. El propietario será el tipo del registro original en el caso de un <xref:System.Windows.DependencyProperty> identificador generado a partir de un <xref:System.Windows.DependencyProperty.Register%2A> llamada o el tipo que se agregó a sí mismo como propietario en el caso de un <xref:System.Windows.DependencyProperty> identificador generado a partir de un <xref:System.Windows.DependencyProperty.AddOwner%2A> llamar.  
  
 El <xref:System.Windows.DependencyProperty.OwnerType%2A> en cualquier <xref:System.Windows.DependencyProperty> es inmutable y no puede ser `null` en válido <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el tipo de propietario basado en un identificador de la propiedad de dependencia `dp`y, a continuación, obtiene los metadatos en el tipo de propietario de ese mismo identificador. Esta operación es realmente el equivalente a obtener <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> en `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that the dependency property uses for its value.</summary>
        <value>El <see cref="T:System.Type" /> del valor de propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica el tipo de valor de la propiedad tal y como declara el registro original de la propiedad a través de la `propertyType` parámetro. Similar a la <xref:System.Windows.DependencyProperty.Name%2A>, el tipo de propiedad de una propiedad de dependencia es inmutable después del registro.  
  
   
  
## Examples  
 En el ejemplo siguiente se consulta varias características de un identificador de la propiedad de dependencia, incluida la <xref:System.Windows.DependencyProperty.PropertyType%2A>. La cadena de nombre de tipo de la <xref:System.Windows.DependencyProperty.PropertyType%2A> se obtiene desde el valor devuelto <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</summary>
        <value>
          <see langword="true" /> Si la propiedad de dependencia es de solo lectura; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propiedades de dependencia de solo lectura se registran en el sistema de propiedades mediante una llamada a la <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> método en contraposición a la <xref:System.Windows.DependencyProperty.Register%2A> método. También se pueden registrar propiedades adjuntas como de solo lectura; vea <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Propiedades de dependencia de solo lectura requieren un <xref:System.Windows.DependencyPropertyKey> identificador en lugar de un <xref:System.Windows.DependencyProperty> identificador para realizar operaciones de metadatos como invalidar los metadatos o establecer el valor. Si ha adquirido una colección de <xref:System.Windows.DependencyProperty> identificadores mediante una llamada a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> u otro [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] que expone los identificadores, compruebe el <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor antes de intentar llamar a <xref:System.Windows.DependencyObject.SetValue%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> con esa identificador de la propiedad de dependencia como parámetro de entrada, para comprobar que la propiedad de dependencia que representa el identificador no es de solo lectura. Si el valor de <xref:System.Windows.DependencyProperty.ReadOnly%2A> es `true` en una propiedad de dependencia, no hay ningún mecanismo de programación para obtener una referencia a la <xref:System.Windows.DependencyPropertyKey> identificador de esa propiedad de dependencia de los metadatos o de la <xref:System.Windows.DependencyProperty> identificador; el identificador debe estar disponible como un campo estático para llamar a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> con respecto a una propiedad de dependencia de solo lectura.  
  
 Al crear una propiedad de dependencia personalizada y registrarla como de solo lectura, debe definir solo un descriptor de acceso get de la [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] propiedad de contenedor. En caso contrario, la clase tendrá un modelo de objetos confuso para el contenedor de propiedad en comparación con el acceso a la propiedad de dependencia de respaldo. Para obtener más información, consulte [propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md) o [propiedades de dependencia de solo lectura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene los metadatos predeterminados y las propiedades de identificador de propiedad de dependencia de distintos campos de propiedad de dependencia y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register. The name must be unique within the registration namespace of the owner type.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 El ejemplo siguiente registra una propiedad de dependencia, incluida una devolución de llamada de validación (la definición de devolución de llamada no se muestra; para obtener detalles sobre la definición de devolución de llamada, vea <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers an attached property with the property system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers an attached property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 El ejemplo siguiente registra una propiedad adjunta en una clase abstracta con esto <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <summary>Registers an attached property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredar de valor de propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia del valor de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedad que exponen la propiedad de dependencia e incluso si no piensa exponer métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia del valor de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia de una propiedad no asociada a través de ciertos límites de elemento en el árbol en tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente realiza la propiedad adjunta una propiedad global en el sistema de propiedades y garantiza que la herencia del valor de propiedad funciona a través de todos los límites en un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades que especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredar de valor de propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia del valor de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedad que exponen la propiedad de dependencia e incluso si no piensa exponer métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia del valor de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia de una propiedad no asociada a través de ciertos límites de elemento en el árbol en tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente realiza la propiedad adjunta una propiedad global en el sistema de propiedades y garantiza que la herencia del valor de propiedad funciona a través de todos los límites en un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades que especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 El ejemplo siguiente registra una propiedad adjunta en una clase abstracta con esto <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma. Esta propiedad adjunta es una propiedad de tipo de enumeración y el registro agrega una devolución de llamada de validación para comprobar que el valor proporcionado es un valor de la enumeración.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a read-only attached property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Por lo general, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden utilizar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a solo aquellas partes del código que son necesarios para establecer esa propiedad de dependencia como parte de la lógica de clase o una aplicación. También se recomienda que exponga un identificador de la propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en la clase.  
  
 Propiedades asociadas de sólo lectura son un escenario poco frecuente, porque el escenario principal para una propiedad adjunta es su uso en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sin un establecedor público, no se puede establecer una propiedad adjunta [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredar de valor de propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia como adjunto es admitir la herencia del valor de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedad que exponen la propiedad de dependencia e incluso si no piensa exponer métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia del valor de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia de una propiedad no asociada a través de ciertos límites de elemento en el árbol en tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente realiza la propiedad adjunta una propiedad global en el sistema de propiedades y garantiza que la herencia del valor de propiedad funciona a través de todos los límites en un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades que especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Normalmente, las claves que representan el tipo <xref:System.Windows.DependencyProperty>. Por lo general, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden utilizar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a solo aquellas partes del código que son necesarios para establecer esa propiedad de dependencia como parte de la lógica de clase o una aplicación. También se recomienda que exponga un identificador de la propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en la clase.  
  
 Propiedades asociadas de sólo lectura son un escenario poco frecuente, porque el escenario principal para una propiedad adjunta es su uso en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sin un establecedor público, no se puede establecer una propiedad adjunta [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredar de valor de propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia tal y como se adjunta en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia del valor de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedad que exponen la propiedad de dependencia e incluso si no piensa exponer métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia del valor de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia de una propiedad no asociada a través de ciertos límites de elemento en el árbol en tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente realiza la propiedad adjunta una propiedad global en el sistema de propiedades y garantiza que la herencia del valor de propiedad funciona a través de todos los límites en un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades que especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property as a read-only dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Por lo general, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden utilizar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a solo aquellas partes del código que son necesarios para establecer esa propiedad de dependencia como parte de la lógica de clase o una aplicación. También se recomienda que exponga un identificador de la propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en la clase.  
  
 Propiedades de dependencia de solo lectura son un escenario bastante típico tanto existente [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] y para escenarios de personalización, porque otros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] características pueden requerir una propiedad de dependencia, incluso si esa propiedad no está destinada a establecerse por autores de llamadas. Puede utilizar el valor de una propiedad de dependencia de solo lectura como base para otras operaciones de sistema de propiedades que toman una propiedad de dependencia, como basar una <xref:System.Windows.Trigger> en la propiedad de dependencia en un estilo.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 El ejemplo siguiente registra un `AquariumSize` propiedad de dependencia como de solo lectura. El ejemplo define `AquariumSizeKey` como una clave interna (para que otros las clases del ensamblado puedan invalidar los metadatos) y expone el identificador de la propiedad de dependencia basado en esa clave como `AquariumSizeProperty`. Además, se crea un contenedor para `AquariumSize`, con solo un descriptor de acceso get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Por lo general, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden utilizar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a solo aquellas partes del código que son necesarios para establecer esa propiedad de dependencia como parte de la lógica de clase o una aplicación. También se recomienda que exponga un identificador de la propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en la clase.  
  
 Propiedades de dependencia de solo lectura son un escenario bastante típico. Puede utilizar el valor de una propiedad de dependencia de solo lectura como base para otras operaciones de sistema de propiedades que toman una propiedad de dependencia, como basar una <xref:System.Windows.Trigger> en la propiedad de dependencia en un estilo.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, vea <xref:System.Windows.DependencyProperty>.  
  
 Validación en una propiedad de dependencia de solo lectura puede ser menos importante. El nivel de acceso no público que especifique para la clave reduce la probabilidad de entrada no válida arbitraria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of the dependency property.</summary>
        <returns>The string representation of the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación devuelve el <xref:System.Windows.DependencyProperty.Name%2A> valor de propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> es un valor de centinela que se utiliza para escenarios donde el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedad es no se puede determinar una solicitado <xref:System.Windows.DependencyProperty> valor. <xref:System.Windows.DependencyProperty.UnsetValue> se utiliza en lugar de `null`, porque `null` podría ser un valor de propiedad válido, así como válido (y de uso frecuente) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> nunca se devuelve fuera de <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Cuando se llama a <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> en una propiedad de dependencia en un <xref:System.Windows.DependencyObject> instancia, de los siguientes casos:  
  
-   Una propiedad de dependencia tiene un valor predeterminado establecido en metadatos y se devuelve ese valor. Este valor podría proceder de <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Se estableció algún otro valor por el sistema de propiedad y el valor predeterminado ya no es relevante. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Establecer un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> de <xref:System.Windows.DependencyProperty.UnsetValue> específicamente no está permitida.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Devuelve <xref:System.Windows.DependencyProperty.UnsetValue> cuando la propiedad solicitada no se localmente estableció.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial cuando se usa como el valor devuelto de un <xref:System.Windows.CoerceValueCallback>. Para obtener más información, consulte [devoluciones de llamada de propiedad de dependencia y validación](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Si va a enlazar a una base de datos, tenga en cuenta que <xref:System.Windows.DependencyProperty.UnsetValue> no es equivalente a <xref:System.DBNull.Value>, de forma similar a cómo <xref:System.DBNull.Value> no es equivalente a un valor null es true.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value validation callback for the dependency property.</summary>
        <value>La devolución de llamada de validación de valor de esta propiedad de dependencia, tal y como se proporcionan para que el <paramref name="validateValueCallback" /> parámetro en el registro original de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contendrá `null` para cualquier propiedad de dependencia con ninguna devolución de llamada de validación registrado.  
  
 Validar valor devoluciones de llamada deben actuar en sentido estático: aplicada a través de la validación de la <xref:System.Windows.ValidateValueCallback> no se puede determinar si el valor proporcionado es válido para cualquier instancia concreta. La devolución de llamada solo puede determinar si todos los objetos que poseen la propiedad de dependencia deben o no deben aceptar el valor proporcionado como válido. Si tiene que realizar la validación que se basa en el conocimiento de los valores de otras propiedades de dependencia en una instancia concreta, use un <xref:System.Windows.CoerceValueCallback> en su lugar. El <xref:System.Windows.CoerceValueCallback> se registra como parte de los metadatos de propiedad de dependencia, en lugar de directamente dentro del identificador de propiedad de dependencia. Para obtener más información, consulte [devoluciones de llamada de propiedad de dependencia y validación](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>