<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc117fffb2ec2f4ee7c294166d054208a4b13ede" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39942034" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa una propiedad que se puede establecer a través de métodos como, por ejemplo, el estilo, el enlace de datos, la animación y la herencia.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.DependencyProperty> admite las siguientes capacidades de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   La propiedad puede establecerse en un estilo. Para obtener más información, consulte [Aplicar estilos y plantillas](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   La propiedad puede establecerse mediante enlace de datos. Para obtener más información sobre las propiedades de dependencia de enlace de datos, vea [Cómo: enlazar las propiedades de dos controles](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   La propiedad puede establecerse con una referencia de recurso dinámico. Para obtener más información, consulte [Recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   La propiedad puede heredar automáticamente su valor de un elemento primario del árbol de elementos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Se puede animar la propiedad. Para obtener más información, consulte [Información general sobre animaciones](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   La propiedad puede notificar cuando ha cambiado el valor anterior de la propiedad y se puede convertir el valor de propiedad. Para obtener más información, consulte [Devoluciones de llamada y validación de las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   La propiedad notifica información a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], como si al cambiar un valor de propiedad necesario el sistema de diseño recomponga los elementos visuales de un elemento.  
  
-   La propiedad recibe soporte técnico en el [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Por ejemplo, la propiedad se puede editar en el **propiedades** ventana.  
  
 Para obtener más información acerca de las propiedades de dependencia, vea [información general sobre las propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Si desea que las propiedades de los tipos personalizados para admitir las capacidades de la lista anterior, debe crear una propiedad de dependencia.  Para obtener información sobre cómo crear propiedades de dependencia personalizadas, vea [propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Una propiedad adjunta es una propiedad que permite a cualquier objeto para notificar la información del tipo que define la propiedad adjunta. En [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], cualquier tipo que hereda de <xref:System.Windows.DependencyObject> puede usar una propiedad adjunta, independientemente de si el tipo hereda del tipo que define la propiedad. Una propiedad adjunta es una característica de la [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] lenguaje.  Para establecer una propiedad adjunta en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], utilice el *tipoDePropietario*.* propertyName* sintaxis. Un ejemplo de una propiedad adjunta es la <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> propiedad. Si desea crear una propiedad que se puede usar en todos los <xref:System.Windows.DependencyObject> tipos, a continuación, debe crear una propiedad adjunta. Para obtener más información sobre las propiedades adjuntas, incluido cómo crearlos, vea [Attached Properties Overview](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Valores XAML  
 `dependencyPropertyName`  
 Una cadena que especifica la <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> de la propiedad de dependencia deseada. Puede ir precedida por un prefijo de espacio de nombres XML si la propiedad no está en el espacio de nombres XML predeterminado (para obtener más información, consulte [los espacios de nombres XAML y Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Una cadena que especifica un tipo de propietario de una propiedad de dependencia, un punto (.), el <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` También puede ir precedido por un prefijo de espacio de nombres XML. Este uso es específico para enlazadas estilos y plantillas, donde se debe especificar el propietario de la propiedad de dependencia para el contexto de análisis porque el `TargetType` todavía no se conoce. Para obtener más información, consulte [Aplicar estilos y plantillas](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Cadena que especifica el propietario de una propiedad adjunta, un punto (.) seguido del nombre de propiedad adjunta. `attachedPropertyOwnerType` También puede ir precedido por un prefijo de espacio de nombres XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega otro tipo como propietario de una propiedad de dependencia que ya está registrada en un tipo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Tipo que se va a agregar como propietario de esta propiedad de dependencia.</param>
        <summary>Agrega otro tipo como propietario de una propiedad de dependencia que ya está registrada.</summary>
        <returns>Referencia al identificador <see cref="T:System.Windows.DependencyProperty" /> original que identifica la propiedad de dependencia. Este identificador debe exponerse mediante la adición de la clase como un campo <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no se registró inicialmente esa propiedad de dependencia determinado.  
  
 Por lo general, <xref:System.Windows.DependencyProperty.AddOwner%2A> se usa para agregar las propiedades de dependencia para las clases que ya no exponen esa propiedad de dependencia a través de la herencia de clases administradas (herencia de clases haría que las propiedades de contenedor que se va a heredar la clase derivada y, por tanto, proporcionaría acceso general de la tabla de miembros para la propiedad de dependencia ya). <xref:System.Windows.DependencyProperty.AddOwner%2A> permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no se registró inicialmente esa propiedad de dependencia.  
  
 Esta firma no permite especificar los metadatos.  Cuando se usa este método, los metadatos se generan automáticamente para el nuevo <xref:System.Windows.DependencyProperty> y su tipo de propietario. Los metadatos generados automáticamente están el resultado de los metadatos combinados de todos los tipos bases que tienen esta propiedad definida. Si no hay metadatos combinados están disponible, se usan los metadatos predeterminados para la propiedad. Si la propiedad se registra mediante el <xref:System.Windows.DependencyProperty.RegisterAttached%2A> es igual que los metadatos que se crean al método y, a continuación, los metadatos predeterminados <xref:System.Windows.DependencyProperty.RegisterAttached%2A> llamó. En caso contrario, el <xref:System.Windows.PropertyMetadata> objeto se crea con el <xref:System.Windows.PropertyMetadata.DefaultValue%2A> propiedad establecida en el valor predeterminado del tipo de propiedad y todas las demás propiedades de la <xref:System.Windows.PropertyMetadata> está establecido en `null`. Use el <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> firma si desea proporcionar metadatos para la versión de la propiedad de dependencia tal como se agregan al tipo proporcionado.  
  
 El valor devuelto de este método se utiliza normalmente para declarar y exponer la propiedad de dependencia mediante el almacenamiento de un identificador de propiedad de dependencia. El identificador proporciona acceso a la propiedad de dependencia, si desea llamar al sistema de propiedades [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] frente a la propiedad de dependencia, especialmente porque existe en la clase de propietario de la adición. El mismo nombre de propiedad para el propietario original y propietario agregado se debe usar para indicar una funcionalidad similar. Debe usar el <xref:System.Windows.DependencyProperty> devolver el valor de la <xref:System.Windows.DependencyProperty.AddOwner%2A> método para definir el identificador de propiedad de dependencia y también para declarar [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad, para las propiedades de dependencia que se agregan a los tipos mediante <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 El <xref:System.Windows.DependencyProperty.AddOwner%2A> se usa la metodología recomendada anteriormente al crear las propiedades de dependencia que se declaran dentro de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Por ejemplo, ambos <xref:System.Windows.Controls.Border> y <xref:System.Windows.Controls.Control> definir un `BorderBrush` propiedad de dependencia, que tienen una funcionalidad similar. <xref:System.Windows.Controls.Control> define su `BorderBrush` propiedad al sistema de propiedades mediante una llamada a <xref:System.Windows.DependencyProperty.AddOwner%2A> basándose en el propietario original <xref:System.Windows.Controls.Border> y su registrados <xref:System.Windows.Controls.Border.BorderBrushProperty> identificador de propiedad de dependencia. El <xref:System.Windows.DependencyProperty.AddOwner%2A> devolver valor, a continuación, se usa para establecer un nuevo estático <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para esa propiedad en el propietario agregado y un `BorderBrush` también se declara el contenedor de propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Tipo que se va a agregar como propietario de esta propiedad de dependencia.</param>
        <param name="typeMetadata">Metadatos que califican la propiedad de dependencia tal como existe en el tipo proporcionado.</param>
        <summary>Agrega otro tipo como propietario de una propiedad de dependencia que ya se ha registrado y ofrece los metadatos de propiedad de dependencia para la propiedad de dependencia como se verá en el tipo de propietario proporcionado.</summary>
        <returns>Referencia al identificador <see cref="T:System.Windows.DependencyProperty" /> original que identifica la propiedad de dependencia. Este identificador debe exponerse mediante la adición de la clase como un campo <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite que el sistema de propiedades para que reconozca una propiedad de dependencia en un tipo que no se registró inicialmente esa propiedad de dependencia determinado.  
  
 El valor devuelto de este método se utiliza para declarar y exponer la propiedad de dependencia, especialmente, tal como existe en la clase de propietario de la adición. Por lo general, se debe usar el mismo nombre de propiedad para el propietario original y propietario agregado para indicar una funcionalidad similar. Es recomendable exponer los identificadores, así como nuevos [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad, para las propiedades de dependencia que se agregan a los tipos mediante <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 El <xref:System.Windows.DependencyProperty.AddOwner%2A> se usa la metodología recomendada anteriormente al crear [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] declarados dentro de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Por ejemplo, ambos <xref:System.Windows.Controls.Border> y <xref:System.Windows.Controls.Control> definir un `BorderBrush` propiedad de dependencia, que tienen una funcionalidad similar. <xref:System.Windows.Controls.Control> define su `BorderBrush` propiedad al sistema de propiedades mediante una llamada a <xref:System.Windows.DependencyProperty.AddOwner%2A> propietario original <xref:System.Windows.Controls.Border> y su registrados <xref:System.Windows.Controls.Border.BorderBrushProperty> identificador de propiedad de dependencia. El <xref:System.Windows.DependencyProperty.AddOwner%2A> devolver valor, a continuación, se usa para establecer una variable static <xref:System.Windows.DependencyProperty> campo (<xref:System.Windows.Controls.Control.BorderBrushProperty>) para esa propiedad en el propietario agregado y un `BorderBrush` también se declara el contenedor de propiedad.  
  
 Identificador de propiedad de dependencia del propietario agregado se debe usar para operaciones tales como <xref:System.Windows.DependencyObject.GetValue%2A>. Sin embargo, operaciones específicas del tipo que implican tipos o instancias de la clase que se ha agregado como propietario con distintos metadatos seguirán devolverán la incluso si los resultados esperados original (no se ha agregado del propietario) se especifica el identificador de propiedad de dependencia en las llamadas a métodos como <xref:System.Windows.DependencyObject.GetValue%2A> o <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Los metadatos para el propietario agregado se perpetúan por la <xref:System.Windows.DependencyProperty.AddOwner%2A> llamar a sí mismo, no necesariamente hace referencia a exclusivamente el campo de identificador de clase de propietario de la adición. No obstante, es recomendable para exponer el identificador, así como nuevo [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] contenedores de propiedad, para las propiedades de dependencia que se agregan a los tipos mediante <xref:System.Windows.DependencyProperty.AddOwner%2A>, porque de lo contrario, crea la disparidad entre el [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] y [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] representaciones de sus propiedades.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base original. Sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características, tales como <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, se reemplazan si se especifican en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. En última instancia, el comportamiento de combinación depende de que se usa para la invalidación, por lo que es el comportamiento descrito aquí para las clases de metadatos de propiedad existentes utilizadas por el tipo de metadatos de propiedad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las propiedades de dependencia. Para obtener más información, consulte [los metadatos de propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [metadatos de propiedad de marco de trabajo](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los metadatos predeterminados de la propiedad de dependencia.</summary>
        <value>Metadatos predeterminados de la propiedad de dependencia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los metadatos predeterminados son los metadatos de propiedad que están disponible para ese objeto concreto o un objeto de un tipo derivado donde no hay metadatos alternativos proporcionó explícita <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamar.  
  
 Si el propietario original aplica metadatos a la primera <xref:System.Windows.DependencyProperty.Register%2A> llamada que es necesario establecer la propiedad de dependencia, a continuación, los metadatos se devuelven como <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Si no hay metadatos se aplican en el original <xref:System.Windows.DependencyProperty.Register%2A> llamar, a continuación, se generan los metadatos desde el <xref:System.Windows.DependencyProperty.Register%2A> llamada y este valor se devuelve como el <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 El propósito principal de tener los metadatos predeterminados asociados con un <xref:System.Windows.DependencyProperty> consiste en proporcionar un valor predeterminado para esta propiedad en cualquier <xref:System.Windows.DependencyObject> o un tipo derivado.  
  
 Para las propiedades no son asociadas, no se puede convertir el tipo de metadatos devuelto por esta propiedad para los tipos derivados de <xref:System.Windows.PropertyMetadata> escribe, incluso si la propiedad se registró originalmente con un tipo de metadatos derivadas. Si desea que los metadatos registrados originalmente, incluidos el tipo de metadatos derivadas posiblemente original, llame a <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> en su lugar, pasando el registro original escriba como un parámetro.  
  
 Para las propiedades adjuntas, el tipo de los metadatos devueltos por esta propiedad coincidirá con el tipo especificado en el original <xref:System.Windows.DependencyProperty.RegisterAttached%2A> método de registro.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un código hash para esta <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Código hash de esta <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema de propiedades usa su propio identificador único <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, y devuelve el valor de la propiedad <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve los metadatos asociados a esta propiedad de dependencia tal como existe para un tipo específico. Este puede ser el tipo en el que la propiedad de dependencia se registró por primera vez, uno al que se agregó posteriormente o uno en el que se obtuvo la propiedad de dependencia a través de la herencia, pero en el que los metadatos se invalidaron específicamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">El tipo específico del que se deben recuperar los metadatos de la propiedad de dependencia.</param>
        <summary>Devuelve los metadatos de esta propiedad de dependencia tal como existe en un tipo especificado.</summary>
        <returns>Objeto de metadatos de una propiedad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especificar el tipo o una referencia de objeto para usar como tipo es necesario porque los metadatos pueden variar desde el registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> llamadas que modifican los metadatos de la propiedad de dependencia tal como existe en un tipo.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene los metadatos para una propiedad de dependencia según su tipo. El tipo se obtiene mediante una `typeof` operador.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objeto de dependencia que se comprueba para el tipo, para determinar de qué versión específica del tipo de la propiedad de dependencia deben proceder los metadatos.</param>
        <summary>Devuelve los metadatos de esta propiedad de dependencia tal como existe en la instancia de objeto especificado.</summary>
        <returns>Objeto de metadatos de una propiedad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifica el tipo o una referencia de objeto es necesaria porque los metadatos de cualquier propiedad de dependencia pueden variar desde el registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> las llamadas que se pueden refinar los metadatos de propiedad, tal como existe en un tipo.  
  
 Al solicitar los metadatos de propiedad basados en una instancia, que está pasando simplemente la instancia para que se puede evaluar su tipo internamente. Los metadatos de propiedad de dependencia no varían por instancia; es siempre coherente para cualquier combinación de propiedades de tipo especificada.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene los metadatos para una propiedad de dependencia basado en un determinado <xref:System.Windows.DependencyObject> instancia.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Objeto específico que registra el tipo de objeto de dependencia del que se quieren obtener los metadatos de la propiedad de dependencia.</param>
        <summary>Devuelve los metadatos de esta propiedad de dependencia tal como existe en un tipo especificado.</summary>
        <returns>Objeto de metadatos de una propiedad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifica el tipo o una referencia de objeto es necesaria porque los metadatos de cualquier propiedad de dependencia pueden variar desde el registro original debido a <xref:System.Windows.DependencyProperty.AddOwner%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> las llamadas que se pueden refinar los metadatos de propiedad, tal como existe en un tipo.  
  
   
  
## Examples  
 El ejemplo siguiente obtiene los metadatos para una propiedad de dependencia en función de su <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor generado internamente que identifica exclusivamente la propiedad de dependencia.</summary>
        <value>Identificador numérico único.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor es un entero, no un identificador único global (GUID). Por lo general, no es necesario utilizar este valor de índice, y no hay ningún índice acceso a las tablas de todas las propiedades de dependencia. En su lugar los campos de identificador deben hacer referencia a las propiedades de dependencia.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> se usa internamente para acelerar el acceso a estructuras de datos que usan el <xref:System.Windows.DependencyProperty.GlobalIndex%2A> como un índice de matriz basada en cero. Un uso similar podría tener aplicaciones de diseñadores o herramientas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">El valor que se va a comprobar.</param>
        <summary>Determina si un valor especificado es aceptable para el tipo de esta propiedad de dependencia, como se ha comprobado en el tipo de propiedad proporcionado en el registro de propiedad de dependencia original.</summary>
        <returns>Es <see langword="true" /> si el valor especificado es el tipo de propiedad registrado o un tipo derivado aceptable; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un valor de `null` es un tipo válido para las propiedades de dependencia de tipo de referencia, o para un <xref:System.Nullable%601> propiedad de dependencia y devolvería `true` para estos casos. En casos donde la propiedad de dependencia es ni una referencia ni un <xref:System.Nullable%601> tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A> devolverá `false` para un valor null en lugar de generar una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Windows.DependencyProperty.IsValidType%2A> como una comprobación antes de llamar a <xref:System.Windows.DependencyObject.SetValue%2A> en la propiedad de dependencia.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">El valor que se va a comprobar.</param>
        <summary>Determina si el valor proporcionado se acepta para el tipo de propiedad mediante la comprobación de tipo básico y, potencialmente, si está comprendido en el intervalo permitido de valores de ese tipo.</summary>
        <returns>Es <see langword="true" /> si el valor es aceptable y es del tipo correcto o un tipo derivado; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una propiedad de dependencia, se puede especificar un intervalo permitido de valores para ese tipo a través de un <xref:System.Windows.ValidateValueCallback> que se proporciona en el registro de la propiedad de dependencia.  
  
 Este método llama a <xref:System.Windows.DependencyProperty.IsValidType%2A> internamente. Si la propiedad de dependencia en cuestión no tiene ningún <xref:System.Windows.ValidateValueCallback>, a continuación, llamar a este método es equivalente a llamar a <xref:System.Windows.DependencyProperty.IsValidType%2A>. Si la propiedad de dependencia tiene un <xref:System.Windows.ValidateValueCallback>y si <xref:System.Windows.DependencyProperty.IsValidType%2A> habría devuelto `true`, a continuación, el valor devuelto será como se implementa en la devolución de llamada.  
  
 Un valor null es un valor válido para las propiedades de dependencia de tipo de referencia, o para un <xref:System.Nullable%601> propiedad de dependencia y devolvería `true` para estos casos. En casos donde la propiedad de dependencia es ni una referencia ni un <xref:System.Nullable%601> tipo, <xref:System.Windows.DependencyProperty.IsValidType%2A> devolverá `false` para un valor null en lugar de generar una excepción.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Windows.DependencyProperty.IsValidValue%2A> como una comprobación antes de llamar a <xref:System.Windows.DependencyObject.SetValue%2A> en la propiedad de dependencia.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de la propiedad de dependencia.</summary>
        <value>Nombre de la propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad obtiene el nombre proporcionado como el `name` parámetro durante el registro de la propiedad de dependencia. Este nombre es inmutable y no puede ser `null` o una cadena vacía. No se permiten registros de nombre duplicado en el mismo tipo de propietario e inician una excepción al intentar registrar el duplicado.  
  
> [!IMPORTANT]
>  El <xref:System.Windows.DependencyProperty.Name%2A> de una dependencia de propiedad debe seguir la convención de que coincida con el nombre de su identificador de propiedad de dependencia sin el sufijo "Property". Para obtener más información, consulte [Propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 El ejemplo siguiente consulta varias características de un identificador de propiedad de dependencia, incluida la <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona los metadatos alternativos para esta propiedad de dependencia cuando se encuentra en instancias de un tipo especificado, frente a los metadatos que se proporcionaron en el registro inicial de la propiedad de dependencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Tipo en el que se hereda esta propiedad de dependencia y donde se aplicarán los metadatos alternativos proporcionados.</param>
        <param name="typeMetadata">Metadatos que se deben aplicar a la propiedad de dependencia en el tipo de reemplazo.</param>
        <summary>Especifica los metadatos alternativos para esta propiedad de dependencia cuando se encuentra en instancias de un tipo especificado y reemplaza los metadatos existentes para la propiedad de dependencia tal y como se heredó de los tipos base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de que el sistema de propiedades utilice la propiedad de dependencia, se deben invalidar los metadatos de propiedad de dependencia. Esto equivale a la vez que se crean instancias específicas mediante la clase que registra la propiedad de dependencia. Las llamadas a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> solo debe realizarse dentro de los constructores estáticos del tipo que se proporciona como el `forType` parámetro de este método, o a través de la creación de instancias similar. Al intentar cambiar los metadatos después de que existan instancias del tipo de propietario no producirá excepciones, pero generará comportamientos incoherentes en el sistema de propiedades.  
  
 Después de establecer los metadatos para una invalidación de la clase derivada concreta con este método, los intentos posteriores de invalidar metadatos en esta misma clase derivada, producirán una excepción.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base originales; sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se reemplazan si se especifica en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. En última instancia, el comportamiento de combinación depende de que se usa para la invalidación, por lo que es el comportamiento descrito aquí para las clases de metadatos de propiedad existentes utilizadas por el tipo de metadatos de propiedad [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las propiedades de dependencia. Para obtener más información, consulte [los metadatos de propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [metadatos de propiedad de marco de trabajo](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se intentaron reemplazar los metadatos en una propiedad de dependencia de solo lectura (esa operación no se puede realizar con esta signatura).</exception>
        <exception cref="T:System.ArgumentException">Los metadatos ya se establecieron para la propiedad de dependencia tal como existe en el tipo proporcionado.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Tipo en el que se hereda esta propiedad de dependencia y donde se aplicarán los metadatos alternativos proporcionados.</param>
        <param name="typeMetadata">Metadatos que se deben aplicar a la propiedad de dependencia en el tipo de reemplazo.</param>
        <param name="key">Clave de acceso para una propiedad de dependencia de solo lectura.</param>
        <summary>Proporciona los metadatos alternativos para una propiedad de dependencia de solo lectura cuando se encuentra en instancias de un tipo especificado y reemplaza los metadatos que se proporcionaron en el registro inicial de la propiedad de dependencia. Debe pasar <see cref="T:System.Windows.DependencyPropertyKey" /> para que la propiedad de dependencia de sólo lectura evite producir una excepción.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma proporciona la implementación subyacente para un identificador de propiedad de dependencia de sólo lectura (<xref:System.Windows.DependencyPropertyKey>) método. Si la invalidación de metadatos para una propiedad de dependencia de lectura y escritura, use <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Antes de que el sistema de propiedades utilice la propiedad de dependencia, se deben invalidar los metadatos de propiedad de dependencia. Esto equivale a la vez que se crean objetos específicos de la clase que registra la propiedad de dependencia. Las llamadas a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> solo debe realizarse dentro de los constructores estáticos del tipo que se proporciona como el `forType` parámetro de este método, o a través de la creación de instancias similar. Al intentar cambiar los metadatos después de que existan instancias del tipo de propietario no producirá excepciones, pero generará comportamientos incoherentes en el sistema de propiedades.  
  
 Después de establecer los metadatos para una invalidación de la clase derivada concreta con este método, los intentos posteriores de invalidar metadatos en esta misma clase derivada, producirán una excepción.  
  
 Los metadatos proporcionados se combinan con los metadatos de propiedad para la propiedad de dependencia tal como existe en el propietario de la base. Se conservará cualquier característica que se especificaron en los metadatos base originales; sólo las características que se cambiaron específicamente en los nuevos metadatos invalidarán las características de los metadatos base. Algunas características como <xref:System.Windows.PropertyMetadata.DefaultValue%2A> se reemplazan si se especifica en los nuevos metadatos. Otros, como <xref:System.Windows.PropertyChangedCallback>, se combinan. El comportamiento de combinación depende el tipo de metadatos de propiedad que se usa para la invalidación. Para obtener más información, consulte [los metadatos de propiedad de dependencia](~/docs/framework/wpf/advanced/dependency-property-metadata.md) y [metadatos de propiedad de marco de trabajo](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo del objeto que registró la propiedad de dependencia con el sistema de propiedades o se agregó a sí mismo como su propietario.</summary>
        <value>Tipo del objeto que registró la propiedad o se agregó a sí mismo como su propietario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor se proporcionó durante el registro de la propiedad. El propietario será el tipo del registro original en el caso de un <xref:System.Windows.DependencyProperty> identificador generado a partir de un <xref:System.Windows.DependencyProperty.Register%2A> llamada o el tipo que se agregó a sí mismo como propietario en el caso de un <xref:System.Windows.DependencyProperty> identificador generado a partir de un <xref:System.Windows.DependencyProperty.AddOwner%2A> llamar a.  
  
 El <xref:System.Windows.DependencyProperty.OwnerType%2A> en cualquier <xref:System.Windows.DependencyProperty> es inmutable y no puede ser `null` en válido <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 En el ejemplo siguiente se obtiene el tipo de propietario en función de un identificador de propiedad de dependencia `dp`y, a continuación, obtiene los metadatos en el tipo de propietario de ese mismo identificador. Esta operación es realmente equivalente a obtener <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> en `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo que usa la propiedad de dependencia para su valor.</summary>
        <value>Clase <see cref="T:System.Type" /> del valor de propiedad.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad indica el tipo de valor de la propiedad tal y como declara el registro original de la propiedad, a través de la `propertyType` parámetro. Similar a la <xref:System.Windows.DependencyProperty.Name%2A>, el tipo de propiedad de una propiedad de dependencia es inmutable después del registro.  
  
   
  
## Examples  
 El ejemplo siguiente consulta varias características de un identificador de propiedad de dependencia, incluida la <xref:System.Windows.DependencyProperty.PropertyType%2A>. La cadena de nombre de tipo de la <xref:System.Windows.DependencyProperty.PropertyType%2A> se obtiene desde el valor devuelto <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la propiedad de dependencia identificada por esta instancia de <see cref="T:System.Windows.DependencyProperty" /> es una propiedad de dependencia de sólo lectura.</summary>
        <value>Es <see langword="true" /> si la propiedad de dependencia es de sólo lectura; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de dependencia de solo lectura se registran en el sistema de propiedades mediante una llamada a la <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> método en contraposición a la <xref:System.Windows.DependencyProperty.Register%2A> método. También se pueden registrar propiedades adjuntas como de solo lectura. consulte <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Las propiedades de dependencia de solo lectura requieren un <xref:System.Windows.DependencyPropertyKey> identificador en lugar de un <xref:System.Windows.DependencyProperty> identificador para realizar operaciones de metadatos como invalidar los metadatos o establecer el valor. Si ha adquirido una colección de <xref:System.Windows.DependencyProperty> identificadores mediante una llamada a <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> u otro [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] que expone los identificadores, compruebe el <xref:System.Windows.DependencyProperty.ReadOnly%2A> valor antes de intentar llamar a <xref:System.Windows.DependencyObject.SetValue%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> está utilizando identificador de propiedad de dependencia como un parámetro de entrada para comprobar que la propiedad de dependencia que representa el identificador no es de solo lectura. Si el valor de <xref:System.Windows.DependencyProperty.ReadOnly%2A> es `true` en una propiedad de dependencia, no hay ninguna manera programática para obtener una referencia a la <xref:System.Windows.DependencyPropertyKey> identificador de esa propiedad de dependencia de los metadatos o desde el <xref:System.Windows.DependencyProperty> identificador; el identificador debe estar disponible como un campo estático para poder llamar a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> con respecto a una propiedad de dependencia de solo lectura.  
  
 Al crear una propiedad de dependencia personalizada y registrarlo como de solo lectura, debe definir solo un descriptor de acceso get de la [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] propiedad de contenedor. En caso contrario, la clase tendrá un modelo de objetos confuso para el contenedor de propiedad en comparación con el acceso a la propiedad de dependencia de respaldo. Para obtener más información, consulte [propiedades de dependencia personalizadas](~/docs/framework/wpf/advanced/custom-dependency-properties.md) o [las propiedades de dependencia de sólo lectura](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 En el ejemplo siguiente obtiene los metadatos predeterminados y las propiedades de identificador de propiedad de dependencia de distintos campos de propiedades de dependencia y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una propiedad de dependencia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar. El nombre debe ser único dentro del espacio de nombres de registro del tipo de propietario.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <summary>Registra una propiedad de dependencia con el nombre de propiedad, el tipo de propiedad y el tipo de propietario especificados.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="typeMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <summary>Registra una propiedad de dependencia con el nombre de la propiedad, el tipo de propiedad, el tipo de propietario y los metadatos de propiedad especificados.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="typeMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <param name="validateValueCallback">Referencia a una devolución de llamada que debe realizar cualquier validación personalizada del valor de la propiedad de dependencia además de la validación habitual de tipo.</param>
        <summary>Registra una propiedad de dependencia con los valores especificados de nombre de la propiedad, tipo de propiedad, tipo de propietario, metadatos de propiedad y una devolución de llamada de validación de la propiedad.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 En el ejemplo siguiente se registra una propiedad de dependencia, incluida una devolución de llamada de validación (la definición de la devolución de llamada no se muestra; para obtener más información sobre la definición de la devolución de llamada, vea <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una propiedad adjunta con el sistema de propiedades.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <summary>Registra una propiedad adjunta con el nombre de propiedad, el tipo de propiedad y el tipo de propietario especificados.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados y que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 En el ejemplo siguiente se registra una propiedad adjunta en una clase abstracta mediante este <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="defaultMetadata">Metadatos de propiedad de la propiedad de dependencia. Esto puede incluir el valor predeterminado, así como otras características.</param>
        <summary>Registra una propiedad adjunta con el nombre de la propiedad, el tipo de propiedad, el tipo de propietario y los metadatos de propiedad especificados.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados y que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredan las propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia de valores de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedades que exponen la propiedad de dependencia e incluso si no desea exponer los métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia de valores de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia para una propiedad no asociada a través de algunos límites de elementos en el árbol de tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente hace que la propiedad adjunta una propiedad global para el sistema de propiedades y garantiza que la herencia de valores de propiedad funciona a través de todos los límites de un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades donde especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="defaultMetadata">Metadatos de propiedad de la propiedad de dependencia. Esto puede incluir el valor predeterminado, así como otras características.</param>
        <param name="validateValueCallback">Referencia a una devolución de llamada que debe realizar cualquier validación personalizada del valor de la propiedad de dependencia además de la validación habitual de tipo.</param>
        <summary>Registra una propiedad adjunta con el tipo de propiedad, el tipo de propietario, los metadatos de propiedad y una devolución de llamada de validación de valor especificados.</summary>
        <returns>Identificador de la propiedad de dependencia que se debe utilizar para establecer el valor de un campo <see langword="public static readonly" /> en la clase. Ese identificador se usa posteriormente para hacer referencia a la propiedad de dependencia, en operaciones como el establecimiento de su valor mediante programación o la obtención de metadatos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una propiedad adjunta es un concepto de propiedad definido por [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] implementa propiedades adjuntas como propiedades de dependencia. Dado que el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] las propiedades adjuntas son propiedades de dependencia, pueden tener metadatos aplicados y que se pueden usar el sistema de propiedades general para operaciones como las características de diseño de informes. Para más información, consulte la [información general sobre propiedades adjuntas](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredan las propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia de valores de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedades que exponen la propiedad de dependencia e incluso si no desea exponer los métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia de valores de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia para una propiedad no asociada a través de algunos límites de elementos en el árbol de tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente hace que la propiedad adjunta una propiedad global para el sistema de propiedades y garantiza que la herencia de valores de propiedad funciona a través de todos los límites de un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades donde especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se registra una propiedad adjunta en una clase abstracta mediante este <xref:System.Windows.DependencyProperty.RegisterAttached%2A> firma. Esta propiedad adjunta es una propiedad de tipo de enumeración y el registro agrega una devolución de llamada de validación para comprobar que el valor proporcionado es un valor de la enumeración.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una propiedad adjunta de solo lectura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="defaultMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <summary>Registra una propiedad adjunta de solo lectura, con el tipo de propiedad, el tipo de propietario y los metadatos de propiedad especificados.</summary>
        <returns>Clave de propiedad de dependencia que debe usarse para establecer el valor de un campo estático de solo lectura en la clase, que se usa para hacer referencia a la propiedad de dependencia más tarde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Normalmente, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden usar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a sólo aquellas partes del código que son necesarias para establecer esa propiedad de dependencia como parte de la clase o una aplicación lógica. También se recomienda que exponga un identificador de propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en su clase.  
  
 Solo lectura de las propiedades adjuntas son un escenario poco frecuente, porque el escenario principal para una propiedad adjunta es su uso en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sin un establecedor público, no se puede establecer una propiedad adjunta [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredan las propiedades de dependencia  
 Adjunto es un escenario concreto para registrar una propiedad de dependencia como admitir la herencia de valores de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedades que exponen la propiedad de dependencia e incluso si no desea exponer los métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia de valores de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia para una propiedad no asociada a través de algunos límites de elementos en el árbol de tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente hace que la propiedad adjunta una propiedad global para el sistema de propiedades y garantiza que la herencia de valores de propiedad funciona a través de todos los límites de un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades donde especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="defaultMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <param name="validateValueCallback">Referencia a una devolución de llamada creada por el usuario que debe realizar cualquier validación personalizada del valor de la propiedad de dependencia además de la validación habitual de tipo.</param>
        <summary>Registra una propiedad adjunta de solo lectura, con el tipo de propiedad, el tipo de propietario, los metadatos de propiedad y una devolución de llamada de validación especificados.</summary>
        <returns>Clave de propiedad de dependencia que debe usarse para establecer el valor de un campo estático de solo lectura en la clase, que se usa para hacer referencia a la propiedad de dependencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Normalmente, las claves que representan el tipo <xref:System.Windows.DependencyProperty>. Normalmente, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden usar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a sólo aquellas partes del código que son necesarias para establecer esa propiedad de dependencia como parte de la clase o una aplicación lógica. También se recomienda que exponga un identificador de propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en su clase.  
  
 Solo lectura de las propiedades adjuntas son un escenario poco frecuente, porque el escenario principal para una propiedad adjunta es su uso en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Sin un establecedor público, no se puede establecer una propiedad adjunta [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Usar RegisterAttached para heredan las propiedades de dependencia  
 Un escenario concreto para registrar una propiedad de dependencia como asociada en lugar de <xref:System.Windows.DependencyProperty.Register%2A> es admitir la herencia de valores de propiedad. Debe registrar heredan las propiedades de dependencia con <xref:System.Windows.DependencyProperty.RegisterAttached%2A> incluso si la clase define los descriptores de acceso de contenedor de propiedades que exponen la propiedad de dependencia e incluso si no desea exponer los métodos estáticos Get * y Set * para proporcionar true adjunta compatibilidad con descriptores de acceso.   Aunque podría parecer que la herencia de valores de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia para una propiedad no asociada a través de algunos límites de elementos en el árbol de tiempo de ejecución es indefinido. Registra la propiedad como asociada, realmente hace que la propiedad adjunta una propiedad global para el sistema de propiedades y garantiza que la herencia de valores de propiedad funciona a través de todos los límites de un árbol de elementos. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades donde especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos. Para más información, vea [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra una propiedad de dependencia como una propiedad de dependencia de solo lectura.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="typeMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <summary>Registra una propiedad de dependencia de solo lectura, con el tipo de propiedad, el tipo de propietario y los metadatos de propiedad especificados.</summary>
        <returns>Clave de propiedad de dependencia que debe usarse para establecer el valor de un campo estático de solo lectura en la clase, que se usa para hacer referencia a la propiedad de dependencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Normalmente, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden usar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a sólo aquellas partes del código que son necesarias para establecer esa propiedad de dependencia como parte de la clase o una aplicación lógica. También se recomienda que exponga un identificador de propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en su clase.  
  
 Las propiedades de dependencia de solo lectura son un escenario bastante típico ambos existente [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] y para escenarios de personalización, porque otros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] características pueden requerir una propiedad de dependencia incluso si esa propiedad no pretende ser configurable por autores de llamadas. Puede usar el valor de una propiedad de dependencia de solo lectura como base para otras operaciones del sistema de propiedades que toman una propiedad de dependencia, como basar un <xref:System.Windows.Trigger> en la propiedad de dependencia en un estilo.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 En el ejemplo siguiente se registra un `AquariumSize` propiedad de dependencia como de solo lectura. El ejemplo define `AquariumSizeKey` como una clave interna (para que las clases del ensamblado podrían invalidar metadatos) y expone el identificador de propiedad de dependencia basándose en esa clave como `AquariumSizeProperty`. Además, se crea un contenedor para `AquariumSize`, con solo un descriptor de acceso get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Nombre de la propiedad de dependencia que se va a registrar.</param>
        <param name="propertyType">Tipo de la propiedad.</param>
        <param name="ownerType">Tipo de propietario que registra la propiedad de dependencia.</param>
        <param name="typeMetadata">Metadatos de propiedad de la propiedad de dependencia.</param>
        <param name="validateValueCallback">Referencia a una devolución de llamada creada por el usuario que debe realizar cualquier validación personalizada del valor de la propiedad de dependencia además de la validación habitual de tipo.</param>
        <summary>Registra una propiedad de dependencia de solo lectura, con el tipo de propiedad, el tipo de propietario, los metadatos de propiedad y una devolución de llamada de validación especificados.</summary>
        <returns>Clave de propiedad de dependencia que debe usarse para establecer el valor de un campo estático de solo lectura en la clase, que se usa para hacer referencia a la propiedad de dependencia más tarde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve el tipo <xref:System.Windows.DependencyPropertyKey>, mientras que <xref:System.Windows.DependencyProperty.RegisterAttached%2A> devuelve el tipo <xref:System.Windows.DependencyProperty>. Normalmente, no se hacen públicas, las claves que representan las propiedades de solo lectura porque las claves se pueden usar para establecer el valor de propiedad de dependencia mediante una llamada a <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. El diseño de clase afectará a sus requisitos, pero generalmente se recomienda limitar el acceso y la visibilidad de cualquier <xref:System.Windows.DependencyPropertyKey> a sólo aquellas partes del código que son necesarias para establecer esa propiedad de dependencia como parte de la clase o una aplicación lógica. También se recomienda que exponga un identificador de propiedad de dependencia para la propiedad de dependencia de solo lectura, exponiendo el valor de <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> como un `public static readonly` campo en su clase.  
  
 Las propiedades de dependencia de solo lectura son un escenario bastante típico. Puede usar el valor de una propiedad de dependencia de solo lectura como base para otras operaciones del sistema de propiedades que toman una propiedad de dependencia, como basar un <xref:System.Windows.Trigger> en la propiedad de dependencia en un estilo.  
  
 Para obtener más información sobre el registro de la propiedad de dependencia, consulte <xref:System.Windows.DependencyProperty>.  
  
 Validación en una propiedad de dependencia de sólo lectura puede ser menos importante. El nivel de acceso no público que especifique para la clave reduce la probabilidad de entrada no válida arbitraria.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la representación de cadena de la propiedad de dependencia.</summary>
        <returns>Representación de cadena de la propiedad de dependencia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación devuelve el <xref:System.Windows.DependencyProperty.Name%2A> valor de propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica un valor estático que usa el sistema de propiedades de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] en vez de <see langword="null" /> para indicar que la propiedad existe, pero el sistema de propiedades no ha establecido su valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> es un valor de centinela que se utiliza para escenarios donde el [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades no puede determinar un solicitado <xref:System.Windows.DependencyProperty> valor. <xref:System.Windows.DependencyProperty.UnsetValue> se usa en lugar de `null`, porque `null` podría ser un valor de propiedad válido, así como válido (y de uso frecuente) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> no se devuelve nunca fuera de <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. Cuando se llama a <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> en una propiedad de dependencia en un <xref:System.Windows.DependencyObject> instancia, los siguientes casos:  
  
-   Una propiedad de dependencia tiene un valor predeterminado establecido en los metadatos y se devuelve ese valor. Este valor podría proceder de <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Algún otro valor se estableció con el sistema de propiedades y el valor predeterminado ya no es relevante. Para obtener más información, consulte [Prioridad de los valores de propiedades de dependencia](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Establecer un <xref:System.Windows.PropertyMetadata.DefaultValue%2A> de <xref:System.Windows.DependencyProperty.UnsetValue> específicamente no está permitida.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Devuelve <xref:System.Windows.DependencyProperty.UnsetValue> cuando la propiedad solicitada no se ha establecido localmente.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial cuando se usa como el valor devuelto de un <xref:System.Windows.CoerceValueCallback>. Para obtener más información, consulte [devoluciones de llamada y validación](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 Si va a enlazar a una base de datos, tenga en cuenta que <xref:System.Windows.DependencyProperty.UnsetValue> no es equivalente a <xref:System.DBNull.Value>, de forma similar a cómo <xref:System.DBNull.Value> no es equivalente a un valor null es true.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la devolución de llamada de validación del valor de la propiedad de dependencia.</summary>
        <value>La devolución de llamada de validación del valor de esta propiedad de dependencia, tal y como se proporciona para el parámetro <paramref name="validateValueCallback" /> del registro de propiedad de dependencia original.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad contendrá `null` para cualquier propiedad de dependencia con ninguna devolución de llamada de validación registrado.  
  
 Validar el valor devoluciones de llamada deben actuar en un sentido estático: aplicada a través de la validación de la <xref:System.Windows.ValidateValueCallback> no se puede determinar si el valor proporcionado es válido para cualquier instancia concreta. La devolución de llamada solo puede determinar si todos los objetos que poseen la propiedad de dependencia deben o no deben aceptar el valor proporcionado como válido. Si tiene que realizar la validación que se basa en el conocimiento de los valores de otras propiedades de dependencia en una instancia concreta, use un <xref:System.Windows.CoerceValueCallback> en su lugar. El <xref:System.Windows.CoerceValueCallback> está registrado como parte de los metadatos de propiedad de dependencia, en lugar de directamente dentro del identificador de propiedad de dependencia. Para obtener más información, consulte [devoluciones de llamada y validación](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>