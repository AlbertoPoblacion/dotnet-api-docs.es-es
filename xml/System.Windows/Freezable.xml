<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="973c346f1874ce6fbdd0454e4370d678d8bcf9de" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39786889" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="68b9c-101">Define un objeto que tiene un estado modificable y un estado de solo lectura (inmovilizado).</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-101">Defines an object that has a modifiable state and a read-only (frozen) state.</span>
      </span>
      <span data-ttu-id="68b9c-102">Las clases que se derivan de <see cref="T:System.Windows.Freezable" /> proporcionan una notificación de los cambios detallados, se pueden convertir en inmutables y pueden clonarse a sí mimas.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-102">Classes that derive from <see cref="T:System.Windows.Freezable" /> provide detailed change notification, can be made immutable, and can clone themselves.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-103">La <xref:System.Windows.Freezable> clase proporciona características especiales que pueden ayudar a mejoran el rendimiento de la aplicación cuando se usan los objetos que son costosos de modificar o copiar.</span><span class="sxs-lookup"><span data-stu-id="68b9c-103">The <xref:System.Windows.Freezable> class provides special features that can help improve application performance when using objects that are expensive to modify or copy.</span></span> <span data-ttu-id="68b9c-104">Ejemplos de <xref:System.Windows.Freezable> objetos incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="68b9c-104">Examples of <xref:System.Windows.Freezable> objects include the following:</span></span>  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a><span data-ttu-id="68b9c-105">Derivan de Freezable</span><span class="sxs-lookup"><span data-stu-id="68b9c-105">Deriving From Freezable</span></span>  
 <span data-ttu-id="68b9c-106">Una clase que derive de <xref:System.Windows.Freezable> incluye las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="68b9c-106">A class that derives from <xref:System.Windows.Freezable> gains the following features:</span></span>  
  
-   <span data-ttu-id="68b9c-107">Estados especiales: un estado de sólo lectura (inmovilizado) y un estado de escritura.</span><span class="sxs-lookup"><span data-stu-id="68b9c-107">Special states: a read-only (frozen) state and a writable state.</span></span>  
  
-   <span data-ttu-id="68b9c-108">Seguridad para subprocesos: inmovilizado <xref:System.Windows.Freezable> objeto se puede compartir entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-108">Thread safety: a frozen <xref:System.Windows.Freezable> object can be shared across threads.</span></span>  
  
-   <span data-ttu-id="68b9c-109">Detallada de la notificación de cambio: a diferencia de otras <xref:System.Windows.DependencyObject> objetos, un <xref:System.Windows.Freezable> objeto proporciona notificaciones de cambios cuando cambian los valores de la subpropiedad.</span><span class="sxs-lookup"><span data-stu-id="68b9c-109">Detailed change notification: Unlike other <xref:System.Windows.DependencyObject> objects, a <xref:System.Windows.Freezable> object provides change notifications when sub-property values change.</span></span>  
  
-   <span data-ttu-id="68b9c-110">Clonación fácil: la clase Freezable ya ha implementado varios métodos que generan clones perfectos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-110">Easy cloning: the Freezable class has already implemented several methods that produce deep clones.</span></span>  
  
 <span data-ttu-id="68b9c-111">Para obtener información sobre el uso y crear su propio <xref:System.Windows.Freezable> objetos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="68b9c-111">For information on using and creating your own <xref:System.Windows.Freezable> objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="68b9c-112">Todos los miembros públicos <see langword="static" /> miembros de este tipo son seguros para subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-112">Any public <see langword="static" /> members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="68b9c-113">No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-113">Any instance members are not guaranteed to be thread safe.</span>
      </span>
      <span data-ttu-id="68b9c-114">Cuando el <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> objeto puede tener acceso solo desde el subproceso donde se creó.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-114">When the <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" />, a <see cref="T:System.Windows.Freezable" /> object can be accessed only from the thread on which it was created.</span>
      </span>
      <span data-ttu-id="68b9c-115">Al intentar acceder a él desde otro subproceso se inicia un <see cref="T:System.InvalidOperationException" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-115">Attempting to access it from another thread throws an <see cref="T:System.InvalidOperationException" />.</span>
      </span>
      <span data-ttu-id="68b9c-116">El <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> y <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> métodos proporcionan soporte técnico para el cálculo de referencias en el subproceso correcto.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-116">The <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> and <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> methods provide support for marshalling to the correct thread.</span>
      </span>
      <span data-ttu-id="68b9c-117">Cuando sus <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objetos son de subprocesamiento libre.</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-117">When their <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objects are free-threaded.</span>
      </span>
      <span data-ttu-id="68b9c-118">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      <span class="sxs-lookup">
        <span data-stu-id="68b9c-118">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-119">Inicializa una nueva instancia de una clase <see cref="T:System.Windows.Freezable" /> derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-119">Initializes a new instance of a <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-120">Éste es el constructor de accesibilidad protegida de una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="68b9c-120">This is the protected-accessibility constructor of an abstract class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-121">Obtiene un valor que indica si el objeto se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-121">Gets a value that indicates whether the object can be made unmodifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68b9c-122">
            <see langword="true" /> si el objeto actual se puede convertir en no modificable o ya lo es; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-122">
              <see langword="true" /> if the current object can be made unmodifiable or is already unmodifiable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-123">
            <para>Implementación de este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método con <paramref name="isChecking" /> establecido en <see langword="true" /> para determinar si un <see cref="T:System.Windows.Freezable" /> puede se puede convertir en no modificable. Para modificar el comportamiento de esta propiedad en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-123">
              <para>This method implementation uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method with <paramref name="isChecking" /> set to <see langword="true" /> to determine whether a <see cref="T:System.Windows.Freezable" /> can be made unmodifiable. To modify the way this property behaves in a derived class, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-124">Se produce cuando se modifican la clase <see cref="T:System.Windows.Freezable" /> o un objeto que la contiene.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-124">Occurs when the <see cref="T:System.Windows.Freezable" /> or an object it contains is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-125">Si intenta agregar o quitar controladores de eventos cuando el objeto actual no es modificable (cuando la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true`), se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="68b9c-125">If you attempt to add or remove event handlers when the current object is not modifiable (when the <xref:System.Windows.Freezable.IsFrozen%2A> property is `true`), an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-126">Crea un clon modificable del elemento <see cref="T:System.Windows.Freezable" /> y hace copias en profundidad de los valores del objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-126">Creates a modifiable clone of the <see cref="T:System.Windows.Freezable" />, making deep copies of the object's values.</span>
          </span>
          <span data-ttu-id="68b9c-127">Cuando se copian las propiedades de dependencia del objeto, este método copia las expresiones (que puede que ya no se resuelvan), pero no copia las animaciones ni sus valores actuales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-127">When copying the object's dependency properties, this method copies expressions (which might no longer resolve) but not animations or their current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-128">Clon modificable del objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-128">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="68b9c-129">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-129">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-130">El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados).</span><span class="sxs-lookup"><span data-stu-id="68b9c-130">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="68b9c-131">El clon es realmente una copia en profundidad del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-131">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="68b9c-132">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-132">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="68b9c-133">Acción</span><span class="sxs-lookup"><span data-stu-id="68b9c-133">Action</span></span>|<span data-ttu-id="68b9c-134">Comportamiento del método Clone</span><span class="sxs-lookup"><span data-stu-id="68b9c-134">Clone method behavior</span></span>|<span data-ttu-id="68b9c-135">Comportamiento del método CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="68b9c-135">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="68b9c-136">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="68b9c-136">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="68b9c-137">La expresión se copia, pero podría no resolverse.</span><span class="sxs-lookup"><span data-stu-id="68b9c-137">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="68b9c-138">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="68b9c-138">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="68b9c-139">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="68b9c-139">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="68b9c-140">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="68b9c-140">Copying an animated dependency property</span></span>|<span data-ttu-id="68b9c-141">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="68b9c-141">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="68b9c-142">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-142">Animations are not copied.</span></span>|<span data-ttu-id="68b9c-143">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-143">The property's current animated value is copied.</span></span> <span data-ttu-id="68b9c-144">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-144">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="68b9c-145">Tenga en cuenta que no se copian las propiedades sin establecer.</span><span class="sxs-lookup"><span data-stu-id="68b9c-145">Note that unset properties are not copied.</span></span> <span data-ttu-id="68b9c-146">Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="68b9c-146">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="68b9c-147">Mover un objeto inmovilizable entre subprocesos</span><span class="sxs-lookup"><span data-stu-id="68b9c-147">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="68b9c-148">Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-148">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="68b9c-149">En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante una llamada a su <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-149">First, make the <xref:System.Windows.Freezable> unmodifiable by calling its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="68b9c-150">Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y realice un local <xref:System.Windows.Freezable.Clone%2A> que puede tener acceso.</span><span class="sxs-lookup"><span data-stu-id="68b9c-150">Now another thread can access the <xref:System.Windows.Freezable> and make a local <xref:System.Windows.Freezable.Clone%2A> that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-151">
            <para>Este método usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> para generar el clon. Para modificar el comportamiento de este método en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-151">
              <para>This method uses <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> to produce the clone. To modify the behavior of this method in a derived class, override the <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="68b9c-152">Objeto que se va a clonar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-152">The object to clone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-153">Convierte la instancia en un clon (copia en profundidad) de la clase <see cref="T:System.Windows.Freezable" /> especificada con valores de propiedad base (no animadas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-153">Makes the instance a clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-154">Este método es invocado por el <xref:System.Windows.Freezable.Clone%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-154">This method is called by the <xref:System.Windows.Freezable.Clone%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="68b9c-155">Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.Clone%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="68b9c-155">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.Clone%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-156">
            <para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Motivos para invalidar incluyen lo siguiente:-la clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  -La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de todas las propiedades de escritura, establecidas localmente, incluidas las expresiones internas.  Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero no se resuelvan. Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto tiene propiedades de dependencia animadas, se copia el valor base (no animados) de esas propiedades. No se copian las animaciones.  Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura. Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  En la lista siguiente se resume el comportamiento esperado para este método:-la copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.  -No se copian las propiedades anular y de solo lectura.  -Las expresiones se copian.  -Ninguno de estos subobjetos se inmoviliza al crearlos.  -No se inmovilice la copia de sí mismo.  -Las animaciones no se copian.  -Solo valores de base de propiedad son copiados, no animado los valores actuales.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-156">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties, including internal expressions.  If the object has data-bound dependency properties, the expressions are copied but might no longer resolve. For more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) value of those properties is copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method:  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   Expressions are copied.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.  -   Animations are not copied.  -   Only property base values are copied, not current animated values.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-157">Crea un clon modificable (copia en profundidad) de <see cref="T:System.Windows.Freezable" /> con sus valores actuales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-157">Creates a modifiable clone (deep copy) of the <see cref="T:System.Windows.Freezable" /> using its current values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-158">Clon modificable del objeto actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-158">A modifiable clone of the current object.</span>
          </span>
          <span data-ttu-id="68b9c-159">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." /></span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-159">The cloned object's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="false" /> even if the source's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is <see langword="true." /></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-160">El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados).</span><span class="sxs-lookup"><span data-stu-id="68b9c-160">The <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods produce modifiable clones of frozen <xref:System.Windows.Freezable> objects (the methods also clone <xref:System.Windows.Freezable> objects that are not frozen).</span></span> <span data-ttu-id="68b9c-161">El clon es realmente una copia en profundidad del objeto actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-161">The clone is effectively a deep copy of the current object.</span></span>  
  
 <span data-ttu-id="68b9c-162">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-162">The following table summarizes the differences between the <xref:System.Windows.Freezable.Clone%2A> and <xref:System.Windows.Freezable.CloneCurrentValue%2A> methods.</span></span>  
  
|<span data-ttu-id="68b9c-163">Acción</span><span class="sxs-lookup"><span data-stu-id="68b9c-163">Action</span></span>|<span data-ttu-id="68b9c-164">Comportamiento del método Clone</span><span class="sxs-lookup"><span data-stu-id="68b9c-164">Clone method behavior</span></span>|<span data-ttu-id="68b9c-165">Comportamiento del método CloneCurrentValue</span><span class="sxs-lookup"><span data-stu-id="68b9c-165">CloneCurrentValue method behavior</span></span>|  
|------------|---------------------------|---------------------------------------|  
|<span data-ttu-id="68b9c-166">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="68b9c-166">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="68b9c-167">La expresión se copia, pero podría no resolverse.</span><span class="sxs-lookup"><span data-stu-id="68b9c-167">The expression is copied, but might no longer resolve.</span></span> <span data-ttu-id="68b9c-168">Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="68b9c-168">For more information, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</span></span>|<span data-ttu-id="68b9c-169">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="68b9c-169">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="68b9c-170">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="68b9c-170">Copying an animated dependency property</span></span>|<span data-ttu-id="68b9c-171">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="68b9c-171">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="68b9c-172">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-172">Animations are not copied.</span></span>|<span data-ttu-id="68b9c-173">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-173">The property's current animated value is copied.</span></span> <span data-ttu-id="68b9c-174">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-174">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="68b9c-175">Tenga en cuenta que no se copian las propiedades sin establecer.</span><span class="sxs-lookup"><span data-stu-id="68b9c-175">Note that unset properties are not copied.</span></span> <span data-ttu-id="68b9c-176">Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.</span><span class="sxs-lookup"><span data-stu-id="68b9c-176">If an unset property has a default value that is a frozen <xref:System.Windows.Freezable>, that property value remains frozen in the otherwise modifiable clone.</span></span>  
  
## <a name="move-a-freezable-between-threads"></a><span data-ttu-id="68b9c-177">Mover un objeto inmovilizable entre subprocesos</span><span class="sxs-lookup"><span data-stu-id="68b9c-177">Move a Freezable Between Threads</span></span>  
 <span data-ttu-id="68b9c-178">Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-178">This method can be useful for moving a <xref:System.Windows.Freezable> between threads.</span></span> <span data-ttu-id="68b9c-179">En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante el uso de su <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-179">First, make the <xref:System.Windows.Freezable> unmodifiable by using its <xref:System.Windows.Freezable.Freeze%2A> method.</span></span> <span data-ttu-id="68b9c-180">Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y crear un clon local que puede tener acceso.</span><span class="sxs-lookup"><span data-stu-id="68b9c-180">Now another thread can access the <xref:System.Windows.Freezable> and make a local clone that it can access.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-181">
            <para>Este método usa la <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> método para generar el clon; <see cref="T:System.Windows.Freezable" /> implementadores que invalidarán <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> debe asegurarse de que no se inmoviliza la copia en la creación.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-181">
              <para>This method uses the <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> method to produce the clone; <see cref="T:System.Windows.Freezable" /> implementers who override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> must ensure that the copy is not frozen on creation.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="68b9c-182">
            <see cref="T:System.Windows.Freezable" /> que se va a clonar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-182">The <see cref="T:System.Windows.Freezable" /> to be cloned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-183">Convierte esta instancia en un clon modificable (copia en profundidad) del <see cref="T:System.Windows.Freezable" /> especificado mediante los valores de propiedad actuales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-183">Makes the instance a modifiable clone (deep copy) of the specified <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-184">Este método es invocado por el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-184">This method is called by the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="68b9c-185">Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.CloneCurrentValue%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="68b9c-185">To create a modifiable copy of the current object, call <xref:System.Windows.Freezable.CloneCurrentValue%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-186">
            <para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Motivos para invalidar incluyen lo siguiente:-la clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  -La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de todas las propiedades establecidas localmente, puede escribir. Si el objeto contiene las propiedades de dependencia con expresiones (por ejemplo, un enlace de datos), se copia el valor actual de la expresión pero no la propia expresión.  Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.  Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura. Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  En la lista siguiente se resume el comportamiento esperado para este método.  -La copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.  -No se copian las propiedades anular y de solo lectura.  -Si una propiedad está animada, se copia su valor actual, pero la animación propiamente dicha no está.  -Ninguno de estos subobjetos se inmoviliza al crearlos.  -No se inmovilice la copia de sí mismo.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-186">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of all writable, locally set properties. If the object contains dependency properties with expressions (such as a data binding), the current value of the expression is copied but not the expression itself.  If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Note that unset properties are not copied, nor are read-only properties. If such a property has a default value that is a frozen <see cref="T:System.Windows.Freezable" />, that property value remains frozen in the otherwise modifiable clone.  The following list summarizes the expected behavior for this method.  -   The copy produced contains copies of all <see cref="T:System.Windows.Freezable" /> sub-objects.  -   Unset and read-only properties are not copied.  -   If a property is animated, its current value is copied, but the animation itself is not.  -   None of these sub-objects are frozen on creation.  -   The copy itself is not frozen.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-187">Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-187">Initializes a new instance of the <see cref="T:System.Windows.Freezable" /> class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-188">La nueva instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-188">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-189">Se trata de un método protegido y las implementaciones específicas de objetos reales para el comportamiento dependen de la implementación de invalidación de la <xref:System.Windows.Freezable.CreateInstanceCore%2A> método, que llama internamente a este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-189">This is a protected method, and the actual object-specific implementations for the behavior are dependent on the override implementation of the <xref:System.Windows.Freezable.CreateInstanceCore%2A> method, which this method calls internally.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-190">Cuando se implementa en una clase derivada, crea una nueva instancia de la clase <see cref="T:System.Windows.Freezable" /> derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-190">When implemented in a derived class, creates a new instance of the <see cref="T:System.Windows.Freezable" /> derived class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-191">La nueva instancia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-191">The new instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-192">No llame a este método directamente (excepto cuando base la llamada en una implementación).</span><span class="sxs-lookup"><span data-stu-id="68b9c-192">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="68b9c-193">Este método se llama internamente en el <xref:System.Windows.Freezable.CreateInstance%2A> método cada vez que una nueva instancia de la <xref:System.Windows.Freezable> se crea.</span><span class="sxs-lookup"><span data-stu-id="68b9c-193">This method is called internally by the <xref:System.Windows.Freezable.CreateInstance%2A> method whenever a new instance of the <xref:System.Windows.Freezable> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="68b9c-194">El ejemplo siguiente muestra una implementación típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span><span class="sxs-lookup"><span data-stu-id="68b9c-194">The following example shows a typical implementation of <xref:System.Windows.Freezable.CreateInstanceCore%2A>.</span></span>  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-195">
            <para>Cada <see cref="T:System.Windows.Freezable" /> clase derivada debe implementar este método. Una implementación típica consiste simplemente en llamar al constructor predeterminado y devolver el resultado.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-195">
              <para>Every <see cref="T:System.Windows.Freezable" /> derived class must implement this method. A typical implementation is to simply call the default constructor and return the result.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-196">Convierte un objeto <see cref="T:System.Windows.Freezable" /> en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />, prueba si un objeto <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-196">Makes a <see cref="T:System.Windows.Freezable" /> object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />, or tests whether a <see cref="T:System.Windows.Freezable" /> object can be made unmodifiable.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-197">Convierte el objeto actual en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-197">Makes the current object unmodifiable and sets its <see cref="P:System.Windows.Freezable.IsFrozen" /> property to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-198">Para evitar la posibilidad de un <xref:System.InvalidOperationException> al llamar a este método, compruebe el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad para determinar si el <xref:System.Windows.Freezable> puede convertir en no modificable antes de llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-198">To avoid the possibility of an <xref:System.InvalidOperationException> when calling this method, check the <xref:System.Windows.Freezable.CanFreeze%2A> property to determine whether the <xref:System.Windows.Freezable> can be made unmodifiable before calling this method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68b9c-199">
            <see cref="T:System.Windows.Freezable" /> no se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-199">The <see cref="T:System.Windows.Freezable" /> cannot be made unmodifiable.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-200">
            <para>Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable. Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-200">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">
          <span data-ttu-id="68b9c-201">Objeto que se va a comprobar o a convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-201">The object to check or make unmodifiable.</span>
          </span>
          <span data-ttu-id="68b9c-202">Si <c>isChecking</c> es <see langword="true" />, se comprueba el objeto para determinar si se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-202">If <c>isChecking</c> is <see langword="true" />, the object is checked to determine whether it can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="68b9c-203">Si <c>isChecking</c> es <see langword="false" />, el objeto se convierte en no modificable, si es posible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-203">If <c>isChecking</c> is <see langword="false" />, the object is made unmodifiable, if possible.</span>
          </span>
        </param>
        <param name="isChecking">
          <span data-ttu-id="68b9c-204">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-204">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-205">Si el valor del parámetro <paramref name="isChecking" /> es <see langword="true" />, este método indica si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-205">If the <paramref name="isChecking" /> parameter is <see langword="true" />, this method indicates whether the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable.</span>
          </span>
          <span data-ttu-id="68b9c-206">Si el valor del parámetro <paramref name="isChecking" /> es <see langword="false" />, este método intenta convertir la clase <see cref="T:System.Windows.Freezable" /> especificada en no modificable e indica si la operación se realiza correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-206">If the <paramref name="isChecking" /> parameter is <see langword="false" />, this method attempts to make the specified <see cref="T:System.Windows.Freezable" /> unmodifiable and indicates whether the operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-207">Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-207">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="68b9c-208">Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-208">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-209">No llame a este método, a menos que se va a derivar de <xref:System.Windows.Freezable> e invalidar la <xref:System.Windows.Freezable.FreezeCore%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-209">Do not call this method unless you are deriving from <xref:System.Windows.Freezable> and overriding the <xref:System.Windows.Freezable.FreezeCore%2A> method.</span></span>  <span data-ttu-id="68b9c-210">Este método puede usarse en el <xref:System.Windows.Freezable.FreezeCore%2A> método inmovilizar los miembros de datos de clase son por sí mismos <xref:System.Windows.Freezable> objetos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-210">This method may be used in the <xref:System.Windows.Freezable.FreezeCore%2A> method to freeze class data members that are themselves <xref:System.Windows.Freezable> objects.</span></span>  
  
 <span data-ttu-id="68b9c-211">Lo bueno es volver a llamar a este método en un <xref:System.Windows.Freezable> objeto que ya está inmovilizado (no modificable).</span><span class="sxs-lookup"><span data-stu-id="68b9c-211">It is alright to call this method again on a <xref:System.Windows.Freezable> object that is already frozen (unmodifiable).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68b9c-212">Cuando el valor de <paramref name="isChecking" /> es <see langword="false" />, el intento para convertir <paramref name="freezable" /> en no modificable no dio resultado; el estado del objeto es desconocido puede estar parcialmente inmovilizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-212">When <paramref name="isChecking" /> is <see langword="false" />, the attempt to make <paramref name="freezable" /> unmodifiable was unsuccessful; the object is now in an unknown state (it might be partially frozen).</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-213">
            <para>Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable. Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-213">
              <para>This method uses the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method to make the <see cref="T:System.Windows.Freezable" /> unmodifiable. To modify freezing behavior, override the <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <span data-ttu-id="68b9c-214">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-214">
              <see langword="true" /> to return an indication of whether the object can be frozen (without actually freezing it); <see langword="false" /> to actually freeze the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-215">Convierte el objeto <see cref="T:System.Windows.Freezable" /> en no modificable o prueba si se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-215">Makes the <see cref="T:System.Windows.Freezable" /> object unmodifiable or tests whether it can be made unmodifiable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-216">Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-216">If <paramref name="isChecking" /> is <see langword="true" />, this method returns <see langword="true" /> if the <see cref="T:System.Windows.Freezable" /> can be made unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
          <span data-ttu-id="68b9c-217">Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-217">If <paramref name="isChecking" /> is <see langword="false" />, this method returns <see langword="true" /> if the if the specified <see cref="T:System.Windows.Freezable" /> is now unmodifiable, or <see langword="false" /> if it cannot be made unmodifiable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-218">No llame a este método directamente (excepto cuando base la llamada en una implementación).</span><span class="sxs-lookup"><span data-stu-id="68b9c-218">Do not call this method directly (except when calling base in an implementation).</span></span> <span data-ttu-id="68b9c-219">Este método se llama internamente en el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad (con `isChecking` igual a `true`) y el <xref:System.Windows.Freezable.Freeze%2A> método (con `isChecking` igual a `false`).</span><span class="sxs-lookup"><span data-stu-id="68b9c-219">This method is called internally by the <xref:System.Windows.Freezable.CanFreeze%2A> property (with `isChecking` equal to `true`) and the <xref:System.Windows.Freezable.Freeze%2A> method (with `isChecking` equal to `false`).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-220">
            <para>
              <see cref="T:System.Windows.Freezable" /> los implementadores deben invalidar este método cuando la clase contiene los datos que no se almacenan utilizando las propiedades de dependencia.  Una implementación típica podría llamar a la base y luego llame al estático <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> método en todos los <see cref="T:System.Windows.Freezable" /> las propiedades que contiene la clase, devolver con tipo <see langword="true" /> sólo si todas las propiedades estén inmovilizadas (o se ha inmovilizado podría, en el caso de especificar <see langword="true" /> para <paramref name="isChecking" />).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-220">
              <para>
                <see cref="T:System.Windows.Freezable" /> implementers must override this method when the class contains data that is not stored using dependency properties.  A typical implementation would call base, then call the static <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> method on all <see cref="T:System.Windows.Freezable" /> typed properties that the class contains, returning <see langword="true" /> only if all properties were frozen (or could have been frozen, in the case of specifying <see langword="true" /> for <paramref name="isChecking" />).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-221">Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" />, con los valores de propiedades base (no animadas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-221">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" />, using base (non-animated) property values.</span>
          </span>
          <span data-ttu-id="68b9c-222">Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-222">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-223">Copia inmovilizada de <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-223">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="68b9c-224">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-224">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-225">Debe comprobar la <xref:System.Windows.Freezable.CanFreeze%2A> propiedad antes de llamar a este método para comprobar que el <xref:System.Windows.Freezable> se puede inmovilizar.</span><span class="sxs-lookup"><span data-stu-id="68b9c-225">You should check the <xref:System.Windows.Freezable.CanFreeze%2A> property before calling this method to verify that the <xref:System.Windows.Freezable> can be frozen.</span></span> <span data-ttu-id="68b9c-226">Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.Clone%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-226">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.Clone%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="68b9c-227">El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.</span><span class="sxs-lookup"><span data-stu-id="68b9c-227">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="68b9c-228">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-228">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="68b9c-229">Acción</span><span class="sxs-lookup"><span data-stu-id="68b9c-229">Action</span></span>|<span data-ttu-id="68b9c-230">Comportamiento del método GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="68b9c-230">GetAsFrozen method behavior</span></span>|<span data-ttu-id="68b9c-231">Comportamiento del método GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="68b9c-231">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="68b9c-232">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="68b9c-232">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="68b9c-233">El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.</span><span class="sxs-lookup"><span data-stu-id="68b9c-233">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="68b9c-234">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="68b9c-234">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="68b9c-235">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="68b9c-235">Copying an animated dependency property</span></span>|<span data-ttu-id="68b9c-236">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="68b9c-236">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="68b9c-237">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-237">Animations are not copied.</span></span>|<span data-ttu-id="68b9c-238">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-238">The property's current animated value is copied.</span></span> <span data-ttu-id="68b9c-239">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-239">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="68b9c-240">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="68b9c-240">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="68b9c-241">Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.Clone%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-241">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.Clone%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68b9c-242">No se puede inmovilizar <see cref="T:System.Windows.Freezable" /> porque contiene expresiones o propiedades animadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-242">The <see cref="T:System.Windows.Freezable" /> cannot be frozen because it contains expressions or animated properties.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-243">
            <para>Este método usa virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-243">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="68b9c-244">Instancia que se va a copiar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-244">The instance to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-245">Convierte la instancia en un clon inmovilizado de la clase <see cref="T:System.Windows.Freezable" /> especificada con los valores de propiedades base (no animadas).</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-245">Makes the instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" /> using base (non-animated) property values.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-246">Este método es invocado por el <xref:System.Windows.Freezable.GetAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-246">This method is called by the <xref:System.Windows.Freezable.GetAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="68b9c-247">Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetAsFrozen%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="68b9c-247">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-248">
            <para>Si deriva de <see cref="T:System.Windows.Freezable" /> deberá reemplazar este método. Motivos para invalidar incluyen lo siguiente:-la clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  -La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de cualquier Freezable no inmovilizados y superficiales copias de todos los demás grabable, localmente contiene las propiedades del conjunto. Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto tiene propiedades de dependencia animadas, se copian los valores base (no animados) de esas propiedades. No se copian las animaciones.  Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.  Si invalida este método, debe llamar a la implementación base.  No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.  El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-248">
              <para>If you derive from <see cref="T:System.Windows.Freezable" /> you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation makes deep copies of any unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the expressions are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the base (non-animated) values of those properties are copied. Animations are not copied.  Note that unset properties are not copied, nor are read-only properties.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-249">Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" /> con los valores de propiedad actuales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-249">Creates a frozen copy of the <see cref="T:System.Windows.Freezable" /> using current property values.</span>
          </span>
          <span data-ttu-id="68b9c-250">Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-250">Because the copy is frozen, any frozen sub-objects are copied by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="68b9c-251">Copia inmovilizada de <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-251">A frozen copy of the <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="68b9c-252">La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-252">The copy's <see cref="P:System.Windows.Freezable.IsFrozen" /> property is set to <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-253">Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.CloneCurrentValue%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-253">Using this method is similar to creating a copy using the <xref:System.Windows.Freezable.CloneCurrentValue%2A> and then freezing it with the <xref:System.Windows.Freezable.Freeze%2A> method.</span></span>  
  
 <span data-ttu-id="68b9c-254">El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.</span><span class="sxs-lookup"><span data-stu-id="68b9c-254">The <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods can improve copying performance because they do not clone <xref:System.Windows.Freezable> sub-objects that are already frozen; they only copy them by reference.</span></span>  
  
 <span data-ttu-id="68b9c-255">En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="68b9c-255">The following table summarizes the differences between the <xref:System.Windows.Freezable.GetAsFrozen%2A> and <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> methods.</span></span>  
  
|<span data-ttu-id="68b9c-256">Acción</span><span class="sxs-lookup"><span data-stu-id="68b9c-256">Action</span></span>|<span data-ttu-id="68b9c-257">Comportamiento del método GetAsFrozen</span><span class="sxs-lookup"><span data-stu-id="68b9c-257">GetAsFrozen method behavior</span></span>|<span data-ttu-id="68b9c-258">Comportamiento del método GetCurrentValueAsFrozen</span><span class="sxs-lookup"><span data-stu-id="68b9c-258">GetCurrentValueAsFrozen method behavior</span></span>|  
|------------|---------------------------------|---------------------------------------------|  
|<span data-ttu-id="68b9c-259">Copiar una propiedad de dependencia que tiene una expresión</span><span class="sxs-lookup"><span data-stu-id="68b9c-259">Copying a dependency property that has an expression</span></span>|<span data-ttu-id="68b9c-260">El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.</span><span class="sxs-lookup"><span data-stu-id="68b9c-260">The method throws an <xref:System.InvalidOperationException> because it cannot <xref:System.Windows.Freezable.Freeze%2A> the property.</span></span>|<span data-ttu-id="68b9c-261">Se copia el valor actual de la expresión, pero no la propia expresión.</span><span class="sxs-lookup"><span data-stu-id="68b9c-261">The current value of the expression is copied, but not the expression itself.</span></span>|  
|<span data-ttu-id="68b9c-262">Copiar una propiedad de dependencia animada</span><span class="sxs-lookup"><span data-stu-id="68b9c-262">Copying an animated dependency property</span></span>|<span data-ttu-id="68b9c-263">Se copia el valor de la propiedad base (no animadas).</span><span class="sxs-lookup"><span data-stu-id="68b9c-263">The property's base (non-animated) value is copied.</span></span> <span data-ttu-id="68b9c-264">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-264">Animations are not copied.</span></span>|<span data-ttu-id="68b9c-265">Se copia el valor animado de la propiedad actual.</span><span class="sxs-lookup"><span data-stu-id="68b9c-265">The property's current animated value is copied.</span></span> <span data-ttu-id="68b9c-266">No se copian las animaciones.</span><span class="sxs-lookup"><span data-stu-id="68b9c-266">Animations are not copied.</span></span>|  
  
 <span data-ttu-id="68b9c-267">Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="68b9c-267">Note that unset properties are not copied, nor are read-only properties.</span></span>  
  
 <span data-ttu-id="68b9c-268">Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-268">To create a copy of the <xref:System.Windows.Freezable> that is not frozen, use the <xref:System.Windows.Freezable.CloneCurrentValue%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-269">
            <para>Este método usa virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-269">
              <para>This method uses the virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> method to produce the clone.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">
          <span data-ttu-id="68b9c-270">Clase <see cref="T:System.Windows.Freezable" /> que se va a copiar e inmovilizar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-270">The <see cref="T:System.Windows.Freezable" /> to copy and freeze.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-271">Convierte la instancia actual en un clon inmovilizado de la clase <see cref="T:System.Windows.Freezable" /> especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-271">Makes the current instance a frozen clone of the specified <see cref="T:System.Windows.Freezable" />.</span>
          </span>
          <span data-ttu-id="68b9c-272">Si el objeto tiene propiedades de dependencia animadas, se copian sus valores animados actuales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-272">If the object has animated dependency properties, their current animated values are copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-273">Este método es invocado por el <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método.</span><span class="sxs-lookup"><span data-stu-id="68b9c-273">This method is called by the <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> method and should not be called directly from your code, except when calling the base implementation while overriding this method.</span></span> <span data-ttu-id="68b9c-274">Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> en lugar de llamar a este método directamente.</span><span class="sxs-lookup"><span data-stu-id="68b9c-274">To create a frozen copy of the current object, call <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> instead of calling this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-275">
            <para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Motivos para invalidar incluyen lo siguiente:-la clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  -La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea un nuevo <see cref="T:System.Windows.Freezable" /> utilizando el <see cref="M:System.Windows.Freezable.CreateInstance" /> método y hace copias en profundidad de Freezable no inmovilizados y copia superficial de todos los demás grabable y propiedades que contiene establecido localmente. Si el objeto tiene propiedades de dependencia enlazada a datos, los enlaces de datos se copian, pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.  Propiedades de dependencia de sólo lectura dentro de un <see cref="T:System.Windows.Freezable" /> no se copian por esta implementación predeterminada.  Si invalida este método, debe llamar a la implementación base.  No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.  El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-275">
              <para>If you derive from <see cref="T:System.Windows.Freezable" />, you may need to override this method. Reasons to override include the following:  -   Your derived class has data that is not exposed via dependency properties.  -   Your derived class must perform extra initialization work that cannot be accomplished by simply overriding <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. For example, this applies if your derived class implements <see cref="T:System.ComponentModel.ISupportInitialize" />.  Classes that store all their data in dependency properties and that do not need to perform extra initialization work do not need to override <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  It is essential that all implementations call the base implementation of this method. Implementations should only perform work that is not performed by the default implementation. The default implementation creates a new <see cref="T:System.Windows.Freezable" /> using the <see cref="M:System.Windows.Freezable.CreateInstance" /> method and makes deep copies of unfrozen freezables and shallow copies of all other writable, locally set properties it contains. If the object has data-bound dependency properties, the data bindings are copied but might no longer resolve; for more information about cloning data-bound objects, see [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). If the object has animated dependency properties, the current animated value of those properties is copied, but the animations are not.  Read-only dependency properties within a <see cref="T:System.Windows.Freezable" /> are not copied by this default implementation.  If you do override this method, you must call the base implementation.  You do not need to <see cref="M:System.Windows.Freezable.Freeze" /> values as they are copied.  The result is frozen by <see cref="M:System.Windows.Freezable.GetAsFrozen" /> before being returned.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-276">Obtiene un valor que indica si el objeto se puede modificar actualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-276">Gets a value that indicates whether the object is currently modifiable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="68b9c-277">Es <see langword="true" /> si el objeto se inmoviliza y no se puede modificar; es <see langword="false" /> si se puede modificar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-277">
              <see langword="true" /> if the object is frozen and cannot be modified; <see langword="false" /> if the object can be modified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-278">Al intentar modificar un objeto cuando su <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true` produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="68b9c-278">Attempting to modify an object when its <xref:System.Windows.Freezable.IsFrozen%2A> property is `true` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="68b9c-279">Esta propiedad es de solo lectura desde la perspectiva del modelo de objeto.</span><span class="sxs-lookup"><span data-stu-id="68b9c-279">This property is read-only from the object model perspective.</span></span> <span data-ttu-id="68b9c-280">Parte de la documentación sobre <xref:System.Windows.Freezable> comportamientos se pueden mencionar "establece <xref:System.Windows.Freezable.IsFrozen%2A> a `true`" o lenguaje similar al hablar sobre el comportamiento de otros métodos de <xref:System.Windows.Freezable>, pero este comportamiento ocurre internamente en las instancias de clases Cuando los métodos de la instancia de manipulan las variables privadas que existen dentro de la clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="68b9c-280">Some of the documentation about <xref:System.Windows.Freezable> behaviors may mention "sets <xref:System.Windows.Freezable.IsFrozen%2A> to `true`" or similar language when discussing the behavior of other methods of <xref:System.Windows.Freezable>, but this behavior is happening internally in the class instances, when methods of the instance manipulate the private variables that exist within the abstract class.</span></span> <span data-ttu-id="68b9c-281">Para establecer el valor de esta propiedad, debe llamar a <xref:System.Windows.Freezable.Freeze%2A>.</span><span class="sxs-lookup"><span data-stu-id="68b9c-281">To set the value of this property, you should call <xref:System.Windows.Freezable.Freeze%2A>.</span></span> <span data-ttu-id="68b9c-282">Esto es efectivamente una operación única para cambiar la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad desde el valor predeterminado inicial `false` estado el `true` estado.</span><span class="sxs-lookup"><span data-stu-id="68b9c-282">This effectively is a one-time operation to change the <xref:System.Windows.Freezable.IsFrozen%2A> property from the initial default `false` state to the `true` state.</span></span> <span data-ttu-id="68b9c-283">No hay ningún medio disponible para establecer el valor a `false`.</span><span class="sxs-lookup"><span data-stu-id="68b9c-283">There is no available means to set the value back to `false`.</span></span> <span data-ttu-id="68b9c-284">En su lugar, puede cambiar cualquier copia en profundidad realizada desde el original (consulte la <xref:System.Windows.Freezable.Clone%2A> método).</span><span class="sxs-lookup"><span data-stu-id="68b9c-284">Instead, you could change any deep copy made from the original (see the <xref:System.Windows.Freezable.Clone%2A> method).</span></span> <span data-ttu-id="68b9c-285">Esto es así por diseño y es cómo debe comportarse cualquier clase derivada cuando se aplica a los casos donde el <xref:System.Windows.Freezable> patrón es útil.</span><span class="sxs-lookup"><span data-stu-id="68b9c-285">This is by design and is how any derived class should behave when applied to the cases where the <xref:System.Windows.Freezable> pattern is useful.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-286">Se le llama cuando se modifica el objeto <see cref="T:System.Windows.Freezable" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-286">Called when the current <see cref="T:System.Windows.Freezable" /> object is modified.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-287">Este método se llama cada vez que el <xref:System.Windows.Freezable.Changed> se produce el evento.</span><span class="sxs-lookup"><span data-stu-id="68b9c-287">This method is called whenever the <xref:System.Windows.Freezable.Changed> event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-288">
            <para>Al implementar una clase que derive de <see cref="T:System.Windows.Freezable" />, puede invalidar este método para llevar a cabo las tareas.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-288">
              <para>When you implement a class that derives from <see cref="T:System.Windows.Freezable" />, you may override this method to perform tasks.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-289">Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos de tipo <see cref="T:System.Windows.DependencyObject" /> que se acaba de modificar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-289">Ensures that appropriate context pointers are established for a data member of type <see cref="T:System.Windows.DependencyObject" /> that has just been modified.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="68b9c-290">Valor previo del miembro de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-290">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="68b9c-291">Valor actual del miembro de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-291">The current value of the data member.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-292">Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos <see cref="T:System.Windows.DependencyObjectType" /> que se acaba de establecer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-292">Ensures that appropriate context pointers are established for a <see cref="T:System.Windows.DependencyObjectType" /> data member that has just been set.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-293">Este método debe llamarse <xref:System.Windows.Freezable> los herederos cada vez que un <xref:System.Windows.DependencyObject> miembro de datos que no se almacena como un <xref:System.Windows.DependencyProperty> está establecido.</span><span class="sxs-lookup"><span data-stu-id="68b9c-293">This method should be called by <xref:System.Windows.Freezable> inheritors each time a <xref:System.Windows.DependencyObject> data member that is not stored as a <xref:System.Windows.DependencyProperty> is set.</span></span>  
  
 <span data-ttu-id="68b9c-294">Este método no deben llamarse para <xref:System.Windows.DependencyObject> miembros de datos que se almacenan con un <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="68b9c-294">This method does not need to be called for <xref:System.Windows.DependencyObject> data members that are stored using a <xref:System.Windows.DependencyProperty>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="68b9c-295">Valor previo del miembro de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-295">The previous value of the data member.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="68b9c-296">Valor actual del miembro de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-296">The current value of the data member.</span>
          </span>
        </param>
        <param name="property">
          <span data-ttu-id="68b9c-297">Propiedad que ha cambiado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-297">The property that changed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-298">Este miembro es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-298">This member supports the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure and is not intended to be used directly from your code.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="68b9c-299">Datos de evento que contienen información acerca de qué propiedad ha cambiado y de sus valores antiguos y nuevos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-299">Event data that contains information about which property changed, and its old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="68b9c-300">Reemplaza la implementación <see cref="T:System.Windows.DependencyObject" /> de <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> para invocar también cualquier controlador <see cref="E:System.Windows.Freezable.Changed" /> en respuesta a una propiedad de dependencia cambiante de tipo <see cref="T:System.Windows.Freezable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-300">Overrides the <see cref="T:System.Windows.DependencyObject" /> implementation of <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> to also invoke any <see cref="E:System.Windows.Freezable.Changed" /> handlers in response to a changing dependency property of type <see cref="T:System.Windows.Freezable" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-301">Los datos de evento contienen información acerca de sólo el <xref:System.Windows.Freezable> propio.</span><span class="sxs-lookup"><span data-stu-id="68b9c-301">The event data contains information about only the <xref:System.Windows.Freezable> itself.</span></span> <span data-ttu-id="68b9c-302">Cualquier información de la subpropiedad debe obtenerse a través de la <xref:System.Windows.Freezable.Changed> controladores.</span><span class="sxs-lookup"><span data-stu-id="68b9c-302">Any sub-property information must be obtained through the <xref:System.Windows.Freezable.Changed> handlers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-303">Se asegura de que se tiene acceso a <see cref="T:System.Windows.Freezable" /> desde un subproceso válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-303">Ensures that the <see cref="T:System.Windows.Freezable" /> is being accessed from a valid thread.</span>
          </span>
          <span data-ttu-id="68b9c-304">Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de las [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que lean miembros de datos que no son propiedades de dependencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-304">Inheritors of <see cref="T:System.Windows.Freezable" /> must call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that reads data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-305">
            <para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a la <see cref="M:System.Windows.Freezable.ReadPreamble" /> método antes de intentar tener acceso a los miembros que no son propiedades de dependencia. El <see cref="M:System.Windows.Freezable.WritePreamble" /> debe llamarse al método antes de que los miembros de este tipo se escriben en.  Este método eficazmente no hace nada más que llamar a <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-305">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call the <see cref="M:System.Windows.Freezable.ReadPreamble" /> method before they attempt to access any members that are not dependency properties. The <see cref="M:System.Windows.Freezable.WritePreamble" /> method should be called before any such members are written to.  This method effectively does nothing more than call <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-306">Provoca el evento <see cref="E:System.Windows.Freezable.Changed" /> de <see cref="T:System.Windows.Freezable" /> e invoca su método <see cref="M:System.Windows.Freezable.OnChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-306">Raises the <see cref="E:System.Windows.Freezable.Changed" /> event for the <see cref="T:System.Windows.Freezable" /> and invokes its <see cref="M:System.Windows.Freezable.OnChanged" /> method.</span>
          </span>
          <span data-ttu-id="68b9c-307">Las clases que derivan de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al final de cualquier API que modifique miembros de clase que no estén almacenados como propiedades de dependencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-307">Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies class members that are not stored as dependency properties.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-308">
            <para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a este método al final de cualquier API que modifique un miembro de clase que no se almacena como un <see cref="T:System.Windows.DependencyProperty" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-308">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call this method at the end of any API that modifies a class member that is not stored as a <see cref="T:System.Windows.DependencyProperty" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="68b9c-309">Comprueba que no se inmovilice <see cref="T:System.Windows.Freezable" /> y que se tiene acceso desde un contexto de subproceso válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-309">Verifies that the <see cref="T:System.Windows.Freezable" /> is not frozen and that it is being accessed from a valid threading context.</span>
          </span>
          <span data-ttu-id="68b9c-310">Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de cualquier [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que escriba en miembros de datos que no sean propiedades de dependencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-310">
              <see cref="T:System.Windows.Freezable" /> inheritors should call this method at the beginning of any [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] that writes to data members that are not dependency properties.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="68b9c-311">Este método llama a <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> para comprobar el contexto del subproceso está accesible, y produce una excepción si el <xref:System.Windows.Freezable> instancia ya está inmovilizada.</span><span class="sxs-lookup"><span data-stu-id="68b9c-311">This method calls <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> to verify the threading context is accessible, and it throws an exception if the <xref:System.Windows.Freezable> instance is already frozen.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="68b9c-312">La instancia de <see cref="T:System.Windows.Freezable" /> se inmoviliza y no se puede escribir en sus miembros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-312">The <see cref="T:System.Windows.Freezable" /> instance is frozen and cannot have its members written to.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <span data-ttu-id="68b9c-313">
            <para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a <see cref="M:System.Windows.Freezable.WritePreamble" /> antes de intentar escribir en los miembros que no son propiedades de dependencia. Si se llama a <see cref="M:System.Windows.Freezable.WritePreamble" /> en un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], puede omitir una llamada a <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="68b9c-313">
              <para>Classes that derive from <see cref="T:System.Windows.Freezable" /> should call <see cref="M:System.Windows.Freezable.WritePreamble" /> before attempting to write to any members that are not dependency properties. If you call <see cref="M:System.Windows.Freezable.WritePreamble" /> in an [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], you can omit a call to <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>