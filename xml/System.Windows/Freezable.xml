<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="97fc92af0ea25eec6f71bb4a67579fbfd994f7b4" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214110" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Define un objeto que tiene un estado modificable y un estado de solo lectura (inmovilizado). Las clases que derivan de <see cref="T:System.Windows.Freezable" /> proporcionan una notificación de cambios detallada, puede hacerse inmutables y pueden clonarse a sí mismas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Windows.Freezable> clase proporciona características especiales que pueden ayudar a mejoran el rendimiento de la aplicación cuando se usan los objetos que son costosos de modificar o copiar. Ejemplos de <xref:System.Windows.Freezable> objetos incluyen lo siguiente:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Derivan de Freezable  
 Una clase que derive de <xref:System.Windows.Freezable> incluye las siguientes características:  
  
-   Estados especiales: un estado de sólo lectura (inmovilizado) y un estado de escritura.  
  
-   Seguridad para subprocesos: inmovilizado <xref:System.Windows.Freezable> objeto se puede compartir entre subprocesos.  
  
-   Detallada de la notificación de cambio: a diferencia de otras <xref:System.Windows.DependencyObject> objetos, un <xref:System.Windows.Freezable> objeto proporciona notificaciones de cambios cuando cambian los valores de la subpropiedad.  
  
-   Clonación fácil: la clase Freezable ya ha implementado varios métodos que generan clones perfectos.  
  
 Para obtener información sobre el uso y crear su propio <xref:System.Windows.Freezable> objetos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos los miembros públicos <see langword="static" /> miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Cuando el <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> objeto puede tener acceso solo desde el subproceso donde se creó. Al intentar acceder a él desde otro subproceso se inicia un <see cref="T:System.InvalidOperationException" />. El <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> y <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> métodos proporcionan soporte técnico para el cálculo de referencias en el subproceso correcto.  
  
Cuando sus <see cref="P:System.Windows.Freezable.IsFrozen" /> propiedad es <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objetos son de subprocesamiento libre.  Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de una clase <see cref="T:System.Windows.Freezable" /> derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Éste es el constructor de accesibilidad protegida de una clase abstracta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto se puede convertir en no modificable.</summary>
        <value><see langword="true" /> si el objeto actual se puede convertir en no modificable o ya lo es; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Implementación de este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método con <paramref name="isChecking" /> establecido en <see langword="true" /> para determinar si un <see cref="T:System.Windows.Freezable" /> puede se puede convertir en no modificable. Para modificar el comportamiento de esta propiedad en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se modifican la clase <see cref="T:System.Windows.Freezable" /> o un objeto que la contiene.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si intenta agregar o quitar controladores de eventos cuando el objeto actual no es modificable (cuando la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true`), se produce una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clon modificable del elemento <see cref="T:System.Windows.Freezable" /> y hace copias en profundidad de los valores del objeto. Cuando se copian las propiedades de dependencia del objeto, este método copia las expresiones (que puede que ya no se resuelvan), pero no copia las animaciones ni sus valores actuales.</summary>
        <returns>Clon modificable del objeto actual. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados). El clon es realmente una copia en profundidad del objeto actual.  
  
 En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.  
  
|Acción|Comportamiento del método Clone|Comportamiento del método CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copiar una propiedad de dependencia que tiene una expresión|La expresión se copia, pero podría no resolverse. Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Se copia el valor actual de la expresión, pero no la propia expresión.|  
|Copiar una propiedad de dependencia animada|Se copia el valor de la propiedad base (no animadas). No se copian las animaciones.|Se copia el valor animado de la propiedad actual. No se copian las animaciones.|  
  
 Tenga en cuenta que no se copian las propiedades sin establecer. Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  
  
## <a name="move-a-freezable-between-threads"></a>Mover un objeto inmovilizable entre subprocesos  
 Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos. En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante una llamada a su <xref:System.Windows.Freezable.Freeze%2A> método. Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y realice un local <xref:System.Windows.Freezable.Clone%2A> que puede tener acceso.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método usa <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> para generar el clon. Para modificar el comportamiento de este método en una clase derivada, invalide el <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objeto que se va a clonar.</param>
        <summary>Convierte la instancia en un clon (copia en profundidad) de la clase <see cref="T:System.Windows.Freezable" /> especificada con valores de propiedad base (no animadas).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el <xref:System.Windows.Freezable.Clone%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método. Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.Clone%2A> en lugar de llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Razones para invalidar incluyen lo siguiente: 
-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  
  
-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de todas las propiedades de escritura, establecidas localmente, incluidas las expresiones internas.  
  
Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero no se resuelvan. Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto tiene propiedades de dependencia animadas, se copia el valor base (no animados) de esas propiedades. No se copian las animaciones.  
  
Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura. Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  
  
En la lista siguiente se resume el comportamiento esperado para este método: 
-La copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.  
  
-No se copian las propiedades anular y de solo lectura.  
  
-Las expresiones se copian.  
  
-Ninguno de estos subobjetos se inmoviliza al crearlos.  
  
-No se inmovilice la copia de sí mismo.  
  
-Las animaciones no se copian.  
  
-Solo valores de base de propiedad son copiados, no animado los valores actuales.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un clon modificable (copia en profundidad) de <see cref="T:System.Windows.Freezable" /> con sus valores actuales.</summary>
        <returns>Clon modificable del objeto actual. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del objeto clonado es <see langword="false" /> aunque la propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> del origen sea <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos producen clones modificables de inmovilizado <xref:System.Windows.Freezable> objetos (los métodos también clonan <xref:System.Windows.Freezable> objetos que no están inmovilizados). El clon es realmente una copia en profundidad del objeto actual.  
  
 En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.Clone%2A> y <xref:System.Windows.Freezable.CloneCurrentValue%2A> métodos.  
  
|Acción|Comportamiento del método Clone|Comportamiento del método CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copiar una propiedad de dependencia que tiene una expresión|La expresión se copia, pero podría no resolverse. Para obtener más información, consulte [Información general sobre objetos Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Se copia el valor actual de la expresión, pero no la propia expresión.|  
|Copiar una propiedad de dependencia animada|Se copia el valor de la propiedad base (no animadas). No se copian las animaciones.|Se copia el valor animado de la propiedad actual. No se copian las animaciones.|  
  
 Tenga en cuenta que no se copian las propiedades sin establecer. Si una propiedad sin establecer tiene un valor predeterminado que está inmovilizado <xref:System.Windows.Freezable>, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  
  
## <a name="move-a-freezable-between-threads"></a>Mover un objeto inmovilizable entre subprocesos  
 Este método puede ser útil para mover un <xref:System.Windows.Freezable> entre subprocesos. En primer lugar, realice la <xref:System.Windows.Freezable> en no modificable mediante el uso de su <xref:System.Windows.Freezable.Freeze%2A> método. Ahora puede tener acceso otro subproceso el <xref:System.Windows.Freezable> y crear un clon local que puede tener acceso.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método usa la <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> método para generar el clon; <see cref="T:System.Windows.Freezable" /> implementadores que invalidarán <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> debe asegurarse de que no se inmoviliza la copia en la creación.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> que se va a clonar.</param>
        <summary>Convierte esta instancia en un clon modificable (copia en profundidad) del <see cref="T:System.Windows.Freezable" /> especificado mediante los valores de propiedad actuales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método. Para crear una copia modificable del objeto actual, llame a <xref:System.Windows.Freezable.CloneCurrentValue%2A> en lugar de llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Razones para invalidar incluyen lo siguiente: 
-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  
  
-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de todas las propiedades establecidas localmente, puede escribir. Si el objeto contiene las propiedades de dependencia con expresiones (por ejemplo, un enlace de datos), se copia el valor actual de la expresión pero no la propia expresión.  
  
Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.  
  
Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura. Si esta propiedad tiene un valor predeterminado que está inmovilizado <see cref="T:System.Windows.Freezable" />, que permanece inmovilizado en el clon modificable de lo contrario, valor de propiedad.  
  
En la lista siguiente se resume el comportamiento esperado para este método.  
  
-La copia generada contiene copias de todos los <see cref="T:System.Windows.Freezable" /> subobjetos.  
  
-No se copian las propiedades anular y de solo lectura.  
  
-Si una propiedad está animada, se copia su valor actual, pero la animación propiamente dicha no está.  
  
-Ninguno de estos subobjetos se inmoviliza al crearlos.  
  
-No se inmovilice la copia de sí mismo.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>La nueva instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se trata de un método protegido y las implementaciones específicas de objetos reales para el comportamiento dependen de la implementación de invalidación de la <xref:System.Windows.Freezable.CreateInstanceCore%2A> método, que llama internamente a este método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se implementa en una clase derivada, crea una nueva instancia de la clase <see cref="T:System.Windows.Freezable" /> derivada.</summary>
        <returns>La nueva instancia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método directamente (excepto cuando base la llamada en una implementación). Este método se llama internamente en el <xref:System.Windows.Freezable.CreateInstance%2A> método cada vez que una nueva instancia de la <xref:System.Windows.Freezable> se crea.  
  
   
  
## Examples  
 El ejemplo siguiente muestra una implementación típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cada <see cref="T:System.Windows.Freezable" /> clase derivada debe implementar este método. Una implementación típica consiste simplemente en llamar al constructor predeterminado y devolver el resultado.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convierte un objeto <see cref="T:System.Windows.Freezable" /> en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />, prueba si un objeto <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Convierte el objeto actual en no modificable y establece su propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> en <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar la posibilidad de un <xref:System.InvalidOperationException> al llamar a este método, compruebe el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad para determinar si el <xref:System.Windows.Freezable> puede convertir en no modificable antes de llamar a este método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Windows.Freezable" /> no se puede convertir en no modificable.</exception>
        <block subset="none" type="overrides"><para>Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable. Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Objeto que se va a comprobar o a convertir en no modificable. Si el valor de <paramref name="isChecking" /> es <see langword="true" />, se comprueba el objeto para determinar si se puede convertir en no modificable. Si el valor de <paramref name="isChecking" /> es <see langword="false" />, el objeto se convierte en no modificable, si es posible.</param>
        <param name="isChecking">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</param>
        <summary>Si el valor del parámetro <paramref name="isChecking" /> es <see langword="true" />, este método indica si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable. Si el valor del parámetro <paramref name="isChecking" /> es <see langword="false" />, este método intenta convertir la clase <see cref="T:System.Windows.Freezable" /> especificada en no modificable e indica si la operación se realiza correctamente.</summary>
        <returns>Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable. Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método, a menos que se va a derivar de <xref:System.Windows.Freezable> e invalidar la <xref:System.Windows.Freezable.FreezeCore%2A> método.  Este método puede usarse en el <xref:System.Windows.Freezable.FreezeCore%2A> método inmovilizar los miembros de datos de clase son por sí mismos <xref:System.Windows.Freezable> objetos.  
  
 Lo bueno es volver a llamar a este método en un <xref:System.Windows.Freezable> objeto que ya está inmovilizado (no modificable).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cuando el valor de <paramref name="isChecking" /> es <see langword="false" />, el intento para convertir <paramref name="freezable" /> en no modificable no dio resultado; el estado del objeto es desconocido puede estar parcialmente inmovilizado.</exception>
        <block subset="none" type="overrides"><para>Este método usa la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método para hacer el <see cref="T:System.Windows.Freezable" /> en no modificable. Para modificar el comportamiento de inmovilización, invalide el <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> método.</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">Es <see langword="true" /> para devolver una indicación de si se puede inmovilizar el objeto (sin inmovilizarlo realmente); es <see langword="false" /> para inmovilizarlo realmente.</param>
        <summary>Convierte el objeto <see cref="T:System.Windows.Freezable" /> en no modificable o prueba si se puede convertir en no modificable.</summary>
        <returns>Si el valor de <paramref name="isChecking" /> es <see langword="true" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> se puede convertir en no modificable o <see langword="false" /> si no se puede convertir en no modificable. Si el valor de <paramref name="isChecking" /> es <see langword="false" />, este método devuelve <see langword="true" /> si la clase <see cref="T:System.Windows.Freezable" /> especificada ahora no es modificable o <see langword="false" /> si no se puede convertir en no modificable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No llame a este método directamente (excepto cuando base la llamada en una implementación). Este método se llama internamente en el <xref:System.Windows.Freezable.CanFreeze%2A> propiedad (con `isChecking` igual a `true`) y el <xref:System.Windows.Freezable.Freeze%2A> método (con `isChecking` igual a `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> los implementadores deben invalidar este método cuando la clase contiene los datos que no se almacenan utilizando las propiedades de dependencia.  
  
Una implementación típica podría llamar a la base y luego llame al estático <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> método en todos los <see cref="T:System.Windows.Freezable" /> las propiedades que contiene la clase, devolver con tipo <see langword="true" /> sólo si todas las propiedades estén inmovilizadas (o se ha inmovilizado podría, en el caso de especificar <see langword="true" /> para <paramref name="isChecking" />).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" />, con los valores de propiedades base (no animadas). Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</summary>
        <returns>Copia inmovilizada de <see cref="T:System.Windows.Freezable" />. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe comprobar la <xref:System.Windows.Freezable.CanFreeze%2A> propiedad antes de llamar a este método para comprobar que el <xref:System.Windows.Freezable> se puede inmovilizar. Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.Clone%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.  
  
 El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.  
  
 En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.  
  
|Acción|Comportamiento del método GetAsFrozen|Comportamiento del método GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copiar una propiedad de dependencia que tiene una expresión|El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.|Se copia el valor actual de la expresión, pero no la propia expresión.|  
|Copiar una propiedad de dependencia animada|Se copia el valor de la propiedad base (no animadas). No se copian las animaciones.|Se copia el valor animado de la propiedad actual. No se copian las animaciones.|  
  
 Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.  
  
 Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.Clone%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se puede inmovilizar <see cref="T:System.Windows.Freezable" /> porque contiene expresiones o propiedades animadas.</exception>
        <block subset="none" type="overrides"><para>Este método usa virtual <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Instancia que se va a copiar.</param>
        <summary>Convierte la instancia en un clon inmovilizado de la clase <see cref="T:System.Windows.Freezable" /> especificada con los valores de propiedades base (no animadas).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el <xref:System.Windows.Freezable.GetAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método. Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetAsFrozen%2A> en lugar de llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si deriva de <see cref="T:System.Windows.Freezable" /> deberá reemplazar este método. Razones para invalidar incluyen lo siguiente: 
-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  
  
-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea copias en profundidad de cualquier Freezable no inmovilizados y superficiales copias de todos los demás grabable, localmente contiene las propiedades del conjunto. Si el objeto tiene propiedades de dependencia enlazada a datos, las expresiones se copian pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto tiene propiedades de dependencia animadas, se copian los valores base (no animados) de esas propiedades. No se copian las animaciones.  
  
Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.  
  
Si invalida este método, debe llamar a la implementación base.  
  
No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.  El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea una copia inmovilizada de <see cref="T:System.Windows.Freezable" /> con los valores de propiedad actuales. Puesto que se inmoviliza la copia, se copia cualquier subobjeto inmovilizado por referencia.</summary>
        <returns>Copia inmovilizada de <see cref="T:System.Windows.Freezable" />. La propiedad <see cref="P:System.Windows.Freezable.IsFrozen" /> de la copia se establece en <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con este método es similar a crear una copia mediante el <xref:System.Windows.Freezable.CloneCurrentValue%2A> y, a continuación, inmovilizarlo con el <xref:System.Windows.Freezable.Freeze%2A> método.  
  
 El <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos pueden mejorar el rendimiento de copia porque no clonan <xref:System.Windows.Freezable> subobjetos que ya están inmovilizados; solo copian por referencia.  
  
 En la tabla siguiente se resume las diferencias entre la <xref:System.Windows.Freezable.GetAsFrozen%2A> y <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> métodos.  
  
|Acción|Comportamiento del método GetAsFrozen|Comportamiento del método GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copiar una propiedad de dependencia que tiene una expresión|El método produce una <xref:System.InvalidOperationException> porque no es posible <xref:System.Windows.Freezable.Freeze%2A> la propiedad.|Se copia el valor actual de la expresión, pero no la propia expresión.|  
|Copiar una propiedad de dependencia animada|Se copia el valor de la propiedad base (no animadas). No se copian las animaciones.|Se copia el valor animado de la propiedad actual. No se copian las animaciones.|  
  
 Tenga en cuenta que no se copian las propiedades sin establecer ni son propiedades de solo lectura.  
  
 Para crear una copia de la <xref:System.Windows.Freezable> es decir, no está inmovilizada, use el <xref:System.Windows.Freezable.CloneCurrentValue%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método usa virtual <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> método para generar el clon.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Clase <see cref="T:System.Windows.Freezable" /> que se va a copiar e inmovilizar.</param>
        <summary>Convierte la instancia actual en un clon inmovilizado del valor de <see cref="T:System.Windows.Freezable" /> especificado. Si el objeto tiene propiedades de dependencia animadas, se copian sus valores animados actuales.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es invocado por el <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> método y no debe llamarse directamente desde el código, excepto cuando se llama a la implementación base mientras se invalida este método. Para crear una copia inmovilizada del objeto actual, llame a <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> en lugar de llamar a este método directamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si deriva de <see cref="T:System.Windows.Freezable" />, es posible que deba reemplazar este método. Razones para invalidar incluyen lo siguiente: 
-La clase derivada tiene datos que no se exponen a través de las propiedades de dependencia.  
  
-La clase derivada debe realizar trabajo adicional de inicialización que no se puede lograr simplemente invalidando <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Por ejemplo, esto se aplica si la clase derivada implementa <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Las clases que almacenan todos los datos en las propiedades de dependencia y que no es necesario realizar trabajo adicional de inicialización no es necesario invalidar <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Es fundamental que todas las implementaciones de llamar a la implementación base de este método. Las implementaciones solo deben realizar el trabajo que no se realiza la implementación predeterminada. La implementación predeterminada crea un nuevo <see cref="T:System.Windows.Freezable" /> utilizando el <see cref="M:System.Windows.Freezable.CreateInstance" /> método y hace copias en profundidad de Freezable no inmovilizados y copia superficial de todos los demás grabable y propiedades que contiene establecido localmente. Si el objeto tiene propiedades de dependencia enlazada a datos, los enlaces de datos se copian, pero ya no se pueden resolver; Para obtener más información acerca de la clonación de los objetos enlazados a datos, vea [Freezable Objects Overview](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si el objeto con propiedades de dependencia animadas, se copia el valor animado actual de esas propiedades, pero las animaciones no son.  
  
Propiedades de dependencia de sólo lectura dentro de un <see cref="T:System.Windows.Freezable" /> no se copian por esta implementación predeterminada.  
  
Si invalida este método, debe llamar a la implementación base.  
  
No es necesario <see cref="M:System.Windows.Freezable.Freeze" /> cuando se copian los valores.  El resultado se congela <see cref="M:System.Windows.Freezable.GetAsFrozen" /> antes de devolverse.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el objeto se puede modificar actualmente.</summary>
        <value><see langword="true" /> si el objeto se inmoviliza y no se puede modificar; <see langword="false" /> si se puede modificar el objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Al intentar modificar un objeto cuando su <xref:System.Windows.Freezable.IsFrozen%2A> propiedad es `true` produce una <xref:System.InvalidOperationException>.  
  
 Esta propiedad es de solo lectura desde la perspectiva del modelo de objeto. Parte de la documentación sobre <xref:System.Windows.Freezable> comportamientos se pueden mencionar "establece <xref:System.Windows.Freezable.IsFrozen%2A> a `true`" o lenguaje similar al hablar sobre el comportamiento de otros métodos de <xref:System.Windows.Freezable>, pero este comportamiento ocurre internamente en las instancias de clases Cuando los métodos de la instancia de manipulan las variables privadas que existen dentro de la clase abstracta. Para establecer el valor de esta propiedad, debe llamar a <xref:System.Windows.Freezable.Freeze%2A>. Esto es efectivamente una operación única para cambiar la <xref:System.Windows.Freezable.IsFrozen%2A> propiedad desde el valor predeterminado inicial `false` estado el `true` estado. No hay ningún medio disponible para establecer el valor a `false`. En su lugar, puede cambiar cualquier copia en profundidad realizada desde el original (consulte la <xref:System.Windows.Freezable.Clone%2A> método). Esto es así por diseño y es cómo debe comportarse cualquier clase derivada cuando se aplica a los casos donde el <xref:System.Windows.Freezable> patrón es útil.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se llama cuando el objeto <see cref="T:System.Windows.Freezable" /> actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama cada vez que el <xref:System.Windows.Freezable.Changed> se produce el evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Al implementar una clase que derive de <see cref="T:System.Windows.Freezable" />, puede invalidar este método para llevar a cabo las tareas.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos de tipo <see cref="T:System.Windows.DependencyObject" /> que se acaba de modificar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Valor previo del miembro de datos.</param>
        <param name="newValue">Valor actual del miembro de datos.</param>
        <summary>Se asegura de que se establecen los punteros contextuales adecuados para un miembro de datos <see cref="T:System.Windows.DependencyObjectType" /> que se acaba de establecer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe llamarse <xref:System.Windows.Freezable> los herederos cada vez que un <xref:System.Windows.DependencyObject> miembro de datos que no se almacena como un <xref:System.Windows.DependencyProperty> está establecido.  
  
 Este método no deben llamarse para <xref:System.Windows.DependencyObject> miembros de datos que se almacenan con un <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Valor previo del miembro de datos.</param>
        <param name="newValue">Valor actual del miembro de datos.</param>
        <param name="property">Propiedad que ha cambiado.</param>
        <summary>Este miembro es compatible con la infraestructura de [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] y no está diseñado para utilizarse directamente desde el código.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos de evento que contienen información acerca de qué propiedad ha cambiado y de sus valores antiguos y nuevos.</param>
        <summary>Reemplaza la implementación <see cref="T:System.Windows.DependencyObject" /> de <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> para invocar también cualquier controlador <see cref="E:System.Windows.Freezable.Changed" /> en respuesta a una propiedad de dependencia cambiante de tipo <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los datos de evento contienen información acerca de sólo el <xref:System.Windows.Freezable> propio. Cualquier información de la subpropiedad debe obtenerse a través de la <xref:System.Windows.Freezable.Changed> controladores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se asegura de que se tiene acceso a <see cref="T:System.Windows.Freezable" /> desde un subproceso válido. Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de las [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que lean miembros de datos que no son propiedades de dependencia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a la <see cref="M:System.Windows.Freezable.ReadPreamble" /> método antes de intentar tener acceso a los miembros que no son propiedades de dependencia. El <see cref="M:System.Windows.Freezable.WritePreamble" /> debe llamarse al método antes de que los miembros de este tipo se escriben en.  
  
Este método eficazmente no hace nada más que llamar a <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera el evento <see cref="E:System.Windows.Freezable.Changed" /> para <see cref="T:System.Windows.Freezable" /> e invoca su método <see cref="M:System.Windows.Freezable.OnChanged" />. Las clases que derivan de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al final de cualquier API que modifique miembros de clase que no estén almacenados como propiedades de dependencia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a este método al final de cualquier API que modifique un miembro de clase que no se almacena como un <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Comprueba que no se inmovilice <see cref="T:System.Windows.Freezable" /> y que se tiene acceso desde un contexto de subproceso válido. Los herederos de <see cref="T:System.Windows.Freezable" /> deben llamar a este método al inicio de cualquier [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] que escriba en miembros de datos que no sean propiedades de dependencia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método llama a <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> para comprobar el contexto del subproceso está accesible, y produce una excepción si el <xref:System.Windows.Freezable> instancia ya está inmovilizada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La instancia de <see cref="T:System.Windows.Freezable" /> se inmoviliza y no se puede escribir en sus miembros.</exception>
        <block subset="none" type="overrides"><para>Las clases que derivan de <see cref="T:System.Windows.Freezable" /> debe llamar a <see cref="M:System.Windows.Freezable.WritePreamble" /> antes de intentar escribir en los miembros que no son propiedades de dependencia. Si se llama a <see cref="M:System.Windows.Freezable.WritePreamble" /> en un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], puede omitir una llamada a <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>