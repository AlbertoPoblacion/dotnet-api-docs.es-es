<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f6112c09b1f961b689a530d29b65eeca46e3156" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679769" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contiene datos de eventos e información de estado asociados a un evento enrutado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentes <xref:System.Windows.RoutedEventArgs> puede utilizarse con un único <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Esta clase es responsable de empaquetar datos de evento para un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, que proporciona información de estado de evento adicional y es utilizada por el sistema de eventos para invocar el controlador asociado con el evento enrutado.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa este constructor sin parámetros, públicas todas las propiedades del nuevo <xref:System.Windows.RoutedEventArgs> instancia supone los siguientes valores predeterminados:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo significa que el <xref:System.Windows.RoutedEventArgs> datos no realizará ningún intento para especificar el origen. Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificador de evento enrutado para esta instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />, utilizando el identificador de evento enrutado proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se utiliza este constructor sobrecargado, no se especifica propiedades de la nueva <xref:System.Windows.RoutedEventArgs> instancia supone los siguientes valores predeterminados:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo significan que esto <xref:System.Windows.RoutedEventArgs> no hace ningún intento para especificar el origen. Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Windows.RoutedEventArgs> para su uso en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificador de evento enrutado para esta instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Origen alternativo que se notificará cuando se controla el evento. Esto rellena previamente la propiedad <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />, utilizando el identificador de evento enrutado proporcionado y dando la oportunidad de declarar un origen diferente para el evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se utiliza este constructor sobrecargado, no se especifica propiedades de la nueva <xref:System.Windows.RoutedEventArgs> instancia supone los siguientes valores predeterminados:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> se rellenan según el elemento que provocó el evento y se pasa mediante el enrutamiento, pero leerán `null` antes de invocación.  
  
 Utilizar esta firma al pasar <xref:System.Windows.RoutedEventArgs> para métodos virtuales como <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, donde se usan los argumentos para llamar a <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica el estado actual del control de eventos para un evento enrutado cuando recorre la ruta.</summary>
        <value>Si se establece, se establece en <see langword="true" /> si el evento se debe marcar como controlado; en caso contrario <see langword="false" />. Si se está leyendo este valor, <see langword="true" /> indica que un controlador de clase o algún controlador de la instancia de la ruta ya ha marcado este evento como controlado. <see langword="false" /> indica que ese controlador no ha marcado el evento como controlado.  
  
 El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcar el evento como controlado limitará la visibilidad del evento enrutado en agentes de escucha a lo largo de la ruta del evento. El evento seguir atravesando el resto de la ruta, pero sólo los controladores agregan específicamente con `HandledEventsToo` `true` en el <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> se invocará la llamada al método de respuesta. Predeterminada de controladores en los agentes de escucha de instancia (como las que se expresan en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) no se invocará. Control de eventos que se marcan controla no es un escenario común.  
  
 Si el autor de un control definir sus propios eventos, las decisiones que tome con respecto a la clase de control de eventos nivel afectará a los usuarios de su control, así como los usuarios de los controles derivados y potencialmente otros elementos que están contenidos en el control o que contienen el control. Para más información, vea [Marcar eventos enrutados como controlados y control de clases](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 En circunstancias muy poco habituales resulta adecuado controlar los eventos donde <xref:System.Windows.RoutedEventArgs.Handled%2A> está marcado como `true`y modificar los argumentos de evento cambiando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `false`. Esto puede ser necesario en determinadas áreas de eventos de entrada de controles, como control de claves de <xref:System.Windows.UIElement.KeyDown> frente a <xref:System.Windows.UIElement.TextInput> donde de bajo nivel y eventos de entrada de alto niveles compiten por el control y cada uno intenta trabajar con una estrategia de enrutamiento diferente.  
  
   
  
## Examples  
 En el ejemplo siguiente se implementa un controlador de eventos que marca el evento como controlado.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implementación del controlador/delegado genérico que se va a invocar.</param>
        <param name="genericTarget">El destino en el que se debe invocar el controlador proporcionado.</param>
        <summary>Cuando se invalida en una clase derivada, proporciona una manera de invocar controladores de eventos de una forma específica del tipo, lo que puede aumentar la eficacia en la implementación base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base incorpora una reflexión para determinar el controlador correcto para todos los casos donde el controlador no es literalmente <xref:System.Windows.RoutedEventHandler>, y este paso de reflexión tiene algunas consecuencias de rendimiento. Las invocaciones se pueden realizar más eficaces no confiar en la reflexión. Este es el escenario que hace que este método está disponible para cualquier clase de argumentos de evento enrutado que elija invalidarlo. Las implementaciones no deberían llamar a la base de este método, porque su implementación ya debe ser responsable de invocar los controladores de prueba de errores de tipo.  
  
   
  
## Examples  
 A continuación se muestra un pseudocódigo que ilustra un patrón básico que puede usarse para la implementación. En este caso, `MyRoutedEventHandler` es una subclase de <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Este método está pensado para ser invalidado por clases de datos de evento derivados para proporcionar una invocación más eficaz de sus delegados. La implementación debe convertir proporcionado <paramref name="genericHandler" /> específica del tipo de delegado y, a continuación, invocar ese controlador.  
  
 La implementación predeterminada intentará invocar el controlador proporcionado, intentando convertirlo como <see cref="T:System.Windows.RoutedEventHandler" />. Si el valor <paramref name="genericHandler" /> o <paramref name="genericTarget" /> se proporciona como <see langword="null" />, se generan excepciones.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nuevo valor en el que se establece <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Cuando se invalida en una clase derivada, proporciona un punto de entrada de devolución de llamada de notificación cada vez que cambia el valor de propiedad <see cref="P:System.Windows.RoutedEventArgs.Source" /> de una instancia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Cambiar mediante programación el origen notificado de un evento puede requerir potencialmente la actualización de los datos específicos del tipo dentro del evento. Por este motivo, el <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> método está protegido virtual y está pensado para ser invalidado por las subclases de <see cref="T:System.Windows.RoutedEventArgs" />.  
  
 Este método no tiene ninguna implementación predeterminada.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el origen inicial de los informes determinado por pruebas de acceso puro, antes de que una clase primaria realice posibles ajustes de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</summary>
        <value>Origen de notificación original, antes de cualquier posible ajuste de <see cref="P:System.Windows.RoutedEventArgs.Source" /> realizado por el control de clases, que se puede hacer para aplanar árboles de elementos compuestos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad adquiere su valor una vez, antes de la clase de controladores de eventos o los controladores de instancia se invocan y nunca se ajusta más allá de este punto. La información de origen original es de solo lectura para controladores de clase o implementaciones de la clase, tal y como se notifica en los datos del evento.  
  
 Donde se puede ajustar el origen de los casos comunes incluyen elementos de contenido dentro de un modelo de contenido para un control (el contenido de un elemento de lista, por ejemplo, notificará el elemento de lista como el <xref:System.Windows.RoutedEventArgs.Source%2A> y el elemento real dentro del elemento de lista será el <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Ajuste de origen por varios elementos y modelos de contenido varía en función de la clase a la clase. Cada clase que ajusta orígenes de eventos intenta anticipar qué origen es el más útil de notificar para la mayoría de los escenarios entrados así como los escenarios para los que la clase está diseñada y, a continuación, Establece que el origen es igual la <xref:System.Windows.RoutedEventArgs.Source%2A>. Si este origen no es aquel que tiene importancia para el control del evento, intente comprobar <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> en su lugar para ver si notifica un origen diferente que sea más adecuado. Para obtener más detalles sobre los eventos de entrada, consulte [información general de la entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> asociado a esta instancia de <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificador del evento que se ha invocado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede establecer este valor en un <xref:System.Windows.RoutedEventArgs> que ya se ha enrutado (por ejemplo, si ha adquirido los argumentos a través de un controlador). Intenta hacerlo, se generará una excepción. Sólo se puede establecer en una instancia que todavía no se haya usado para generar una invocación del evento.  
  
 El valor de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> no puede ser `null` en cualquier momento.  
  
   
  
## Examples  
 En el ejemplo siguiente se crean nuevos datos de eventos enrutados con un constructor inicial y, a continuación, Establece el <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propiedad como una operación subsiguiente. Debe tener <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> establecer antes de generar el evento enrutado.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se ha intentado cambiar el valor <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> mientras se enruta el evento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia al objeto que generó el evento.</summary>
        <value>El objeto que ha generado el evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para cualquier propagación enruta el evento que ha viajado realmente la ruta más allá del elemento que lo generó, y para cualquier protocolo de túnel evento que no ha enrutado todavía túnel hacia abajo hasta el elemento que lo provocó el valor de <xref:System.Windows.RoutedEventArgs.Source%2A> será diferente del valor de la `sender` parámetro de la clase de argumentos de evento. Cuál de los dos elementos implicados en el evento son de la mayor importancia en cualquier controlador determinado (<xref:System.Windows.RoutedEventArgs.Source%2A>, el elemento que lo provocó o `sender`, el elemento que se está controlando actualmente) depende de la lógica de aplicación que está solucionando el controlador.  
  
 Al establecer esta propiedad normalmente solo se realiza al invalidar o implementar otro [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] que ajustar los orígenes de eventos, como cuando un evento de control de clases. No se recomienda restablecer orígenes de eventos aparentes de controladores de instancias, especialmente cuando el controlador no marca el evento como controlado.  
  
 Si restablece <xref:System.Windows.RoutedEventArgs.Source%2A> para informar de un origen de evento diferente, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> seguirá creando informes origen como primer generado por el que se origina <xref:System.Windows.UIElement.RaiseEvent%2A> llamar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>