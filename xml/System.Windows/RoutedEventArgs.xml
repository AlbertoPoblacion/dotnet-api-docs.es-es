<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a843beac65eade38d0b3c1e6f313c24a1d7afd68" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65009582" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contiene datos de eventos e información de estado asociados a un evento enrutado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentes <xref:System.Windows.RoutedEventArgs> puede utilizarse con una sola <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Esta clase es responsable de empaquetar los datos del evento para un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, proporcionando información de estado de evento adicional y se usa el sistema de eventos para invocar el controlador asociado con el evento enrutado.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa este constructor sin parámetros, propiedades públicas del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> el valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> el valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo significa que el <xref:System.Windows.RoutedEventArgs> datos no realiza ningún intento para especificar el origen. Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">El identificador de evento enrutado para esta instancia de la <see cref="T:System.Windows.RoutedEventArgs" /> clase.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.Windows.RoutedEventArgs" /> clase, utilizando el identificador de evento enrutado proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa este constructor sobrecargado, no se especifica las propiedades del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> el valor predeterminado es `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sólo quiere decir esto <xref:System.Windows.RoutedEventArgs> no hace ningún intento para especificar el origen. Cuando se usa esta instancia en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> y <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valores se rellenan según el elemento que provocó el evento y se pasa a los agentes de escucha mediante el enrutamiento.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un nuevo <xref:System.Windows.RoutedEventArgs> para su uso en una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">El identificador de evento enrutado para esta instancia de la <see cref="T:System.Windows.RoutedEventArgs" /> clase.</param>
        <param name="source">Un origen alternativo que se notificará cuando se controla el evento. Esto rellena previamente la <see cref="P:System.Windows.RoutedEventArgs.Source" /> propiedad.</param>
        <summary>Inicializa una nueva instancia de la <see cref="T:System.Windows.RoutedEventArgs" /> clase, utilizando el identificador de evento enrutado proporcionado y dando la oportunidad de declarar un origen diferente para el evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa este constructor sobrecargado, no se especifica las propiedades del nuevo <xref:System.Windows.RoutedEventArgs> instancia suponen los valores predeterminados siguientes:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> el valor predeterminado es `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> el valor predeterminado es `null`.  
  
 Valores NULL para <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> se rellenan según el elemento que provocó el evento y se pasa mediante el enrutamiento, pero leerá `null` antes de invocación.  
  
 Utilizar esta firma al pasar <xref:System.Windows.RoutedEventArgs> a métodos virtuales como <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, donde los argumentos se usan para llamar a <xref:System.Windows.UIElement.RaiseEvent%2A> internamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica el estado actual del control de eventos para un evento enrutado cuando recorre la ruta.</summary>
        <value>Si se establece, se establece en <see langword="true" /> si el evento se debe marcar como controlado; en caso contrario <see langword="false" />. Si se lee este valor, <see langword="true" /> indica que un controlador de clase o algún controlador de instancia a lo largo de la ruta, ya ha marcado este evento como controlado. <see langword="false" /> indica que ese controlador no ha marcado el evento como controlado.  
  
El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marcar el evento como controlado limita la visibilidad del evento enrutado en agentes de escucha a lo largo de la ruta del evento. El evento seguir atravesando el resto de la ruta, pero sólo los controladores agregan específicamente con `HandledEventsToo` `true` en el <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> se invocará la llamada al método de respuesta. Predeterminada de controladores en los agentes de escucha de instancia (como los que se expresan en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) no se invocará. Controlar eventos marcados controlados no es un escenario común.  
  
 Si el autor de un control definir sus propios eventos, las decisiones que tome sobre eventos control en el nivel de clase afectará a los usuarios de su control, así como los usuarios de los controles derivados y potencialmente otros elementos que están contenidos en su control o que contienen el control. Para más información, vea [Marcar eventos enrutados como controlados y control de clases](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 En circunstancias muy poco habituales es adecuado controlar los eventos donde <xref:System.Windows.RoutedEventArgs.Handled%2A> está marcado como `true`y modificar los argumentos de evento cambiando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `false`. Esto puede ser necesario en determinadas áreas de los eventos de entrada de controles, como control de clave de <xref:System.Windows.UIElement.KeyDown> frente a <xref:System.Windows.UIElement.TextInput> donde bajo nivel y los eventos de entrada de alto niveles que compiten por el control y cada uno está intentando trabajar con una estrategia de enrutamiento distintos.  
  
   
  
## Examples  
 El ejemplo siguiente implementa un controlador de eventos que marca el evento como controlado.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implementación del controlador/delegado genérico que se va a invocar.</param>
        <param name="genericTarget">El destino en el que se debe invocar el controlador proporcionado.</param>
        <summary>Cuando se invalida en una clase derivada, proporciona una manera de invocar controladores de eventos de una forma específica del tipo, lo que puede aumentar la eficacia en la implementación base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación base incorpora una reflexión para determinar el controlador correcto para todos los casos donde el controlador no es literalmente <xref:System.Windows.RoutedEventHandler>, y este paso de reflexión tiene algunas consecuencias de rendimiento. Las invocaciones se pueden hacer más eficaces, no se base en la reflexión. Este es el escenario que motiva este método está disponible para cualquier clase de argumentos de evento enrutado que elija invalidarlo. Las implementaciones no deben llamar a la base para este método, porque su implementación ya debe ser responsable de invocar los controladores de tipo seguro.  
  
   
  
## Examples  
 El siguiente es un pseudocódigo que ilustra un patrón básico que puede usarse para la implementación. En este caso, `MyRoutedEventHandler` es una subclase de <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Este método está pensado para ser invalidado por las clases de datos de evento derivados para proporcionar una invocación más eficaz de sus delegados. La implementación debería convertir proporcionado <paramref name="genericHandler" /> específico del tipo de delegado y, a continuación, invocar ese controlador.  
  
La implementación predeterminada intentará invocar el controlador proporcionado, intentando convertirlo como <see cref="T:System.Windows.RoutedEventHandler" />. Si bien <paramref name="genericHandler" /> o <paramref name="genericTarget" /> se proporciona como <see langword="null" />, se generan excepciones.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">El nuevo valor que <see cref="P:System.Windows.RoutedEventArgs.Source" /> se establece en.</param>
        <summary>Cuando se invalida en una clase derivada, proporciona una entrada de devolución de llamada de notificación cada vez que seleccione el valor de la <see cref="P:System.Windows.RoutedEventArgs.Source" /> propiedad de los cambios de la instancia.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Cambiar el origen de un evento notificado mediante programación posiblemente puede exigir la actualización de los datos específicos del tipo dentro del evento. Por este motivo, el <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> método está protegido virtual y está pensado para ser invalidado por las subclases de <see cref="T:System.Windows.RoutedEventArgs" />.  
  
Este método no tiene ninguna implementación predeterminada.</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el origen inicial de los informes determinado por pruebas de acceso puro, antes de que una clase primaria realice posibles ajustes de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</summary>
        <value>Origen inicial de los informes, antes de que el control de clases realizara posibles ajustes de <see cref="P:System.Windows.RoutedEventArgs.Source" />, que podría haber llevado a cabo para reducir árboles de elementos compuestos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad adquiere su valor una vez, antes de la clase de controladores de eventos o cualquier instancia se invocan y nunca se ajusta más allá de este punto. La información de origen original es de solo lectura a los controladores de clase o implementaciones de la clase, tal como se notifica en los datos del evento.  
  
 Donde se puede ajustar el origen de los casos comunes incluyen elementos de contenido dentro de un modelo de contenido para un control (el contenido de un elemento de lista, por ejemplo, notificará el elemento de lista como la <xref:System.Windows.RoutedEventArgs.Source%2A> y el elemento real dentro del elemento de lista será el <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Ajuste de origen por varios elementos y los modelos de contenido varía en función de la clase. Cada clase que se ajusta a los orígenes de eventos intenta anticipar qué origen es el más útil informar de más escenarios de entrada y los escenarios para los que la clase está diseñada y, a continuación, Establece que el origen de como el <xref:System.Windows.RoutedEventArgs.Source%2A>. Si este origen no es aquel que tiene relevancia para el control del evento, vuelva a comprobar <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> en su lugar para ver si notifica un origen diferente que sea más adecuado. Para obtener más detalles sobre los eventos de entrada, consulte [información general sobre entrada](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> asociado a esta instancia <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificador del evento que se ha invocado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se puede establecer este valor en un <xref:System.Windows.RoutedEventArgs> que ya se ha enrutado (por ejemplo, si ha obtenido los argumentos a través de un controlador). Intenta hacer esto, se generará una excepción. Solo se puede establecer en una instancia que aún no se ha usado para generar una invocación del evento.  
  
 El valor de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> no puede ser `null` en cualquier momento.  
  
   
  
## Examples  
 El ejemplo siguiente se crea nuevos datos de eventos enrutados con un constructor inicial y, a continuación, Establece el <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propiedad como una operación posterior. Debe tener <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> establecido antes de provocar el evento enrutado.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Intentó cambiar la <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> valor mientras se estaba enrutando el evento.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una referencia al objeto que generó el evento.</summary>
        <value>El objeto que ha generado el evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para cualquier propagación enruta el evento que se haya desplazado realmente la ruta más allá del elemento que lo generó, y para cualquier tipo de túnel enruta los eventos que no tiene todavía hasta el elemento que lo generó, el valor de la tunelización <xref:System.Windows.RoutedEventArgs.Source%2A> será diferente del valor de la `sender` parámetro de la clase de argumentos de evento. Cuál de los dos elementos implicados en el evento son de la mayor importancia en cualquier controlador determinado (<xref:System.Windows.RoutedEventArgs.Source%2A>, el elemento que lo provocó o `sender`, el elemento que se está controlando actualmente) depende de la lógica de aplicación que es el controlador direccionamiento.  
  
 Al establecer esta propiedad normalmente solo se realiza al invalidar o implementar otras [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] que ajustar los orígenes de eventos, como cuando un evento de control de clases. No se recomienda restablecer orígenes de eventos aparente de los controladores de instancia, especialmente cuando el controlador no marca el evento como controlado.  
  
 Si restablece <xref:System.Windows.RoutedEventArgs.Source%2A> para informar de un origen de eventos diferentes, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> seguirá al informe de origen como primera generado por el que se origina <xref:System.Windows.UIElement.RaiseEvent%2A> llamar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>