<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CoerceValueCallback.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5edddfb39d197bb5c7d9ebb6e4c366a99eae21935.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edddfb39d197bb5c7d9ebb6e4c366a99eae21935</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The object that the property exists on.</source>
          <target state="translated">Objeto en el que existe la propiedad.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>When the callback is invoked, the property system will pass this value.</source>
          <target state="translated">Cuando se invoca la devolución de llamada, el sistema de propiedades pasará este valor.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The new value of the property, prior to any coercion attempt.</source>
          <target state="translated">Nuevo valor de la propiedad, antes de cualquier intento de conversión.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</source>
          <target state="translated">Proporciona una plantilla para un método al que se llama cuando se vuelve a evaluar el valor de una propiedad de dependencia o cuando se solicita específicamente la conversión.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The coerced value (with appropriate type).</source>
          <target state="translated">Valor convertido (con el tipo apropiado).</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Callbacks based on <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.</source>
          <target state="translated">Tomando como base las devoluciones de llamada <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> puede asignarse a una propiedad de dependencia a través de varias técnicas diferentes.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Each of these techniques requires that you first create a new property metadata object (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</source>
          <target state="translated">Cada una de estas técnicas requiere que primero cree un nuevo objeto de metadatos de propiedad (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, o una clase derivada como <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Create the metadata object using a constructor signature that takes the <ph id="ph1">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.</source>
          <target state="translated">Crear el objeto de metadatos mediante una firma de constructor que toma el <ph id="ph1">`coerceValueCallback`</ph> parámetro y asignar ese parámetro al controlador de devolución de llamada.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Or construct the metadata by any signature and set the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.</source>
          <target state="translated">O generar los metadatos por cualquier firma y el conjunto del <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> propiedad antes de colocar los metadatos en uso.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>When you have this metadata, you can:</source>
          <target state="translated">Cuando tenga estos metadatos, hacer lo siguiente:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Define a new dependency property on a new class, using either signature of  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id="ph2">`typeMetadata`</ph> value.</source>
          <target state="translated">Definir una nueva propiedad de dependencia en una nueva clase, utilizando cualquiera de las firmas de <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, proporcionando los metadatos como el <ph id="ph2">`typeMetadata`</ph> valor.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Override the metadata (call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.</source>
          <target state="translated">Invalidar los metadatos (llamar a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) para una propiedad de dependencia existente, al derivar de la clase que posee la propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Add an existing dependency property to a new <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Agregar una propiedad de dependencia existente a un nuevo <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> de la clase, utilizando los nuevos metadatos, mediante una llamada a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Implementations of this callback should check the value in <ph id="ph1">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.</source>
          <target state="translated">Las implementaciones de esta devolución de llamada deben comprobar el valor <ph id="ph1">`baseValue`</ph> y determinar según el valor o el tipo si se trata de un valor que necesita ser convertidos aún más.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id="ph4">`dp`</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> de una dependencia de propiedad se invoca cada vez que el sistema de propiedades o algún otro llamador llama <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> en un <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instancia especificando el identificador de la propiedad como el <ph id="ph4">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Changes to the property value may have come from any possible participant in the property system.</source>
          <target state="translated">Cambios en el valor de propiedad pueden proceder de cualquier posible participante en el sistema de propiedades.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</source>
          <target state="translated">Esto incluye estilos, invalidación genérica, desencadenadores, herencia del valor de propiedad y valor local.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Generally you should avoid specifying more than one <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</source>
          <target state="translated">Por lo general, no debes especificar más de una <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> para cualquier tiene la propiedad de dependencia (reemplazando o agregando con nuevos metadatos para una propiedad de dependencia que ya tenía un <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.</source>
          <target state="translated">Solo una de las devoluciones de llamada podrá actuar. La devolución de llamada que actúe será la que se aplica a la clase más derivada en la herencia en comparación con el <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> autor de la llamada.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</source>
          <target state="translated">Otras devoluciones de llamada como asignadas a los metadatos para la propiedad de dependencia tal como se encontraban superior en la jerarquía del propietario se reemplazan cuando se invalidan los metadatos.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</source>
          <target state="translated">En el ejemplo siguiente se incluye una implementación de esta devolución de llamada para convertir el valor almacenado de una propiedad de dependencia basado en otras entradas, como valor de otra propiedad.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>In this case, the callback checks to see whether the <ph id="ph1">`ShirtType`</ph> property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the <ph id="ph2">`ButtonColor`</ph>, if the shirt type has no buttons, it coerces the <ph id="ph3">`ButtonColor`</ph> value back to a starting value, which causes the <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (not shown) to remove that dropdown from the effective choices.</source>
          <target state="translated">En este caso, la devolución de llamada comprueba si la <ph id="ph1">`ShirtType`</ph> propiedad se corresponde con un tipo de camisa que tiene botones; si es así establece un color predeterminado inicial para la <ph id="ph2">`ButtonColor`</ph>, si el tipo de camisa no tiene ningún botón, convierte la <ph id="ph3">`ButtonColor`</ph> valor un valor inicial, lo que hace el <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (no mostrado) para quitar esa lista desplegable de las opciones efectivo.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>