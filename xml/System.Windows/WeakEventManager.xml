<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7c50f8e21321e058314ffb0c59534252db4eb2aa" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52232401" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una clase base para el administrador de eventos que se usa en el *modelo de evento débil*. El administrador agrega y quita los agentes de escucha para los eventos (o las devoluciones de llamada) que también usan el modelo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, el modelo de evento débil se usa cuando el origen de eventos tiene una duración del objeto que es independiente de los agentes de escucha de eventos. Mediante el evento central distribuir la capacidad de un <xref:System.Windows.WeakEventManager> que los controladores de los agentes de escucha pueden recogidos incluso si persiste el objeto de origen. Por el contrario, un enlace de eventos regulares mediante la `+=` operador hace que el origen potencialmente desconectado mantener una referencia a los agentes de escucha. Esto impide que el receptor se recopila de manera oportuna.  
  
 Una situación común donde se deben usar las relaciones de duración entre orígenes y los agentes de escucha del modelo de evento débil es el control de eventos de actualización procedentes de los enlaces de datos.  
  
 El modelo de evento débil puede usarse también para las devoluciones de llamada y eventos normales.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Para obtener un ejemplo de un personalizado <see cref="T:System.Windows.WeakEventManager" />, consulte [modelos de evento débil](~/docs/framework/wpf/advanced/weak-event-patterns.md).</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa los valores de la clase base cuando el constructor de una clase derivada los usa como inicializador.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Objeto en el que se administra el evento.</param>
        <param name="args">
          <see cref="T:System.EventArgs" /> que contiene los datos que el evento va a entregar.</param>
        <summary>Entrega el evento que se administra a cada agente de escucha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método dentro de los controladores de eventos que se agregan o quitan por la <xref:System.Windows.WeakEventManager.StartListening%2A> y <xref:System.Windows.WeakEventManager.StopListening%2A> las implementaciones de las subclases.  
  
 Si se llama a la <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> método en su `AddListener` implementación de la clase, la lista de agentes de escucha recibe el evento se mantiene en una colección subyacente. (`AddListener` no forma parte de un contrato de interfaz o clase. `AddListener` es el nombre sugerido para el método de la clase de administrador que llama a <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> y agrega los agentes de escucha de evento débil patrón para el evento.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> los agentes de escucha se agrega a una lista. Si la implementación del administrador mantiene más de una lista de agentes de escucha por evento, no use <xref:System.Windows.WeakEventManager.DeliverEvent%2A> o <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. En su lugar, la implementación debe crear su propio <xref:System.Windows.WeakEventManager.ListenerList> instancias, `AddListener` debe agregar los agentes de escucha a la lista correspondiente, y los eventos se deben entregar a la lista de agente de escucha adecuado mediante una llamada a <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">Objeto en el que se administra el evento.</param>
        <param name="args">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <param name="list">
          <see cref="T:System.Windows.WeakEventManager.ListenerList" /> proporcionado.</param>
        <summary>Entrega el evento que se administra a cada agente de escucha en la lista proporcionada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es necesario si la implementación del administrador mantiene las listas de agentes de escucha independientes según la información que se captura en los datos del evento. Si usa esta técnica avanzada, debe crear y mantener listas independientes como parte de la implementación del administrador, y debe proporcionar una manera de agregar los agentes de escucha a una lista específica. La implementación del controlador que escucha el evento sin formato debe actuar según la condición que se usa para diferenciar las listas y entregar el evento únicamente a la lista o listas adecuadas.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">Tipo para el que se obtiene <see cref="T:System.Windows.WeakEventManager" />.</param>
        <summary>Devuelve la implementación de <see cref="T:System.Windows.WeakEventManager" /> que se usa para el tipo proporcionado.</summary>
        <returns>Implementación de <see cref="T:System.Windows.WeakEventManager" /> correspondiente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> las implementaciones de llamar a este método mediante su pasado `managerType`. El valor devuelto <xref:System.Windows.WeakEventManager> , a continuación, se usa como el diferenciador que determina qué evento se recibió y qué controlador de clase privada que se inicia.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Índice de base cero del origen solicitado.</param>
        <summary>Obtiene o establece los datos que se almacenan para el origen especificado.</summary>
        <value>Datos que almacena el administrador para este origen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas pueden elegir qué datos y tipos se almacenan en este indizador. Normalmente, esto se implementa como un <xref:System.Windows.WeakEventManager.ListenerList>, que es una lista de referencias débiles a los agentes de escucha. Sólo tendría que cambiar este tipo si el <xref:System.Windows.WeakEventManager.ListenerList> tipo no puede contener la información necesaria. Si es así, tendrá que reemplazar el <xref:System.Windows.WeakEventManager.Purge%2A> método para que toda la limpieza del tipo subyacente se realiza correctamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un nuevo objeto para contener agentes de escucha para un evento.</summary>
        <returns>Nuevo objeto para contener agentes de escucha para un evento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">El objeto de origen al que el delegado de controlador se suscribe.</param>
        <param name="handler">Delegado que controla el evento generado por <paramref name="source" />.</param>
        <summary>Agrega el delegado especificado como controlador de eventos del origen especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Origen al que se asocian los agentes de escucha.</param>
        <param name="listener">Clase que realiza las escuchas (que debe implementar <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Agrega el agente de escucha proporcionado al origen proporcionado para el evento que se administra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método dentro de la clase manager `AddListener` métodos en <xref:System.Windows.WeakEventManager> implementaciones. `AddListener` es el nombre sugerido para el método estático que define en la clase de administrador para habilitar otras clases agregar un agente de escucha para el modelo de evento débil. `AddListener` debe tomar dos parámetros: el `source` donde el agente de escucha está conectado y el `listener` instancia. Para su `AddListener` implementación, llamada la <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> método en el administrador actual y pase los mismos dos parámetros.  
  
 Si la lista de agentes de escucha estaba vacía anteriormente <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> llamadas la <xref:System.Windows.WeakEventManager.StartListening%2A> método internamente, que llamará específica de su <xref:System.Windows.WeakEventManager.StartListening%2A> invalidar a través de polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> los agentes de escucha se agrega a una sola interna <xref:System.Windows.WeakEventManager.ListenerList> por `source`. Si la implementación del administrador mantiene más de una lista de agentes de escucha para cada combinación de origen del evento, no use <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. En su lugar, la implementación debe crear su propio <xref:System.Windows.WeakEventManager.ListenerList> instancias, `AddListener` debe agregar los agentes de escucha a la lista correspondiente, y los eventos se deben entregar a la lista de agente de escucha adecuado mediante una llamada a la <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> eventos en lugar de la <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Origen del que se va a quitar el controlador.</param>
        <param name="handler">Delegado que se va a quitar de <paramref name="source" />.</param>
        <summary>Quita el controlador agregado anteriormente del origen especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">Origen del que se quitan los agentes de escucha.</param>
        <param name="listener">Clase que realiza las escuchas (que debe implementar <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Quita un agente de escucha previamente agregado del origen proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método dentro de la clase manager `RemoveListener` métodos en <xref:System.Windows.WeakEventManager> implementaciones. `RemoveListener` es el nombre sugerido para el método estático que define en la clase de administrador para habilitar otras clases quitar un agente de escucha para el modelo de evento débil. `RemoveListener` debe tomar dos parámetros: el `source` donde se quita el agente de escucha y el `listener` clase. Para su `RemoveListener` implementación, llamada la <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> método en el administrador actual y pase los mismos dos parámetros.  
  
 Si una llamada a <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> quita el último agente de escucha en la lista, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> llamadas la <xref:System.Windows.WeakEventManager.StopListening%2A> método internamente, que llamará específica de su <xref:System.Windows.WeakEventManager.StopListening%2A> invalidar a través de polimorfismo.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Quita los agentes de escucha de un solo interno <xref:System.Windows.WeakEventManager.ListenerList> por `source`. Si la implementación del administrador mantiene más de una lista de agentes de escucha para cada combinación de origen del evento, no use <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. En su lugar, la implementación debe crear su propio <xref:System.Windows.WeakEventManager.ListenerList> instancias, `RemoveListener` debe quitar los agentes de escucha de la lista adecuada y los eventos se deben entregar a la lista de agente de escucha adecuado mediante una llamada a la <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> método en lugar de la <xref:System.Windows.WeakEventManager.DeliverEvent%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Origen de los eventos que se escuchan.</param>
        <param name="data">Datos que se van a comprobar. Se espera que este objeto sea una implementación de <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <param name="purgeAll">Es <see langword="true" /> para dejar de escuchar a <paramref name="source" /> y quitar completamente todas las entradas de <paramref name="data" />.</param>
        <summary>Quita las entradas del agente de escucha inactivas de la lista de datos para el origen proporcionado. Devuelve <see langword="true" /> si se quitaron realmente algunas entradas de la lista.</summary>
        <returns>
          <see langword="true" /> si se han quitado realmente algunas entradas; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.WeakEventManager.Purge%2A> método tiene una implementación predeterminada que se quitará todas las entradas cuando los datos están un <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si la base de tipo de la <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> es algo que no sean <see cref="T:System.Windows.WeakEventManager.ListenerList" />, o contiene datos más allá de un <see cref="T:System.Windows.WeakEventManager.ListenerList" />, debe invalidar el <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> método. La invalidación debe proporcionar el comportamiento de purga de la lista de elementos de tipo alternativo. Por lo general, la invalidación debe proporcionar el comportamiento sin llamar a la implementación base. Si un determinado <see cref="T:System.Windows.WeakEventManager.ListenerList" /> todavía necesita borrar, llamada <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un bloqueo de lectura en la tabla de datos subyacente y devuelve <see cref="T:System.IDisposable" />.</summary>
        <value>Objeto que puede usarse para establecer un bloqueo en los miembros de la tabla de datos y, a continuación, eliminarse correctamente con una construcción <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En las clases derivadas, consulta a la tabla contenida en <xref:System.Windows.WeakEventManager.Item%2A> siempre debe realizarse dentro de un `using (ReadLock) { ... }` cláusula, excepto para las consultas que ya están dentro de un bloqueo de escritura. Estas consultas pueden ser necesarias si su clase admite más sofisticados `AddListener` implementación que requiere más datos más allá de la `source` y `listener`y usa el <xref:System.Windows.WeakEventManager.Item%2A> colección para almacenar la información adicional.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origen del que se quita la información del agente de escucha.</param>
        <summary>Quita todos los agentes de escucha del origen especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita que se realice una purga de entradas no usadas en la lista de agentes de escucha subyacente en un subproceso de menor prioridad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a la <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> es similar a llamar al método el <xref:System.Windows.WeakEventManager.Purge%2A> método en la lista del administrador actual, con prioridad inferior de subprocesos, con el `purgeAll` parámetro establecido en `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">Tipo en el que se establece el nuevo administrador de eventos.</param>
        <param name="manager">Nuevo administrador del evento.</param>
        <summary>Establece el administrador actual para el tipo de administrador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a la <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> método para inicializar un administrador, si es necesario mediante una llamada a su `CurrentManager` propiedad en un <xref:System.Windows.WeakEventManager> implementación.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origen en el que se empiezan a realizar escuchas.</param>
        <summary>Cuando se invalida en una clase derivada, inicia la escucha para el evento que se administra. Después de llamar al método <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> por primera vez, el administrador debe estar en el estado de llamar a <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> o <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> cada vez que se administre el evento pertinente del origen proporcionado.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> Overrides deben agregar un controlador a proporcionado <paramref name="source" />. El controlador se declara mediante el propio administrador. El controlador de clase no debe ser público y solo debe llamarse en respuesta al evento que se va a administrar. El controlador de clase debe llamar a la <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> método o la <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> método correctamente.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Origen en el que se dejan de realizar escuchas.</param>
        <summary>Cuando se invalida en una clase derivada, deja de realizar escuchas en el origen proporcionado para el evento que se administra.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> las implementaciones deben quitar el controlador de clase como agregados por el <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> método. Quitar un agente de escucha no debe borrar la lista de escucha. En su lugar, solo debe desconectar el controlador de clase (quizás temporalmente). Existen otros métodos para borrar la lista completa, como el <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> método con el <paramref name="purgeAll" /> parámetro establecido en <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece un bloqueo de escritura en la tabla de datos subyacente y devuelve <see cref="T:System.IDisposable" />.</summary>
        <value>Objeto que puede usarse para establecer un bloqueo en los miembros de la tabla de datos y, a continuación, eliminarse correctamente con una construcción <see langword="using" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En las clases derivadas, todas las modificaciones en la tabla de datos subyacente deben realizarse dentro de un `using (WriteLock) { ... }` cláusula. Estas modificaciones pueden ser necesarias si su clase admite más sofisticados `AddListener` implementación que requiere más datos más allá de la `source` y `listener`y usa el <xref:System.Windows.WeakEventManager.Item%2A> colección para almacenar la información adicional.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>