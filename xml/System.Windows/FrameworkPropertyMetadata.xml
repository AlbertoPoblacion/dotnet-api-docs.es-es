<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkPropertyMetadata.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c70304d7b52b8f4e76c37fd1e35de0928f9619c7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c70304d7b52b8f4e76c37fd1e35de0928f9619c7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Reports or applies metadata for a dependency property, specifically adding framework-specific property system characteristics.</source>
          <target state="translated">Notifica o aplica los metadatos de una propiedad de dependencia, agregando específicamente las características del sistema de propiedades específico del marco.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class derives from <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (through <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>) .</source>
          <target state="translated">Esta clase se deriva de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> (a través de <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>For most WPF framework-level application development purposes, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is the type used for dependency property metadata, rather than the base metadata types <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> or <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Para fines de desarrollo de aplicaciones de nivel de marco WPF mayoría, <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> es el tipo utilizado para los metadatos de la propiedad de dependencia, en lugar de los tipos de metadatos base <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> o <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This is true both for existing dependency properties and for most custom dependency property scenarios.</source>
          <target state="translated">Esto es cierto para las propiedades de dependencia existentes y para la mayoría de los escenarios de propiedad de dependencia personalizada.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The members declared by this class that supplement the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> base class include various Boolean properties that specify or report WPF framework-level property system behavior such as property inheritance, data binding, and layout.</source>
          <target state="translated">Los miembros declarados por esta clase que complementan la <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> clase base incluyen varias propiedades booleanas que especifican o comportamiento del sistema de propiedad de nivel de marco WPF como herencia de propiedades, enlace de datos y diseño de informes.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Several constructor signatures for creating a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance take a <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parameter.</source>
          <target state="translated">Varias firmas de constructor para crear un <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instancia tienen un <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> parámetro.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeration is used only to specify initial behavior in the constructor, and is not otherwise exposed after <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> is constructed.</source>
          <target state="translated">El <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> enumeración sólo se utiliza para especificar el comportamiento inicial en el constructor y no se expone en caso contrario, después de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> se construye.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>From a constructed instance, you can get or set the corresponding information through various properties that share the name of the enumeration values used in the constructor call.</source>
          <target state="translated">Desde una instancia construida, puede obtener o establecer la información correspondiente a través de varias propiedades que comparten el nombre de los valores de enumeración que se utiliza en la llamada al constructor.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>This class is not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Esta clase no se utiliza normalmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>The following example gets metadata for a dependency property on a particular owner as the initial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type.</source>
          <target state="translated">En el ejemplo siguiente se obtiene metadatos para una propiedad de dependencia en el propietario de un determinado como la inicial base <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> tipo.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>That metadata is cast to <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</source>
          <target state="translated">Que los metadatos se convierten en <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>If the cast returned a valid <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, then various <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> property values are reported through a simple UI (not shown).</source>
          <target state="translated">Si la conversión devolvió válido <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>, a continuación, varios <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> valores de propiedad se notifican a través de una interfaz de usuario simple (no se muestra).</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkPropertyMetadata">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source>This signature initializes all values of <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> to their property defaults.</source>
          <target state="translated">Esta firma inicializa todos los valores de <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A&gt;</ph> en sus valores de propiedad predeterminados.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor">
          <source><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> will be <ph id="ph2">`null`</ph>, and the various <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> Boolean properties will be <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> será <ph id="ph2">`null`</ph>y los diversos <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades booleanas será <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified default value.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado especificado.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con la devolución de llamada de <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Marcadores de la opción de metadatos (una combinación de valores de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework-level metadata options.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado y las opciones de metadatos de nivel de marco.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Los valores marcan como marcadores establecidos en el <ph id="ph1">`flags`</ph> parámetro establecerá el valor booleano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades que coinciden con que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nombre del marcador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>You can subsequently change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Posteriormente puede cambiar los valores de las propiedades de los metadatos, como los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado y la devolución de llamada de <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Se llamará a una referencia a una implementación del controlador siempre que el sistema de propiedades llame a <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> para esta propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the specified callbacks.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con las devoluciones de llamada de especificadas.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>This implementation calls a base initializer and then adds the <ph id="ph1">`coerceValueCallback`</ph> by setting the property on the base instance.</source>
          <target state="translated">Esta implementación llama a un inicializador de base y, a continuación, agrega el <ph id="ph1">`coerceValueCallback`</ph> estableciendo la propiedad en la instancia de base.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The default value of the dependency property, usually provided as a value of a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Marcadores de la opción de metadatos (una combinación de valores de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> callback.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado, las opciones de metadatos de nivel de marco y la devolución de llamada de <ph id="ph2">&lt;see cref="T:System.Windows.PropertyChangedCallback" /&gt;</ph> especificada.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Los valores marcan como marcadores establecidos en el <ph id="ph1">`flags`</ph> parámetro establecerá el valor booleano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades que coinciden con que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nombre del marcador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Todavía puede cambiar los valores de las propiedades de los metadatos, como los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> for this dependency property.</source>
          <target state="translated">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> para esta propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and specified callbacks.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado y las devoluciones de llamada especificadas.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Marcadores de la opción de metadatos (una combinación de valores de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> en esta propiedad.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, and specified callbacks.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado, las opciones de metadatos de nivel de marco y las devoluciones de llamada especificadas.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Los valores marcan como marcadores establecidos en el <ph id="ph1">`flags`</ph> parámetro establecerá el valor booleano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades que coinciden con que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nombre del marcador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Todavía puede cambiar los valores de las propiedades de los metadatos, como los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Marcadores de la opción de metadatos (una combinación de valores de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> on this dependency property.</source>
          <target state="translated">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> en esta propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para evitar que el sistema de propiedades anime la propiedad a la que se aplican los metadatos.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Tales propiedades producirán una excepción en tiempo de ejecución que se origina desde el sistema de propiedades si se intentan su animación.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to permit animating the property.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="false" /&gt;</ph> para permitir animar la propiedad.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, and a Boolean that can be used to prevent animation of the property.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado y las opciones de metadatos de marco, las devoluciones de llamada especificadas y un valor de tipo booleano que se pueden usar para evitar la animación de la propiedad.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated">El <ph id="ph1">`isAnimationProhibited`</ph> parámetro establece el valor inicial de la <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> propiedad declarada por la base de inmediata <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Los valores marcan como marcadores establecidos en el <ph id="ph1">`flags`</ph> parámetro establecerá el valor booleano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades que coinciden con que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nombre del marcador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Todavía puede cambiar los valores de las propiedades de los metadatos, como los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source>The following example calls this constructor signature:</source>
          <target state="translated">En el ejemplo siguiente se llama a esta firma de constructor:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default value of the dependency property, usually provided as a specific type.</source>
          <target state="translated">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The metadata option flags (a combination of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph> values).</source>
          <target state="translated">Marcadores de la opción de metadatos (una combinación de valores de <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>These options specify characteristics of the dependency property that interact with systems such as layout or data binding.</source>
          <target state="translated">Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that the property system will call whenever the effective value of the property changes.</source>
          <target state="translated">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>A reference to a handler implementation that will be called whenever the property system calls <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> against this property.</source>
          <target state="translated">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /&gt;</ph> en esta propiedad.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to prevent the property system from animating the property that this metadata is applied to.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> para evitar que el sistema de propiedades anime la propiedad a la que se aplican los metadatos.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Such properties will raise a run-time exception originating from the property system if animations of them are attempted.</source>
          <target state="translated">Tales propiedades producirán una excepción en tiempo de ejecución que se origina desde el sistema de propiedades si se intentan su animación.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for this property are applied that have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> que se va a usar cuando se aplican enlaces para esta propiedad que tiene su conjunto de <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> establecido en <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> class with the provided default value and framework metadata options, specified callbacks, a Boolean that can be used to prevent animation of the property, and a data-binding update trigger default.</source>
          <target state="translated">Inicializa una nueva instancia de la clase <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> con el valor predeterminado proporcionado y las opciones de metadatos de marco, las devoluciones de llamada especificadas y un valor de tipo booleano que se pueden usar para evitar la animación de la propiedad; así como el valor predeterminado de un desencadenador de actualización de enlace de datos.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The type of the value provided for <ph id="ph1">`defaultValue`</ph> must match or be related to the type specified in the original registration of the dependency property that this metadata will be applied to.</source>
          <target state="translated">El tipo del valor proporcionado para <ph id="ph1">`defaultValue`</ph> deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicará a estos metadatos.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Mismatches between metadata default value type and the type of the dependency property it is being applied to can be difficult to debug, because the mismatch is not detectable during compilation.</source>
          <target state="translated">Las diferencias entre el tipo de valor predeterminado de metadatos y el tipo de la propiedad de dependencia que se está aplicando a pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The property system does not evaluate the effective value of a property until run time, so the result of a default value type/property type mismatch is a run-time error.</source>
          <target state="translated">El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta el tiempo de ejecución, por lo que el resultado de la coincidencia de tipo de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The value <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has special meaning in the property system, and cannot be used as a dependency property default value.</source>
          <target state="translated">El valor <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>The <ph id="ph1">`isAnimationProhibited`</ph> parameter sets the initial value of the <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> property declared by the immediate base <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> class.</source>
          <target state="translated">El <ph id="ph1">`isAnimationProhibited`</ph> parámetro establece el valor inicial de la <ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> propiedad declarada por la base de inmediata <ph id="ph3">&lt;xref:System.Windows.UIPropertyMetadata&gt;</ph> clase.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>For more information about the update source behavior for bindings, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Para obtener más información sobre el comportamiento del origen de actualización para los enlaces, vea <bpt id="p1">[</bpt>información general sobre el enlace de datos<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>Values marked as set flags in the <ph id="ph1">`flags`</ph> parameter will set the Boolean value of <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties that match that <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> flag's name to <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Los valores marcan como marcadores establecidos en el <ph id="ph1">`flags`</ph> parámetro establecerá el valor booleano de <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades que coinciden con que <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> nombre del marcador para <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source>You can still change the values of the properties in the metadata, as long as the metadata has not yet been applied to a specific property system operation.</source>
          <target state="translated">Todavía puede cambiar los valores de las propiedades de los metadatos, como los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)">
          <source><ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</source>
          <target state="translated">El valor de <ph id="ph1">&lt;paramref name="defaultValue" /&gt;</ph> está establecido en <ph id="ph2">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass during layout engine operations.</source>
          <target state="translated">Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de organización durante las operaciones del motor de diseño.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de organización; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluyen una implementación de <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que supervisa los cambios de valor efectivo para todas las propiedades de dependencia que existen en un elemento.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element (a call to <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</source>
          <target state="translated">Como parte de esa lógica, las propiedades de dependencia que cambian la vigencia de valor y tienen los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph> iniciarán una solicitud diferida para invalidar los elementos visuales de ese elemento (una llamada a <ph id="ph3">&lt;xref:System.Windows.UIElement.InvalidateArrange%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> a menos que esté sustituyendo o modificar el comportamiento del diseño de nivel de marco WPF sustancialmente.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizado <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementaciones pueden elegir tener un comportamiento similar para los cambios de propiedad de dependencia donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>Members of this class are either not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase se utilizan normalmente no en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass during layout engine operations.</source>
          <target state="translated">Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de medida durante las operaciones del motor de diseño.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de medida; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluyen una implementación de <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que supervisa los cambios de valor efectivo para todas las propiedades de dependencia que existen en un elemento.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">Como parte de esa lógica, las propiedades de dependencia que cambian la vigencia de valor y tienen los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph> iniciarán una solicitud diferida para invalidar los elementos visuales de ese elemento.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> a menos que esté sustituyendo o modificar el comportamiento del diseño de nivel de marco WPF sustancialmente.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizado <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementaciones pueden elegir tener un comportamiento similar para los cambios de propiedad de dependencia donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the arrange pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de organización del diseño de su elemento principal durante las operaciones del motor de diseño.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the arrange pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de organización, específicamente en su elemento principal; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluyen una implementación de <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que supervisa los cambios de valor efectivo para todas las propiedades de dependencia que existen en un elemento.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">Como parte de esa lógica, las propiedades de dependencia que cambian la vigencia de valor y tienen los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph> iniciarán una solicitud diferida para invalidar los elementos visuales del elemento primario.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Por lo general, no es necesario para notificar los cambios de un <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> propiedad a un elemento primario mediante <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> ya que el propio elemento ya tendría su propio <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A&gt;</ph> como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent arrange when appropriate.</source>
          <target state="translated">Generalmente es suficiente, ya que los cambios en el elemento secundario generalmente inician una organización primaria cuando corresponda.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> a veces se utiliza para un <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> clase derivada.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">En este caso, los conjuntos de elementos secundarios una propiedad, pero un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> clase derivada no controla su propia representación.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">La representación se controla mediante un <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> elemento primario que actúa como el host de contenido.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property by a child element invalidates arrange of the parent, because the position of the child in the parent must be changed.</source>
          <target state="translated">Por ejemplo, un cambio en el valor de la <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> propiedad adjunta un elemento secundario invalida organizar del elemento primario, porque se debe cambiar la posición del elemento secundario en el elemento primario.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> attached property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Por lo tanto, la <ph id="ph1">&lt;xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType&gt;</ph> propiedad adjunta tiene metadatos donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Another example is <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; when this property changes, the parent might change the positioning of the child, depending on available space.</source>
          <target state="translated">Otro ejemplo es <ph id="ph1">&lt;xref:System.Windows.Controls.Control.Padding%2A&gt;</ph>; cuando se cambia esta propiedad, el elemento primario puede cambiar la posición del elemento secundario, según el espacio disponible.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> a menos que esté sustituyendo o modificar el comportamiento del diseño de nivel de marco WPF sustancialmente.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizado <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementaciones pueden elegir tener un comportamiento similar para los cambios de propiedad de dependencia donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades en cualquiera de las clases de derivan <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the measure pass of its parent element's layout during layout engine operations.</source>
          <target state="translated">Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de medición del diseño de su elemento principal durante las operaciones del motor de diseño.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists potentially affects the measure pass specifically on its parent element; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.The default is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de medición, específicamente en su elemento principal; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>. El valor predeterminado es <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluyen una implementación de <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que supervisa los cambios de valor efectivo para todas las propiedades de dependencia que existen en un elemento.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for the parent element.</source>
          <target state="translated">Como parte de esa lógica, las propiedades de dependencia que cambian la vigencia de valor y tienen los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph> iniciarán una solicitud diferida para invalidar los elementos visuales del elemento primario.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> a menos que esté sustituyendo o modificar el comportamiento del diseño de nivel de marco WPF sustancialmente.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Generally, you do not need to report changes of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property to a parent element using <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> because the element itself would already have its own <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> as <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Por lo general, no es necesario para notificar los cambios de un <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> propiedad a un elemento primario mediante <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> ya que el propio elemento ya tendría su propio <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph> como <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>That is usually sufficient, because changes in the child element generally initiate a parent measure pass when appropriate.</source>
          <target state="translated">Que es generalmente es suficiente, ya que los cambios en el elemento secundario generalmente inician un paso de medida primario cuando corresponda.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is sometimes used for a <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> a veces se utiliza para un <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> clase derivada.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>In this case, the child element sets a property, but a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived class does not control its own rendering.</source>
          <target state="translated">En este caso, los conjuntos de elementos secundarios una propiedad, pero un <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> clase derivada no controla su propia representación.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The rendering is handled by a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that serves as the content host.</source>
          <target state="translated">La representación se controla mediante un <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> elemento primario que actúa como el host de contenido.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, a change to the value of the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property by a child element invalidates measure of the parent, because the relative spacing of paragraphs might change and might increase or decrease the content host size.</source>
          <target state="translated">Por ejemplo, un cambio en el valor de la <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> propiedad por un elemento secundario invalida la medición del elemento primario, dado que el espaciado relativo de párrafos puede cambiar y puede aumentar o disminuir el tamaño del host de contenido.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Therefore, the <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> property has metadata where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Por lo tanto, la <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType&gt;</ph> propiedad tiene metadatos donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Content host elements also frequently look for changes in dependency properties where <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph2">`true`</ph>, as part of content host rendering logic.</source>
          <target state="translated">Elementos host de contenido también suelen buscar cambios en las propiedades de dependencia donde <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> es <ph id="ph2">`true`</ph>, como parte de la lógica de procesamiento de host de contenido.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>For instance, the <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> element must respond to certain changes within text that might require that the bounding box of the <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> itself be changed.</source>
          <target state="translated">Por ejemplo, el <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> elemento debe responder a algunos cambios del texto que pueden requerir que el cuadro de límite de la <ph id="ph2">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> propio cambiarse.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizado <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementaciones pueden elegir tener un comportamiento similar para los cambios de propiedad de dependencia donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades en cualquiera de las clases de derivan <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Gets or sets a value that indicates whether a dependency property potentially affects the general layout in some way that does not specifically influence arrangement or measurement, but would require a redraw.</source>
          <target state="translated">Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al diseño general de alguna manera que no influye en concreto en la organización o medición, pero requeriría volver a dibujar.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists affects rendering; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos afecta a la representación; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> include an implementation of <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> that monitors effective value changes to all dependency properties that exist on an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> incluyen una implementación de <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.OnPropertyChanged%2A&gt;</ph> que supervisa los cambios de valor efectivo para todas las propiedades de dependencia que existen en un elemento.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>As part of that logic, dependency properties that change effective value and have metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> set to <ph id="ph2">`true`</ph> will initiate a deferred request to invalidate the visuals for that element.</source>
          <target state="translated">Como parte de esa lógica, las propiedades de dependencia que cambian la vigencia de valor y tienen los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph> iniciarán una solicitud diferida para invalidar los elementos visuales de ese elemento.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Because this WPF framework-level implementation is already in place, you typically do not need to look for dependency properties with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> unless you are substantially replacing or modifying the WPF framework-level layout behavior.</source>
          <target state="translated">Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> a menos que esté sustituyendo o modificar el comportamiento del diseño de nivel de marco WPF sustancialmente.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Custom <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementations might choose to have similar behavior for dependency property changes where <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> is <ph id="ph3">`true`</ph>.</source>
          <target state="translated">Personalizado <ph id="ph1">&lt;xref:System.Windows.DependencyObject.OnPropertyChanged%2A&gt;</ph> implementaciones pueden elegir tener un comportamiento similar para los cambios de propiedad de dependencia donde <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> es <ph id="ph3">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades en cualquiera de las clases de derivan <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.AffectsRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Gets or sets a value that indicates whether the property binds two-way by default.</source>
          <target state="translated">Obtiene o establece un valor que indica si la propiedad enlaza de manera bidireccional de forma predeterminada.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property on which this metadata exists binds two-way by default; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad de dependencia en la que existen estos metadatos enlaza de manera bidireccional de forma predeterminada; de lo contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In absence of this property being <ph id="ph1">`true`</ph>, binding updates are one-way by default, based on the default behavior of the <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> constructors or equivalent <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">En ausencia de esta propiedad que se va a <ph id="ph1">`true`</ph>, las actualizaciones de enlace son unidireccionales de manera predeterminada, basándose en el comportamiento predeterminado de la <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> constructores o un grupo equivalente <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> sintaxis.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>In existing elements, you will usually find this property set to <ph id="ph1">`true`</ph> in metadata for dependency properties that both report state and are modifiable by user action, for example <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">En los elementos existentes, normalmente encontrará esta propiedad establecida en <ph id="ph1">`true`</ph> en los metadatos para propiedades de dependencia que notifican el estado y son modificables por acción del usuario, por ejemplo <ph id="ph2">&lt;xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This property only reports the default binding update characteristics of the dependency property in general.</source>
          <target state="translated">Esta propiedad sólo notifica las características de actualización de enlace predeterminadas de la propiedad de dependencia en general.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Any binding set to this property on an instance can locally set the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> property of the binding and change this default.</source>
          <target state="translated">Cualquier enlace establecido en esta propiedad en una instancia puede establecer localmente la <ph id="ph1">&lt;xref:System.Windows.Data.Binding.Mode%2A&gt;</ph> propiedad del enlace y cambiar este comportamiento predeterminado.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Properties on any derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades en cualquiera de las clases de derivan <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Gets or sets the default for <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> to use when bindings for the property with this metadata are applied, which have their <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> set to <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Obtiene o establece el valor predeterminado para que se use <ph id="ph1">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> cuando se aplican los enlaces de la propiedad con los metadatos, que tienen su enumeración <ph id="ph2">&lt;see cref="T:System.Windows.Data.UpdateSourceTrigger" /&gt;</ph> establecida en <ph id="ph3">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>A value of the enumeration, other than <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</source>
          <target state="translated">Valor de la enumeración, que no sea <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>This property is set to <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; the value you set is supposed to become the default when requested by bindings.</source>
          <target state="translated">Esta propiedad está establecida en <ph id="ph1">&lt;see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /&gt;</ph>; el valor que establece se supone que se convierte en el valor predeterminado cuando lo solicitaron los enlaces.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Gets or sets a value that indicates whether the value of the dependency property is inheritable.</source>
          <target state="translated">Obtiene o establece un valor que indica si el valor de la propiedad de dependencia es heredable.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value is inheritable; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si se hereda el valor de propiedad; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system at the WPF framework level, whereby certain dependency properties can be locally set on an element at or near the root of a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element tree and then have their value inherited by all elements within the logical tree of child elements that also possess that property.</source>
          <target state="translated">Herencia del valor de propiedad es una característica de la <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> sistema de propiedades en el nivel de marco WPF, por la que ciertas propiedades de dependencia pueden establecerse localmente en un elemento en o cerca de la raíz de un <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> elemento del árbol y, a continuación, tener su valor heredada por todos los elementos dentro del árbol lógico de elementos secundarios que también presentan esa propiedad.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Property value inheritance is not enabled by default, and enabling it does have some performance implications.</source>
          <target state="translated">Herencia del valor de propiedad no está habilitada de forma predeterminada y habilitarla tiene algunas implicaciones de rendimiento.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>For details, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Para obtener información detallada, consulte <bpt id="p1">[</bpt>Herencia de valores de propiedad<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain object-object divisions in the runtime tree is undefined.</source>
          <target state="translated">Aunque podría parecer que la herencia del valor de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia de una propiedad no asociada a través de ciertas divisiones de objeto del objeto en el árbol en tiempo de ejecución es indefinido.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Utilice siempre <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> para registrar las propiedades que especifique <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> en los metadatos.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Inherits">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Gets a value that indicates whether data binding is supported for the dependency property.</source>
          <target state="translated">Obtiene un valor que indica si el enlace de datos se admite en la propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data binding is supported on the dependency property to which this metadata applies; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si el enlace de datos es compatible con la propiedad de dependencia a la que se aplican los metadatos; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property reports <ph id="ph1">`false`</ph> for one of two possible conditions: either data binding to a dependency property is not allowed because the dependency property is read-only (as reported in the dependency property identifier, not the metadata), or the value of another metadata property, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, is set to <ph id="ph3">`true`</ph> in this metadata.</source>
          <target state="translated">Esta propiedad notifica <ph id="ph1">`false`</ph> para uno de dos posibles condiciones: cualquier enlace de datos a una propiedad de dependencia no está permitido porque la propiedad de dependencia es de sólo lectura (como se muestren en el identificador de la propiedad de dependencia, no los metadatos), o el valor de otra propiedad de metadatos, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>, se establece en <ph id="ph3">`true`</ph> en estos metadatos.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>This property is exposed as a convenience so that callers do not have to check both <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Esta propiedad se expone como una comodidad para que los llamadores no tengan que comprobar ambos <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> y <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>If you are attempting to create metadata that specifies that an otherwise read/write property should not support data binding, specify the flag <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (note the slight naming convention difference versus <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</source>
          <target state="translated">Si está intentando crear metadatos que especifica que una propiedad de lectura/escritura en caso contrario no debe admitir el enlace de datos, especifique el marcador <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable&gt;</ph> (tenga en cuenta la pequeña diferencia de convención de nomenclatura frente a <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed">
          <source>The following example obtains the default metadata from various dependency property fields, queries the value of various <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> properties on it, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">En el ejemplo siguiente se obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> propiedades en él y utiliza la información para rellenar una tabla para implementar un "Explorador de metadatos".</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Gets or sets a value that indicates whether the dependency property supports data binding.</source>
          <target state="translated">Obtiene o establece un valor que indica si la propiedad de dependencia admite enlace de datos.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property does not support data binding; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la propiedad no admite el enlace de datos; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Note that this metadata property is set to <ph id="ph1">`true`</ph> specifically for properties that should not support data binding, despite being read-write properties.</source>
          <target state="translated">Tenga en cuenta que esta propiedad de metadatos se establece en <ph id="ph1">`true`</ph> específicamente para las propiedades que no se deben admitir el enlace de datos, a pesar de ser propiedades de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The expectation is that in most cases where a dependency property is declared, data binding is desired, because data binding is one of the key scenarios where a dependency property is useful.</source>
          <target state="translated">La expectativa es que en la mayoría de los casos donde se declara una propiedad de dependencia, se desea el enlace de datos, porque el enlace de datos es uno de los escenarios clave donde una propiedad de dependencia es útil.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Unlike <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, this does not merely change a default that can later be changed on a specific binding.</source>
          <target state="translated">A diferencia de <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A&gt;</ph>, esto no cambia simplemente un valor predeterminado que se puede cambiar posteriormente en un enlace específico.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Setting this property <ph id="ph1">`true`</ph> in the metadata for a dependency property metadata will disable all bindings from applying their values through expressions to that dependency property.</source>
          <target state="translated">Al establecer esta propiedad <ph id="ph1">`true`</ph> en los metadatos de una propiedad de dependencia metadatos deshabilitará todos los enlaces de aplicar sus valores a través de expresiones a esa propiedad de dependencia.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Read-only dependency properties do not support data binding (because they have no setter that can apply changed values), but will still report <ph id="ph1">`false`</ph> for <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</source>
          <target state="translated">Propiedades de dependencia de solo lectura no admiten el enlace de datos (porque no tienen ningún establecedor que puede aplicar los valores cambiados), pero seguirá informe <ph id="ph1">`false`</ph> para <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is because properties that correspond to a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> values will report parity with how the metadata was actually established, rather than always reporting the end result behavior that the naming of the property might imply.</source>
          <target state="translated">Esto es porque las propiedades que corresponden a un <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadataOptions&gt;</ph> valores notificará paridad con los metadatos de cómo se estableció realmente, en lugar de informar siempre el comportamiento del resultado final que implique la nomenclatura de la propiedad.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>To determine whether a given dependency property permits data binding, you should usually check <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> instead.</source>
          <target state="translated">Para determinar si una propiedad de dependencia especificada permite el enlace de datos, normalmente se debe comprobar <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> en su lugar.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> is a convenience for checking both <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> as a single operation, yielding the expected result.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A&gt;</ph> es una comodidad para la comprobación de ambos <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> y <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A&gt;</ph> como una sola operación, lo que produce el resultado esperado.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Gets or sets a value that indicates whether this property contains journaling information that applications can or should store as part of a journaling implementation.</source>
          <target state="translated">Obtiene o establece un valor que indica si esta propiedad contiene información de registro en diario que las aplicaciones pueden o deben almacenar como parte de una implementación del diario.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if journaling should be performed on the dependency property that this metadata is applied to; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> si se debe realizar el registro en diario en la propiedad de dependencia a la que se aplican estos metadatos; en caso contrario, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.Journal">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The base metadata to merge.</source>
          <target state="translated">Metadatos base para fusionar mediante combinación.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The dependency property this metadata is being applied to.</source>
          <target state="translated">Propiedad de dependencia que se aplica a estos metadatos.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Enables a merge of the source metadata with base metadata.</source>
          <target state="translated">Habilita una fusión mediante combinación de metadatos de origen con metadatos base.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>This method is used internally when metadata is being overridden.</source>
          <target state="translated">Este método se usa internamente cuando se está reemplazando los metadatos.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Classes that derive from <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (or this class particularly) should override this method to account for any metadata properties they have added in their implementations.</source>
          <target state="translated">Las clases que derivan de <ph id="ph1">&lt;see cref="T:System.Windows.PropertyMetadata" /&gt;</ph> (o esta clase en particular) deben invalidar este método para tener en cuenta para cualquier propiedad de metadatos que hayan agregado en sus implementaciones.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>For instance, your implementation might have added a new flagwise enumeration value, and the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation should then be able to combine those flags correctly.</source>
          <target state="translated">Por ejemplo, su implementación podría haber agregado un nuevo valor de enumeración basada en marcadores y el <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementación, a continuación, podrá combinar correctamente esos marcadores.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>Always call the base implementation prior to your own implementation, because the base implementation takes care of merging all the properties already defined on previous types in the hierarchy.</source>
          <target state="translated">Llame siempre a la implementación base antes de su propia implementación, ya que la implementación base se ocupa de combinar todas las propiedades ya definidas en tipos anteriores de la jerarquía.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The behavior added by the <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementation in <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> is that specific WPF framework-level properties in the metadata such as <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> are combined in a bitwise or operation.</source>
          <target state="translated">El comportamiento agregado por la <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> implementación en <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> es que propiedades específicas de nivel de marco WPF en los metadatos como <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /&gt;</ph> se combinan en un bit a bit o la operación.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)">
          <source>The <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> behavior also implements the behavior when you override the property metadata on an existing dependency property by calling <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., using override metadata that is <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /&gt;</ph> comportamiento también implementa el comportamiento al invalidar los metadatos de propiedad en una propiedad de dependencia existente mediante una llamada a <ph id="ph2">&lt;see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" /&gt;</ph>., mediante la invalidación de los metadatos es <ph id="ph3">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The dependency property to which the metadata has been applied.</source>
          <target state="translated">Propiedad de dependencia a la que se han aplicado los metadatos.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The type associated with this metadata if this is type-specific metadata.</source>
          <target state="translated">Tipo asociado a estos metadatos si se trata de metadatos específicos de tipo.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>If this is default metadata, this value can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Si se trata de los metadatos predeterminados, este valor puede ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Called when this metadata has been applied to a property, which indicates that the metadata is being sealed.</source>
          <target state="translated">Se le llama cuando los metadatos se han aplicado a una propiedad, que indica que se sellan los metadatos.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>Any mutability of the data structure of a <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instance should be marked as immutable when this method is invoked.</source>
          <target state="translated">Cualquier mutabilidad de la estructura de datos de un <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> instancia debe marcarse como inmutable cuando se invoca este método.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementation of this method does nothing beyond calling the base implementation.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkPropertyMetadata" /&gt;</ph> implementación de este método no hace nada más allá de una llamada a la implementación base.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Gets or sets a value that indicates whether the property value inheritance evaluation should span across certain content boundaries in the logical tree of elements.</source>
          <target state="translated">Obtiene o establece un valor que indica si la evaluación de la herencia del valor de propiedad se debe extender a algunos límites de contenido en el árbol lógico de elementos.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the property value inheritance should span across certain content boundaries; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si la herencia del valor de propiedad se debe extender a algunos límites del contenido; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This metadata reports a seldom-applied modification to property value inheritance behavior across special parent element-child element boundaries.</source>
          <target state="translated">Estos metadatos notifican una modificación rara vez aplica el comportamiento de herencia del valor de propiedad a través de límites de elemento secundario del elemento primario especial.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The canonical example of such a boundary is the contents of a <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, where the <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> content might get reloaded independently of the existence of the <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</source>
          <target state="translated">El ejemplo canónico de un límite de este tipo es el contenido de un <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, donde la <ph id="ph2">&lt;xref:System.Windows.Controls.Frame&gt;</ph> contenido puede recargar independientemente de la existencia de la <ph id="ph3">&lt;xref:System.Windows.Controls.Frame&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The desired property system behavior is that property value inheritance should not traverse into the contents of the <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, because these contents might be elements that the application hosting the frame does not own or control.</source>
          <target state="translated">El comportamiento del sistema de propiedad es que la herencia de valores de propiedad no debe pasar el contenido de la <ph id="ph1">&lt;xref:System.Windows.Controls.Frame&gt;</ph>, ya que este contenido puede ser elementos que la aplicación que hospeda el marco no posee ni controla.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Specifying metadata with <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> set to <ph id="ph2">`true`</ph>, as well as specifying <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> as <ph id="ph4">`true`</ph>, will cause the property on which the metadata is applied to be inheritable even across the <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> boundary or similar boundaries.</source>
          <target state="translated">Especificar los metadatos con <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A&gt;</ph> establecido en <ph id="ph2">`true`</ph>, así como especificar <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> como <ph id="ph4">`true`</ph>, hará que la propiedad que se aplicaron los metadatos para poder heredar incluso a través del <ph id="ph5">&lt;xref:System.Windows.Controls.Frame&gt;</ph> límite o los límites similar.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>However, after the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, después de que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Gets or sets a value that indicates whether sub-properties of the dependency property do not affect the rendering of the containing object.</source>
          <target state="translated">Obtiene o establece un valor que indica si las subpropiedades de la propiedad de dependencia no afectan a la representación del objeto contenedor.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if changes to sub-property values do not affect rendering if changed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Es <ph id="ph1">&lt;see langword="true" /&gt;</ph> si los cambios de los valores de la subpropiedad no afectan la representación si se cambian; de lo contrario, es <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This metadata option is pertinent for dependency properties that are reference types, where that type has property values of its own.</source>
          <target state="translated">Esta opción de metadatos es pertinente para las propiedades de dependencia que son tipos de referencia, que ese tipo tiene valores de propiedad de su propio.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Typically, the layout system logic is to assume that any dependency property with sub-properties potentially will affect layout, because checking all sub-properties for changes is more time consuming than actually running another render pass.</source>
          <target state="translated">Normalmente, la lógica del sistema de diseño es suponer que cualquier propiedad de dependencia con subpropiedades afectará potencialmente el diseño, porque la comprobación de todas las subpropiedades de cambios es requiere más tiempo que se ejecuta realmente otro paso de representación.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Setting this option to <ph id="ph1">`true`</ph> is useful for optimizing performance of the WPF framework level layout system implementation.</source>
          <target state="translated">Establecer esta opción en <ph id="ph1">`true`</ph> es útil para optimizar el rendimiento de la implementación de sistema de diseño de nivel de marco WPF.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Properties on derived classes of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> are typically defined in the object model as read-write.</source>
          <target state="translated">Propiedades de las clases derivadas de <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> normalmente se definen en el modelo de objetos como de lectura y escritura.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>This is so they can be adjusted after initialization of the instance.</source>
          <target state="translated">Esto es por lo que se pueden ajustar después de la inicialización de la instancia.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>However, once the metadata is consumed as part of a call to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, the property system will seal that metadata instance and properties that convey the specifics of the metadata are now considered immutable.</source>
          <target state="translated">Sin embargo, una vez que los metadatos se usan como parte de una llamada a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, o <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que transmiten los detalles de los metadatos ahora se consideran inmutables.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Attempting to set this property after <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> is <ph id="ph2">`true`</ph> on this metadata instance will raise an exception.</source>
          <target state="translated">Al establecer esta propiedad después de intentar <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.IsSealed%2A&gt;</ph> es <ph id="ph2">`true`</ph> en los metadatos de esta instancia producirá una excepción.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>XAML Text Usage</source>
          <target state="translated">Uso de texto XAML</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>Members of this class are not typically used in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Los miembros de esta clase no se utilizan habitualmente en <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender">
          <source>The metadata has already been applied to a dependency property operation, so that metadata is sealed and properties of the metadata cannot be set.</source>
          <target state="translated">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>