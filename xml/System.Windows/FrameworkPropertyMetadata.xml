<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474429" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Notifica o aplica los metadatos de una propiedad de dependencia, agregando específicamente las características del sistema de propiedades específico del marco.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase se deriva de <xref:System.Windows.PropertyMetadata> (a través de <xref:System.Windows.UIPropertyMetadata>). Para fines de desarrollo de aplicaciones de nivel de marco WPF mayoría, <xref:System.Windows.FrameworkPropertyMetadata> es el tipo utilizado para los metadatos de propiedad de dependencia, en lugar de los tipos de metadatos base <xref:System.Windows.PropertyMetadata> o <xref:System.Windows.UIPropertyMetadata>. Esto es cierto tanto para las propiedades de dependencia existentes para la mayoría de los escenarios de propiedad de dependencia personalizada.  
  
 Los miembros declarados por esta clase ese complemento la <xref:System.Windows.PropertyMetadata> clase base se incluyen diversas propiedades booleanas que especifican o comportamiento del sistema de propiedad de nivel de marco WPF, como la herencia de propiedades, enlace de datos y diseño de informes.  
  
 Varias firmas de constructor para crear un <xref:System.Windows.FrameworkPropertyMetadata> instancia toman un <xref:System.Windows.FrameworkPropertyMetadataOptions> parámetro. El <xref:System.Windows.FrameworkPropertyMetadataOptions> enumeración sólo se utiliza para especificar el comportamiento inicial en el constructor y no se expone después <xref:System.Windows.FrameworkPropertyMetadata> se construye. Desde una instancia construida, puede obtener o establecer la información correspondiente a través de varias propiedades que comparten el nombre de los valores de enumeración que se usa en la llamada al constructor.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Esta clase no se utiliza normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El ejemplo siguiente obtiene los metadatos para una propiedad de dependencia en el propietario de un determinado como inicial base <xref:System.Windows.PropertyMetadata> tipo. Los metadatos se convierten a <xref:System.Windows.FrameworkPropertyMetadata>. Si la conversión devolvió válido <xref:System.Windows.FrameworkPropertyMetadata>, a continuación, varios <xref:System.Windows.FrameworkPropertyMetadata> los valores de propiedad se notifican a través de una interfaz de usuario simple (no mostrado).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta firma inicializa todos los valores de <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> en sus valores de propiedad predeterminados. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> será `null`y las distintas <xref:System.Windows.FrameworkPropertyMetadata> propiedades booleanas será `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con la devolución de llamada de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</param>
        <param name="flags">Marcadores de la opción de metadatos (una combinación de valores de <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado y las opciones de metadatos de nivel de marco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
 Los valores marcan como marcadores establecidos en el `flags` parámetro establecerá el valor booleano de <xref:System.Windows.FrameworkPropertyMetadata> propiedades que coincidan <xref:System.Windows.FrameworkPropertyMetadataOptions> nombre del marcador para `true`. Posteriormente puede cambiar los valores de las propiedades de los metadatos, siempre que los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado y la devolución de llamada de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <param name="coerceValueCallback">Se llamará a una referencia a una implementación del controlador siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para esta propiedad de dependencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con las devoluciones de llamada de especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación llama a un inicializador de base y, a continuación, agrega el `coerceValueCallback` estableciendo la propiedad en la instancia de base.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como valor de un tipo específico.</param>
        <param name="flags">Marcadores de la opción de metadatos (una combinación de valores de <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado, las opciones de metadatos de nivel de marco y la devolución de llamada de <see cref="T:System.Windows.PropertyChangedCallback" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
 Los valores marcan como marcadores establecidos en el `flags` parámetro establecerá el valor booleano de <xref:System.Windows.FrameworkPropertyMetadata> propiedades que coincidan <xref:System.Windows.FrameworkPropertyMetadataOptions> nombre del marcador para `true`. Todavía puede cambiar los valores de las propiedades de los metadatos, siempre que los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <param name="coerceValueCallback">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> para esta propiedad de dependencia.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado y las devoluciones de llamada especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</param>
        <param name="flags">Marcadores de la opción de metadatos (una combinación de valores de <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <param name="coerceValueCallback">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> en esta propiedad.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado, las opciones de metadatos de nivel de marco y las devoluciones de llamada especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
 Los valores marcan como marcadores establecidos en el `flags` parámetro establecerá el valor booleano de <xref:System.Windows.FrameworkPropertyMetadata> propiedades que coincidan <xref:System.Windows.FrameworkPropertyMetadataOptions> nombre del marcador para `true`. Todavía puede cambiar los valores de las propiedades de los metadatos, siempre que los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</param>
        <param name="flags">Marcadores de la opción de metadatos (una combinación de valores de <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <param name="coerceValueCallback">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> en esta propiedad de dependencia.</param>
        <param name="isAnimationProhibited">Es <see langword="true" /> para evitar que el sistema de propiedades anime la propiedad a la que se aplican los metadatos. Tales propiedades producirán una excepción en tiempo de ejecución que se origina desde el sistema de propiedades si se intentan su animación. Es <see langword="false" /> para permitir animar la propiedad. De manera predeterminada, es <see langword="false" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado y las opciones de metadatos de marco, las devoluciones de llamada especificadas y un valor de tipo booleano que se pueden usar para evitar la animación de la propiedad.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
 El `isAnimationProhibited` parámetro establece el valor inicial de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propiedad declarada por la base de inmediata <xref:System.Windows.UIPropertyMetadata> clase.  
  
 Los valores marcan como marcadores establecidos en el `flags` parámetro establecerá el valor booleano de <xref:System.Windows.FrameworkPropertyMetadata> propiedades que coincidan <xref:System.Windows.FrameworkPropertyMetadataOptions> nombre del marcador para `true`. Todavía puede cambiar los valores de las propiedades de los metadatos, siempre que los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.  
  
   
  
## Examples  
 El ejemplo siguiente se llama a esta firma de constructor:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valor predeterminado de la propiedad de dependencia, proporcionado normalmente como un tipo específico.</param>
        <param name="flags">Marcadores de la opción de metadatos (una combinación de valores de <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Estas opciones especifican características de la propiedad de dependencia que interactúan con sistemas como el de diseño o el de enlace de datos.</param>
        <param name="propertyChangedCallback">Referencia a una implementación de controlador a la que llamará el sistema de propiedades cada vez que cambie el valor real de la propiedad.</param>
        <param name="coerceValueCallback">Referencia a una implementación del controlador a la que se llamará siempre que el sistema de propiedades llame a <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> en esta propiedad.</param>
        <param name="isAnimationProhibited">Es <see langword="true" /> para evitar que el sistema de propiedades anime la propiedad a la que se aplican los metadatos. Tales propiedades producirán una excepción en tiempo de ejecución que se origina desde el sistema de propiedades si se intentan su animación. De manera predeterminada, es <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> que se va a usar cuando se aplican enlaces para esta propiedad que tiene su conjunto de <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> establecido en <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.FrameworkPropertyMetadata" /> con el valor predeterminado proporcionado y las opciones de metadatos de marco, las devoluciones de llamada especificadas y un valor de tipo booleano que se pueden usar para evitar la animación de la propiedad; así como el valor predeterminado de un desencadenador de actualización de enlace de datos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo del valor proporcionado para `defaultValue` deben coincidir o estar relacionado con el tipo especificado en el registro original de la propiedad de dependencia que se aplicarán estos metadatos a. Las diferencias entre el tipo de valor predeterminado de los metadatos y el tipo de la propiedad de dependencia que se está aplicando pueden ser difíciles de depurar, ya que la falta de coincidencia no se detectan durante la compilación. El sistema de propiedades no evalúa el valor efectivo de una propiedad hasta que el tiempo de ejecución, por lo que el resultado de la coincidencia de tipos de tipo y propiedad de valor predeterminado es un error en tiempo de ejecución.  
  
 El valor <xref:System.Windows.DependencyProperty.UnsetValue> tiene un significado especial en el sistema de propiedades y no se puede usar como un valor predeterminado de propiedad de dependencia.  
  
 El `isAnimationProhibited` parámetro establece el valor inicial de la <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> propiedad declarada por la base de inmediata <xref:System.Windows.UIPropertyMetadata> clase.  
  
 Para obtener más información sobre el comportamiento del origen de actualización para los enlaces, vea [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Los valores marcan como marcadores establecidos en el `flags` parámetro establecerá el valor booleano de <xref:System.Windows.FrameworkPropertyMetadata> propiedades que coincidan <xref:System.Windows.FrameworkPropertyMetadataOptions> nombre del marcador para `true`. Todavía puede cambiar los valores de las propiedades de los metadatos, siempre que los metadatos aún no se ha aplicado a una operación del sistema de propiedades concreta.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de <paramref name="defaultValue" /> está establecido en <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de organización durante las operaciones del motor de diseño.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de organización; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> incluyen una implementación de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que supervisa los cambios de valor efectivo en todas las propiedades de dependencia que existen en un elemento. Como parte de esa lógica, las propiedades de dependencia que cambian en vigor, valor y tienen los metadatos con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> establecido en `true` iniciará una solicitud diferida para invalidar los elementos visuales de ese elemento (una llamada a <xref:System.Windows.UIElement.InvalidateArrange%2A>). Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> a menos que esencialmente va a reemplazar o modificar el comportamiento de diseño de nivel de marco WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementaciones pueden optar por tener un comportamiento similar para los cambios de propiedad de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> es `true`.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase se utilizan normalmente no en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de medida durante las operaciones del motor de diseño.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de medida; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> incluyen una implementación de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que supervisa los cambios de valor efectivo en todas las propiedades de dependencia que existen en un elemento. Como parte de esa lógica, las propiedades de dependencia que cambian en vigor, valor y tienen los metadatos con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> establecido en `true` iniciará una solicitud diferida para invalidar los elementos visuales de ese elemento. Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> a menos que esencialmente va a reemplazar o modificar el comportamiento de diseño de nivel de marco WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementaciones pueden optar por tener un comportamiento similar para los cambios de propiedad de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> es `true`.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de organización del diseño de su elemento principal durante las operaciones del motor de diseño.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de organización, específicamente en su elemento principal; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> incluyen una implementación de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que supervisa los cambios de valor efectivo en todas las propiedades de dependencia que existen en un elemento. Como parte de esa lógica, las propiedades de dependencia que cambian en vigor, valor y tienen los metadatos con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> establecido en `true` iniciará una solicitud diferida para invalidar los elementos visuales del elemento primario.  
  
 Por lo general, no es necesario para notificar los cambios de un <xref:System.Windows.FrameworkElement> propiedad a un elemento primario mediante <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> porque el propio elemento ya tendría su propia <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> como `true`. Que generalmente es suficiente, ya que generalmente se inician los cambios en el elemento secundario primario organizar cuando corresponda. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> a veces se usa para un <xref:System.Windows.FrameworkContentElement> clase derivada. En este caso, los conjuntos de elementos secundarios una propiedad, pero un <xref:System.Windows.FrameworkContentElement> clase derivada no controla su propia representación. La representación se controla mediante un <xref:System.Windows.FrameworkElement> elemento primario que actúa como host de contenido. Por ejemplo, un cambio en el valor de la <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propiedad adjunta un elemento secundario invalida organizar del elemento primario, ya que se debe cambiar la posición del elemento secundario en el elemento primario. Por lo tanto, el <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> propiedad adjunta tiene metadatos donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> es `true`. Otro ejemplo es <xref:System.Windows.Controls.Control.Padding%2A>; cuando se cambia esta propiedad, el elemento primario puede cambiar la posición del elemento secundario, según el espacio disponible.  
  
 Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> a menos que esencialmente va a reemplazar o modificar el comportamiento de diseño de nivel de marco WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementaciones pueden optar por tener un comportamiento similar para los cambios de propiedad de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> es `true`.  
  
 Las propiedades en cualquier las clases derivan de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al paso de medición del diseño de su elemento principal durante las operaciones del motor de diseño.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos afecta potencialmente al paso de medición, específicamente en su elemento principal; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> incluyen una implementación de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que supervisa los cambios de valor efectivo en todas las propiedades de dependencia que existen en un elemento. Como parte de esa lógica, las propiedades de dependencia que cambian en vigor, valor y tienen los metadatos con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> establecido en `true` iniciará una solicitud diferida para invalidar los elementos visuales del elemento primario. Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> a menos que esencialmente va a reemplazar o modificar el comportamiento de diseño de nivel de marco WPF.  
  
 Por lo general, no es necesario para notificar los cambios de un <xref:System.Windows.FrameworkElement> propiedad a un elemento primario mediante <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> porque el propio elemento ya tendría su propia <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> como `true`. Que generalmente es suficiente, ya que los cambios en el elemento secundario generalmente inician un paso de medida primario cuando corresponda. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> a veces se usa para un <xref:System.Windows.FrameworkContentElement> clase derivada. En este caso, los conjuntos de elementos secundarios una propiedad, pero un <xref:System.Windows.FrameworkContentElement> clase derivada no controla su propia representación. La representación se controla mediante un <xref:System.Windows.FrameworkElement> elemento primario que actúa como host de contenido. Por ejemplo, un cambio en el valor de la <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propiedad por un elemento secundario invalida la medición del elemento primario, porque el espaciado de párrafos relativo podría cambiar y puede aumentar o disminuir el tamaño del host de contenido. Por lo tanto, el <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> propiedad tiene metadatos donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> es `true`.  
  
 Elementos host de contenido también suelen buscar cambios en las propiedades de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> es `true`, como parte de la lógica de procesamiento de host de contenido. Por ejemplo, el <xref:System.Windows.Controls.TextBox> elemento debe responder a algunos cambios del texto que pueden requerir que el cuadro de límite de la <xref:System.Windows.Controls.TextBox> sí se puede cambiar.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementaciones pueden optar por tener un comportamiento similar para los cambios de propiedad de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> es `true`.  
  
 Las propiedades en cualquier las clases derivan de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una propiedad de dependencia afecta potencialmente al diseño general de alguna manera que no influye en concreto en la organización o medición, pero requeriría volver a dibujar.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos afecta a la representación; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> y <xref:System.Windows.FrameworkContentElement> incluyen una implementación de <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> que supervisa los cambios de valor efectivo en todas las propiedades de dependencia que existen en un elemento. Como parte de esa lógica, las propiedades de dependencia que cambian en vigor, valor y tienen los metadatos con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> establecido en `true` iniciará una solicitud diferida para invalidar los elementos visuales de ese elemento. Dado que esta implementación de nivel de marco WPF ya está en su lugar, normalmente no es necesario buscar las propiedades de dependencia con <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> a menos que esencialmente va a reemplazar o modificar el comportamiento de diseño de nivel de marco WPF.  
  
 Custom <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> implementaciones pueden optar por tener un comportamiento similar para los cambios de propiedad de dependencia donde <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> es `true`.  
  
 Las propiedades en cualquier las clases derivan de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la propiedad enlaza de manera bidireccional de forma predeterminada.</summary>
        <value><see langword="true" /> si la propiedad de dependencia en la que existen estos metadatos enlaza de manera bidireccional de forma predeterminada; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En ausencia de esta propiedad está `true`, actualizaciones de enlaces son unidireccionales de manera predeterminada, según el comportamiento predeterminado de la <xref:System.Windows.Data.Binding> constructores o equivalente [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sintaxis.  
  
 En los elementos existentes, normalmente encontrará esta propiedad establecida en `true` en los metadatos de las propiedades de dependencia que notifican el estado y son modificables por acción del usuario, por ejemplo <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Esta propiedad sólo notifica las características de actualización de enlace predeterminada de la propiedad de dependencia en general. Cualquier enlace establecido en esta propiedad en una instancia puede establecer localmente la <xref:System.Windows.Data.Binding.Mode%2A> propiedad del enlace y cambiar este comportamiento predeterminado.  
  
 Las propiedades en cualquier las clases derivan de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor predeterminado para que se use <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> cuando se aplican los enlaces de la propiedad con los metadatos, que tienen su enumeración <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> establecida en <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Un valor de la enumeración, aparte de <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Esta propiedad está establecida en <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; el valor que establece se supone que se convierte en el valor predeterminado cuando lo solicitaron los enlaces.</exception>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el valor de la propiedad de dependencia es heredable.</summary>
        <value><see langword="true" /> si el valor de propiedad es heredable; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Herencia de valores de propiedad es una característica de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propiedades en el nivel de marco WPF, mediante el cual ciertas propiedades de dependencia se pueden establecer localmente en un elemento en o cerca de la raíz de un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] elemento de árbol y, a continuación, tiene su valor heredado por todos los elementos dentro del árbol lógico de los elementos secundarios que también poseen esa propiedad. Herencia de valores de propiedad no está habilitada de forma predeterminada y habilitarla tiene algunas implicaciones de rendimiento. Para obtener información detallada, consulte [Herencia de valores de propiedad](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Aunque podría parecer que la herencia de valores de propiedad funciona para las propiedades de dependencia, el comportamiento de herencia para una propiedad no asociada a través de ciertas divisiones de objeto del objeto en el árbol de tiempo de ejecución es indefinido. Utilice siempre <xref:System.Windows.DependencyProperty.RegisterAttached%2A> para registrar las propiedades donde especifique <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> en los metadatos.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el enlace de datos se admite en la propiedad de dependencia.</summary>
        <value><see langword="true" /> si el enlace de datos se admite en la propiedad de dependencia en la que se aplican los metadatos; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad notifica `false` para uno de dos condiciones posibles: cualquier enlace de datos a una propiedad de dependencia no está permitido porque la propiedad de dependencia es de solo lectura (como notificadas en el identificador de propiedad de dependencia, no los metadatos), o el valor de otra propiedad de metadatos, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, se establece en `true` en estos metadatos. Esta propiedad se expone como una comodidad para que los llamadores no tengan que comprobar ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> y <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Si está intentando crear los metadatos que especifica que una propiedad de lectura/escritura en caso contrario, no debe admitir el enlace de datos, especifique el marcador <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (tenga en cuenta la ligera diferencia de convención de nomenclatura frente a <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 El siguiente ejemplo obtiene los metadatos predeterminados de dependencia de distintos campos de propiedades, consulta el valor de diversos <xref:System.Windows.FrameworkPropertyMetadata> propiedades en él y usa la información para rellenar una tabla para implementar un "Explorador de metadatos".  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la propiedad de dependencia admite enlace de datos.</summary>
        <value><see langword="true" /> si la propiedad no admite enlace de datos; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que esta propiedad de metadatos se establece en `true` específicamente para las propiedades que no se deben admitir el enlace de datos, a pesar de ser propiedades de lectura y escritura. La expectativa es que en la mayoría de los casos donde se declara una propiedad de dependencia, enlace de datos es el deseado, porque el enlace de datos es uno de los escenarios clave donde resulta útil una propiedad de dependencia. A diferencia de <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, esto no cambia simplemente un valor predeterminado que se puede cambiar más adelante en un enlace específico. Al establecer esta propiedad `true` en los metadatos de una propiedad de dependencia metadatos deshabilitará todos los enlaces de aplicar sus valores a través de expresiones a esa propiedad de dependencia.  
  
 Las propiedades de dependencia de solo lectura no admiten el enlace de datos (porque no tienen ningún establecedor que se puede aplicar los valores modificados), pero seguirá informe `false` para <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Esto es porque las propiedades que corresponden a un <xref:System.Windows.FrameworkPropertyMetadataOptions> valores informará de paridad con los metadatos de cómo se estableció en realidad, en lugar de informar siempre el comportamiento del resultado final que implique la nomenclatura de la propiedad. Para determinar si una propiedad de dependencia determinado permite el enlace de datos, normalmente se debe comprobar <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> en su lugar. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> resulta práctico para comprobar ambos <xref:System.Windows.DependencyProperty.ReadOnly%2A> y <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> como una sola operación, lo que produce el resultado esperado.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si esta propiedad contiene información de registro en diario que las aplicaciones pueden o deben almacenar como parte de una implementación del diario.</summary>
        <value><see langword="true" /> si se debe realizar el registro en diario en la propiedad de dependencia a la que se aplican estos metadatos; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Metadatos base para fusionar mediante combinación.</param>
        <param name="dp">Propiedad de dependencia que se aplica a estos metadatos.</param>
        <summary>Habilita una fusión mediante combinación de metadatos de origen con metadatos base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa internamente cuando se invalida los metadatos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Las clases que derivan de <see cref="T:System.Windows.PropertyMetadata" /> (o esta clase en particular) deben invalidar este método para tener en cuenta las propiedades de metadatos que hayan agregado en sus implementaciones. Por ejemplo, su implementación podría haber agregado un nuevo valor de enumeración basada en marcas y el <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementación, a continuación, podrá combinar esos indicadores correctamente.  
  
Llame siempre a la implementación base antes de su propia implementación, ya que la implementación base se ocupa de combinar todas las propiedades ya definidas en tipos anteriores de la jerarquía.  
  
El comportamiento agregado por el <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> implementación en <see cref="T:System.Windows.FrameworkPropertyMetadata" /> es que propiedades específicas de nivel de marco WPF en los metadatos como <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> se combinan en un bit a bit o de operación.  
  
El <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> comportamiento también implementa el comportamiento al invalidar los metadatos de propiedad en una propiedad de dependencia existente mediante una llamada a <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />, mediante la invalidación de los metadatos que es <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Propiedad de dependencia a la que se han aplicado los metadatos.</param>
        <param name="targetType">Tipo asociado a estos metadatos si se trata de metadatos específicos de tipo. Si se trata de los metadatos predeterminados, este valor puede ser <see langword="null" />.</param>
        <summary>Se le llama cuando los metadatos se han aplicado a una propiedad, que indica que se sellan los metadatos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cualquier mutabilidad de la estructura de datos de un <xref:System.Windows.FrameworkPropertyMetadata> instancia debe marcarse como inmutable cuando se invoca este método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>El <see cref="T:System.Windows.FrameworkPropertyMetadata" /> implementación de este método no hace nada más allá de una llamada a la implementación base.</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la evaluación de la herencia del valor de propiedad se debe extender a algunos límites de contenido en el árbol lógico de elementos.</summary>
        <value>Es <see langword="true" /> si la herencia del valor de propiedad se debe extender a algunos límites de contenido; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estos metadatos notifican una modificación rara vez aplica al comportamiento de herencia del valor de propiedad entre límites de elementos secundarios del elemento principal especial. El ejemplo canónico de este tipo de límite es el contenido de un <xref:System.Windows.Controls.Frame>, donde el <xref:System.Windows.Controls.Frame> contenido puede recargar independientemente de la existencia de la <xref:System.Windows.Controls.Frame>. El comportamiento del sistema de propiedad deseada es que la herencia de valores de propiedad no debe pasar el contenido de la <xref:System.Windows.Controls.Frame>, ya que este contenido podría ser elementos que la aplicación que hospeda el marco no posea o controle. Especificación de metadatos con <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> establecido en `true`, así como especificando <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> como `true`, hará que la propiedad que se aplican los metadatos para que sea heredable incluso en el <xref:System.Windows.Controls.Frame> límite o límites similares.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, después de que los metadatos se consumen como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si las subpropiedades de la propiedad de dependencia no afectan a la representación del objeto contenedor.</summary>
        <value><see langword="true" /> si los cambios en los valores de la subpropiedad no afectan a la representación si ha cambiado; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta opción de metadatos es pertinente para las propiedades de dependencia que son tipos de referencia, que ese tipo tiene valores de propiedad de su propio. Normalmente, la lógica del sistema de diseño es suponer que cualquier propiedad de dependencia con subpropiedades afectará potencialmente el diseño, porque la comprobación de todas las subpropiedades de cambios es requiere más tiempo que se ejecuta realmente otro paso de representación. Si esta opción `true` es útil para optimizar el rendimiento de la implementación de sistema de diseño de nivel de marco WPF.  
  
 Las propiedades de las clases derivadas de <xref:System.Windows.PropertyMetadata> normalmente se definen en el modelo de objetos de lectura y escritura. Esto es por lo que se pueden ajustar después de la inicialización de la instancia. Sin embargo, una vez que se consumen los metadatos como parte de una llamada a <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, el sistema de propiedades sellar esa instancia de metadatos y propiedades que contienen los detalles de los metadatos se consideran inmutables. Se intentó establecer esta propiedad después de <xref:System.Windows.PropertyMetadata.IsSealed%2A> es `true` en los metadatos de esta instancia genera una excepción.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 Los miembros de esta clase no se usan normalmente en [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Los metadatos ya se aplicaron a una operación de propiedad de dependencia, por lo que están sellados y no se pueden establecer sus propiedades.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>