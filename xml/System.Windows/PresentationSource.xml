<Type Name="PresentationSource" FullName="System.Windows.PresentationSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="58b35ccf6a31c443742468f6bc5012aa361f47ef" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490951" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class PresentationSource : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract PresentationSource extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PresentationSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PresentationSource&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class PresentationSource abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type PresentationSource = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona una base abstracta para las clases que presentan contenido de otra tecnología como parte de un escenario de interoperación. Además, esta clase proporciona métodos estáticos para trabajar con estos orígenes, así como la arquitectura de presentación básica de nivel visual.</summary>
    <remarks>To be added.</remarks>
    <permission cref="T:System.Security.Permissions.UIPermission">derivar de esta clase. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
    <altmember cref="T:System.Windows.Interop.HwndSource" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PresentationSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PresentationSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Proporciona la inicialización de los valores de clase base cuando lo invoca el constructor de una clase derivada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSource">
      <MemberSignature Language="C#" Value="protected void AddSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.AddSource" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddSource ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddSource();" />
      <MemberSignature Language="F#" Value="member this.AddSource : unit -&gt; unit" Usage="presentationSource.AddSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Agrega una instancia de clase derivada de <see cref="T:System.Windows.PresentationSource" /> a la lista de orígenes de presentación conocidos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método debe llamarse por clases derivadas para indicar que es necesario realizar un seguimiento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddSourceChangedHandler">
      <MemberSignature Language="C#" Value="public static void AddSourceChangedHandler (System.Windows.IInputElement element, System.Windows.SourceChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddSourceChangedHandler(class System.Windows.IInputElement element, class System.Windows.SourceChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.AddSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddSourceChangedHandler (element As IInputElement, handler As SourceChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddSourceChangedHandler(System::Windows::IInputElement ^ element, System::Windows::SourceChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddSourceChangedHandler : System.Windows.IInputElement * System.Windows.SourceChangedEventHandler -&gt; unit" Usage="System.Windows.PresentationSource.AddSourceChangedHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="handler" Type="System.Windows.SourceChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">Elemento al que se va a agregar el controlador.</param>
        <param name="handler">Implementación del controlador que se va a agregar.</param>
        <summary>Agrega un controlador para el evento <see langword="SourceChanged" /> al elemento proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesar de lo que indica el bloque de sintaxis para este evento, hay no legítimos [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] adjunta el uso de la propiedad. No debe intentar agregar controladores en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], y controladores en el código solo se deben colocar en los objetos que actúan como hosts de presentación (<xref:System.Windows.PresentationSource> ) contenido. Tales controladores solo deben asociarse durante la inicialización del objeto y se deben quitar explícitamente en un método Dispose o limpieza de objetos equivalentes.  
  
 Aunque se trata de un evento enrutado, existen las restricciones especiales que difieren del comportamiento normal de eventos enrutados, debido al número relativamente pequeño de elementos en un escenario de aplicación que se ocuparían de controlar esto evento.  
  
-   No puede usar el <xref:System.Windows.UIElement> o <xref:System.Windows.ContentElement> <xref:System.Windows.UIElement.AddHandler%2A> métodos para agregar controladores. Debe usar <xref:System.Windows.PresentationSource.AddSourceChangedHandler%2A>.  
  
-   C# `+=` y `-=` las sintaxis de controlador de eventos y sintaxis de los controladores relacionados específicos del lenguaje, no se admiten, porque el propio evento no se expone como público. Solo el <xref:System.Windows.PresentationSource> métodos de utilidad para agregar y quitar los controladores directamente son compatibles.  
  
-   No se permiten los controladores de clase. En concreto, no puede llamar a <xref:System.Windows.EventManager.RegisterClassHandler%2A> frente a este evento en un constructor de clase porque aunque existe un campo de identificador para SourceChanged, el identificador no es público.  
  
-   Todos los controladores registrados recibirán el evento SourceChanged, incluso si uno de los controladores intenta marcar los argumentos como controlado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para llamar a o implemente este método. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ClearContentRenderedListeners">
      <MemberSignature Language="C#" Value="protected void ClearContentRenderedListeners ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearContentRenderedListeners() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.ClearContentRenderedListeners" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearContentRenderedListeners ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearContentRenderedListeners();" />
      <MemberSignature Language="F#" Value="member this.ClearContentRenderedListeners : unit -&gt; unit" Usage="presentationSource.ClearContentRenderedListeners " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la lista de agentes de escucha para el evento <see cref="E:System.Windows.PresentationSource.ContentRendered" /> en <see langword="null" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.PresentationSource.ContentRendered" />
      </Docs>
    </Member>
    <Member MemberName="CompositionTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CompositionTarget CompositionTarget { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CompositionTarget CompositionTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.CompositionTarget" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompositionTarget As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CompositionTarget ^ CompositionTarget { System::Windows::Media::CompositionTarget ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompositionTarget : System.Windows.Media.CompositionTarget" Usage="System.Windows.PresentationSource.CompositionTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el destino visual para los objetos visuales que se presentan en el origen.</summary>
        <value>Un destino visual (instancia de una clase derivada de <see cref="T:System.Windows.Media.CompositionTarget" /> ).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto de esta propiedad se basa en una implementación de <xref:System.Windows.PresentationSource.GetCompositionTargetCore%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Las clases derivadas pueden optar por ocultar esta propiedad para proporcionar un valor específico del tipo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.PresentationSource.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando se representa el contenido y está listo para la interacción del usuario.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentSources">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerable CurrentSources { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.IEnumerable CurrentSources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.CurrentSources" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentSources As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::IEnumerable ^ CurrentSources { System::Collections::IEnumerable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSources : System.Collections.IEnumerable" Usage="System.Windows.PresentationSource.CurrentSources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve una lista de orígenes.</summary>
        <value>Lista de referencias débiles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La lista devuelta admite un enumerador sobre una copia segura para subprocesos de solo lectura de la lista de orígenes como agregado con <xref:System.Windows.PresentationSource.AddSource%2A>.  
  
 El enumerador omite cualquier referencia débil muerta en la lista.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener los orígenes. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromDependencyObject">
      <MemberSignature Language="C#" Value="public static System.Windows.PresentationSource FromDependencyObject (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PresentationSource FromDependencyObject(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.FromDependencyObject(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PresentationSource ^ FromDependencyObject(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member FromDependencyObject : System.Windows.DependencyObject -&gt; System.Windows.PresentationSource" Usage="System.Windows.PresentationSource.FromDependencyObject dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PresentationSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objeto <see cref="T:System.Windows.DependencyObject" /> cuyo origen se va a buscar.</param>
        <summary>Devuelve el origen en el que se presenta el objeto <see cref="T:System.Windows.DependencyObject" /> especificado.</summary>
        <returns>
          <see cref="T:System.Windows.PresentationSource" /> en el que se presenta el objeto de dependencia.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para llamar a o implemente este método. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FromVisual">
      <MemberSignature Language="C#" Value="public static System.Windows.PresentationSource FromVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PresentationSource FromVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.FromVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PresentationSource ^ FromVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="static member FromVisual : System.Windows.Media.Visual -&gt; System.Windows.PresentationSource" Usage="System.Windows.PresentationSource.FromVisual visual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PresentationSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">Objeto <see cref="T:System.Windows.Media.Visual" /> cuyo origen se va a buscar.</param>
        <summary>Devuelve el origen en el que se presenta el objeto <see cref="T:System.Windows.Media.Visual" /> especificado.</summary>
        <returns>
          <see cref="T:System.Windows.PresentationSource" /> en que se presenta el elemento visual, o <see langword="null" /> si se elimina <paramref name="visual" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="visual" /> es <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para llamar a o implemente este método. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCompositionTargetCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Media.CompositionTarget GetCompositionTargetCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.CompositionTarget GetCompositionTargetCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.GetCompositionTargetCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetCompositionTargetCore () As CompositionTarget" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Media::CompositionTarget ^ GetCompositionTargetCore();" />
      <MemberSignature Language="F#" Value="abstract member GetCompositionTargetCore : unit -&gt; System.Windows.Media.CompositionTarget" Usage="presentationSource.GetCompositionTargetCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se invalida en una clase derivada, devuelve un destino visual para el origen dado.</summary>
        <returns>Devuelve un objeto <see cref="T:System.Windows.Media.CompositionTarget" /> que es el destino para representar el objeto visual.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Invalide este método para declarar el valor que el <see cref="P:System.Windows.PresentationSource.CompositionTarget" /> devolverá la propiedad de solo lectura.  La invalidación debe devolver instancias de tipo específico de la <see cref="T:System.Windows.Media.CompositionTarget" /> deriva el tipo de clase que se usa para el escenario de interoperación.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public abstract bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.PresentationSource.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene un valor que declara si el objeto se ha eliminado.</summary>
        <value>
          <see langword="true" />, si el objeto se desecha; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Las clases derivadas deben implementar <see cref="T:System.IDisposable" /> o proporcionar un comportamiento equivalente.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RemoveSource">
      <MemberSignature Language="C#" Value="protected void RemoveSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveSource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RemoveSource" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveSource ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveSource();" />
      <MemberSignature Language="F#" Value="member this.RemoveSource : unit -&gt; unit" Usage="presentationSource.RemoveSource " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita una instancia de clase derivada de <see cref="T:System.Windows.PresentationSource" /> de la lista de orígenes de presentación conocidos.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveSourceChangedHandler">
      <MemberSignature Language="C#" Value="public static void RemoveSourceChangedHandler (System.Windows.IInputElement e, System.Windows.SourceChangedEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveSourceChangedHandler(class System.Windows.IInputElement e, class System.Windows.SourceChangedEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RemoveSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveSourceChangedHandler (e As IInputElement, handler As SourceChangedEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveSourceChangedHandler(System::Windows::IInputElement ^ e, System::Windows::SourceChangedEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveSourceChangedHandler : System.Windows.IInputElement * System.Windows.SourceChangedEventHandler -&gt; unit" Usage="System.Windows.PresentationSource.RemoveSourceChangedHandler (e, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.IInputElement" />
        <Parameter Name="handler" Type="System.Windows.SourceChangedEventHandler" />
      </Parameters>
      <Docs>
        <param name="e">Elemento del que se va a quitar el controlador.</param>
        <param name="handler">Implementación de controlador que se va a quitar.</param>
        <summary>Quita un controlador para el evento <see langword="SourceChanged" /> del elemento proporcionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aunque se trata de un evento enrutado, existen las restricciones especiales que difieren del comportamiento normal de eventos enrutados, debido al número relativamente pequeño de elementos en un escenario de aplicación que se ocuparían de controlar esto evento.  
  
-   No puede usar el <xref:System.Windows.UIElement> o <xref:System.Windows.ContentElement> <xref:System.Windows.UIElement.RemoveHandler%2A> métodos para quitar los controladores. Debe usar <xref:System.Windows.PresentationSource.RemoveSourceChangedHandler%2A>.  
  
-   C# `+=` y `-=` las sintaxis de controlador de eventos y otras sintaxis de controlador específico del lenguaje, no se admiten, porque el propio evento no se expone como público. Solo el <xref:System.Windows.PresentationSource> métodos de utilidad para agregar y quitar los controladores directamente son compatibles.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PresentationSource.AddSourceChangedHandler(System.Windows.IInputElement,System.Windows.SourceChangedEventHandler)" />
      </Docs>
    </Member>
    <Member MemberName="RootChanged">
      <MemberSignature Language="C#" Value="protected void RootChanged (System.Windows.Media.Visual oldRoot, System.Windows.Media.Visual newRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RootChanged(class System.Windows.Media.Visual oldRoot, class System.Windows.Media.Visual newRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PresentationSource.RootChanged(System.Windows.Media.Visual,System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RootChanged (oldRoot As Visual, newRoot As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RootChanged(System::Windows::Media::Visual ^ oldRoot, System::Windows::Media::Visual ^ newRoot);" />
      <MemberSignature Language="F#" Value="member this.RootChanged : System.Windows.Media.Visual * System.Windows.Media.Visual -&gt; unit" Usage="presentationSource.RootChanged (oldRoot, newRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityTreatAsSafe</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldRoot" Type="System.Windows.Media.Visual" />
        <Parameter Name="newRoot" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="oldRoot">Anterior objeto <see cref="T:System.Windows.Media.Visual" /> raíz.</param>
        <param name="newRoot">Nuevo objeto <see cref="T:System.Windows.Media.Visual" /> raíz.</param>
        <summary>Proporciona notificación de que el objeto <see cref="T:System.Windows.Media.Visual" /> raíz ha cambiado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases derivadas deben llamar a este método para indicar que su raíz <xref:System.Windows.Media.Visual> ha cambiado.  
  
 Llamar a este método hace que dos eventos de duración del objeto que se produzca en los objetos visuales de raíz especificado, si y solo si esos objetos visuales de raíz son <xref:System.Windows.FrameworkElement> las clases derivadas.  
  
-   El objeto visual raíz anterior, se producirá la <xref:System.Windows.FrameworkElement.Unloaded> eventos y procesará su árbol de elementos hacia abajo, difundir este evento a cada elemento secundario.  
  
-   El objeto visual raíz, se producirá la <xref:System.Windows.FrameworkElement.Loaded> eventos y procesará su árbol de elementos hacia abajo, difundir este evento a cada elemento secundario.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootVisual">
      <MemberSignature Language="C#" Value="public abstract System.Windows.Media.Visual RootVisual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual RootVisual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PresentationSource.RootVisual" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property RootVisual As Visual" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Windows::Media::Visual ^ RootVisual { System::Windows::Media::Visual ^ get(); void set(System::Windows::Media::Visual ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RootVisual : System.Windows.Media.Visual with get, set" Usage="System.Windows.PresentationSource.RootVisual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cuando se invalida en una clase derivada, obtiene o establece el objeto visual raíz que se presenta en el origen.</summary>
        <value>Raíz visual.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para invalidar la propiedad (<see langword="InheritanceDemand" />). Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>