<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="da601451bb4dff3411e8b46597e59b92555fe9b8" /><Meta Name="ms.sourcegitcommit" Value="22744e2f9d07a51900a968efffd9e390117d64a1" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/03/2019" /><Meta Name="ms.locfileid" Value="55671894" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite crear, configurar, mostrar y administrar la duración de las ventanas y los cuadros de diálogo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El punto de interacción entre un usuario y una aplicación independiente es una ventana. Un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] ventana consta de dos áreas distintas:  
  
-   Un área no cliente, que hospeda los elementos gráficos de windows, como un icono, título, menú del sistema, botón Minimizar, maximizar el botón, botón Restaurar, el botón Cerrar y un borde.  
  
-   Un área de cliente, que hospeda el contenido específico de la aplicación.  
  
 En la siguiente ilustración se muestra una ventana estándar:  
  
 ![Elementos de la ventana](~/add/media/windowoverviewfigure1.PNG "elementos de la ventana")  
  
 <xref:System.Windows.Window> Encapsula la capacidad de crear, configurar, mostrar y administrar la duración de las ventanas y cuadros de diálogo y proporciona los siguientes servicios de clave:  
  
 **Administración de la duración**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Administración de ventanas**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Apariencia y comportamiento**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Cuadros de diálogo**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Además, <xref:System.Windows.Application> expone una compatibilidad especial para administrar todas las ventanas en una aplicación:  
  
-   Aplicación mantiene una lista de todas las ventanas que actualmente se crean instancias de la aplicación. Esta lista se expone mediante el <xref:System.Windows.Application.Windows%2A> propiedad.  
  
-   De forma predeterminada, <xref:System.Windows.Application.MainWindow%2A> se establece automáticamente con una referencia al primer <xref:System.Windows.Window> que se crea una instancia en una aplicación. Esto, por lo que la ventana de la ventana principal de la aplicación.  
  
 Un <xref:System.Windows.Window> puede implementarse mediante marcado, marcado y código subyacente o código.  
  
 <xref:System.Windows.Window> se utiliza principalmente para mostrar las ventanas y cuadros de diálogo para las aplicaciones independientes. Sin embargo, para aplicaciones que requieren la navegación en el nivel de la ventana, como los asistentes, puede usar <xref:System.Windows.Navigation.NavigationWindow> en su lugar; <xref:System.Windows.Navigation.NavigationWindow> deriva <xref:System.Windows.Window> y lo amplía con compatibilidad con la navegación de tipo explorador.  
  
> [!NOTE]
>  Se pueden incorporar islas de contenido navegable en otros contenidos y contenedores de contenido mediante <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> necesita `UnmanagedCode` permiso de seguridad que se creará una instancia. Esto tiene las siguientes consecuencias:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-las aplicaciones independientes implementadas solicitará la elevación de permisos cuando se inicia desde las zonas de Internet o Intranet Local.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] todo lo que solicitar menor que todos los permisos no podrán crear instancias de windows o los cuadros de diálogo.  
  
 Para obtener información acerca de la implementación de aplicaciones independientes y consideraciones de seguridad, consulte [estrategia de seguridad de WPF: seguridad de la plataforma](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Un <xref:System.Windows.Window> es un <xref:System.Windows.Controls.ContentControl>, lo que significa que puede contener un único objeto de cualquier tipo (por ejemplo, una cadena, una imagen o un panel). Para obtener más información, vea la clase <xref:System.Windows.Controls.ContentControl>. Además, <xref:System.Windows.Window> es un elemento raíz y, por lo tanto, no puede formar parte del contenido de otro elemento.  
  
> [!NOTE]
>  El <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, y <xref:System.Windows.Window.Left%2A> propiedades establecidas en un <xref:System.Windows.Window> a través de un estilo no se aplicará en tiempo de ejecución.  
  
## <a name="customizing-the-window-control"></a>Personalizar el Control de ventana  
 Para aplicar la misma configuración de la propiedad a varios <xref:System.Windows.Window> controles, utilizar el <xref:System.Windows.FrameworkElement.Style%2A> propiedad. Puede modificar el valor predeterminado <xref:System.Windows.Controls.ControlTemplate> para proporcionar el control una apariencia única. Para obtener más información acerca de cómo crear un <xref:System.Windows.Controls.ControlTemplate>, consulte [personalizar la apariencia de un Control existente creando una clase ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Para ver las partes y los Estados que son específicos de la <xref:System.Windows.Window>, consulte [plantillas y estilos de ventana](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Las propiedades de dependencia para este control pueden establecerse mediante el estilo del control de forma predeterminada.  Si una propiedad se establece mediante un estilo predeterminado, puede cambiar la propiedad de su valor predeterminado cuando el control aparece en la aplicación. El estilo predeterminado se determina por el tema de escritorio que se utiliza cuando se ejecuta la aplicación.  Para obtener más información, consulte [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 El ejemplo siguiente muestra cómo es una ventana estándar define sólo mediante marcado:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 El ejemplo siguiente se muestra cómo se define una ventana estándar utilizando sólo código:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 El ejemplo siguiente muestra cómo es una ventana estándar definido mediante una combinación de marcado y código subyacente.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El constructor inicializa el <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, y <xref:System.Windows.Window.Left%2A> propiedades en sus valores predeterminados <xref:System.Windows.Window> valores.  
  
 Si se crea una ventana dentro de un <xref:System.AppDomain> que tiene un <xref:System.Windows.Application> objeto, el constructor agrega el <xref:System.Windows.Window> objeto al conjunto de <xref:System.Windows.Application>-administrado de windows a través de la <xref:System.Windows.Application.Windows%2A> propiedad de la <xref:System.Windows.Application> objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para obtener permiso para este objeto llamar a métodos nativos no seguros. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Intenta situar la ventana en primer plano y la activa.</summary>
        <returns>Devuelve <see langword="true" /> si el objeto <see cref="T:System.Windows.Window" /> se activó correctamente; en caso contrario, devuelve <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las reglas que determinan si se activa la ventana son los mismos que los utilizados por el [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` función (User32.dll).  
  
 Si la ventana se activa en una aplicación de Windows Presentation Foundation que no es una aplicación en primer plano del usuario, <xref:System.Windows.Application.Activated> provoca el evento.  
  
> [!NOTE]
>  No se puede llamar a este método cuando una ventana se hospeda en un explorador.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso activar una ventana. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una ventana se convierte en ventana de primer plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una ventana se activa (se convierte en la ventana de primer plano) cuando:  
  
-   Se abre la ventana por primera vez.  
  
-   Un usuario cambia a una ventana seleccionando con el mouse, al presionar ALT+TAB, o desde el Administrador de tareas.  
  
-   Un usuario hace clic en el botón de barra de tareas de la ventana.  
  
 Pueden controlar Windows que necesitan detectar cuándo se activan el <xref:System.Windows.Window.Activated> eventos.  
  
 Después de activa una ventana en primer lugar, puede estar desactivado y reactivado muchas veces durante su vigencia. Si el estado o comportamiento de una aplicación depende de su estado de activación, puede inspeccionar <xref:System.Windows.Window.IsActive%2A> para determinar qué estado de activación.  
  
 También puede ser una aplicación <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el área cliente de una ventana admite la transparencia.</summary>
        <value>Devuelve <see langword="true" /> si la ventana admite la transparencia; de lo contrario, devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Controls.Control.Background%2A> propiedad de una ventana está establecida en un modo transparente de color, con <xref:System.Windows.Media.Brushes.Transparent%2A> por ejemplo, la ventana permanece opaca. Esto significa que no se vean el escritorio y las aplicaciones en ejecución "beneath" de la ventana. Para habilitar este tipo de transparencia, <xref:System.Windows.Window.AllowsTransparency%2A> debe establecerse en `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> existe para facilitar la creación de ventanas no rectangulares y, por lo tanto, cuando <xref:System.Windows.Window.AllowsTransparency%2A> está establecido en `true`, una ventana <xref:System.Windows.Window.WindowStyle%2A> propiedad debe establecerse en <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ventana cuya propiedad <see cref="P:System.Windows.Window.WindowStyle" /> tiene un valor que no sea <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds"><see cref="T:System.Windows.Size" /> que refleja el tamaño final que la ventana debe usar para organizarse y organizar sus elementos secundarios.</param>
        <summary>Invalide este método para organizar y ajustar el tamaño de una ventana y sus elementos secundarios.</summary>
        <returns><see cref="T:System.Windows.Size" /> que refleja el tamaño real que se utilizó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> no se llama cuando el <xref:System.Windows.UIElement.Visibility%2A> propiedad tiene un valor de <xref:System.Windows.Visibility.Collapsed>. Si el valor de la <xref:System.Windows.UIElement.Visibility%2A> propiedad <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> se llama.  
  
> [!NOTE]
>  Cuando ya sea <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> se denominan, el <xref:System.Windows.UIElement.Visibility%2A> propiedad de un <xref:System.Windows.Window> está establecido en <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra manualmente un objeto <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Window> puede cerrarse con uno de los diversos mecanismos bien conocidos, proporcionado por el sistema se encuentran en su barra de título, como:  
  
-   ALT+F4.  
  
-   Menú del sistema &#124; **cerrar**.  
  
-   **Cerrar** botón.  
  
 Un <xref:System.Windows.Window> también se puede cerrar con uno de varios mecanismos bien conocidos dentro del área de cliente proporcionadas por los desarrolladores, incluidos:  
  
-   **Archivo** &#124; **Exit** en una ventana principal.  
  
-   **Archivo** &#124; **cerrar** o un **cerrar** botón en una ventana secundaria.  
  
> [!NOTE]
>  **Aceptar** y **cancelar** botones en un cuadro de diálogo también son proporcionados por desarrolladores, aunque le conjunto probable <xref:System.Windows.Window.DialogResult%2A>, que cierra automáticamente una ventana que se abrió llamando <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Estos mecanismos requieren que llamar explícitamente a <xref:System.Windows.Window.Close%2A> para cerrar una ventana.  
  
> [!NOTE]
>  Si abre una ventana, mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>y con un <xref:System.Windows.Controls.Button> con su <xref:System.Windows.Controls.Button.IsCancel%2A> propiedad establecida en true, se cerrará automáticamente cuando se haga clic en el botón, o presione ESC. Si se abrió la ventana mediante <xref:System.Windows.Window.Show%2A>, sin embargo, <xref:System.Windows.Window.Close%2A> debe ser llamados explícitamente, como <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos para el <xref:System.Windows.Controls.Button>.  
  
 Al cerrar una ventana hace que el <xref:System.Windows.Window.Closing> evento. Si el <xref:System.Windows.Window.Closing> no se cancela el evento, ocurre lo siguiente:  
  
-   El <xref:System.Windows.Window> se quita de <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (si una <xref:System.Windows.Application> objeto existe).  
  
-   El <xref:System.Windows.Window> se quita el propietario <xref:System.Windows.Window> si se puede establecer la relación propietarias y pertenecientes antes de la propiedad <xref:System.Windows.Window> apareció y después el propietario <xref:System.Windows.Window> se abrió.  
  
-   Se genera el evento <xref:System.Windows.Window.Closed>.  
  
-   No administrada de los recursos creados por el <xref:System.Windows.Window> se eliminan.  
  
-   Si <xref:System.Windows.Window.ShowDialog%2A> se llamó para mostrar el <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> devuelve.  
  
 Cerrar un <xref:System.Windows.Window> hace que todas las ventanas que posee para cerrarse. Además, se cierra un <xref:System.Windows.Window> podrían provocar que una aplicación detener la ejecución en función de la <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> se establece la propiedad.  
  
> [!NOTE]
>  No se puede llamar a este método cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 El ejemplo siguiente se muestra un **archivo** &#124; **Exit** menú que se va a controlar para llamar explícitamente a <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">permiso usar todas las ventanas y eventos de entrada de usuario sin restricciones. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando la ventana está a punto de cerrarse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una vez que se genera este evento, no se puede evitar una ventana de cierre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se establece la propiedad <see cref="P:System.Windows.UIElement.Visibility" /> o se llama a <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> o <see cref="M:System.Windows.Window.Hide" /> mientras se cierra una ventana.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce inmediatamente después de llamar a <see cref="M:System.Windows.Window.Close" /> y se puede controlar para que se cancele el cierre de la ventana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> se puede controlar para detectar cuándo se cierra una ventana (por ejemplo, cuando <xref:System.Windows.Window.Close%2A> se denomina). Además, <xref:System.Windows.Window.Closing> puede usarse para evitar que se cierre una ventana. Para evitar que se cierre una ventana, puede establecer el <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propiedad de la <xref:System.ComponentModel.CancelEventArgs> argumento `true`.  
  
 El <xref:System.Windows.Window.Closing> evento se desencadena cuando <xref:System.Windows.Window.Close%2A> se llama si se hace clic en el botón de cierre de una ventana, o si el usuario presiona ALT+F4.  
  
 Si se ha abierto una ventana poseída utilizando su propietario de la ventana <xref:System.Windows.Window.Show%2A>y el propietario de la ventana se cierra la ventana poseída <xref:System.Windows.Window.Closing> no se produce el evento. Si el propietario de una ventana se cierra (consulte <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> no se genera en la ventana poseída.  
  
 Si <xref:System.Windows.Application.Shutdown%2A> se llama, el <xref:System.Windows.Window.Closing> se provoca el evento de cada ventana. Sin embargo, si <xref:System.Windows.Window.Closing> está cancelado, se omitirá la cancelación.  
  
 Si una sesión finaliza debido a un usuario cierra la sesión o apaga, <xref:System.Windows.Window.Closing> no se genera; controlar <xref:System.Windows.Application.SessionEnding> para implementar el código que cancela el cierre de la aplicación.  
  
 Si desea mostrar y ocultar una ventana varias veces durante la vigencia de una aplicación, y no desea crear una nueva instancia la ventana cada vez que mostrar, se puede controlar la <xref:System.Windows.Window.Closing> eventos, cancelarlo y llamar a la <xref:System.Windows.Window.Hide%2A> método. A continuación, puede llamar a <xref:System.Windows.Window.Show%2A> en la misma instancia para volver a abrirla.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra un <xref:System.Windows.Window> que determina si necesita la intervención del usuario para cerrar.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se establece la propiedad <see cref="P:System.Windows.UIElement.Visibility" /> o se llama a <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> o <see cref="M:System.Windows.Window.Close" /> mientras se cierra una ventana.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce después de representar el contenido de una ventana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ventana no tiene contenido, no se genera este evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando una ventana se convierte en ventana de fondo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se desactiva una ventana (se convierte en una ventana en segundo plano) cuando:  
  
-   Un usuario cambia a otra ventana de la aplicación actual.  
  
-   Un usuario cambia a la ventana en otra aplicación mediante el uso de ALT+TAB, o mediante el Administrador de tareas.  
  
-   Un usuario hace clic con el botón de barra de tareas para una ventana en otra aplicación.  
  
 Windows que necesitan detectar cuándo se desactivan controlando el <xref:System.Windows.Window.Deactivated> eventos.  
  
 Primero se desactiva una ventana, es posible que se reactiva y desactivado muchas veces durante su vigencia. Si el estado o comportamiento de una aplicación depende de su estado de activación, puede inspeccionar <xref:System.Windows.Window.IsActive%2A> para determinar qué estado de activación.  
  
 También puede ser una aplicación <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del resultado del cuadro de diálogo, que es el valor devuelto por el método <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Valor <see cref="T:System.Nullable`1" /> de tipo <see cref="T:System.Boolean" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> puede usarse desde el código que se ha mostrado un cuadro de diálogo para determinar si un usuario acepta (`true`) o cancelado (`false`) el cuadro de diálogo. Si se aceptó un cuadro de diálogo, se indica en el código que abre el cuadro de diálogo para recuperar los datos recopilados por el usuario y procesarlo. Si se ha cancelado un cuadro de diálogo, sin embargo, esto significa que el código de llamada debe detener cualquier procesamiento posterior.  
  
 De forma predeterminada, un cuadro de diálogo se cancela cuando un usuario realiza una de las siguientes acciones:  
  
-   PressesALT + F4.  
  
-   Hace clic en el **cerrar** botón.  
  
-   Selecciona **cerrar** desde el menú del sistema.  
  
 En todos estos casos, <xref:System.Windows.Window.DialogResult%2A> es `false` de forma predeterminada.  
  
 Normalmente, un cuadro de diálogo proporciona un botón para cancelar un cuadro de diálogo, que es el botón especial cuya <xref:System.Windows.Controls.Button.IsCancel%2A> propiedad está establecida en `true`. Un botón configurado de esta forma cerrará automáticamente una ventana cuando se presione o cuando se presiona la tecla ESC. En cualquiera de estos casos, <xref:System.Windows.Window.DialogResult%2A> permanece `false`.  
  
 Un cuadro de diálogo normalmente también otorga un botón Aceptar, que es el botón cuya <xref:System.Windows.Controls.Button.IsDefault%2A> propiedad está establecida en `true`. Un botón configurado de esta forma, se producirá su <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos cuando se presiona este archivo o la tecla ENTRAR. Sin embargo, no cerrará automáticamente el cuadro de diálogo ni establecerá <xref:System.Windows.Window.DialogResult%2A> a `true`. Tiene que escribir manualmente este código, normalmente desde el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos para el botón predeterminado.  
  
 <xref:System.Windows.Window.DialogResult%2A> es `null` cuando se muestra el cuadro de diálogo, pero no aceptadas ni cancelar.  
  
 Después de cerrar un cuadro de diálogo, puede obtener el resultado del cuadro de diálogo desde el valor devuelto por <xref:System.Windows.Window.ShowDialog%2A> método, o inspeccionando el <xref:System.Windows.Window.DialogResult%2A> propiedad.  
  
 <xref:System.Windows.Window.DialogResult%2A> solo puede establecerse cuando un <xref:System.Windows.Window> se abre mediante una llamada a su <xref:System.Windows.Window.ShowDialog%2A> método.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo configurar un botón Aceptar y un botón Cancelar para devolver la correspondiente <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se establece <see cref="P:System.Windows.Window.DialogResult" /> antes de que se abra una ventana al llamar a <see cref="M:System.Windows.Window.ShowDialog" />.  
  
O bien 
 <see cref="P:System.Windows.Window.DialogResult" /> se establece en una ventana que se abre al llamar a <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce después de que cambie el valor de PPP de la pantalla en la que se muestra la ventana.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEvent" /> cuando el valor de PPP de la pantalla de Windows está en los cambios.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite arrastrar una ventana por un mouse con su botón primario presionado sobre un área expuesta del área cliente de la ventana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Debe ser el botón primario del mouse hacia abajo cuando <xref:System.Windows.Window.DragMove%2A> se llama. Es una manera de detectar cuándo se presiona el botón primario del mouse controlar la <xref:System.Windows.UIElement.MouseLeftButtonDown> eventos.  
  
 Cuando <xref:System.Windows.Window.DragMove%2A> se llama a la izquierda debe estar presionado el botón del mouse sobre un área expuesta del área cliente de la ventana.  
  
> [!NOTE]
>  No se puede llamar a este método cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo invalidar <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> para llamar a <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">El botón primario del mouse no está presionado.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso arrastrar una ventana. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objeto de dependencia.</param>
        <summary>Devuelve una referencia al objeto <see cref="T:System.Windows.Window" /> en el que se hospeda el árbol de contenido donde está ubicado el objeto de dependencia.</summary>
        <returns>Referencia de <see cref="T:System.Windows.Window" /> a la ventana host.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> es null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Oculta una ventana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No se cierra una ventana cuando está oculto y ni el <xref:System.Windows.Window.Closing> ni <xref:System.Windows.Window.Closed> provoca el evento. En su lugar, la ventana <xref:System.Windows.UIElement.Visibility%2A> propiedad está establecida en <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Si una ventana es la aplicación <xref:System.Windows.Application.MainWindow%2A> y la aplicación <xref:System.Windows.Application.ShutdownMode%2A> es <xref:System.Windows.ShutdownMode.OnMainWindowClose>, la aplicación no se cierra. Del mismo modo, la aplicación no se cierra si una ventana es la única y modo de apagado de la aplicación es <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Si desea mostrar y ocultar una ventana varias veces durante la vigencia de una aplicación, y no desea volver a crear una instancia de la ventana cada vez que mostrar, se puede controlar la <xref:System.Windows.Window.Closing> eventos, cancelarlo y llamar a la <xref:System.Windows.Window.Hide%2A> método. A continuación, puede llamar a <xref:System.Windows.Window.Show%2A> en la misma instancia para volver a abrirla.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.Windows.Window.Hide" /> en una ventana que se está cerrando (<see cref="E:System.Windows.Window.Closing" />) o se ha cerrado (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el icono de una ventana.</summary>
        <value>Objeto <see cref="T:System.Windows.Media.ImageSource" /> que representa el icono.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones independientes de Windows Presentation Foundation (WPF) tienen dos tipos de iconos:  
  
-   Icono de un ensamblado, que se especifica mediante el `<ApplicationIcon>` archivo de compilación de la propiedad de proyecto de la aplicación. Este icono se utiliza como el icono del escritorio para un ensamblado.  
  
    > [!NOTE]
    >  Cuando se depura en Visual Studio, el icono no puede aparecer debido al proceso de hospedaje. Si ejecuta el ejecutable, aparecerá el icono. Para obtener más información, vea [Proceso de alojamiento (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Un icono por ventana que se especifica estableciendo <xref:System.Windows.Window.Icon%2A>. Para cada ventana, este icono se utiliza en la barra de título su botón de barra de tareas y en su entrada de lista de selección de aplicación ALT+TAB.  
  
 Una ventana de WPF siempre muestra un icono. Cuando no se proporciona mediante el establecimiento <xref:System.Windows.Window.Icon%2A>, WPF elige un icono para mostrar basándose en las siguientes reglas:  
  
1.  Utilice el icono de ensamblado, si se especifica.  
  
2.  Si no se especifica el icono de ensamblado, utilice el icono de Microsoft Windows de forma predeterminada.  
  
 Si usas <xref:System.Windows.Window.Icon%2A> para especificar un icono de ventana personalizado, puede restaurar el icono de aplicación predeterminado estableciendo <xref:System.Windows.Window.Icon%2A> a `null`.  
  
 Un solo icono puede usarse en una variedad de formas en Windows, como se muestra en la barra de título de una ventana, la barra de tareas para una ventana, la lista de selección de archivo ALT + TAB. Cada uno de ellos muestra el icono con un tamaño distinto; se muestra un icono de 16 x 16 píxeles en la barra de título de una ventana y en la barra de tareas, mientras se muestra un icono de 32 x 32 píxeles en la lista de selección de archivo ALT + TAB. Algunas aplicaciones, como [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], proporcione un **vista** menú que le permite elegir el tamaño del icono que le gustaría ver.  
  
 Para satisfacer los distintos tamaños de pantalla, un archivo de icono se compone de uno o varios iconos reales donde cada uno de ellos representa una versión del icono que tiene como destino una profundidad de color y tamaño específica. Por ejemplo, un icono solo puede tener un único icono de 16 x 16 píxeles y 16 colores, mientras que otro puede contener 16 x 16 píxeles y los iconos de 32 x 32 píxeles con 16 colores y 256 colores.  
  
 Si existen iconos para todos los posibles tamaños y profundidad de color dentro de un archivo de icono, <xref:System.Windows.Window> usará el icono adecuado. Si un archivo de icono contiene sólo un subconjunto de todos los iconos posibles <xref:System.Windows.Window> utiliza el siguiente icono más apropiado en orden decreciente de los tamaños y profundidad de color.  
  
 El resultado es que siempre se usará un icono por <xref:System.Windows.Window>, aunque el icono utilizado no puede tener como destino la profundidad de color y tamaño necesaria. Por ejemplo, un icono de 16 x 16 píxeles y 16 colores puede utilizarse para mostrar como un icono de 32 x 32 píxeles con 256 colores. Esto puede provocar efectos visuales no deseados, como la pixilación, pero puede evitarse mediante la creación de iconos para todos los tamaños y profundidad de color.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.IconProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer un icono de ventana.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso establecer el icono. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la ventana está activa.</summary>
        <value>Devuelve <see langword="true" /> si la ventana está activa; de lo contrario, devuelve <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una ventana activa es la ventana de primer plano actual del usuario y tiene el foco, que se especifica mediante la apariencia de la barra de título activa. Una ventana activa también será la parte superior de todas las ventanas de nivel superior que no establecen explícitamente la <xref:System.Windows.Window.Topmost%2A> propiedad.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.IsActiveProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición del borde izquierdo de la ventana con respecto al escritorio.</summary>
        <value>Posición del borde izquierdo de la ventana, en unidades lógicas (1/96 de una pulgada).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Window> está maximizada o minimizada, este valor representa el borde izquierdo de la restauración de punto para la <xref:System.Windows.Window>.  
  
 Esta propiedad no se puede establecer a través de un estilo.  
  
 Si no especifica un valor, <xref:System.Windows.Window.Left%2A> se establece en el valor predeterminado del sistema. También puede especificar el valor predeterminado del sistema estableciendo <xref:System.Windows.Window.Left%2A> a <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> es un valor válido para <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.LeftProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia la ubicación de la ventana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ubicación de la ventana cambia cuando:  
  
-   Un usuario mueve una ventana arrastrando la barra de título.  
  
-   Una ventana se mueve después <xref:System.Windows.Window.DragMove%2A> se llama.  
  
-   Ya sea el <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> propiedad se establece mediante programación.  
  
-   El **mover** se elige el elemento de menú del menú de sistema de una ventana.  
  
-   El <xref:System.Windows.Window.WindowState%2A> se cambia la propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un enumerador para los elementos secundarios lógicos de una ventana.</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> de los elementos secundarios lógicos de una ventana.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize"><see cref="T:System.Windows.Size" /> que refleja el tamaño disponible que esta ventana puede dar al elemento secundario. Se puede usar infinito como valor para indicar que la ventana puede ajustarse a cualquier contenido disponible.</param>
        <summary>Invalide este método para medir el tamaño de una ventana.</summary>
        <returns><see cref="T:System.Windows.Size" /> que refleja el tamaño que esta ventana determina que necesita durante el diseño, basándose en sus cálculos del tamaño de los elementos secundarios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> no se llama cuando el <xref:System.Windows.UIElement.Visibility%2A> propiedad tiene un valor de <xref:System.Windows.Visibility.Collapsed>. Si el valor de la <xref:System.Windows.UIElement.Visibility%2A> propiedad <xref:System.Windows.Visibility.Hidden> o <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> se llama.  
  
> [!NOTE]
>  Cuando ya sea <xref:System.Windows.Window.Show%2A> o <xref:System.Windows.Window.ShowDialog%2A> se denominan, el <xref:System.Windows.UIElement.Visibility%2A> propiedad de un <xref:System.Windows.Window> está establecido en <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> genera el evento <xref:System.Windows.Window.Activated>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnActivated%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnActivated%2A> en la clase base si <xref:System.Windows.Window.Activated> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> genera el evento <xref:System.Windows.Window.Closed>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnClosed%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnClosed%2A> en la clase base si <xref:System.Windows.Window.Closed> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.ComponentModel.CancelEventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> genera el evento <xref:System.Windows.Window.Closing>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnClosing%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnClosing%2A> en la clase base si <xref:System.Windows.Window.Closing> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Referencia a la raíz del árbol de contenido antiguo.</param>
        <param name="newContent">Referencia a la raíz del árbol de contenido nuevo.</param>
        <summary>Se le llama cuando cambia la propiedad <see cref="P:System.Windows.Controls.ContentControl.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> genera el evento <xref:System.Windows.Window.ContentRendered>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnContentRendered%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnContentRendered%2A> en la clase base si <xref:System.Windows.Window.ContentRendered> debe generarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea y devuelve un objeto <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> para este <see cref="T:System.Windows.Window" />.</summary>
        <returns>Un objeto <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> para este <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> genera el evento <xref:System.Windows.Window.Deactivated>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnDeactivated%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnDeactivated%2A> en la clase base si <xref:System.Windows.Window.Deactivated> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Configuración de escala de PPP anterior.</param>
        <param name="newDpi">Nueva configuración de escala de PPP.</param>
        <summary>Llamado cuando cambia el valor de PPP en el que esta ventana se representa.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> genera el evento <xref:System.Windows.Window.LocationChanged>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnLocationChanged%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnLocationChanged%2A> en la clase base si <xref:System.Windows.Window.LocationChanged> debe generarse.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Se invoca cuando se produce el evento <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación no cambia el estado controlado (la <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad) de la <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> datos del evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si invalida <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> genera el evento <xref:System.Windows.Window.SourceInitialized>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnSourceInitialized%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnSourceInitialized%2A> en la clase base si <xref:System.Windows.Window.SourceInitialized> debe generarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Genera el evento <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> genera el evento <xref:System.Windows.Window.StateChanged>.  
  
 Un tipo que derive de <xref:System.Windows.Window> pueden invalidar <xref:System.Windows.Window.OnStateChanged%2A>. El método invalidado debe llamar a <xref:System.Windows.Window.OnStateChanged%2A> en la clase base si <xref:System.Windows.Window.StateChanged> debe generarse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded"><see cref="T:System.Windows.Media.Visual" /> que se agregó a la colección.</param>
        <param name="visualRemoved">El <see cref="T:System.Windows.Media.Visual" /> que se ha quitado de la recolección.</param>
        <summary>Se le llama cuando se modifica la colección <see cref="T:System.Windows.Media.VisualCollection" /> del objeto <see cref="T:System.Windows.Window" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Elemento primario anterior. Se establece en null si el objeto <see cref="T:System.Windows.DependencyObject" /> no tiene un elemento primario anterior.</param>
        <summary>Se llama a este método cuando cambia el elemento primario de la ventana.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de ventanas de las que esta ventana es el propietario.</summary>
        <value><see cref="T:System.Windows.WindowCollection" /> que contiene referencias a las ventanas de las que esta ventana es el propietario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una ventana poseída es uno cuyo <xref:System.Windows.Window.Owner%2A> propiedad se establece con una referencia a otra ventana, que se conoce como la ventana propietaria. Para buscar todas las ventanas de una ventana propietaria, puede enumerar <xref:System.Windows.WindowCollection> devuelta por la <xref:System.Windows.Window.OwnedWindows%2A> propiedad.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo enumerar <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Windows.Window" /> que es la ventana propietaria de este objeto <see cref="T:System.Windows.Window" />.</summary>
        <value>Objeto <see cref="T:System.Windows.Window" /> que representa la ventana propietaria de este objeto <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se abre una ventana secundaria de una ventana primaria mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>, se establece una relación implícita entre la ventana primaria y secundaria. Esta relación exige determinados comportamientos incluidos con respecto a minimizar, maximizar y restaurar.  
  
 Cuando se crea una ventana secundaria de una ventana primaria mediante una llamada a <xref:System.Windows.Window.Show%2A>, sin embargo, la ventana secundaria no tiene una relación con la ventana primaria. Esto significa que:  
  
-   La ventana secundaria no tiene una referencia a la ventana primaria.  
  
-   El comportamiento de la ventana secundaria no es dependiente del comportamiento de la ventana primaria; cualquier ventana puede cubrir la otra o minimizarse, maximizarse y restaurarse independientemente de la otra.  
  
 Para poder crear una relación entre una ventana secundaria y una ventana primaria, <xref:System.Windows.Window> admite la noción de la propiedad. La propiedad se establece cuando el <xref:System.Windows.Window.Owner%2A> se establece la propiedad de una ventana (la ventana poseída) con una referencia a otra ventana (la ventana propietaria).  
  
 Una vez establecida esta relación, se exhibe los comportamientos siguientes:  
  
-   Si se minimiza una ventana propietaria, se minimizan también todas sus ventanas que se poseen.  
  
-   Si se minimiza una ventana poseída, su propietario no se minimiza.  
  
-   Si se maximiza una ventana propietaria, se restauran la ventana propietaria y las ventanas pertenecientes.  
  
-   Una ventana propietaria nunca puede cubrir una ventana poseída.  
  
-   Propiedad de windows que no se abrieron mediante <xref:System.Windows.Window.ShowDialog%2A> no son modales. El usuario todavía puede interactuar con la ventana propietaria.  
  
-   Si cierra una ventana propietaria, también se cierran las ventanas pertenecientes.  
  
-   Si se ha abierto una ventana poseída utilizando su propietario de la ventana <xref:System.Windows.Window.Show%2A>y el propietario de la ventana se cierra la ventana poseída <xref:System.Windows.Window.Closing> no se produce el evento.  
  
 Cuando abre una ventana secundaria mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>, también debe establecer el <xref:System.Windows.Window.Owner%2A> propiedad de la ventana secundaria. Si no lo hace, a continuación, los usuarios no podrán restaurar la ventana secundaria y ventana primaria presionando el botón de barra de tareas. En su lugar, al presionar el botón de barra de tareas producirá una lista de windows, incluidos la ventana primaria y secundaria, les permite seleccionar; se restaura solo la ventana seleccionada.  
  
> [!IMPORTANT]
>  También debe establecer el <xref:System.Windows.Window.Owner%2A> propiedad en una ventana que se abre mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A> para garantizar el comportamiento correcto con.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer la relación propietarias y pertenecientes.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Una ventana intenta ser propietaria de sí misma. 
O bien 
Dos ventanas intentan ser propietarias la una de la otra.</exception>
        <exception cref="T:System.InvalidOperationException">La propiedad <see cref="P:System.Windows.Window.Owner" /> está establecida en una ventana visible que se muestra mediante <see cref="M:System.Windows.Window.ShowDialog" />.  
  
O bien 
La propiedad <see cref="P:System.Windows.Window.Owner" /> está establecida en una ventana que no se ha mostrado anteriormente.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">permiso usar todas las ventanas y eventos de entrada de usuario sin restricciones. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el modo de cambio de tamaño.</summary>
        <value>Valor de <see cref="T:System.Windows.ResizeMode" /> que especifica el modo de cambio de tamaño.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay cuatro opciones:  
  
-   **NoResize**. El usuario no puede cambiar el tamaño de la ventana. No se muestran los cuadros maximizar y minimizar.  
  
-   **CanMinimize**. El usuario sólo puede minimizar la ventana y restaurarla a partir de la barra de tareas. Los cuadros Minimizar y maximizar se muestran, pero solo en el cuadro de minimizar está habilitado.  
  
-   **CanResize**. El usuario tiene la capacidad completa para cambiar el tamaño de la ventana, utilizando los cuadros Minimizar y maximizar y un contorno arrastrable alrededor de la ventana. Los cuadros Minimizar y maximizar se muestran y habilitados. (Valor predeterminado).  
  
-   **CanResizeWithGrip**. Esta opción tiene la misma funcionalidad que <xref:System.Windows.ResizeMode.CanResize>, pero agrega un "control de cambio de tamaño" en la esquina inferior derecha de la ventana.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.ResizeModeProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño y la ubicación de una ventana antes de ser minimizada o maximizada.</summary>
        <value><see cref="T:System.Windows.Rect" /> que especifica el tamaño y la ubicación de una ventana antes de ser minimizada o maximizada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El rectángulo de restauración es el área ocupada por la ventana antes de ser minimizada o maximizada. Puede usar <xref:System.Windows.Window.RestoreBounds%2A> para guardar el último tamaño y la ubicación de una ventana antes de cerrar una aplicación y recuperar esos valores la próxima vez que se inicia una aplicación para restaurar una ventana en la forma en que un usuario lo dejó.  
  
 Si consulta <xref:System.Windows.Window.RestoreBounds%2A> antes de que se muestre la ventana o después de que se ha cerrado, <xref:System.Windows.Rect.Empty%2A> se devuelve.  
  
> [!NOTE]
>  No se puede obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa <xref:System.Windows.Window.RestoreBounds%2A> y aislamiento de almacenamiento para asegurarse de que el tamaño y la ubicación de una ventana son iguales que estaban la última vez que se mostrara la ventana.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para que obtener permiso para consultar el tamaño y la ubicación de una ventana del rectángulo delimitador. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abre una ventana y devuelve un valor sin esperar a que se cierre la ventana que acaba de abrirse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Window> se crea una instancia de clase, no es visible de forma predeterminada. <xref:System.Windows.Window.Show%2A> se muestra una ventana y devuelve inmediatamente, sin esperar a la ventana que se cerrará. Por lo tanto, la ventana abierta no impide que los usuarios interactuar con otras ventanas de la aplicación. Este tipo de ventana se denomina un *no modal* ventana. Algunos ejemplos comunes de windows no modales son paletas, cuadros de herramientas y ventanas de propiedades. Para restringir un usuario a la interacción con una ventana específica, debe abrirse la ventana mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Una ventana que se abre mediante una llamada a <xref:System.Windows.Window.Show%2A> does automáticamente no tienen una relación con la ventana que abrió; en concreto, la ventana abierta no sabe qué ventana la abrió. Se puede establecer esta relación mediante la <xref:System.Windows.Window.Owner%2A> propiedad y administrar mediante el <xref:System.Windows.Window.OwnedWindows%2A> propiedad.  
  
 Una llamada a <xref:System.Windows.Window.Show%2A> consigue el mismo resultado final como configuración <xref:System.Windows.UIElement.Visibility%2A> propiedad de la <xref:System.Windows.Window> objeto <xref:System.Windows.Visibility.Visible>. Sin embargo, hay una diferencia entre los dos desde la perspectiva del control de tiempo.  
  
 Una llamada a <xref:System.Windows.Window.Show%2A> es una operación sincrónica que devuelve solo después el <xref:System.Windows.FrameworkElement.Loaded> ha generado el evento en la ventana secundaria:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Establecer <xref:System.Windows.UIElement.Visibility%2A>, sin embargo, es una operación asincrónica que devuelve inmediatamente:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Al establecer <xref:System.Windows.UIElement.Visibility%2A>, los eventos de la ventana registrar antes de establecer <xref:System.Windows.UIElement.Visibility%2A> no es posible que se producen hasta después del método donde estableció <xref:System.Windows.UIElement.Visibility%2A> ha completado su ejecución.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo abrir una ventana no modal.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.Windows.Window.Show" /> en una ventana que se está cerrando (<see cref="E:System.Windows.Window.Closing" />) o se ha cerrado (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una ventana se activa la primera vez que se muestra.</summary>
        <value>Es <see langword="true" /> si una ventana se activa la primera vez que se muestra; de lo contrario, es <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando una ventana con su <xref:System.Windows.Window.ShowActivated%2A> propiedad establecida en `false` está abierto, la ventana no está activada y su <xref:System.Windows.Window.Activated> no se provoca el evento hasta que un usuario activa manualmente la ventana, selecciónelo. Después de la ventana se selecciona, activa y desactiva con normalidad.  
  
 Para evitar que una ventana que se activa cuando se abre, la <xref:System.Windows.Window.ShowActivated%2A> propiedad debe establecerse en `false` antes de que se muestra la ventana (mediante una llamada a <xref:System.Windows.Window.Show%2A>); el parámetro <xref:System.Windows.Window.ShowActivated%2A> a `false` después de que se muestre una ventana no tiene ningún efecto.  
  
 Establecer <xref:System.Windows.Window.ShowActivated%2A> a `false` en una ventana que se abre de forma modal, mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>, no tiene ningún impacto real. Aunque no se activará la ventana modal, la ventana modal impedirá al usuario activar otras ventanas de aplicación abierta.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el marcado para configurar una ventana que se puede abrir sin que se está activando.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 El ejemplo siguiente muestra cómo usar código para configurar una ventana que se puede abrir sin que se va a activar.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abre una ventana y devuelve un valor sólo cuando se cierra la ventana que acaba de abrirse.</summary>
        <returns>Valor <see cref="T:System.Nullable`1" /> de tipo <see cref="T:System.Boolean" /> que especifica si la actividad se aceptó (<see langword="true" />) o se canceló (<see langword="false" />). El valor devuelto es el valor de la propiedad <see cref="P:System.Windows.Window.DialogResult" /> antes de que se cierre una ventana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un <xref:System.Windows.Window> se crea una instancia de clase, no es visible de forma predeterminada. <xref:System.Windows.Window.ShowDialog%2A> se muestra la ventana, deshabilita todas las demás ventanas en la aplicación y devuelve solo cuando se cierra la ventana. Este tipo de ventana se conoce como un *modal* ventana.  
  
 Ventanas modales se utilizan principalmente como cuadros de diálogo. Un cuadro de diálogo es un tipo especial de ventana que las aplicaciones utilizan para interactuar con los usuarios realizar tareas, como abrir archivos o imprimir documentos. Normalmente, los cuadros de diálogo Permitir que los usuarios Aceptar o cancelar la tarea para el que se mostraron antes de cerrar el cuadro de diálogo. <xref:System.Windows.Window.ShowDialog%2A> Devuelve un <xref:System.Nullable%601> <xref:System.Boolean> valor que especifica si se acepta o se cancela la actividad. El valor devuelto es el valor de la propiedad <xref:System.Windows.Window.DialogResult%2A> antes de que se cierre una ventana. Para obtener más información, vea <xref:System.Windows.Window.DialogResult%2A>.  
  
 Una ventana que se abre mediante una llamada a la <xref:System.Windows.Window.ShowDialog%2A> método no tiene una relación con la ventana que se ha abierto automáticamente; en concreto, la ventana abierta no sabe qué ventana la abrió. Se puede establecer esta relación mediante la <xref:System.Windows.Window.Owner%2A> propiedad y administrar mediante el <xref:System.Windows.Window.OwnedWindows%2A> propiedad. Para admitir [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automatización (consulte [UI Automation Overview](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> se debe establecer para una ventana abierta mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Cuando un estado modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ventana (ventana abierta mediante una llamada a <xref:System.Windows.Window.ShowDialog%2A>) está cerrada, activada previamente se vuelve a activar ventana. Si un estado modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ventana tiene una ventana propietaria (vea <xref:System.Windows.Window.Owner%2A>), la ventana propietaria no es vuelve a activar cuando el estado modal [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] se cierra la ventana a menos que sea la ventana activada previamente.  
  
> [!NOTE]
>  No se puede llamar a este método cuando una ventana se hospeda en un explorador.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo abrir una ventana modal.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama a <see cref="M:System.Windows.Window.ShowDialog" /> en una ventana que se está cerrando (<see cref="E:System.Windows.Window.Closing" />) o se ha cerrado (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Para obtener permiso activar una ventana. Enumeración asociada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si la ventana tiene un botón de barra de tareas.</summary>
        <value>Devuelve <see langword="true" /> si la ventana tiene un botón de barra de tareas; de lo contrario, devuelve <see langword="false" />. No se aplica cuando la ventana se hospeda en un explorador.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Window.ShowInTaskbar%2A> está establecido en `true`, la ventana también aparecerá en la lista de selección de la aplicación de ALT+TAB.  
  
 El icono que se usa para el botón de barra de tareas y la lista de selección de la aplicación de ALT+TAB es el valor de la <xref:System.Windows.Window.Icon%2A> propiedad.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una ventana ajustará automáticamente su tamaño al de su contenido.</summary>
        <value>Valor <see cref="T:System.Windows.SizeToContent" />. De manera predeterminada, es <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Windows.Window.SizeToContent%2A> está establecido en <xref:System.Windows.SizeToContent.WidthAndHeight>, configuración <xref:System.Windows.FrameworkElement.Height%2A> o <xref:System.Windows.FrameworkElement.Width%2A> no tiene ningún efecto; se pueden establecer ambas propiedades, pero los valores que están establecidas con no se aplican a la ventana.  
  
 Cuando <xref:System.Windows.Window.SizeToContent%2A> está establecido en <xref:System.Windows.SizeToContent.Height>, estableciendo <xref:System.Windows.FrameworkElement.Height%2A> no cambia el alto de la ventana.  
  
 Cuando <xref:System.Windows.Window.SizeToContent%2A> está establecido en <xref:System.Windows.SizeToContent.Width>, estableciendo <xref:System.Windows.FrameworkElement.Width%2A> no cambia el ancho de la ventana.  
  
 Si <xref:System.Windows.Window.SizeToContent%2A> tiene un valor distinto <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> se establece automáticamente en <xref:System.Windows.SizeToContent.Manual> si un usuario cambia el tamaño de la ventana mediante el control de cambio de tamaño o arrastre el borde.  
  
-   Si cambia el tamaño del contenido de forma que hace que la ventana de tamaño él mismo, <xref:System.Windows.FrameworkElement.SizeChanged> se genera.  
  
 Si una ventana es transparente (vea <xref:System.Windows.Window.AllowsTransparency%2A>), debería considerar la configuración <xref:System.Windows.Window.SizeToContent%2A> a <xref:System.Windows.SizeToContent.WidthAndHeight> para asegurarse de que la ventana no es mayor que su contenido visible.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.SizeToContentProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Window.SizeToContent%2A> propiedad en el código para especificar cómo se redimensiona una ventana para ajustar su contenido.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Este evento se provoca para admitir la interoperación con [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Vea <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia la propiedad <see cref="P:System.Windows.Window.WindowState" /> de la ventana.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la miniatura de la barra de tareas de [!INCLUDE[win7](~/includes/win7-md.md)] para <see cref="T:System.Windows.Window" />.</summary>
        <value>Miniatura de la barra de tareas de [!INCLUDE[win7](~/includes/win7-md.md)] para <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre cómo usar el [!INCLUDE[win7](~/includes/win7-md.md)] barra de tareas en miniatura, vea el <xref:System.Windows.Shell.TaskbarItemInfo> clase.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un título para la ventana.</summary>
        <value><see cref="T:System.String" /> que contiene el título de la ventana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El título de un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, o [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], también puede establecerse mediante el uso de <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.TitleProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición del borde superior de la ventana con respecto al escritorio.</summary>
        <value>Posición del borde superior de la ventana, en unidades lógicas (1/96 de una pulgada).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Windows.Window> está maximizada o minimizada, este valor representa el borde superior de la restauración de punto para la <xref:System.Windows.Window>.  
  
 Esta propiedad no se puede establecer a través de un estilo.  
  
 Si no especifica un valor, <xref:System.Windows.Window.Top%2A> se establece en el valor predeterminado del sistema. También puede especificar el valor predeterminado del sistema estableciendo <xref:System.Windows.Window.Top%2A> a <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> es un valor válido para <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.TopProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una ventana aparece en el punto más alto en el orden Z.</summary>
        <value>Devuelve <see langword="true" /> si la ventana es la ventana de nivel superior; de lo contrario, devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una ventana cuyo <xref:System.Windows.Window.Topmost%2A> propiedad está establecida en `true` aparece por encima de todas las ventanas cuya <xref:System.Windows.Window.Topmost%2A> propiedades se establecen en `false`.  
  
 En el grupo de windows que tienen <xref:System.Windows.Window.Topmost%2A> propiedad está establecida en `true`, la ventana que está activada actualmente es la ventana de nivel superior. Lo mismo para el grupo de windows que tienen <xref:System.Windows.Window.Topmost%2A> propiedad está establecida en `false`.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.TopmostProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición de la ventana cuando se muestra por primera vez.</summary>
        <value>Valor de <see cref="T:System.Windows.WindowStartupLocation" /> que especifica la posición de los bordes superior e izquierdo de una ventana cuando se muestra por primera vez. De manera predeterminada, es <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el `WindowStartupLocation` propiedad <xref:System.Windows.WindowStartupLocation.Manual> hace que una ventana se coloca según su <xref:System.Windows.Window.Left%2A> y <xref:System.Windows.Window.Top%2A> los valores de propiedad. Si el <xref:System.Windows.Window.Left%2A> o <xref:System.Windows.Window.Top%2A> no se especifican las propiedades, sus valores se determinan mediante Windows.  
  
 Establecer el `WindowStartupLocation` propiedad <xref:System.Windows.WindowStartupLocation.CenterScreen> hace que una ventana se coloca en el centro de la pantalla que contiene el cursor del mouse.  
  
 Establecer el `WindowStartupLocation` propiedad <xref:System.Windows.WindowStartupLocation.CenterOwner> hace que una ventana se coloca en el centro de la ventana propietaria (vea <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>), si se especifica. La ventana propietaria puede ser otra ventana WPF o una ventana que no son de WPF.

> [!NOTE]   
>  Para obtener más información acerca de las ventanas WPF con windows que no son de WPF, vea [WPF e interoperabilidad con Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) y <xref:System.Windows.Interop.WindowInteropHelper>. 

 Si no se especifica una ventana propietaria, se determina la posición de la ventana de la misma manera que si el `WindowStartupLocation` propiedad está establecida en <xref:System.Windows.WindowStartupLocation.Manual>.

> [!NOTE]
>  No puede establecer ni obtener el valor de esta propiedad cuando una ventana está hospedada en un explorador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si una ventana está restaurada, minimizada o maximizada.</summary>
        <value>Valor de <see cref="T:System.Windows.WindowState" /> que determina si una ventana está restaurada, minimizada o maximizada. El valor predeterminado es <see cref="F:System.Windows.WindowState.Normal" /> (restaurada).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de que una ventana está minimizada o maximizada, su tamaño y la ubicación se almacenan en <xref:System.Windows.Window.RestoreBounds%2A>. Cuando posteriormente se restaura una ventana, sus valores de tamaño y la ubicación se restauran con los valores de <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Cuando el <xref:System.Windows.Window.WindowState%2A> propiedad ha cambiado, <xref:System.Windows.Window.StateChanged> se genera.  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.WindowStateProperty>|  
|Establecen las propiedades de metadatos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un estilo de borde para la ventana.</summary>
        <value><see cref="T:System.Windows.WindowStyle" /> que especifica el estilo de borde de una ventana. De manera predeterminada, es <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> puede ser uno de los <xref:System.Windows.WindowStyle> valores de enumeración, incluidos <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (valor predeterminado), y <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 La siguiente ilustración muestra los estilos de ventana en [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (tema Aero de Windows Vista, con efecto de cristal transparente habilitado):  
  
 ![Estilos de ventana](~/add/media/windowoverviewfigure6.PNG "estilos de ventana")  
  
> [!NOTE]
>  No puede establecer ni obtener esta propiedad cuando una ventana se hospeda en un explorador.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Window.WindowStyleProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>