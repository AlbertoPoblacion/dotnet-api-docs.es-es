<Type Name="EventManager" FullName="System.Windows.EventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c77ae0f0dbeb2878102af1c07c306ec83ccf92c4" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30678569" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class EventManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EventManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.EventManager" />
  <TypeSignature Language="VB.NET" Value="Public Class EventManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventManager abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona métodos de utilidad relacionados con eventos que registran eventos enrutados para los propietarios de la clase y agregan controladores de clases.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase se usa normalmente para registrar un nuevo evento enrutado, con <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.  
  
 El segundo más común [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] uso es <xref:System.Windows.EventManager.RegisterClassHandler%2A>. Utilice este método para habilitar el control de clases de un evento enrutado en la clase o un evento adjunto. Para obtener más información, consulte [Marcar eventos enrutados como Handled and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar esta clase para registrar un nuevo evento enrutado como un miembro de clase, junto con la técnica de "contenedor" de evento enrutado de invalidación de agregar y quitar las implementaciones para una [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] eventos.  
  
 [!code-csharp[DPCustom#EventManagerClass](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#eventmanagerclass)]
 [!code-vb[DPCustom#EventManagerClass](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#eventmanagerclass)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="GetRoutedEvents">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEvents () As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEvents();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve los identificadores de los eventos enrutados registrados en el sistema de eventos.</summary>
        <returns>Matriz de tipo <see cref="T:System.Windows.RoutedEvent" /> que contiene los objetos registrados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Más <xref:System.Windows.RoutedEvent> objetos se pueden registrar más tarde. Este método obtiene una instantánea y la colección de eventos enrutados es grabable en toda la duración de la aplicación. La colección devuelta podría ser bastante grande. Aunque solo contar los eventos que forman parte de la [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], es el número de colecciones en cientos alta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRoutedEventsForOwner">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent[] GetRoutedEventsForOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent[] GetRoutedEventsForOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.GetRoutedEventsForOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRoutedEventsForOwner (ownerType As Type) As RoutedEvent()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Windows::RoutedEvent ^&gt; ^ GetRoutedEventsForOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Tipo con el que se va a iniciar la búsqueda. Las clases base se incluyen en la búsqueda.</param>
        <summary>Busca eventos en todos los identificadores de eventos enrutados con el tipo de propietario proporcionado.</summary>
        <returns>Es una matriz de identificadores de eventos enrutados coincidentes si se encuentra cualquier coincidencia; de lo contrario, es <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterClassHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registra un controlador de clase de un evento enrutado concreto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="classType">Tipo de la clase que declara el control de clase.</param>
        <param name="routedEvent">Identificador de eventos enrutados del evento que se va a controlar.</param>
        <param name="handler">Referencia a la implementación del controlador de clase.</param>
        <summary>Registra un controlador de clase de un evento enrutado concreto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Control de clases es una característica que está disponible para los eventos enrutados, incluidos los eventos asociados que se implementan con el respaldo de eventos enrutados. Un controlador de clase es como un controlador estático que existe para todas las instancias de la clase. Dado que el controlador es estático, no se puede cambiar las propiedades de instancia directamente con un controlador de clase, pero puede tener acceso a instancias a través de la `sender` parámetro o los datos del evento.  
  
 Controladores de clase se invocan antes que los controladores de instancia. Puede implementar un controlador de clase que tiene el comportamiento de marcar el evento como controlado. Por lo tanto, no se invocan controladores de instancia para un evento controlado de clase, a menos que los controladores de instancia se registren específicamente para los eventos controlados.  
  
 Muchas de las [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] eventos de elemento base proporcionan métodos virtuales de control de clases. Al invalidar estos métodos en clases que heredan las clases base, puede implementar clase de control sin llamar a <xref:System.Windows.EventManager.RegisterClassHandler%2A> en constructores estáticos. Normalmente, estos métodos de control de la clase existen para eventos de entrada y tienen nombres que empiezan por "On" y terminan con el nombre del evento que se está administrado por la clase.  
  
 Para obtener más información sobre el control de clases, consulte [Marcar eventos enrutados como Handled and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Con esta firma, los controladores de clases se registra para invocar solo como respuesta a eventos no controlados. También puede registrar los controladores de clases para invocar incluso si los argumentos de evento están marcado como controlados, mediante el uso de la <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> firma, con `handledEventsToo` establecido en `true`.  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega un controlador para <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>, al llamar a <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 [!code-csharp[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#staticandregisterclasshandler)]
 [!code-vb[ClassHandling#StaticAndRegisterClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#staticandregisterclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterClassHandler">
      <MemberSignature Language="C#" Value="public static void RegisterClassHandler (Type classType, System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterClassHandler(class System.Type classType, class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterClassHandler(System.Type,System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterClassHandler(Type ^ classType, System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classType" Type="System.Type" />
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classType">Tipo de la clase que declara el control de clase.</param>
        <param name="routedEvent">Identificador de eventos enrutados del evento que se va a controlar.</param>
        <param name="handler">Referencia a la implementación del controlador de clase.</param>
        <param name="handledEventsToo">
          Es <see langword="true" /> para invocar este controlador de clase aunque los argumentos del evento enrutado se hayan marcado como controlados; es <see langword="false" /> para retener el comportamiento predeterminado de no invocar el controlador en ningún evento marcado como controlado.</param>
        <summary>Registra un controlador de clase de un evento enrutado concreto, con la opción de controlar los eventos en los que los datos del evento ya estén marcados como controlados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Control de clases es una característica que está disponible para los eventos enrutados, incluidos los eventos asociados que se implementan con el respaldo de eventos enrutados. Un controlador de clase es como un controlador estático que existe para todas las instancias de la clase. Dado que el controlador es estático, no se puede cambiar las propiedades de instancia directamente con un controlador de clase, pero puede tener acceso a instancias a través de la `sender` parámetro o los datos del evento.  
  
 Controladores de clase se invocan antes que los controladores de instancia. Puede implementar un controlador de clase que tiene el comportamiento de marcar el evento como controlado. Por lo tanto, no se invocan controladores de instancia para un evento controlado de clase, a menos que los controladores de instancia se registren específicamente para los eventos controlados.  
  
 Muchas de las [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] eventos de elemento base proporcionan métodos virtuales de control de clases. Al invalidar estos métodos en clases que heredan las clases base, puede implementar clase de control sin llamar a <xref:System.Windows.EventManager.RegisterClassHandler%2A> en constructores estáticos. Normalmente, estos métodos de control de la clase existen para eventos de entrada y tienen nombres que empiezan por "On" y terminan con el nombre del evento que se está administrado por la clase.  
  
 Para obtener más información sobre el control de clases, consulte [Marcar eventos enrutados como Handled and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 Con esta firma, los controladores de clase se pueden registrar para invocar eventos controlados, estableciendo `handledEventsToo` establecido en `true`. Por lo general, debe hacerlo solo si hay un problema de control conocido que está intentando buscar soluciones alternativas, como sistema de entrada de control de eventos del mouse o teclado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRoutedEvent">
      <MemberSignature Language="C#" Value="public static System.Windows.RoutedEvent RegisterRoutedEvent (string name, System.Windows.RoutingStrategy routingStrategy, Type handlerType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.RoutedEvent RegisterRoutedEvent(string name, valuetype System.Windows.RoutingStrategy routingStrategy, class System.Type handlerType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.EventManager.RegisterRoutedEvent(System.String,System.Windows.RoutingStrategy,System.Type,System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::RoutedEvent ^ RegisterRoutedEvent(System::String ^ name, System::Windows::RoutingStrategy routingStrategy, Type ^ handlerType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="routingStrategy" Type="System.Windows.RoutingStrategy" />
        <Parameter Name="handlerType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del evento enrutado. El nombre debe ser único en el tipo de propietario y no puede ser <see langword="null" /> ni una cadena vacía.</param>
        <param name="routingStrategy">Estrategia de enrutamiento del evento como valor de la enumeración.</param>
        <param name="handlerType">Tipo del controlador de eventos. Se debe tratar de un tipo de delegado y no puede ser <see langword="null" />.</param>
        <param name="ownerType">Tipo de clase de propietario del evento enrutado. Su valor no puede ser <see langword="null" />.</param>
        <summary>Registra un nuevo evento enrutado en el sistema de eventos del [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)].</summary>
        <returns>Identificador del evento enrutado recién registrado. Este objeto de identificador puede almacenarse como un campo estático en una clase y, a continuación, usarse como parámetro para los métodos que asocian controladores al evento. El identificador del evento enrutado también se usa para otras [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] del sistema de eventos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice el valor devuelto de este método para crear la declaración estática de un único <xref:System.Windows.RoutedEvent> campo identificador. Este campo debe almacenarse en el tipo de propietario.  
  
 Hay un número considerable de convenciones y los procedimientos recomendados asociados con los eventos enrutados cómo deben denominados, registrados y exponer en una clase. Para obtener más información, consulte [enrutan Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>