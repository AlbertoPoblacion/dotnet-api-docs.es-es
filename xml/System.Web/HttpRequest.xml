<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f5e927b6dd4443feead33b37497ab93ccb239d7a" /><Meta Name="ms.sourcegitcommit" Value="c5fd6b431a16f0412349201a0e93a9eacddf4b35" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/14/2018" /><Meta Name="ms.locfileid" Value="53393737" /></Metadata><TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <TypeSignature Language="F#" Value="type HttpRequest = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Permite a ASP.NET leer los valores HTTP enviados por un cliente durante una solicitud web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos y propiedades de la <xref:System.Web.HttpRequest> clase se exponen a través de la `Request` propiedades de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 Para acceder a ellos desde el <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, o <xref:System.Web.HttpRequest.ServerVariables%2A> colecciones, puede escribir `Request["key"]`, tal y como se muestra en el ejemplo de la <xref:System.Web.HttpRequest.QueryString%2A> propiedad.  
  
> [!NOTE]
>  Compatibilidad con Unicode <xref:System.Web.HttpRequest> los miembros de clase requiere IIS versión 6.0 o posterior.  
  
   
  
## Examples  
 Los siguientes ejemplos de acceso del <xref:System.Web.HttpRequest> instancia para la solicitud actual mediante el uso de la <xref:System.Web.UI.Page.Request%2A> propiedad de la <xref:System.Web.UI.Page> clase.  
  
 Puede usar una sintaxis simplificada para tener acceso a datos desde el <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, o <xref:System.Web.HttpRequest.ServerVariables%2A> colecciones. Puede escribir `Request["key"]`.  
  
 El primer ejemplo muestra cómo recuperar un valor de cadena de consulta cuando se carga una página.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 El ejemplo siguiente muestra cómo comprobar si la solicitud está autenticada y recuperar la dirección URL sin procesar.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Un proyecto de sitio Web de Visual Studio con código fuente está disponible para este tema: [Descargar](https://go.microsoft.com/fwlink/?LinkID=191455).  
  
 Este ejemplo se usa el <xref:System.IO.StreamWriter> clase para escribir los valores de varias <xref:System.Web.HttpRequest> propiedades a un archivo de la clase. Para las propiedades que son de tipo cadena, los valores son HTML codificado como se escriben en el archivo. Las propiedades que representan una colección se recorren, y cada par clave-valor que contienen se escribe en el archivo.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](https://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpRequest : string * string * string -&gt; System.Web.HttpRequest" Usage="new System.Web.HttpRequest (filename, url, queryString)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo asociado a la solicitud.</param>
        <param name="url">Información acerca de la dirección URL de la solicitud actual.</param>
        <param name="queryString">Cadena de consulta completa enviada con la solicitud (todo lo que va después de <c>'?'</c>).</param>
        <summary>Inicializa un objeto <see cref="T:System.Web.HttpRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No es necesario crear su propia instancia de la <xref:System.Web.HttpRequest> clase. Los métodos y propiedades de la <xref:System.Web.HttpRequest> clase se exponen a través de la `Request` propiedad de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="httpRequest.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina de manera forzosa la conexión TCP subyacente, lo que provoca el error de cualquier E/S pendiente. Podría usar este método en respuesta a un ataque de un cliente HTTP malintencionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es seguro para subprocesos. Cualquier subproceso puede llamar a él en cualquier momento.  
  
 Este método solo puede usarse en el modo integrado. Si se invoca en el modo clásico, se produce una excepción. Para determinar el modo de canalización, utilice <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AcceptTypes : string[]" Usage="System.Web.HttpRequest.AcceptTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de cadenas de tipos accept MIME admitidos por el cliente.</summary>
        <value>Matriz de cadenas de tipos accept MIME admitidos por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se captura los diversos valores devueltos por la <xref:System.Web.HttpRequest.AcceptTypes%2A> propiedad en una variable de objeto y escribe el número y el nombre de cada valor a una línea independiente de la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AnonymousID : string" Usage="System.Web.HttpRequest.AnonymousID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador anónimo del usuario, si lo hay.</summary>
        <value>Cadena que representa el identificador anónimo de usuario actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad asigna un identificador único de larga duración a un usuario no autenticado, que puede usarse para realizar un seguimiento del usuario o asignar propiedades de perfil a ese usuario sin almacenar los datos en un `Session` objeto. De forma predeterminada, el <xref:System.Web.HttpRequest.AnonymousID%2A> se realiza el seguimiento de propiedad mediante una cookie, pero se puede establecer para usar el identificador URI cuando el <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> atributo en la sección de configuración de la identificación anónima está establecido en el <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.HttpCookieMode.UseDeviceProfile>, o <xref:System.Web.HttpCookieMode.AutoDetect> valor. Debe borrar la cookie explícitamente si ya no desea que esté disponible, por ejemplo, cuando se autentica un usuario anónimo.  
  
 Identificación anónima se utiliza cuando es necesario para identificar las entidades que no se autentican y cuando se necesita autorización. Para obtener más información, consulte [anonymousIdentification Element (ASP.NET Settings Schema)](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100))  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad controlando el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos en el archivo Global.asax. En este ejemplo tiene dos partes:  
  
-   Un método en el archivo Global.asax que controla el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos.  
  
-   Una página de formularios Web Forms.  
  
 La primera parte del ejemplo de código muestra cómo establecer el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad controlando el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos en el archivo Global.asax. El método que se denomina `AnonymousIdentification_Creating` establece el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad cuando se crea un identificador anónimo.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 La segunda parte del ejemplo de código muestra cómo mostrar el nuevo <xref:System.Web.HttpRequest.AnonymousID%2A> creado por el `AnonymousIdentification_Creating` controlador de eventos en el ejemplo anterior.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/91ka2e6a(v=vs.100)">Elemento anonymousIdentification (Esquema de configuración de ASP.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationPath : string" Usage="System.Web.HttpRequest.ApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso a la raíz virtual de la aplicación ASP.NET en el servidor.</summary>
        <value>Ruta de acceso virtual de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para construir una dirección URL relativa a la raíz de la aplicación desde una página o control de usuario Web que no está en el directorio raíz. Esto permite que las páginas y controles compartidos que existen en diferentes niveles de una estructura de directorios para utilizar el mismo código para vincular a recursos desde una ubicación fija en la aplicación.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.StreamWriter.Write%2A> método para codificar en HTML y, a continuación, escribir el valor de la <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad a un archivo de texto. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase. Presupone la existencia de un <xref:System.IO.StreamWriter> objeto denominado `sw`.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad para construir mediante programación una ruta de acceso a un recurso que se encuentra en una ubicación fija en la aplicación. No tiene la página que hace referencia a los recursos se encuentren en el mismo directorio que el recurso.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 Si ejecuta este ejemplo en una aplicación Web que se denomina WebSite1, `/WebSite1` se mostrará como el valor de la <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad y `/WebSite1/images/Image1.gif` se mostrará como la ruta de acceso completa de la imagen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppRelativeCurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la raíz de la aplicación y la convierte en relativa mediante la tilde (\~) para la raíz de la aplicación (como en "\~/page.aspx").</summary>
        <value>Ruta de acceso virtual de la raíz de la aplicación para la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para proporcionar información de dirección URL que seguirá siendo la misma incluso si la aplicación cambie de ubicación. Esto permite que el mismo código de asignación de dirección URL que se usará en un entorno de prueba y en el entorno de implementación final, o que va a usar copias de las aplicaciones Web en diferentes dominios.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> propiedad para establecer la dirección URL de un <xref:System.Web.UI.WebControls.Image> control a una imagen en el mismo directorio que la página. Ejecute esta página en diferentes niveles de una estructura de directorios para ver el resultado <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> los valores de propiedad.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> propiedad para establecer la ruta de acceso mediante programación a un recurso, en función de la ruta de acceso actual de la página.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberSignature Language="F#" Value="member this.BinaryRead : int -&gt; byte[]" Usage="httpRequest.BinaryRead count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Número de bytes que se va a leer.</param>
        <summary>Realiza una lectura binaria de un número de bytes especificado en el flujo de entrada actual.</summary>
        <returns>Matriz de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.BinaryRead%2A> método se proporciona por compatibilidad con ASP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> es 0.  
  
O bien 
 <paramref name="count" /> es mayor que el número de bytes disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities with get, set" Usage="System.Web.HttpRequest.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información acerca de las capacidades del explorador del cliente que realiza la solicitud.</summary>
        <value>Objeto <see cref="T:System.Web.HttpBrowserCapabilities" /> que enumera en una lista las capacidades del explorador del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código envía una lista de las capacidades del explorador al cliente en una página HTML.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Controles de servidor ASP.NET y las capacidades del explorador</related>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificate : System.Web.HttpClientCertificate" Usage="System.Web.HttpRequest.ClientCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el certificado de seguridad del cliente para la solicitud actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpClientCertificate" /> que contiene información sobre la configuración del certificado de seguridad del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código envía la configuración del certificado del cliente al cliente en una página HTML.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpRequest.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el juego de caracteres del cuerpo de la entidad.</summary>
        <value>Objeto <see cref="T:System.Text.Encoding" /> que representa el juego de caracteres del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de contenido predeterminada puede especificarse en el [globalización Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) de un archivo de configuración. Si también se especifica la codificación del contenido por el cliente, se reemplaza la configuración predeterminada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se asigna un valor que representa la descripción de la codificación de HTTP actual a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentLength : int" Usage="System.Web.HttpRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica la longitud del contenido enviado por el cliente, en bytes.</summary>
        <value>Longitud, en bytes, del contenido enviado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna el valor que representa la longitud del contenido de la solicitud entrante a una variable entera.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de contenido MIME de la solicitud entrante.</summary>
        <value>Una cadena que representa el tipo de contenido MIME de la solicitud entrante, por ejemplo "text/html". Otros tipos MIME comunes son "audio.wav", "image/gif" y "application/pdf".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna el valor que representa el tipo de contenido de la solicitud entrante a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 El ejemplo siguiente muestra el resultado que se puede producir este código.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpRequest.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de cookies enviada por el cliente.</summary>
        <value>Objeto <see cref="T:System.Web.HttpCookieCollection" /> que representa las variables de cookies del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET incluye dos colecciones de cookies intrínseca. La colección que tiene acceso a través del <xref:System.Web.HttpRequest.Cookies%2A> colección de <xref:System.Web.HttpRequest> contiene cookies transmitidas por el cliente al servidor en el `Cookie` encabezado. La colección que tiene acceso a través del <xref:System.Web.HttpResponse.Cookies%2A> colección de <xref:System.Web.HttpResponse> contiene nuevas cookies creadas en el servidor y transmite al cliente en el `Set-Cookie` encabezado.  
  
> [!NOTE]
>  Después de agregar una cookie utilizando la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> colección, la cookie está inmediatamente disponible en el <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> colección, incluso si no se ha enviado la respuesta al cliente.  
  
   
  
## Examples  
 El ejemplo de código siguiente recorre en bucle todas las cookies enviadas por el cliente y envía el nombre, fecha de expiración, el parámetro de seguridad y los valores de cada cookie a la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePath : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> Devuelve la ruta de acceso al controlador de la página actualmente en ejecución. Para escenarios de redirección con <xref:System.Web.HttpServerUtility.Execute%2A> y <xref:System.Web.HttpServerUtility.Transfer%2A> métodos Esto significa que el <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad devuelve la ruta de acceso a la página redirigida (página secundaria). Sin embargo, cuando el cliente se redirige a otra página, el <xref:System.Web.HttpRequest.FilePath%2A> propiedad devuelve la ruta de acceso a la página original.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentExecutionFilePathExtension : string" Usage="System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la extensión del nombre de archivo que se especifica en la propiedad <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</summary>
        <value>Extensión del nombre de archivo que se especifica en la propiedad <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Web.HttpRequest.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.FilePath%2A> propiedad no incluye el <xref:System.Web.HttpRequest.PathInfo%2A> finalizador. Por ejemplo, para la dirección URL http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.FilePath%2A> valor es/virdir/page.HTML.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.FilePath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Files : System.Web.HttpFileCollection" Usage="System.Web.HttpRequest.Files" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de archivos cargada por el cliente, en formato MIME de varias partes.</summary>
        <value>Objeto <see cref="T:System.Web.HttpFileCollection" /> que representa una colección de archivos cargados por el cliente. Los elementos del objeto <see cref="T:System.Web.HttpFileCollection" /> son del tipo <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección de archivos se rellena únicamente cuando la solicitud HTTP `Content-Type` valor es "multipart/form-data".  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los nombres de todos los archivos en el <xref:System.Web.HttpRequest.Files%2A> colección.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpRequest.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el filtro que se utilizará al leer el flujo de entrada actual.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que se va a usar como filtro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente crea dos nuevas clases `QQQ1` y `QQQ2` ese filtro el <xref:System.Web.HttpRequest.InputStream%2A>. Coloque las clases en el archivo Global.asax en el directorio de la aplicación de ASP.NET para que se van a filtrar todas las entradas de todas las páginas Web ASP.NET en la aplicación.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El valor de <see cref="T:System.IO.Stream" /> especificado no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Form : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de variables de formulario.</summary>
        <value>Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> que representa una colección de variables de formulario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.Form%2A> propiedad se rellena cuando la solicitud HTTP `Content-Type` valor es "application/x--www-form-urlencoded" o "multipart/form-data".  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo se leen los valores de la colección de formulario enviada desde un explorador. Cada par nombre/valor de la colección representa un control en el formulario y su valor.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferedInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferedInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es idéntico a <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> salvo que también copia los bytes que se leen en el almacenamiento interno que ASP.NET utiliza para rellenar el <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Files%2A>, y <xref:System.Web.HttpRequest.InputStream%2A> propiedades. Dado que esta información se conserva, el código de nivel inferior, como las páginas de formularios ASP.NET Web Forms (archivos .aspx), se ejecutará correctamente. Esto no sucede así con el método <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes: 
-   La propiedad <see cref="P:System.Web.HttpRequest.Form" />.  
  
-   La propiedad <see cref="P:System.Web.HttpRequest.Files" />.  
  
-   La propiedad <see cref="P:System.Web.HttpRequest.InputStream" />.  
  
-   El método <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" />.  
  
Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : unit -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una alternativa al uso de la <xref:System.Web.HttpRequest.InputStream%2A> propiedad. El <xref:System.Web.HttpRequest.InputStream%2A> propiedad espera hasta que se ha recibido la solicitud antes de devolver un <xref:System.IO.Stream> objeto. En cambio, el <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> método devuelve el <xref:System.IO.Stream> objeto inmediatamente. Puede usar el método para comenzar a procesar el cuerpo de la entidad antes de que el contenido completo del organismo se recibieron.  
  
 El cuerpo de entidad (o como parte del mismo que se solicite y se ha recibido) se devuelve solo cuando se usa el objeto devuelto por este método para leer la secuencia, mediante una llamada a métodos, como el <xref:System.IO.Stream.Read%2A> método. Usar parámetros de la <xref:System.IO.Stream.Read%2A> método para especificar cuánto para leer el cuerpo de entidad.  
  
 La <xref:System.IO.Stream> objeto devuelto por ASP.NET de este método es compatible con métodos de lectura sincrónicos y asincrónicos. El <xref:System.IO.Stream> objeto implementa tanto la <xref:System.IO.Stream.BeginRead%2A> y <xref:System.IO.Stream.EndRead%2A> métodos. Los métodos asincrónicos le permiten leer de forma asincrónica la entidad de solicitud en fragmentos, mientras que ASP.NET libera el subproceso actual entre cada iteración de un bucle de lectura asincrónico.  
  
 Este método puede ser útil si la solicitud está cargando un archivo grande y desea comenzar a tener acceso al contenido de archivo antes de que finalice la carga. Sin embargo, solo debe usar este método para escenarios donde desea ocupe todo el procesamiento del cuerpo de entidad. Esto significa que no se puede usar este método desde una página .aspx, porque en el momento en que se ejecuta una página .aspx, ya se ha leído el cuerpo de entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes: 
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberSignature Language="F#" Value="member this.GetBufferlessInputStream : bool -&gt; System.IO.Stream" Usage="httpRequest.GetBufferlessInputStream disableMaxRequestLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength"><see langword="true" /> para deshabilitar el límite de longitud de la solicitud; en caso contrario, <see langword="false" />.</param>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP entrante y deshabilita opcionalmente el límite de longitud de la solicitud que se establece en la propiedad <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" />.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de este método, consulte el <xref:System.Web.HttpRequest.GetBufferlessInputStream> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes: 
-   La propiedad <see cref="P:System.Web.HttpRequest.Form" />.  
  
-   La propiedad <see cref="P:System.Web.HttpRequest.Files" />.  
  
-   La propiedad <see cref="P:System.Web.HttpRequest.InputStream" />.  
  
-   El método <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />.  
  
Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de encabezados HTTP.</summary>
        <value><see cref="T:System.Collections.Specialized.NameValueCollection" /> de encabezados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de todos los encabezados posibles, consulte [campos de encabezado de solicitud](https://go.microsoft.com/fwlink/?LinkId=73147) en el sitio Web de W3C.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los nombres y valores de todos los encabezados en la solicitud HTTP.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpChannelBinding : System.Security.Authentication.ExtendedProtection.ChannelBinding" Usage="System.Web.HttpRequest.HttpChannelBinding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> de la instancia de <see cref="T:System.Web.HttpWorkerRequest" /> actual.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> de la instancia de <see cref="T:System.Web.HttpWorkerRequest" /> actual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">El objeto <see cref="T:System.Web.HttpWorkerRequest" /> actual no es un objeto <see langword="System.Web.Hosting.IIS7WorkerRequest" /> ni <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HttpMethod : string" Usage="System.Web.HttpRequest.HttpMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el método de transferencia de datos HTTP (como <see langword="GET" />, <see langword="POST" /> o <see langword="HEAD" />) que usa el cliente.</summary>
        <value>Método de transferencia de datos HTTP usado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.HttpMethod%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 El ejemplo siguiente muestra la salida generada por este código.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputStream : System.IO.Stream" Usage="System.Web.HttpRequest.InputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contenido del cuerpo de la entidad HTTP entrante.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que representa el contenido del cuerpo de contenido HTTP entrante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se copia el contenido de un <xref:System.Web.HttpRequest.InputStream%2A> en una cadena.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona un contenedor administrado para el método de IIS que inserta el cuerpo de una entidad de solicitud HTTP en la memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A> sobrecargas del método proporcionan acceso administrado a las 7 de IIS `IHttpRequest::InsertEntityBody` método. El método de IIS, inserta un cuerpo de entidad de solicitud HTTP (es decir, los datos que se registran un cliente) en la memoria. Esto es útil porque IIS no mantiene una copia de la entidad de solicitud después de que se ha leído. El <xref:System.Web.HttpRequest.InsertEntityBody%2A> métodos crean una copia de los datos de entidad de solicitud HTTP y ponerlo a disposición de IIS para el control personalizado adicional.  
  
> [!NOTE]
>  El <xref:System.Web.HttpRequest.InsertEntityBody%2A> sobrecargas del método funcionan únicamente en IIS 7.0 o posterior, porque el `IHttpRequest::InsertEntityBody` método se agregó en IIS 7.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : unit -&gt; unit" Usage="httpRequest.InsertEntityBody " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona a IIS una copia del cuerpo de la entidad de solicitud HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS no mantiene una copia de la solicitud después de que se ha leído. Por lo tanto, se recomienda que solo el controlador para una solicitud HTTP debe leer la entidad de solicitud.  
  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> sobrecarga del método proporciona a IIS una copia de la entidad de solicitud si previamente se obtuvo por ASP.NET. Esta sobrecarga del método es útil para los casos donde ASP.NET ha leído la solicitud de la entidad y desea volver a usar los datos de solicitud existente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">El método se invocó en una versión de IIS anterior a IIS 7.0.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">para trabajar en un entorno hospedado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.InsertEntityBody : byte[] * int * int -&gt; unit" Usage="httpRequest.InsertEntityBody (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz que contiene los datos de la entidad de solicitud.</param>
        <param name="offset">Posición de base cero en <paramref name="buffer" /> donde se comienzan a almacenar los datos de la entidad de solicitud.</param>
        <param name="count">Número de bytes que se van a leer en la matriz <paramref name="buffer" />.</param>
        <summary>Proporciona a IIS una copia del cuerpo de la entidad de solicitud HTTP e información sobre el objeto entidad de solicitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS no mantiene una copia de la solicitud después de que se ha leído. Por lo tanto, se recomienda que solo el controlador para una solicitud HTTP debe leer la entidad de solicitud.  
  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> sobrecarga del método es útil cuando desea realizar el procesamiento personalizado, como la inserción de un cuerpo de entidad diferente en la memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">El método se invocó en una versión de IIS anterior a IIS 7.0.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El valor de <paramref name="offset" /> o <paramref name="count" /> es negativo.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="count" /> es mayor que el espacio disponible en <paramref name="buffer" />, especificado el valor <paramref name="offset" />.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">para trabajar en un entorno hospedado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Web.HttpRequest.IsAuthenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud se autenticó.</summary>
        <value><see langword="true" /> si se ha autenticado la solicitud; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpRequest.IsAuthenticated%2A> propiedad para determinar si se ha autenticado la solicitud actual. Si no se ha autenticado, la solicitud se redirige a otra página donde los usuarios pueden escribir sus credenciales en la aplicación Web. Se trata de una técnica común que se utiliza en la página predeterminada para una aplicación.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLocal : bool" Usage="System.Web.HttpRequest.IsLocal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud es del equipo local.</summary>
        <value>Es <see langword="true" /> si la solicitud procede del equipo local; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.IsLocal%2A> propiedad devuelve `true` si la dirección IP del autor de la solicitud es 127.0.0.1 o si la dirección IP de la solicitud es el mismo que la dirección IP del servidor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecureConnection : bool" Usage="System.Web.HttpRequest.IsSecureConnection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la conexión HTTP usa sockets seguros, es decir, HTTPS.</summary>
        <value><see langword="true" /> si la conexión es una conexión SSL; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente determina si el <xref:System.Web.HttpRequest.IsSecureConnection%2A> propiedad está establecida en false. Si es así, el <xref:System.Web.HttpResponse.SuppressContent%2A> propiedad está establecida en true para detener el envío de la respuesta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Web.HttpRequest.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Nombre del miembro de colección que se va a obtener.</param>
        <summary>Obtiene el objeto especificado de las colecciones <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> o <see cref="P:System.Web.HttpRequest.ServerVariables" /></summary>
        <value>Miembro de la colección <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> o <see cref="P:System.Web.HttpRequest.ServerVariables" /> especificado en el parámetro <paramref name="key" />. Si no se encuentra el objeto <paramref name="key" /> especificado, se devuelve <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogonUserIdentity : System.Security.Principal.WindowsIdentity" Usage="System.Web.HttpRequest.LogonUserIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo <see cref="T:System.Security.Principal.WindowsIdentity" /> del usuario actual.</summary>
        <value>Objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> que corresponde a la configuración de autenticación actual de Microsoft Internet Information Services (IIS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.LogonUserIdentity%2A> propiedad expone las propiedades y métodos de la <xref:System.Security.Principal.WindowsIdentity> objeto para el usuario actualmente conectado a Microsoft Internet Information Services (IIS). La instancia de la <xref:System.Security.Principal.WindowsIdentity> clase que se expone mediante <xref:System.Web.HttpRequest.LogonUserIdentity%2A> realiza un seguimiento el token de solicitud IIS y proporciona fácil acceso a este token para la solicitud HTTP actual está procesando dentro de ASP.NET. Una instancia de la <xref:System.Security.Principal.WindowsIdentity> automáticamente se crea la clase por lo que no necesita crearse a con el fin de obtener acceso a sus métodos y propiedades.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo recuperar el <xref:System.Web.HttpRequest.LogonUserIdentity%2A> propiedad para el usuario actual y la escritura de los valores de cada elemento en un archivo de texto. Coloque este código en la página ASP.NET al que hace referencia el formulario `ACTION` atributo.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La aplicación web se está ejecutando en modo integrado de IIS 7 y todavía no se ha provocado el evento <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapImageCoordinates : string -&gt; int[]" Usage="httpRequest.MapImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nombre de la asignación de imágenes del formulario.</param>
        <summary>Asigna un parámetro de formulario entrante de campo de imagen a los valores de coordenada X y coordenada Y adecuados.</summary>
        <returns>Matriz bidimensional de enteros.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asigna la ruta de acceso virtual de la dirección URL solicitada a una ruta de acceso física del servidor, correspondiente a la solicitud actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string -&gt; string" Usage="httpRequest.MapPath virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual (absoluta o relativa) de la solicitud actual.</param>
        <summary>Asigna la ruta de acceso virtual especificada a una ruta de acceso física.</summary>
        <returns>Ruta de acceso física del servidor especificado por <paramref name="virtualPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  El <xref:System.Web.HttpRequest.MapPath%2A> propiedad puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpRequest.MapPath%2A> método para convertir una ruta de acceso virtual en una ruta de acceso física completa en el servidor. En este ejemplo tiene dos partes:  
  
-   Una página .aspx asigna la ruta de acceso, lee el archivo y muestra los resultados de la operación de lectura.  
  
-   Una clase, `UpperCaseFilterStream`, que cambia todos los caracteres que se pasa a mayúsculas.  
  
 La primera parte del ejemplo muestra cómo convertir una ruta de acceso virtual a una ruta de acceso física completa mediante el <xref:System.Web.HttpRequest.MapPath%2A> método. Esta ruta de acceso física, a continuación, se pasa a un <xref:System.IO.StreamReader> objeto, que obtiene el contenido del archivo. El <xref:System.Web.HttpResponse.Write%2A> , a continuación, se llama el método para mostrar el contenido del archivo en la página. El <xref:System.Web.HttpResponse.Filter%2A> propiedad se utiliza para adjuntar un filtro a la secuencia de respuesta que hace que el texto que aparece a la página de todas las letras mayúsculas.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 La segunda parte del ejemplo muestra una clase que hereda de <xref:System.IO.Stream> y convierte todos los caracteres de una secuencia en mayúsculas. Coloque este código en el `App_Code` carpeta para su aplicación.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No hay objetos <see cref="T:System.Web.HttpContext" /> definidos para la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="F#" Value="member this.MapPath : string * string * bool -&gt; string" Usage="httpRequest.MapPath (virtualPath, baseVirtualDir, allowCrossAppMapping)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual (absoluta o relativa) de la solicitud actual.</param>
        <param name="baseVirtualDir">Ruta de acceso al directorio base virtual que se usa para una resolución relativa.</param>
        <param name="allowCrossAppMapping"><see langword="true" /> para indicar que <paramref name="virtualPath" /> puede pertenecer a otra aplicación; en caso contrario, <see langword="false" />.</param>
        <summary>Asigna la ruta de acceso virtual especificada a una ruta de acceso física.</summary>
        <returns>Ruta de acceso física del servidor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  El <xref:System.Web.HttpRequest.MapPath%2A> propiedad puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException"><paramref name="allowCrossMapping" /> es <see langword="false" /> y <paramref name="virtualPath" /> pertenece a otra aplicación.

O bien 
No hay objetos <see cref="T:System.Web.HttpContext" /> definidos para la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberSignature Language="F#" Value="member this.MapRawImageCoordinates : string -&gt; double[]" Usage="httpRequest.MapRawImageCoordinates imageFieldName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nombre del campo de imagen.</param>
        <summary>Asigna un parámetro de formulario entrante de campo de imagen a los valores de coordenadas X e Y adecuados.</summary>
        <returns>Valores de coordenadas X e Y.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Params : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.Params" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección combinada de elementos <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> y <see cref="P:System.Web.HttpRequest.ServerVariables" />.</summary>
        <value>Un objeto <see cref="T:System.Collections.Specialized.NameValueCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pares nombre-valor se agregan a la colección en el orden siguiente:  
  
1.  Parámetros de cadena de consulta.  
  
2.  Campos de formulario.  
  
3.  Cookies.  
  
4.  Variables de servidor.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo recorrer el <xref:System.Web.HttpRequest.Params%2A> propiedad para una página y cómo se mostrará cada par clave/valor.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Path : string" Usage="System.Web.HttpRequest.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.Path%2A> es la concatenación de la <xref:System.Web.HttpRequest.FilePath%2A> y <xref:System.Web.HttpRequest.PathInfo%2A> finalizador. Por ejemplo, para la dirección URL http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.Path%2A> es /virdir/page.html/tail.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.Path%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PathInfo : string" Usage="System.Web.HttpRequest.PathInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información adicional de la ruta de acceso de un recurso con extensión de dirección URL.</summary>
        <value>Información adicional de la ruta de acceso de un recurso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para la dirección URL Http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.PathInfo%2A> valor es/tail.  
  
   
  
## Examples  
 El ejemplo de código siguiente determina si el <xref:System.Web.HttpRequest.PathInfo%2A> propiedad contiene una cadena vacía. Si es así, el <xref:System.IO.StreamWriter.Write%2A> método escribe una cadena que indica esto en un archivo. Si no, el <xref:System.Web.HttpUtility.HtmlEncode%2A> método codifica en HTML el valor de la <xref:System.Web.HttpRequest.PathInfo%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método escribe el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalApplicationPath : string" Usage="System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso al sistema de archivos físico del directorio raíz de la aplicación de servidor que se está ejecutando.</summary>
        <value>Ruta de acceso al sistema de archivos del directorio raíz de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalPath : string" Usage="System.Web.HttpRequest.PhysicalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso al sistema de archivos físico correspondiente a la dirección URL solicitada.</summary>
        <value>Ruta de acceso al sistema de archivos de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En escenarios de redirección con <xref:System.Web.HttpServerUtility.Execute%2A> y <xref:System.Web.HttpServerUtility.Transfer%2A>, el <xref:System.Web.HttpRequest.PhysicalPath%2A> propiedad devuelve la ruta de acceso a la página original. Para buscar la ruta de acceso física de la utilización de la página está ejecutando actualmente el <xref:System.Web.HttpRequest.MapPath%2A> método con el argumento de entrada se establece como el <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.PhysicalPath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.QueryString : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.QueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de variables de tipo cadena de consulta HTTP.</summary>
        <value>Variables de cadena de consulta enviadas por el cliente. Las claves y los valores son de descodificación de URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente muestra dos maneras de obtener el valor de una variable de cadena de consulta denominada "fullname". En cada caso, si la dirección URL es `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, a continuación, el valor devuelto es "Delia Fakhouri" porque el `%20` es la dirección URL descodificada en un carácter de espacio. Si la dirección URL no tiene un `fullname` Id. de cadena de consulta, el valor devuelto sería `null`.  
  
 La primera línea de código busca la clave "fullname" solo en la cadena de consulta; la segunda línea busca la clave "fullname" en todas las colecciones de la solicitud HTTP. Para obtener más información acerca de la segunda línea, consulte <xref:System.Web.HttpRequest.Item%2A>.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawUrl : string" Usage="System.Web.HttpRequest.RawUrl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección URL sin procesar de la solicitud actual.</summary>
        <value>Dirección URL sin procesar de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dirección URL sin procesar se define como parte de la dirección URL siguiendo la información de dominio. En la cadena de dirección URL http://www.contoso.com/articles/recent.aspx, la dirección URL original es/articles/recent.aspx. Dirección URL original incluye la cadena de consulta, si está presente.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.RawUrl%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadEntityBodyMode : System.Web.ReadEntityBodyMode" Usage="System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se leyó el cuerpo de la entidad de la solicitud y, si es así, cómo se leyó.</summary>
        <value>Valor que indica cómo se leyó el cuerpo de la entidad de la solicitud o que no se leyó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para evitar la excepción que se produce si ya se ha leído el cuerpo de entidad y se realiza un intento para leerlo mediante un método compatible. Métodos y propiedades que leer el cuerpo de entidad incluyen lo siguiente:  
  
-   Propiedad <xref:System.Web.HttpRequest.Form%2A>  
  
-   Propiedad <xref:System.Web.HttpRequest.Files%2A>  
  
-   Propiedad <xref:System.Web.HttpRequest.InputStream%2A>  
  
-   El método <xref:System.Web.HttpRequest.GetBufferedInputStream%2A> .  
  
-   El método <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestContext : System.Web.Routing.RequestContext with get, set" Usage="System.Web.HttpRequest.RequestContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia de <see cref="T:System.Web.Routing.RequestContext" /> de la solicitud actual.</summary>
        <value>Instancia de <see cref="T:System.Web.Routing.RequestContext" /> de la solicitud actual. En el caso de solicitudes no enrutadas, el objeto <see cref="T:System.Web.Routing.RequestContext" /> que se devuelve está vacío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso a la <xref:System.Web.Routing.RouteData> objeto de la solicitud actual. Para obtener más información sobre el enrutamiento de ASP.NET, vea. [Enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Tutorial: Uso de enrutamiento en una aplicación de Web Forms de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/dc88e6ba-470c-4b20-b644-35874cfd781d">Procedimiento Parámetros de dirección URL de acceso en una página enrutada</related>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RequestType : string with get, set" Usage="System.Web.HttpRequest.RequestType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el método de transferencia de datos HTTP (<see langword="GET" /> o <see langword="POST" />) que usa el cliente.</summary>
        <value>Cadena que representa el tipo de invocación HTTP enviado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.RequestType%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberSignature Language="F#" Value="member this.SaveAs : string * bool -&gt; unit" Usage="httpRequest.SaveAs (filename, includeHeaders)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Ruta de acceso física a la unidad.</param>
        <param name="includeHeaders">Valor booleano que especifica si se debe guardar en el disco un encabezado HTTP.</param>
        <summary>Guarda una solicitud HTTP en el disco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Guardar el contexto de solicitud en el disco puede ser útil para depurar.  
  
   
  
## Examples  
 El siguiente ejemplo de código llama el <xref:System.Web.HttpRequest.SaveAs%2A> método cuando se carga una página. La llamada especifica que la solicitud se guarda como un archivo de texto en un directorio donde la identidad del proceso ASP.NET tiene concedida permisos de escritura, y que cualquier información de encabezado incluido en la solicitud está incluida en el archivo.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propiedad <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> de <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> está establecida en <see langword="true" />, pero <paramref name="filename" /> no es una ruta de acceso absoluta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ServerVariables : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpRequest.ServerVariables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de variables de servidor web.</summary>
        <value>Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> de variables de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de variables de servidor compatibles con IIS, consulte [Variables de servidor IIS](https://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra los nombres y valores de todas las variables de servidor con nombre.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.TimedOutToken : System.Threading.CancellationToken" Usage="System.Web.HttpRequest.TimedOutToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Threading.CancellationToken" /> que se desencadena cuando una solicitud consume el tiempo de espera.</summary>
        <value>Token de cancelación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El período de tiempo de espera puede especificarse en el archivo Web.config (consulte <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) o mediante programación (consulte <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>). El período de tiempo de espera se mide desde el momento en que la solicitud entra en juego. Si el tiempo de espera predeterminado de 110 segundos está en vigor, no sea anterior a 110 segundos después de que comience el procesamiento de la solicitud se se desencadena el token de cancelación. Puede cambiar el <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> valor de propiedad, y como long este token no se ha recorrido aún, se respetan el nuevo valor de tiempo de espera.  
  
 Actualmente, el token solo proporciona 15 segundos, lo que significa que si el valor de tiempo de espera es de 110 segundos, el token se se desencadena cualquiera entre 125 y 110 segundos después de que comience el procesamiento de la solicitud. La granularidad se puede cambiar en el futuro.  
  
 Aunque esta propiedad es segura para subprocesos, hay restricciones sobre su uso. Para obtener más información, vea <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Esta propiedad no tiene sentida si se ha iniciado el procesamiento de la solicitud de WebSockets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TlsTokenBindingInfo : System.Web.ITlsTokenBindingInfo" Usage="System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información de enlace del token TLS. La propiedad permite que las aplicaciones recuperen información del token de las solicitudes HTTP entrantes para usar autenticación mejorada.</summary>
        <value>Token de enlace de la conexión actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `null` en plataformas que no sean windows10.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalBytes : int" Usage="System.Web.HttpRequest.TotalBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes del flujo de entrada actual.</summary>
        <value>Número de bytes del flujo de entrada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo de código siguiente determina si el <xref:System.Web.HttpRequest.TotalBytes%2A> valor de propiedad es mayor que 1000 bytes y escribe esa información en un archivo.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Unvalidated : System.Web.UnvalidatedRequestValues" Usage="System.Web.HttpRequest.Unvalidated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los valores de solicitud HTTP sin que se desencadene la validación de solicitudes.</summary>
        <value>Valores de solicitud HTTP que no se comprobaron con la validación de solicitudes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solicitar comprobaciones de validación para marcado HTML y secuencias de comandos que podrían indicar un posible ataque de scripting entre sitios. De forma predeterminada, todos los valores se comprueban con la validación de solicitud y si los valores contienen marcado o el script, ASP.NET genera un <xref:System.Web.HttpRequestValidationException> excepción. Utilice este método si prevé que la solicitud contendrá marcado (por ejemplo, permitiendo a los usuarios enviar contenido que contiene el marcado) y desea obtener el valor de una solicitud sin procesar.  
  
> [!IMPORTANT]
>  Si utiliza esta propiedad, debe comprobar manualmente los datos de posibles ataques de scripting entre sitios.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Web.HttpRequest.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre la dirección URL de la solicitud actual.</summary>
        <value>Objeto <see cref="T:System.Uri" /> que contiene la dirección URL de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo, se asigna el <xref:System.Uri> objeto de la solicitud actual a una variable de objeto y muestra el valor de dos propiedades de la dirección URL del objeto en la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UrlReferrer : Uri" Usage="System.Web.HttpRequest.UrlReferrer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre la dirección URL de la solicitud anterior del cliente que establecía un vínculo con la dirección URL actual.</summary>
        <value>Un objeto <see cref="T:System.Uri" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de dos propiedades de la dirección URL que remitió al cliente a la aplicación actual.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">El encabezado de la solicitud HTTP <see langword="Referer" /> es incorrecto y no se puede convertir en un objeto <see cref="T:System.Uri" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAgent : string" Usage="System.Web.HttpRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena de agente de usuario no procesada del explorador del cliente que se ha proporcionado. Tenga en cuenta que su valor puede ser null.</summary>
        <value>Cadena de agente de usuario no procesada del explorador del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna la identificación del tipo de explorador que realiza la solicitud a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
        <related type="Article" href="https://msdn.microsoft.com/library/143d14d6-9d12-4d4b-ae60-f00e0eb6938f">Controles de servidor ASP.NET y las capacidades del explorador</related>
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostAddress : string" Usage="System.Web.HttpRequest.UserHostAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección IP del host del cliente remoto.</summary>
        <value>Dirección IP del cliente remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.UserHostAddress%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserHostName : string" Usage="System.Web.HttpRequest.UserHostName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre DNS del cliente remoto.</summary>
        <value>Nombre DNS del cliente remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.UserHostName%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserLanguages : string[]" Usage="System.Web.HttpRequest.UserLanguages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de cadenas ordenada con las preferencias de idioma del cliente.</summary>
        <value>Matriz de cadenas ordenada con las preferencias de idioma del cliente, o <see langword="null" /> si está vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se captura los diversos valores devueltos por la <xref:System.Web.HttpRequest.UserLanguages%2A> propiedad en una matriz de cadenas y escribe el nombre de cada idioma en una línea distinta de la salida HTTP.  
  
 Los nombres de lenguaje son proporcionados por el explorador y no hay ninguna lista definitiva de todos los posibles códigos.  Normalmente, estos elementos consisten un códigos de dos caracteres para el lenguaje, un guión y un código de dos caracteres para la referencia cultural, como "en-us" para EE. UU. El inglés y "fr-ca" para francés canadiense.  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberSignature Language="F#" Value="member this.ValidateInput : unit -&gt; unit" Usage="httpRequest.ValidateInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que se produzca la validación en las colecciones a las que se obtuvo acceso a través de las propiedades <see cref="P:System.Web.HttpRequest.Cookies" />, <see cref="P:System.Web.HttpRequest.Form" /> y <see cref="P:System.Web.HttpRequest.QueryString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest> clase utiliza marcas de validación de entrada para realizar un seguimiento de si se debe realizar la validación en las colecciones de solicitud tiene acceso a través del <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, y <xref:System.Web.HttpRequest.QueryString%2A> propiedades. El <xref:System.Web.HttpRequest.ValidateInput%2A> método establece estos marcadores de modo que, cuando los descriptores de acceso get el <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, o <xref:System.Web.HttpRequest.QueryString%2A> se invoca la propiedad, se realiza la validación de entrada. Validación funciona mediante la comprobación de todos los datos de entrada con una lista codificada de forma rígida de datos potencialmente peligrosos.  
  
 Si está habilitada la característica de validación mediante la directiva de página o la configuración, se llama a este método durante la página `ProcessRequest` fase del proceso. El <xref:System.Web.HttpRequest.ValidateInput%2A> método puede llamarse mediante su código si no está habilitada la característica de validación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Se recibieron datos potencialmente peligrosos del cliente.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>