<Type Name="HttpRequest" FullName="System.Web.HttpRequest">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48982b0cd7a40f21c7ebc1535d74a9dc862f068e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610629" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpRequest" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpRequest extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpRequest" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpRequest" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpRequest sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Permite a ASP.NET leer los valores HTTP enviados por un cliente durante una solicitud web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos y propiedades de la <xref:System.Web.HttpRequest> clase se exponen a través de la `Request` propiedades de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 Para obtener acceso a datos desde el <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, o <xref:System.Web.HttpRequest.ServerVariables%2A> colecciones, puede escribir `Request["key"]`, tal y como se muestra en el ejemplo de la <xref:System.Web.HttpRequest.QueryString%2A> propiedad.  
  
> [!NOTE]
>  Compatibilidad con Unicode <xref:System.Web.HttpRequest> miembros de clase requiere IIS versión 6.0 o posterior.  
  
   
  
## Examples  
 El siguiente acceso de ejemplos el <xref:System.Web.HttpRequest> instancia para la solicitud actual mediante el uso de la <xref:System.Web.UI.Page.Request%2A> propiedad de la <xref:System.Web.UI.Page> clase.  
  
 Puede usar una sintaxis simplificada para tener acceso a datos de la <xref:System.Web.HttpRequest.QueryString%2A>, <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Cookies%2A>, o <xref:System.Web.HttpRequest.ServerVariables%2A> colecciones. Puede escribir `Request["key"]`.  
  
 El primer ejemplo muestra cómo recuperar un valor de cadena de consulta cuando se carga una página.  
  
```csharp  
public partial class AddToCart : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        string rawId = Request["ProductID"];  
        int productId;  
        if (!String.IsNullOrEmpty(rawId) && int.TryParse(rawId, out productId))  
        {  
            using (ShoppingCartActions usersShoppingCart = new ShoppingCartActions())  
            {  
                usersShoppingCart.AddToCart(productId);  
            }  
        }  
        else  
        {  
            throw new Exception("Tried to call AddToCart.aspx without setting a ProductId.");  
        }  
        Response.Redirect("ShoppingCart.aspx");  
    }  
}  
```  
  
```vb  
Public Class AddToCart  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        Dim rawId = Request("ProductID")  
        Dim productId As Integer  
        If Not String.IsNullOrEmpty(rawId) And Integer.TryParse(rawId, productId) Then  
            Using usersShoppingCart As New ShoppingCartActions()  
                usersShoppingCart.AddToCart(productId)  
            End Using  
  
        Else  
            Throw New Exception("Tried to call AddToCart.aspx without setting a ProductId.")  
        End If  
        Response.Redirect("ShoppingCart.aspx")  
    End Sub  
End Class  
```  
  
 En el ejemplo siguiente se muestra cómo comprobar si la solicitud está autenticada y recuperar la dirección URL sin procesar.  
  
```csharp  
public partial class RestrictedPage : Page  
{  
    protected void Page_Load(object sender, EventArgs e)  
    {  
        if (!Request.IsAuthenticated)  
        {  
            var rawUrl = Request.RawUrl;  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl));  
        }  
    }  
}  
```  
  
```vb  
Public Class RestrictedPage  
    Inherits Page  
  
    Protected Sub Page_Load(ByVal sender As Object, ByVal e As EventArgs) Handles Me.Load  
        If Not Request.IsAuthenticated Then  
            Dim rawUrl = Request.RawUrl  
            Response.Redirect("/Account/Login?ru=" + Server.HtmlEncode(rawUrl))  
        End If  
    End Sub  
End Class  
```  
  
 Un proyecto de sitio Web de Visual Studio con código fuente está disponible como acompañamiento de este tema: [descargar](http://go.microsoft.com/fwlink/?LinkID=191455).  
  
 Este ejemplo se utiliza la <xref:System.IO.StreamWriter> clase para escribir los valores de varias <xref:System.Web.HttpRequest> propiedades a un archivo de la clase. Para las propiedades que son del tipo cadena, los valores son HTML codificado como se escriben en el archivo. Las propiedades que representan una colección se recorren, y cada par de clave/valor que contienen se escribe en el archivo.  
  
> [!IMPORTANT]
>  Este ejemplo tiene un cuadro de texto que acepta datos proporcionados por el usuario, lo que puede suponer una amenaza para la seguridad. De forma predeterminada, ASP.NET Web Pages valida que los datos proporcionados por el usuario no incluyen elementos HTML ni de script. Para más información, consulte [Información general sobre los ataques mediante scripts](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpRequest (string filename, string url, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filename, string url, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filename As String, url As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpRequest(System::String ^ filename, System::String ^ url, System::String ^ queryString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo asociado a la solicitud.</param>
        <param name="url">Información acerca de la dirección URL de la solicitud actual.</param>
        <param name="queryString">Cadena de consulta completa enviada con la solicitud (todo lo que va después de <c>'?'</c>).</param>
        <summary>Inicializa un objeto <see cref="T:System.Web.HttpRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No es necesario crear su propia instancia de la <xref:System.Web.HttpRequest> clase. Los métodos y propiedades de la <xref:System.Web.HttpRequest> clase se exponen a través de la `Request` propiedad de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Termina de manera forzosa la conexión TCP subyacente, lo que provoca el error de cualquier E/S pendiente. Podría usar este método en respuesta a un ataque de un cliente HTTP malintencionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es seguro para subprocesos. Cualquier subproceso puede llamar a él en cualquier momento.  
  
 Este método solo se puede utilizar en el modo integrado. Si se invoca en modo clásico, se produce una excepción. Para determinar el modo de canalización, utilice <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptTypes">
      <MemberSignature Language="C#" Value="public string[] AcceptTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AcceptTypes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AcceptTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AcceptTypes As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AcceptTypes { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de cadenas de tipos accept MIME admitidos por el cliente.</summary>
        <value>Matriz de cadenas de tipos accept MIME admitidos por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se captura los diversos valores devueltos por la <xref:System.Web.HttpRequest.AcceptTypes%2A> propiedad en una variable de objeto y escribe el número y el nombre de cada valor de una línea independiente de la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.AcceptTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.AcceptTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AnonymousID">
      <MemberSignature Language="C#" Value="public string AnonymousID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AnonymousID" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AnonymousID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AnonymousID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AnonymousID { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el identificador anónimo del usuario, si lo hay.</summary>
        <value>Cadena que representa el identificador anónimo de usuario actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad asigna un identificador único de larga duración a un usuario no autenticado, que se puede usar para realizar un seguimiento del usuario o asignar propiedades de perfil para ese usuario sin almacenar los datos en un `Session` objeto. De forma predeterminada, el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad se realiza un seguimiento con una cookie, pero puede establecerse para usar el identificador URI cuando el <xref:System.Web.Configuration.SessionStateSection.Cookieless%2A> atributo en la sección de configuración de identificación anónima está establecido en el <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.HttpCookieMode.UseDeviceProfile>, o <xref:System.Web.HttpCookieMode.AutoDetect> valor. Debe borrar la cookie explícitamente si ya no quiere que lo está disponible, por ejemplo cuando se autentica un usuario anónimo.  
  
 Identificación anónima se utiliza cuando es necesario para identificar entidades que no se autentican y cuando se necesita autorización. Para obtener más información, vea [anonymousIdentification Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/2bd927ef-9057-4703-9c55-4cfb6d7d0929)  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad controlando el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos en el archivo Global.asax. Este ejemplo tiene dos partes:  
  
-   Un método en el archivo Global.asax que controla el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos.  
  
-   Una página de formularios Web Forms.  
  
 La primera parte del ejemplo de código muestra cómo establecer el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad controlando el <xref:System.Web.Security.AnonymousIdentificationModule.Creating> eventos en el archivo Global.asax. El método que se denomina `AnonymousIdentification_Creating` establece el <xref:System.Web.HttpRequest.AnonymousID%2A> propiedad cuando se crea un identificador anónimo.  
  
 [!code-csharp[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/global_asax.cs#2)]
 [!code-vb[System.Web.HttpRequest_AnonymousID#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/global_asax.vb#2)]  
  
 La segunda parte del ejemplo de código muestra cómo mostrar el nuevo <xref:System.Web.HttpRequest.AnonymousID%2A> creado por el `AnonymousIdentification_Creating` controlador de eventos en el ejemplo anterior.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/CS/anonid_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_AnonymousID#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_AnonymousID/vb/anonid_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.IsAuthenticated" />
        <altmember cref="E:System.Web.Security.AnonymousIdentificationModule.Creating" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationPath">
      <MemberSignature Language="C#" Value="public string ApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso a la raíz virtual de la aplicación ASP.NET en el servidor.</summary>
        <value>Ruta de acceso virtual de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para construir una dirección URL relativa a la raíz de la aplicación desde una página o el control de usuario Web que no está en el directorio raíz. Esto permite que las páginas y los controles compartidos que existen en diferentes niveles de una estructura de directorios para usar el mismo código para establecer vínculos a recursos desde una ubicación fija en la aplicación.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.IO.StreamWriter.Write%2A> método para codificar en HTML y, a continuación, escribir el valor de la <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad a un archivo de texto. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase. Se supone la existencia de un <xref:System.IO.StreamWriter> objeto denominado `sw`.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad que se va a crear mediante programación una ruta de acceso a un recurso que se encuentra en una ubicación fija en la aplicación. La página que hace referencia al recurso no tiene que encontrarse en el mismo directorio que el recurso.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/ApplicationPath.aspx#2)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/ApplicationPath.aspx#2)]  
  
 Si ejecuta este ejemplo en una aplicación Web que se denomina WebSite1, `/WebSite1` se mostrará como el valor de la <xref:System.Web.HttpRequest.ApplicationPath%2A> propiedad y `/WebSite1/images/Image1.gif` se mostrará como la ruta de acceso completa de la imagen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeCurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string AppRelativeCurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AppRelativeCurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppRelativeCurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la raíz de la aplicación y la hace relativa mediante el uso de la notación de tilde (~) para la raíz de la aplicación (como en "~/page.aspx").</summary>
        <value>Ruta de acceso virtual de la raíz de la aplicación para la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice esta propiedad para proporcionar información de dirección URL que seguirá siendo la misma aunque la aplicación cambie de ubicación. Esto permite que el mismo código de asignación de dirección URL que se usarán en un entorno de prueba y en el entorno de implementación final, o que va a usar copias de las aplicaciones Web en dominios diferentes.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> propiedad para establecer la dirección URL de un <xref:System.Web.UI.WebControls.Image> control a una imagen en el mismo directorio que la página. Ejecute esta página en diferentes niveles de una estructura de directorios para ver los resultante <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> valores de propiedad.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/CS/AppRelativeCurrentExecutionPathCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.AppRelativeCurrentExecutionPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.AppRelativeCurrentExecutionPath/VB/AppRelativeCurrentExecutionPathVB.aspx#1)]  
  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpRequest.AppRelativeCurrentExecutionFilePath%2A> propiedad que se va a establecer la ruta de acceso mediante programación a un recurso, en función de la ruta de acceso actual de la página.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/CS/apprelativecurrentexecutionfilepath.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.ApplicationPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.ApplicationPath/VB/apprelativecurrentexecutionfilepath.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinaryRead">
      <MemberSignature Language="C#" Value="public byte[] BinaryRead (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] BinaryRead(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.BinaryRead(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinaryRead (count As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ BinaryRead(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Número de bytes que se va a leer.</param>
        <summary>Realiza una lectura binaria de un número de bytes especificado en el flujo de entrada actual.</summary>
        <returns>Matriz de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.BinaryRead%2A> método se proporciona por compatibilidad con ASP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> es 0.  
  
 \- o -  
  
 <paramref name="count" /> es mayor que el número de bytes disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="public System.Web.HttpBrowserCapabilities Browser { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Browser" />
      <MemberSignature Language="VB.NET" Value="Public Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); void set(System::Web::HttpBrowserCapabilities ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información acerca de las capacidades del explorador del cliente que realiza la solicitud.</summary>
        <value>Objeto <see cref="T:System.Web.HttpBrowserCapabilities" /> que enumera en una lista las capacidades del explorador del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se envía una lista de las capacidades del explorador al cliente en una página HTML.  
  
 [!code-csharp[Classic HttpRequest.Browser Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Browser Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Browser Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.UserAgent" />
      </Docs>
    </Member>
    <Member MemberName="ClientCertificate">
      <MemberSignature Language="C#" Value="public System.Web.HttpClientCertificate ClientCertificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpClientCertificate ClientCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ClientCertificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificate As HttpClientCertificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpClientCertificate ^ ClientCertificate { System::Web::HttpClientCertificate ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpClientCertificate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el certificado de seguridad del cliente para la solicitud actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpClientCertificate" /> que contiene información sobre la configuración del certificado de seguridad del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se envía la configuración del cliente certificado al cliente en una página HTML.  
  
 [!code-csharp[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ClientCertificate Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ClientCertificate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el juego de caracteres del cuerpo de la entidad.</summary>
        <value>Objeto <see cref="T:System.Text.Encoding" /> que representa el juego de caracteres del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de contenido predeterminada puede especificarse en el [globalización Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) de un archivo de configuración. Si también se especifica la codificación de contenido por el cliente, se reemplaza la configuración predeterminada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se asigna un valor que representa la descripción de la codificación de HTTP actual a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public int ContentLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ContentLength { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica la longitud del contenido enviado por el cliente, en bytes.</summary>
        <value>Longitud, en bytes, del contenido enviado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna el valor que representa la longitud del contenido de la solicitud entrante a una variable entera.  
  
 [!code-csharp[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentLength Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentLength Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo de contenido MIME de la solicitud entrante.</summary>
        <value>Una cadena que representa el tipo de contenido MIME de la solicitud entrante, por ejemplo "text/html". Otros tipos MIME comunes son "audio.wav", "image/gif" y "application/pdf".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna el valor que representa el tipo de contenido de la solicitud entrante a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.ContentType Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ContentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ContentType Example/VB/source.vb#1)]  
  
 En el ejemplo siguiente se muestra la salida que se puede producir por este código.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de cookies enviada por el cliente.</summary>
        <value>Objeto <see cref="T:System.Web.HttpCookieCollection" /> que representa las variables de cookies del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET incluye dos colecciones de cookies intrínseca. La colección que tiene acceso a través de la <xref:System.Web.HttpRequest.Cookies%2A> colección de <xref:System.Web.HttpRequest> contiene cookies transmitidas por el cliente al servidor en el `Cookie` encabezado. La colección que tiene acceso a través de la <xref:System.Web.HttpResponse.Cookies%2A> colección de <xref:System.Web.HttpResponse> contiene nuevas cookies creadas en el servidor y la transmite al cliente en el `Set-Cookie` encabezado.  
  
> [!NOTE]
>  Después de agregar una cookie mediante la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> colección, la cookie está inmediatamente disponible en la <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> colección, incluso si la respuesta no se ha enviado al cliente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se recorre en bucle todas las cookies enviadas por el cliente y envía el nombre, fecha de expiración, el parámetro de seguridad y los valores de cada cookie a la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePath">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> Devuelve la ruta de acceso al controlador de la página está ejecutando actualmente. En los escenarios de redirección con <xref:System.Web.HttpServerUtility.Execute%2A> y <xref:System.Web.HttpServerUtility.Transfer%2A> métodos Esto significa que el <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad devuelve la ruta de acceso a la página que se redirige a (página secundaria). Sin embargo, cuando el cliente se redirige a otra página, el <xref:System.Web.HttpRequest.FilePath%2A> propiedad devuelve la ruta de acceso a la página original.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="M:System.Web.HttpServerUtility.Execute(System.String)" />
        <altmember cref="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentExecutionFilePathExtension">
      <MemberSignature Language="C#" Value="public string CurrentExecutionFilePathExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CurrentExecutionFilePathExtension" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.CurrentExecutionFilePathExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentExecutionFilePathExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CurrentExecutionFilePathExtension { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la extensión del nombre de archivo que se especifica en la propiedad <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</summary>
        <value>Extensión del nombre de archivo que se especifica en la propiedad <see cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.FilePath%2A> propiedad no incluye el <xref:System.Web.HttpRequest.PathInfo%2A> finalizador. Por ejemplo, para la dirección URL http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.FilePath%2A> valor es/virdir/page.HTML.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.FilePath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
        <altmember cref="P:System.Web.HttpRequest.Path" />
      </Docs>
    </Member>
    <Member MemberName="Files">
      <MemberSignature Language="C#" Value="public System.Web.HttpFileCollection Files { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpFileCollection Files" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Files" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Files As HttpFileCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpFileCollection ^ Files { System::Web::HttpFileCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpFileCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de archivos cargada por el cliente, en formato MIME de varias partes.</summary>
        <value>Objeto <see cref="T:System.Web.HttpFileCollection" /> que representa una colección de archivos cargados por el cliente. Los elementos del objeto <see cref="T:System.Web.HttpFileCollection" /> son del tipo <see cref="T:System.Web.HttpPostedFile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La colección de archivos se rellena únicamente cuando la solicitud HTTP `Content-Type` valor es "multipart/form-data".  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra los nombres de todos los archivos de la <xref:System.Web.HttpRequest.Files%2A> colección.  
  
 [!code-csharp[Classic HttpRequest.Files Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Files Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Files Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Files Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el filtro que se utilizará al leer el flujo de entrada actual.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que se va a usar como filtro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se crea dos nuevas clases, `QQQ1` y `QQQ2` ese filtro el <xref:System.Web.HttpRequest.InputStream%2A>. Coloque las clases en el archivo Global.asax en el directorio de la aplicación de ASP.NET para que se filtrarán todas las entradas para todas las páginas Web ASP.NET en la aplicación.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Filter#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/CS/systemwebhttprequestfilter.cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Filter#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Filter/VB/systemwebhttprequestfilter.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El valor de <see cref="T:System.IO.Stream" /> especificado no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Form" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Form As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Form { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de variables de formulario.</summary>
        <value>Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> que representa una colección de variables de formulario.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.Form%2A> propiedad se rellena cuando la solicitud HTTP `Content-Type` valor es "application/x--www-form-urlencoded" o "multipart/form-data".  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer los valores de la colección de formulario enviada desde un explorador. Cada par de nombre/valor de la colección representa un control en el formulario y su valor.  
  
 [!code-csharp[Classic HttpRequest.Form Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Form Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Form Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Form Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferedInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferedInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferedInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferedInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferedInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferedInputStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es idéntico a <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> salvo que también copia los bytes que se leen en el almacenamiento interno que usa ASP.NET para rellenar el <xref:System.Web.HttpRequest.Form%2A>, <xref:System.Web.HttpRequest.Files%2A>, y <xref:System.Web.HttpRequest.InputStream%2A> propiedades. Dado que esta información se conserva, el código de nivel inferior, como las páginas de formularios ASP.NET Web Forms (archivos .aspx), se ejecutará correctamente. Esto no sucede así con el método <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes:  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.Form" />  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.Files" />  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   Método <see cref="M:System.Web.HttpRequest.GetBufferlessInputStream" />.  
  
 Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetBufferlessInputStream">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de entidad HTTP entrante.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método proporciona una alternativa al uso de la <xref:System.Web.HttpRequest.InputStream%2A> propiedad. El <xref:System.Web.HttpRequest.InputStream%2A> propiedad espera hasta que toda la solicitud se ha recibido antes de devolver un <xref:System.IO.Stream> objeto. En cambio, el <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A> método devuelve el <xref:System.IO.Stream> objeto inmediatamente. Puede usar el método debe para empezar a procesar el cuerpo de entidad antes de que se han recibido el contenido completo del cuerpo.  
  
 El cuerpo de entidad (o como gran parte de él que solicitar y se ha recibido) se devuelve solo cuando se usa el objeto devuelto por este método para leer la secuencia, mediante una llamada a métodos como el <xref:System.IO.Stream.Read%2A> método. Usar parámetros de la <xref:System.IO.Stream.Read%2A> método para especificar la cantidad de leer el cuerpo de entidad.  
  
 La <xref:System.IO.Stream> objeto devuelto por ASP.NET de este método es compatible con métodos de lectura sincrónicos y asincrónicos. El <xref:System.IO.Stream> objeto implementa tanto la <xref:System.IO.Stream.BeginRead%2A> y <xref:System.IO.Stream.EndRead%2A> métodos. Los métodos asincrónicos le permiten leer de forma asincrónica la entidad de solicitud en fragmentos, mientras que ASP.NET libera el subproceso actual entre cada iteración de un bucle de lectura asincrónico.  
  
 Este método puede ser útil si la solicitud está cargando un archivo grande y desea empezar a obtener acceso a los contenidos del archivo antes de que termine la carga. Sin embargo, sólo debe utilizar este método para escenarios donde desea asumir todo el procesamiento del cuerpo de entidad. Esto significa que no se puede utilizar este método desde una página .aspx, porque en el momento en que se ejecuta una página .aspx, ya se ha leído el cuerpo de entidad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes:  
  
-   <see cref="P:System.Web.HttpRequest.Form" />  
  
-   <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   <see cref="P:System.Web.HttpRequest.Files" />  
  
-   <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />  
  
 Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="GetBufferlessInputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetBufferlessInputStream (bool disableMaxRequestLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetBufferlessInputStream(bool disableMaxRequestLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.GetBufferlessInputStream(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBufferlessInputStream (disableMaxRequestLength As Boolean) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Stream ^ GetBufferlessInputStream(bool disableMaxRequestLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disableMaxRequestLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disableMaxRequestLength">
          <see langword="true" /> para deshabilitar el límite de longitud de la solicitud; en caso contrario, <see langword="false" />.</param>
        <summary>Obtiene un objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP entrante y deshabilita opcionalmente el límite de longitud de la solicitud que se establece en la propiedad <see cref="P:System.Web.Configuration.HttpRuntimeSection.MaxRequestLength" />.</summary>
        <returns>Objeto <see cref="T:System.IO.Stream" /> que se puede usar para leer el cuerpo de la entidad HTTP de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información acerca de este método, consulte el <xref:System.Web.HttpRequest.GetBufferlessInputStream> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El cuerpo de la entidad de la solicitud ya se ha cargado y ha analizado. Entre los ejemplos de propiedades que producen la carga y el análisis del cuerpo de la entidad se incluyen los siguientes:  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.Form" />  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.Files" />  
  
-   Propiedad <see cref="P:System.Web.HttpRequest.InputStream" />  
  
-   Método <see cref="M:System.Web.HttpRequest.GetBufferedInputStream" />.  
  
 Para evitar esta excepción, llame primero al método <see cref="P:System.Web.HttpRequest.ReadEntityBodyMode" />. Esta excepción también se produce si el cliente se desconecta mientras se está leyendo el cuerpo de la entidad.</exception>
        <altmember cref="M:System.Web.HttpRequest.GetBufferedInputStream" />
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de encabezados HTTP.</summary>
        <value>
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> de encabezados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de todos los posibles encabezados, consulte [campos de encabezado de solicitud](http://go.microsoft.com/fwlink/?LinkId=73147) en el sitio Web de W3C.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra los nombres y valores de todos los encabezados de la solicitud HTTP.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HttpChannelBinding">
      <MemberSignature Language="C#" Value="public System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Authentication.ExtendedProtection.ChannelBinding HttpChannelBinding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpChannelBinding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpChannelBinding As ChannelBinding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Authentication::ExtendedProtection::ChannelBinding ^ HttpChannelBinding { System::Security::Authentication::ExtendedProtection::ChannelBinding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Authentication.ExtendedProtection.ChannelBinding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> de la instancia de <see cref="T:System.Web.HttpWorkerRequest" /> actual.</summary>
        <value>Objeto <see cref="T:System.Security.Authentication.ExtendedProtection.ChannelBinding" /> de la instancia de <see cref="T:System.Web.HttpWorkerRequest" /> actual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">El objeto <see cref="T:System.Web.HttpWorkerRequest" /> actual no es un objeto <see langword="System.Web.Hosting.IIS7WorkerRequest" /> ni <see langword="System.Web.Hosting.ISAPIWorkerRequestInProc" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HttpMethod">
      <MemberSignature Language="C#" Value="public string HttpMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HttpMethod" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.HttpMethod" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HttpMethod As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ HttpMethod { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el método de transferencia de datos HTTP (como <see langword="GET" />, <see langword="POST" /> o <see langword="HEAD" />) que usa el cliente.</summary>
        <value>Método de transferencia de datos HTTP usado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.HttpMethod%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 En el ejemplo siguiente se muestra la salida generada por este código.  
  
 `GET`  
  
 `127.0.0.1`  
  
 `127.0.0.1`  
  
 `GET`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream InputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream InputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.InputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ InputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el contenido del cuerpo de la entidad HTTP entrante.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que representa el contenido del cuerpo de contenido HTTP entrante.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se copia el contenido de un <xref:System.Web.HttpRequest.InputStream%2A> en una cadena.  
  
 [!code-csharp[Classic HttpRequest.InputStream Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/cs/source.aspx#1)]
 [!code-vb[Classic HttpRequest.InputStream Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.InputStream Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InsertEntityBody">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Proporciona un contenedor administrado para el método de IIS que inserta el cuerpo de una entidad de solicitud HTTP en la memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A> sobrecargas del método proporcionan acceso administrado para IIS 7 `IHttpRequest::InsertEntityBody` método. El método IIS inserta un cuerpo de entidad de solicitud HTTP (es decir, los datos que se registran un cliente) en la memoria. Esto es útil porque IIS no mantiene una copia de la entidad de solicitud después de que se ha leído. El <xref:System.Web.HttpRequest.InsertEntityBody%2A> métodos crean una copia de los datos de entidad de solicitud HTTP y ponerlo a disposición de IIS para mayor control personalizado.  
  
> [!NOTE]
>  El <xref:System.Web.HttpRequest.InsertEntityBody%2A> sobrecargas de método trabajo solo en IIS 7.0 o posterior, porque el `IHttpRequest::InsertEntityBody` método se agregó en IIS 7.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Proporciona a IIS una copia del cuerpo de la entidad de solicitud HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS no mantiene una copia de la solicitud después de que se ha leído. Por lo tanto, se recomienda que sólo el controlador de una solicitud HTTP debe leer la entidad de solicitud.  
  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> sobrecarga del método proporciona a IIS una copia de la entidad de solicitud si se ha leído previamente por ASP.NET. Esta sobrecarga del método es útil para los casos donde ASP.NET ha leído la solicitud de la entidad y desea reutilizar los datos existentes de la solicitud.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">El método se invocó en una versión de IIS anterior a IIS 7.0.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">para trabajar en un entorno hospedado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InsertEntityBody">
      <MemberSignature Language="C#" Value="public void InsertEntityBody (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertEntityBody(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.InsertEntityBody(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertEntityBody (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertEntityBody(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz que contiene los datos de la entidad de solicitud.</param>
        <param name="offset">Posición de base cero en <c>buffer</c> donde se comienzan a almacenar los datos de la entidad de solicitud.</param>
        <param name="count">Número de bytes que se van a leer en la matriz <c>buffer</c>.</param>
        <summary>Proporciona a IIS una copia del cuerpo de la entidad de solicitud HTTP e información sobre el objeto entidad de solicitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IIS no mantiene una copia de la solicitud después de que se ha leído. Por lo tanto, se recomienda que sólo el controlador de una solicitud HTTP debe leer la entidad de solicitud.  
  
 El <xref:System.Web.HttpRequest.InsertEntityBody%2A?displayProperty=nameWithType> sobrecarga del método es útil cuando desea realizar un procesamiento personalizado, como la inserción de un cuerpo de entidad diferente en la memoria.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">El método se invocó en una versión de IIS anterior a IIS 7.0.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> es un valor negativo.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de <paramref name="count" /> es mayor que el espacio disponible en <paramref name="buffer" />, especificado el valor <paramref name="offset" />.</exception>
        <permission cref="T:System.Web.AspNetHostingPermission">para trabajar en un entorno hospedado. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeración asociada: <see cref="F:System.Web.AspNetHostingPermissionLevel.High" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud se autenticó.</summary>
        <value>
          <see langword="true" /> si se ha autenticado la solicitud; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpRequest.IsAuthenticated%2A> propiedad para determinar si se ha autenticado la solicitud actual. Si no se ha autenticado, la solicitud se redirige a otra página donde los usuarios pueden especificar sus credenciales en la aplicación Web. Se trata de una técnica común utilizada en la página predeterminada para una aplicación.  
  
 [!code-csharp[System.Web.HttpRequest_Sample3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/CS/isauthenticatedcs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample3/VB/isauthenticatedvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocal">
      <MemberSignature Language="C#" Value="public bool IsLocal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocal" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsLocal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud es del equipo local.</summary>
        <value>
          Es <see langword="true" /> si la solicitud procede del equipo local; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.IsLocal%2A> propiedad devuelve `true` si la dirección IP del originador de la solicitud es 127.0.0.1 o si la dirección IP de la solicitud es el mismo que la dirección IP del servidor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecureConnection">
      <MemberSignature Language="C#" Value="public bool IsSecureConnection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecureConnection" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.IsSecureConnection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSecureConnection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSecureConnection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la conexión HTTP usa sockets seguros, es decir, HTTPS.</summary>
        <value>
          <see langword="true" /> si la conexión es una conexión SSL; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se determina si el <xref:System.Web.HttpRequest.IsSecureConnection%2A> propiedad está establecida en false. Si es así, la <xref:System.Web.HttpResponse.SuppressContent%2A> propiedad está establecida en true para detener el envío de la respuesta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public string this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ key); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Nombre del miembro de colección que se va a obtener.</param>
        <summary>Obtiene el objeto especificado de las colecciones <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> o <see cref="P:System.Web.HttpRequest.ServerVariables" /></summary>
        <value>Miembro de la colección <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> o <see cref="P:System.Web.HttpRequest.ServerVariables" /> especificado en el parámetro <paramref name="key" />. Si no se encuentra el objeto <paramref name="key" /> especificado, se devuelve <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogonUserIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.WindowsIdentity LogonUserIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.WindowsIdentity LogonUserIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.LogonUserIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogonUserIdentity As WindowsIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::WindowsIdentity ^ LogonUserIdentity { System::Security::Principal::WindowsIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.WindowsIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo <see cref="T:System.Security.Principal.WindowsIdentity" /> del usuario actual.</summary>
        <value>Objeto <see cref="T:System.Security.Principal.WindowsIdentity" /> que corresponde a la configuración de autenticación actual de Microsoft Internet Information Services (IIS).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.LogonUserIdentity%2A> propiedad expone las propiedades y métodos de la <xref:System.Security.Principal.WindowsIdentity> objeto para el usuario conectado actualmente a Microsoft Internet Information Services (IIS). La instancia de la <xref:System.Security.Principal.WindowsIdentity> clase que se expone mediante <xref:System.Web.HttpRequest.LogonUserIdentity%2A> realiza un seguimiento el token de solicitud IIS y proporciona fácil acceso a este token para la solicitud HTTP actual está procesando dentro de ASP.NET. Una instancia de la <xref:System.Security.Principal.WindowsIdentity> clase se crea automáticamente por lo que no es necesario construir a con el fin de obtener acceso a sus métodos y propiedades.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo recuperar el <xref:System.Web.HttpRequest.LogonUserIdentity%2A> propiedad para el usuario actual y escribir los valores de cada elemento en un archivo de texto. Colocar este código en la página ASP.NET al que hace referencia el formulario `ACTION` atributo.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/CS/logonuseridentity_cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_LogonUserIdentity#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_LogonUserIdentity/VB/logonuseridentity_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La aplicación web se está ejecutando en modo integrado de IIS 7 y todavía no se ha provocado el evento <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapImageCoordinates">
      <MemberSignature Language="C#" Value="public int[] MapImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32[] MapImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapImageCoordinates (imageFieldName As String) As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;int&gt; ^ MapImageCoordinates(System::String ^ imageFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nombre de la asignación de imágenes del formulario.</param>
        <summary>Asigna un parámetro de formulario entrante de campo de imagen a los valores de coordenada X y coordenada Y adecuados.</summary>
        <returns>Matriz bidimensional de enteros.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MapPath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Asigna la ruta de acceso virtual de la dirección URL solicitada a una ruta de acceso física del servidor, correspondiente a la solicitud actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual (absoluta o relativa) de la solicitud actual.</param>
        <summary>Asigna la ruta de acceso virtual especificada a una ruta de acceso física.</summary>
        <returns>Ruta de acceso física del servidor especificado por <paramref name="virtualPath" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  El <xref:System.Web.HttpRequest.MapPath%2A> propiedad puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpRequest.MapPath%2A> método para convertir una ruta de acceso virtual en una ruta de acceso física completa en el servidor. Este ejemplo tiene dos partes:  
  
-   Una página .aspx asigna la ruta de acceso, lee el archivo y muestra los resultados de la operación de lectura.  
  
-   Una clase, `UpperCaseFilterStream`, que cambia todos los caracteres que se pasan a través de él a mayúsculas.  
  
 La primera parte del ejemplo muestra cómo convertir una ruta de acceso virtual a una ruta de acceso física completa mediante el <xref:System.Web.HttpRequest.MapPath%2A> método. Esta ruta de acceso física, a continuación, se pasa a un <xref:System.IO.StreamReader> objeto, que obtiene el contenido del archivo. El <xref:System.Web.HttpResponse.Write%2A> , a continuación, se llama el método para mostrar el contenido del archivo en la página. El <xref:System.Web.HttpResponse.Filter%2A> propiedad se utiliza para adjuntar un filtro a la secuencia de respuesta que hace que el texto mostrado en la página de todas las letras mayúsculas.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 La segunda parte del ejemplo muestra una clase que hereda de <xref:System.IO.Stream> y convierte todos los caracteres en una secuencia en mayúsculas. Coloque este código el `App_Code` carpeta de la aplicación.  
  
 [!code-csharp[System.Web.HttpRequest_Samples2#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/responsefilter.cs#2)]
 [!code-vb[System.Web.HttpRequest_Samples2#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/responsefilter.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No hay ningún objeto <see cref="T:System.Web.HttpContext" /> definido para la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath, string baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath, string baseVirtualDir, bool allowCrossAppMapping) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapPath(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (virtualPath As String, baseVirtualDir As String, allowCrossAppMapping As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ virtualPath, System::String ^ baseVirtualDir, bool allowCrossAppMapping);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="baseVirtualDir" Type="System.String" />
        <Parameter Name="allowCrossAppMapping" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual (absoluta o relativa) de la solicitud actual.</param>
        <param name="baseVirtualDir">Ruta de acceso al directorio base virtual que se usa para una resolución relativa.</param>
        <param name="allowCrossAppMapping">
          <see langword="true" /> para indicar que <c>virtualPath</c> puede pertenecer a otra aplicación; de lo contrario, <see langword="false" />.</param>
        <summary>Asigna la ruta de acceso virtual especificada a una ruta de acceso física.</summary>
        <returns>Ruta de acceso física del servidor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  El <xref:System.Web.HttpRequest.MapPath%2A> propiedad puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No hay ningún objeto <see cref="T:System.Web.HttpContext" /> definido para la solicitud.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapRawImageCoordinates">
      <MemberSignature Language="C#" Value="public double[] MapRawImageCoordinates (string imageFieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64[] MapRawImageCoordinates(string imageFieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.MapRawImageCoordinates(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapRawImageCoordinates (imageFieldName As String) As Double()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;double&gt; ^ MapRawImageCoordinates(System::String ^ imageFieldName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="imageFieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="imageFieldName">Nombre del campo de imagen.</param>
        <summary>Asigna un parámetro de formulario entrante de campo de imagen a los valores de coordenadas X e Y adecuados.</summary>
        <returns>Valores de coordenadas X e Y.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Params">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Params { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Params" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Params" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Params As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Params { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección combinada de elementos <see cref="P:System.Web.HttpRequest.QueryString" />, <see cref="P:System.Web.HttpRequest.Form" />, <see cref="P:System.Web.HttpRequest.Cookies" /> y <see cref="P:System.Web.HttpRequest.ServerVariables" />.</summary>
        <value>Un objeto <see cref="T:System.Collections.Specialized.NameValueCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pares de nombre-valor se agregan a la colección en el orden siguiente:  
  
1.  Parámetros de cadena de consulta.  
  
2.  Campos de formulario.  
  
3.  Cookies.  
  
4.  Variables de servidor.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo recorrer el <xref:System.Web.HttpRequest.Params%2A> propiedad de una página y cómo mostrar cada par de clave/valor.  
  
 [!code-aspx-csharp[System.Web.HttpRequest.Params#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest.Params/CS/requestparamscs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest.Params#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest.Params/VB/requestparamsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Path" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso virtual de la solicitud actual.</summary>
        <value>Ruta de acceso virtual de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest.Path%2A> es la concatenación de la <xref:System.Web.HttpRequest.FilePath%2A> y <xref:System.Web.HttpRequest.PathInfo%2A> finalizador. Por ejemplo, para la dirección URL http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.Path%2A> es /virdir/page.html/tail.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.Path%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#2)]
 [!code-vb[System.Web.HttpRequest_Sample1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
        <altmember cref="P:System.Web.HttpRequest.PathInfo" />
      </Docs>
    </Member>
    <Member MemberName="PathInfo">
      <MemberSignature Language="C#" Value="public string PathInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PathInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathInfo { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información adicional de la ruta de acceso de un recurso con extensión de dirección URL.</summary>
        <value>Información adicional de la ruta de acceso de un recurso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para la dirección URL Http://www.contoso.com/virdir/page.html/tail, el <xref:System.Web.HttpRequest.PathInfo%2A> valor es/tail.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se determina si el <xref:System.Web.HttpRequest.PathInfo%2A> propiedad contiene una cadena vacía. Si es así, la <xref:System.IO.StreamWriter.Write%2A> método escribe una cadena que indica esto en un archivo. Si no es así, el <xref:System.Web.HttpUtility.HtmlEncode%2A> método codifica en HTML el valor de la <xref:System.Web.HttpRequest.PathInfo%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método escribe el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#4)]
 [!code-vb[System.Web.HttpRequest_Sample1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpRequest.Path" />
        <altmember cref="P:System.Web.HttpRequest.FilePath" />
      </Docs>
    </Member>
    <Member MemberName="PhysicalApplicationPath">
      <MemberSignature Language="C#" Value="public string PhysicalApplicationPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalApplicationPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalApplicationPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalApplicationPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalApplicationPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso al sistema de archivos físico del directorio raíz de la aplicación de servidor que se está ejecutando.</summary>
        <value>Ruta de acceso al sistema de archivos del directorio raíz de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.PhysicalApplicationPath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalPath">
      <MemberSignature Language="C#" Value="public string PhysicalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PhysicalPath" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.PhysicalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PhysicalPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la ruta de acceso al sistema de archivos físico correspondiente a la dirección URL solicitada.</summary>
        <value>Ruta de acceso al sistema de archivos de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En escenarios de redirección con <xref:System.Web.HttpServerUtility.Execute%2A> y <xref:System.Web.HttpServerUtility.Transfer%2A>, el <xref:System.Web.HttpRequest.PhysicalPath%2A> propiedad devuelve la ruta de acceso a la página original. Para buscar la ruta de acceso física de la página se utiliza actualmente en ejecución la <xref:System.Web.HttpRequest.MapPath%2A> método con el argumento de entrada establecido como el <xref:System.Web.HttpRequest.CurrentExecutionFilePath%2A> propiedad.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.PhysicalPath%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.MapPath(System.String)" />
        <altmember cref="P:System.Web.HttpRequest.CurrentExecutionFilePath" />
      </Docs>
    </Member>
    <Member MemberName="QueryString">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection QueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection QueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.QueryString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property QueryString As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ QueryString { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de variables de tipo cadena de consulta HTTP.</summary>
        <value>Variables de cadena de consulta enviadas por el cliente. Las claves y los valores son de descodificación de URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra dos maneras de obtener el valor de una variable de cadena de consulta denominada "fullname". En cada caso, si la dirección URL es `http://www.contoso.com/default.aspx?fullname=Fadi%20Fakhouri`, a continuación, el valor devuelto es "Delia Fakhouri" porque el `%20` es la descodificación de URL en un carácter de espacio. Si la dirección URL no tiene un `fullname` identificador de cadena de consulta, el valor devuelto debería ser `null`.  
  
 La primera línea de código busca la clave "fullname" solo en la cadena de consulta; la segunda línea busca la clave "fullname" en todas las colecciones de solicitud HTTP. Para obtener más información acerca de la segunda línea, consulte <xref:System.Web.HttpRequest.Item%2A>.  
  
```csharp  
string fullname1 = Request.QueryString["fullname"];  
string fullname2 = Request["fullname"];  
  
```  
  
```vb  
Dim fullname1 As String = Request.QueryString("fullname")  
Dim fullname2 As String = Request("fullname")  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpRequest.ValidateInput" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
      </Docs>
    </Member>
    <Member MemberName="RawUrl">
      <MemberSignature Language="C#" Value="public string RawUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RawUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RawUrl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RawUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección URL sin procesar de la solicitud actual.</summary>
        <value>Dirección URL sin procesar de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La dirección URL sin procesar se define como la parte de la dirección URL siguiendo la información de dominio. En la cadena de dirección URL http://www.contoso.com/articles/recent.aspx, la dirección URL original es/articles/recent.aspx. La dirección URL original incluye la cadena de consulta, si está presente.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.RawUrl%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#5)]
 [!code-vb[System.Web.HttpRequest_Sample1#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEntityBodyMode">
      <MemberSignature Language="C#" Value="public System.Web.ReadEntityBodyMode ReadEntityBodyMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.ReadEntityBodyMode ReadEntityBodyMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ReadEntityBodyMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadEntityBodyMode As ReadEntityBodyMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ReadEntityBodyMode ReadEntityBodyMode { System::Web::ReadEntityBodyMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ReadEntityBodyMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se leyó el cuerpo de la entidad de la solicitud y, si es así, cómo se leyó.</summary>
        <value>Valor que indica cómo se leyó el cuerpo de la entidad de la solicitud o que no se leyó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza para evitar la excepción que se produce si ya se ha leído el cuerpo de entidad y se realiza un intento para leerlo mediante un método compatible. Métodos y propiedades que leen el cuerpo de entidad son los siguientes:  
  
-   Propiedad <xref:System.Web.HttpRequest.Form%2A>  
  
-   Propiedad <xref:System.Web.HttpRequest.Files%2A>  
  
-   Propiedad <xref:System.Web.HttpRequest.InputStream%2A>  
  
-   Método <xref:System.Web.HttpRequest.GetBufferedInputStream%2A>.  
  
-   Método <xref:System.Web.HttpRequest.GetBufferlessInputStream%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestContext">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RequestContext RequestContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RequestContext RequestContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestContext" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestContext As RequestContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Routing::RequestContext ^ RequestContext { System::Web::Routing::RequestContext ^ get(); void set(System::Web::Routing::RequestContext ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RequestContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia de <see cref="T:System.Web.Routing.RequestContext" /> de la solicitud actual.</summary>
        <value>Instancia de <see cref="T:System.Web.Routing.RequestContext" /> de la solicitud actual. En el caso de solicitudes no enrutadas, el objeto <see cref="T:System.Web.Routing.RequestContext" /> que se devuelve está vacío.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona acceso a la <xref:System.Web.Routing.RouteData> objeto de la solicitud actual. Para obtener más información sobre el enrutamiento de ASP.NET, vea. [Enrutamiento de ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestType">
      <MemberSignature Language="C#" Value="public string RequestType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequestType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.RequestType" />
      <MemberSignature Language="VB.NET" Value="Public Property RequestType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RequestType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el método de transferencia de datos HTTP (<see langword="GET" /> o <see langword="POST" />) que usa el cliente.</summary>
        <value>Cadena que representa el tipo de invocación HTTP enviado por el cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.RequestType%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveAs">
      <MemberSignature Language="C#" Value="public void SaveAs (string filename, bool includeHeaders);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveAs(string filename, bool includeHeaders) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.SaveAs(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveAs (filename As String, includeHeaders As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveAs(System::String ^ filename, bool includeHeaders);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="includeHeaders" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Ruta de acceso física a la unidad.</param>
        <param name="includeHeaders">Valor booleano que especifica si se debe guardar en el disco un encabezado HTTP.</param>
        <summary>Guarda una solicitud HTTP en el disco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Guardar el contexto de solicitud en el disco puede ser útil para la depuración.  
  
   
  
## Examples  
 El siguiente ejemplo de código llama el <xref:System.Web.HttpRequest.SaveAs%2A> método cuando se carga una página. La llamada especifica que la solicitud se guarda como un archivo de texto en un directorio donde la identidad de proceso ASP.NET se ha concedido permisos de escritura, y que cualquier información de encabezado incluida en la solicitud se incluye en el archivo.  
  
 [!code-csharp[System.Web.HttpRequest_Sample6#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/cs/requestsample6cs.aspx#1)]
 [!code-vb[System.Web.HttpRequest_Sample6#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample6/vb/requestsample6vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propiedad <see cref="P:System.Web.Configuration.HttpRuntimeSection.RequireRootedSaveAsPath" /> de <see cref="T:System.Web.Configuration.HttpRuntimeSection" /> está establecida en <see langword="true" />, pero <paramref name="filename" /> no es una ruta de acceso absoluta.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerVariables">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection ServerVariables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection ServerVariables" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.ServerVariables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ServerVariables As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ ServerVariables { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de variables de servidor web.</summary>
        <value>Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> de variables de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener una lista de variables de servidor compatibles con IIS, consulte [Variables de servidor IIS](http://go.microsoft.com/fwlink/?LinkId=52471).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra los nombres y valores de todas las variables de servidor con nombre.  
  
 [!code-csharp[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.ServerVariables Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.ServerVariables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimedOutToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken TimedOutToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken TimedOutToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TimedOutToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimedOutToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken TimedOutToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Threading.CancellationToken" /> que se desencadena cuando una solicitud consume el tiempo de espera.</summary>
        <value>Token de cancelación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El período de tiempo de espera puede especificarse en el archivo Web.config (consulte <xref:System.Web.Configuration.HttpRuntimeSection.ExecutionTimeout%2A?displayProperty=nameWithType>) o mediante programación (vea <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType>). El período de tiempo de espera se mide desde el momento en que la solicitud proviene de. Si el tiempo de espera predeterminado de 110 segundos está en vigor, el token de cancelación se se desencadena no sea anterior a 110 segundos después de que comience el procesamiento de la solicitud. Puede cambiar la <xref:System.Web.HttpServerUtility.ScriptTimeout%2A?displayProperty=nameWithType> valor de propiedad, y como long este token no desencadena todavía, se respetan el nuevo valor de tiempo de espera.  
  
 Actualmente el token solo proporciona 15 granularidad segundo, lo que significa que si el valor de tiempo de espera es de 110 segundos, el token se se desencadena en algún momento entre 110 y 125 segundos después de que comience el procesamiento de la solicitud. La granularidad puede cambiar en el futuro.  
  
 Aunque esta propiedad es segura para subprocesos, hay restricciones sobre su uso. Para obtener más información, vea <xref:System.Web.HttpResponse.ClientDisconnectedToken%2A?displayProperty=nameWithType>.  
  
 Esta propiedad no tiene sentida si ha iniciado el procesamiento de la solicitud de WebSockets.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TlsTokenBindingInfo">
      <MemberSignature Language="C#" Value="public System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ITlsTokenBindingInfo TlsTokenBindingInfo" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TlsTokenBindingInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TlsTokenBindingInfo As ITlsTokenBindingInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::ITlsTokenBindingInfo ^ TlsTokenBindingInfo { System::Web::ITlsTokenBindingInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ITlsTokenBindingInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información de enlace del token TLS. La propiedad permite que las aplicaciones recuperen información del token de las solicitudes HTTP entrantes para usar autenticación mejorada.</summary>
        <value>Token de enlace de la conexión actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve `null` en plataformas no windows10.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TotalBytes">
      <MemberSignature Language="C#" Value="public int TotalBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TotalBytes" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.TotalBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalBytes As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TotalBytes { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de bytes del flujo de entrada actual.</summary>
        <value>Número de bytes del flujo de entrada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se determina si la <xref:System.Web.HttpRequest.TotalBytes%2A> valor de la propiedad es mayor que 1000 bytes y escribe esa información en un archivo.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#6)]
 [!code-vb[System.Web.HttpRequest_Sample1#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unvalidated">
      <MemberSignature Language="C#" Value="public System.Web.UnvalidatedRequestValues Unvalidated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UnvalidatedRequestValues Unvalidated" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Unvalidated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Unvalidated As UnvalidatedRequestValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UnvalidatedRequestValues ^ Unvalidated { System::Web::UnvalidatedRequestValues ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UnvalidatedRequestValues</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los valores de solicitud HTTP sin que se desencadene la validación de solicitudes.</summary>
        <value>Valores de solicitud HTTP que no se comprobaron con la validación de solicitudes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solicitar comprobaciones de validación para el marcado HTML y scripts que podrían indicar un posible ataque de scripting entre sitios. De forma predeterminada, todos los valores se comprueban con la validación de solicitud y si los valores contienen script o marcado, ASP.NET genera un <xref:System.Web.HttpRequestValidationException> excepción. Utilice este método si se prevé que la solicitud contendrá marcado (por ejemplo, permitiendo a los usuarios publicar contenido que contiene marcado) y desea obtener el valor sin formato de una solicitud.  
  
> [!IMPORTANT]
>  Si utiliza esta propiedad, se deben comprobar manualmente los datos de posibles ataques de scripts entre sitios.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UnvalidatedRequestValues" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre la dirección URL de la solicitud actual.</summary>
        <value>Objeto <see cref="T:System.Uri" /> que contiene la dirección URL de la solicitud actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente código de ejemplo, se asigna la <xref:System.Uri> objeto de la solicitud actual a una variable de objeto y muestra el valor de dos propiedades de la dirección URL del objeto en la salida HTTP.  
  
 [!code-csharp[Classic HttpRequest.Url Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Url Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Url Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Url Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Uri" />
        <altmember cref="P:System.Web.HttpRequest.RawUrl" />
      </Docs>
    </Member>
    <Member MemberName="UrlReferrer">
      <MemberSignature Language="C#" Value="public Uri UrlReferrer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UrlReferrer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UrlReferrer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UrlReferrer As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UrlReferrer { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene información sobre la dirección URL de la solicitud anterior del cliente que establecía un vínculo con la dirección URL actual.</summary>
        <value>Un objeto <see cref="T:System.Uri" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra el valor de dos propiedades de la dirección URL que hace referencia al cliente a la aplicación actual.  
  
 [!code-csharp[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UrlReferrer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UrlReferrer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UriFormatException">El encabezado de la solicitud HTTP <see langword="Referer" /> es incorrecto y no se puede convertir en un objeto <see cref="T:System.Uri" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserAgent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserAgent As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserAgent { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la cadena de agente de usuario no procesada del explorador del cliente.</summary>
        <value>Cadena de agente de usuario no procesada del explorador del cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se asigna la identificación del tipo de explorador la solicitud a una variable de cadena.  
  
 [!code-csharp[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserAgent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserAgent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.Page.ClientTarget" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="P:System.Web.HttpRequest.Browser" />
      </Docs>
    </Member>
    <Member MemberName="UserHostAddress">
      <MemberSignature Language="C#" Value="public string UserHostAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostAddress" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostAddress { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la dirección IP del host del cliente remoto.</summary>
        <value>Dirección IP del cliente remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.UserHostAddress%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserHostName">
      <MemberSignature Language="C#" Value="public string UserHostName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserHostName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserHostName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserHostName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserHostName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre DNS del cliente remoto.</summary>
        <value>Nombre DNS del cliente remoto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpUtility.HtmlEncode%2A> método para codificar en HTML el valor de la <xref:System.Web.HttpRequest.UserHostName%2A> propiedad y el <xref:System.IO.TextWriter.WriteLine%2A> método para escribir el valor codificado en el archivo. Este ejemplo de código forma parte de un ejemplo mayor proporcionado para el <xref:System.Web.HttpRequest> clase.  
  
 [!code-csharp[System.Web.HttpRequest_Sample1#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/CS/requestdetailscs.aspx#7)]
 [!code-vb[System.Web.HttpRequest_Sample1#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Sample1/VB/requestdetailsvb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserLanguages">
      <MemberSignature Language="C#" Value="public string[] UserLanguages { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] UserLanguages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpRequest.UserLanguages" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserLanguages As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ UserLanguages { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de cadenas ordenada con las preferencias de idioma del cliente.</summary>
        <value>Matriz de cadenas ordenada con las preferencias de idioma del cliente, o <see langword="null" /> si está vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se captura los diversos valores devueltos por la <xref:System.Web.HttpRequest.UserLanguages%2A> propiedad en una matriz de cadenas y escribe el nombre de cada lenguaje en una línea distinta de la salida HTTP.  
  
 Los nombres de lenguaje son proporcionados por el explorador, y no hay ninguna lista de todos los posibles códigos definitiva.  Normalmente estas constan de los códigos de dos caracteres para el idioma, un guión y un código de dos caracteres para la referencia cultural, como "en-us" para Estados Unidos El inglés y "fr-ca" para francés canadiense.  
  
 [!code-csharp[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.UserLanguages Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.UserLanguages Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateInput">
      <MemberSignature Language="C#" Value="public void ValidateInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpRequest.ValidateInput" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateInput ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ValidateInput();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hace que se produzca la validación en las colecciones a las que se obtuvo acceso a través de las propiedades <see cref="P:System.Web.HttpRequest.Cookies" />, <see cref="P:System.Web.HttpRequest.Form" /> y <see cref="P:System.Web.HttpRequest.QueryString" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpRequest> clase utiliza marcas de validación de entrada para realizar el seguimiento si se debe realizar la validación en las colecciones de solicitud tiene accesibles a través de la <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, y <xref:System.Web.HttpRequest.QueryString%2A> propiedades. El <xref:System.Web.HttpRequest.ValidateInput%2A> método establece estos marcadores lo que, cuando los descriptores de acceso get para la <xref:System.Web.HttpRequest.Cookies%2A>, <xref:System.Web.HttpRequest.Form%2A>, o <xref:System.Web.HttpRequest.QueryString%2A> se invoca la propiedad, se realiza una validación de entrada. Validación funciona mediante la comprobación de todos los datos de entrada en una lista codificada de forma rígida de datos potencialmente peligrosos.  
  
 Si está habilitada la característica de validación mediante la directiva de página o la configuración, se llama a este método durante la página `ProcessRequest` la fase de procesamiento. El <xref:System.Web.HttpRequest.ValidateInput%2A> método puede llamarse mediante el código si no está habilitada la característica de validación.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpRequestValidationException">Se recibieron datos potencialmente peligrosos del cliente.</exception>
        <altmember cref="P:System.Web.HttpRequest.Cookies" />
        <altmember cref="P:System.Web.HttpRequest.Form" />
        <altmember cref="P:System.Web.HttpRequest.QueryString" />
      </Docs>
    </Member>
  </Members>
</Type>