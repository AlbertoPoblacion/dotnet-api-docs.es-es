<Type Name="HttpServerUtility" FullName="System.Web.HttpServerUtility">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="af79683dbebba2bc232c66a7a70dd0748a5935a9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30610769" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpServerUtility" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpServerUtility extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpServerUtility" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpServerUtility" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpServerUtility sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona métodos auxiliares para procesar las solicitudes web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos y propiedades de la <xref:System.Web.HttpServerUtility> clase se exponen a través de la función intrínseca <xref:System.Web.HttpContext.Server%2A> objeto proporcionado por ASP.NET.  
  
   
  
## Examples  
 Un proyecto de sitio Web de Visual Studio con código fuente está disponible como acompañamiento de este tema: [descargar](http://go.microsoft.com/fwlink/?LinkId=192870).  
  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método y <xref:System.Web.HttpServerUtility.UrlEncode%2A> método de la <xref:System.Web.HttpServerUtility> clase. El <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método ayuda a garantizar que cualquier cadena proporcionada por el usuario de entrada se representará como texto estático en los exploradores en lugar de los elementos HTML ni de secuencias de comandos ejecutables. El <xref:System.Web.HttpServerUtility.UrlEncode%2A> método codifica las direcciones URL para que se transmitan correctamente en el flujo de HTTP.  
  
 [!code-aspx-csharp[System.Web.HttpServerUtility1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpServerUtility1/cs/HttpServerUtilityCS.aspx#1)]
 [!code-aspx-vb[System.Web.HttpServerUtility1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpServerUtility1/vb/HttpServerUtilityVB.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.HttpContext" />
  </Docs>
  <Members>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra la excepción anterior.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se borra la última excepción que se produjo.  
  
 [!code-csharp[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ClearError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ClearError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.GetLastError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crea una instancia de servidor de un objeto COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (progID As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Clase o tipo de objeto del que se va a crear una instancia.</param>
        <summary>Crea una instancia de servidor de un objeto COM identificado mediante su identificador de programación (ProgID).</summary>
        <returns>El objeto nuevo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un objeto mediante el uso de ProgID del objeto.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObject Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObject Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se pudo crear una instancia del objeto.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public object CreateObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <see cref="T:System.Type" /> que representa el objeto que se va a crear.</param>
        <summary>Crea una instancia de servidor de un objeto COM identificado por el tipo de objeto.</summary>
        <returns>El objeto nuevo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectFromClsid">
      <MemberSignature Language="C#" Value="public object CreateObjectFromClsid (string clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateObjectFromClsid(string clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.CreateObjectFromClsid(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObjectFromClsid (clsid As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateObjectFromClsid(System::String ^ clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">Identificador de clase del objeto del que se va a crear una instancia.</param>
        <summary>Crea una instancia de servidor de un objeto COM identificado por su identificador de clase (CLSID).</summary>
        <returns>El objeto nuevo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Web.HttpServerUtility.CreateObjectFromClsid%2A> método para crear una instancia del servidor de un objeto COM.  
  
 [!code-csharp[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.CreateObjectFromClsid Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.CreateObjectFromClsid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se pudo crear una instancia del objeto.</exception>
        <altmember cref="M:System.Web.HttpServerUtility.CreateObject(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Execute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ejecuta el controlador de un recurso especificado en el contexto de la solicitud actual y devuelve la ejecución a la página que lo invocó.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de la dirección URL que se va a ejecutar.</param>
        <summary>Ejecuta el controlador de la ruta de acceso virtual especificada en el contexto de la solicitud actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.Execute%2A> método continúa la ejecución de la página original una vez completada la ejecución de la nueva página. El <xref:System.Web.HttpServerUtility.Transfer%2A> método transfiere incondicionalmente la ejecución a otro controlador.  
  
 ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Execute%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Execute%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad de su aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Execute%2A> método. <xref:System.Web.HttpResponse.Redirect%2A> realiza una redirección de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad de Internet Information Services (IIS) y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Execute%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra la página .aspx "Updateinfo.aspx" en el directorio actual. Ejecución del programa se devuelve a la página de inicio cuando se muestre la página Updateinfo.aspx.  
  
 [!code-csharp[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El <see cref="T:System.Web.HttpContext" /> actual es <see langword="null" />.  
  
 \- o -  
  
 Se produjo un error durante la ejecución del controlador especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="path" /> no es una ruta de acceso virtual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de la dirección URL que se va a ejecutar.</param>
        <param name="preserveForm">
          <see langword="true" /> para conservar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Ejecuta el controlador para la ruta de acceso virtual especificada en el contexto de la solicitud actual y especifica si se van a borrar las colecciones de <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo ejecutar la página .aspx `Updateinfo.aspx` en la solicitud actual y se conserva el <xref:System.Web.HttpRequest.QueryString%2A> y <xref:System.Web.HttpRequest.Form%2A> colecciones. Ejecución del programa regresa a la página de inicio después de `Updateinfo.aspx` se muestra.  
  
 [!code-csharp[HttpServerUtility.Execute#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute/CS/httpserverutility.execute_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute/VB/httpserverutility.execute_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El <see cref="T:System.Web.HttpContext" /> actual es <see langword="null" />.  
  
 \- o -  
  
 Se produjo un error durante la ejecución del controlador especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="path" /> no es una ruta de acceso virtual.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de la dirección URL que se va a ejecutar.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> que capturará la salida.</param>
        <summary>Ejecuta el controlador de la ruta de acceso virtual especificada en el contexto de la solicitud actual. Una clase <see cref="T:System.IO.TextWriter" /> captura los resultados del controlador ejecutado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.Execute%2A> método continúa la ejecución de la solicitud original una vez finalizada la ejecución de la ruta de acceso virtual especificada. El <xref:System.Web.HttpServerUtility.Transfer%2A> método transfiere incondicionalmente la ejecución a otro controlador.  
  
 ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Execute%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Execute%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad de su aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Execute%2A> método. <xref:System.Web.HttpResponse.Redirect%2A> realiza una redirección de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad de Internet Information Services (IIS) y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Execute%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta el `Login.aspx` página en el servidor en el directorio actual y recibe los resultados de la página a través de la <xref:System.IO.StringWriter> objeto `writer`. Escribe la secuencia HTML recibida desde `writer` a HTTP el flujo de salida.  
  
 [!code-csharp[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Execute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Execute1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El <see cref="T:System.Web.HttpContext" /> actual es <see langword="null" />.  
  
 \- o -  
  
 Se produjo un error durante la ejecución del controlador especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.  
  
 \- o -  
  
 <paramref name="path" /> no es una ruta de acceso virtual.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (string path, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(string path, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.String,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (path As String, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::String ^ path, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de la dirección URL que se va a ejecutar.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> que capturará la salida.</param>
        <param name="preserveForm">
          <see langword="true" /> para conservar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Ejecuta el controlador de la ruta de acceso virtual especificada en el contexto de la solicitud actual. Una clase <see cref="T:System.IO.TextWriter" /> captura los resultados de la página y un parámetro Boolean especifica si se van a borrar las colecciones de <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.Execute%2A> método continúa la ejecución de la solicitud original una vez finalizada la ejecución de la ruta de acceso virtual especificada. El <xref:System.Web.HttpServerUtility.Transfer%2A> método transfiere incondicionalmente la ejecución a otro controlador.  
  
 ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Execute%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Execute%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad de su aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Execute%2A> método. <xref:System.Web.HttpResponse.Redirect%2A> realiza una redirección de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad de Internet Information Services (IIS) y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Execute%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta el `Login.aspx` página en el servidor en el directorio actual y recibe los resultados de la página a través de la <xref:System.IO.StringWriter> objeto `writer`. Escribe la secuencia HTML recibida desde `writer` a HTTP el flujo de salida. El contenido de la <xref:System.Web.HttpRequest.Form%2A> y <xref:System.Web.HttpRequest.QueryString%2A> se conservan las colecciones.  
  
 [!code-csharp[HttpServerUtility.Execute02#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpServerUtility.Execute02/CS/httpserverutility.execute02_cs.aspx#1)]
 [!code-vb[HttpServerUtility.Execute02#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpServerUtility.Execute02/VB/httpserverutility.execute02_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La clase <see cref="T:System.Web.HttpContext" /> actual es una referencia nula (<see langword="Nothing" /> en Visual Basic).  
  
 \- o -  
  
 <paramref name="path" /> termina con un punto (.).  
  
 \- o -  
  
 Se produjo un error durante la ejecución del controlador especificado por <paramref name="path" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> no es una ruta de acceso virtual.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (System.Web.IHttpHandler handler, System.IO.TextWriter writer, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Execute(class System.Web.IHttpHandler handler, class System.IO.TextWriter writer, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Execute(System.Web.IHttpHandler,System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (handler As IHttpHandler, writer As TextWriter, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Execute(System::Web::IHttpHandler ^ handler, System::IO::TextWriter ^ writer, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Controlador HTTP que implementa la interfaz <see cref="T:System.Web.IHttpHandler" /> a la que se va a transferir la solicitud actual.</param>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> que capturará la salida.</param>
        <param name="preserveForm">
          <see langword="true" /> para conservar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Ejecuta el controlador de la ruta de acceso virtual especificada en el contexto de la solicitud actual. Una clase <see cref="T:System.IO.TextWriter" /> captura los resultados del controlador ejecutado y un parámetro Boolean especifica si se van a borrar las colecciones de <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede escribir controladores HTTP personalizados para procesar tipos predefinidos y específicos de solicitudes HTTP en cualquier lenguaje que sea compatible con Common Language Specification (CLS). Código ejecutable que se define en las clases de controlador HTTP en lugar de las páginas ASP (también conocido como ASP clásico) convencionales o páginas ASP.NET responde a estas solicitudes específicas. Controladores HTTP permiten interactuar con los servicios de respuesta de un servidor Web que ejecuta Internet Information Services (IIS) y la solicitud de bajo nivel, y proporcionan una funcionalidad similar a las extensiones ISAPI pero con un modelo de programación más simple.  
  
 ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso que se entrega por la <xref:System.Web.HttpServerUtility.Execute%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Execute%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad para la aplicación requiere que los clientes tengan la autorización adecuada para obtener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Execute%2A> método. El <xref:System.Web.HttpResponse.Redirect%2A> realiza un redireccionamiento de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad IIS y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Execute%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se produjo un error durante la ejecución del controlador especificado por <paramref name="handler" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="handler" /> es <see langword="null" />.</exception>
        <altmember cref="Overload:System.Web.HttpServerUtility.Transfer" />
      </Docs>
    </Member>
    <Member MemberName="GetLastError">
      <MemberSignature Language="C#" Value="public Exception GetLastError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Exception GetLastError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.GetLastError" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastError () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception ^ GetLastError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la excepción anterior.</summary>
        <returns>Excepción que se produjo anteriormente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se imprime una descripción del último error de la aplicación en el flujo de salida HTTP. Imprime "Sin errores" Si no se ha encontrado ningún error.  
  
 [!code-csharp[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.GetLastError Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.GetLastError Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpServerUtility.ClearError" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Descodifica una cadena que se ha codificado para eliminar caracteres HTML no válidos.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public string HtmlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena HTML que se va a descodificar.</param>
        <summary>Descodifica una cadena con código HTML y devuelve la cadena descodificada.</summary>
        <returns>Texto descodificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación HTML garantiza que el texto se muestre correctamente en el explorador y no interpretado por el explorador como HTML. Por ejemplo, si una cadena de texto contiene un signo menos (\<) o mayor signo menor que (>), el explorador interpretaría estos caracteres como la apertura o un corchete de cierre de una etiqueta HTML. Cuando los caracteres se codifica en HTML, se convierten a las cadenas de `&lt;` y `&gt;`, lo que hace que el explorador mostrar el menor que el inicio de sesión y mayor que inicie sesión correctamente. <xref:System.Web.HttpServerUtility.HtmlDecode%2A> descodifica el texto que se ha transmitido al servidor.  
  
 Este método es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, este método utiliza <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> para descodificar las cadenas.  
  
 En el archivo de código subyacente de una página web ASP.NET, tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase a través de la `Server` propiedad. En una clase que no está en un archivo de código subyacente, utilice `HttpContext.Current.Server` para tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase.  
  
 Fuera de una aplicación web, use la <xref:System.Net.WebUtility> clase para codificar o descodificar valores.  
  
   
  
## Examples  
 El ejemplo siguiente contiene la función `LoadDecodedFile`, que descodifica los datos desde un archivo y lo copia en una sola cadena.  
  
 [!code-aspx-csharp[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/CS/sourcecs.aspx#1)]
 [!code-aspx-vb[Classic HttpServerUtility.HtmlDecode Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode Example/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlDecode">
      <MemberSignature Language="C#" Value="public void HtmlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Cadena HTML que se va a descodificar.</param>
        <param name="output">Flujo de salida de <see cref="T:System.IO.TextWriter" /> que contiene la cadena descodificada.</param>
        <summary>Descodifica una cadena con código HTML y envía el resultado a un flujo de salida de <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación HTML garantiza que el texto se muestre correctamente en el explorador y no interpretado por el explorador como HTML. Por ejemplo, si una cadena de texto contiene un signo menos (\<) o mayor signo menor que (>), el explorador interpretaría estos caracteres como la apertura o un corchete de cierre de una etiqueta HTML. Cuando los caracteres se codifica en HTML, se convierten a las cadenas de `&lt;` y `&gt;`, lo que hace que el explorador mostrar el menor que el inicio de sesión y mayor que inicie sesión correctamente.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> descodifica el texto que se ha transmitido al servidor.  
  
 <xref:System.Web.HttpServerUtility.HtmlDecode%2A> es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.HtmlDecode%2A> utiliza <xref:System.Web.HttpUtility.HtmlDecode%2A?displayProperty=nameWithType> para descodificar las cadenas.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 En el ejemplo siguiente, se descodifica una cadena que se ha codificado en HTML para su transmisión a través de HTTP. Descodifica la cadena suministrada denominada `EncodedString` que contiene el texto "Esto es un &lt;Test String&gt;." y lo copia en la cadena denominada `DecodedString` como "se trata de un \<Test String >.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HtmlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica una cadena que se va a mostrar en un explorador.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public string HtmlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string HtmlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function HtmlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ HtmlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena de texto que se va a codificar.</param>
        <summary>Codifica una cadena en HTML y devuelve la cadena codificada.</summary>
        <returns>Texto codificado en HTML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación HTML garantiza que el texto se muestre correctamente en el explorador y no interpretado por el explorador como HTML. Por ejemplo, si una cadena de texto contiene un signo menos (\<) o mayor signo menor que (>), el explorador interpretaría estos caracteres como la apertura o un corchete de cierre de una etiqueta HTML. Cuando los caracteres se codifica en HTML, se convierten a las cadenas de `&lt;` y `&gt;`, lo que hace que el explorador mostrar el menor que el inicio de sesión y mayor que inicie sesión correctamente.  
  
 Este método es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, este método utiliza <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> para codificar las cadenas.  
  
 En el archivo de código subyacente de una página web ASP.NET, tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase a través de la `Server` propiedad. En una clase que no está en un archivo de código subyacente, utilice `HttpContext.Current.Server` para tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase.  
  
 Fuera de una aplicación web, use la <xref:System.Net.WebUtility> clase para codificar o descodificar valores.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo codificar en HTML un valor que potencialmente códigos de código no seguro. El código reside en el archivo de código subyacente para una página web. El valor para codificar está codificado de forma rígida en este ejemplo solo pretende simplificar el ejemplo y muestran al tipo de valor que se puede codificar en HTML. Normalmente, se podría codificar en HTML un valor que recibió del usuario o de la solicitud. `Result` hace referencia a un `Literal` control.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/default.aspx.vb#1)]  
  
 El ejemplo siguiente es similar al ejemplo anterior, solo muestra cómo codificar en HTML un valor dentro de una clase que no está en el archivo de código subyacente.  
  
 [!code-csharp[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.HtmlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.htmlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HtmlEncode">
      <MemberSignature Language="C#" Value="public void HtmlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void HtmlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.HtmlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub HtmlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void HtmlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se va a codificar.</param>
        <param name="output">Flujo de salida de <see cref="T:System.IO.TextWriter" /> que contiene la cadena codificada.</param>
        <summary>Codifica mediante HTML una cadena y envía el resultado a un flujo de salida de <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación HTML garantiza que texto se mostrarán correctamente en el explorador, no interpretado por el explorador como HTML. Por ejemplo, si una cadena de texto contiene un signo menos (\<) o mayor signo menor que (>), el explorador interpretaría estos caracteres como apertura o corchete de cierre de una etiqueta HTML. La codificación HTML de estos dos caracteres es `&lt;` y `&gt;`, respectivamente, que hace que el explorador mostrar el menor que el inicio de sesión y mayor que inicie sesión correctamente.  
  
 <xref:System.Web.HttpServerUtility.HtmlEncode%2A> es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.HtmlEncode%2A> utiliza <xref:System.Web.HttpUtility.HtmlEncode%2A?displayProperty=nameWithType> para codificar las cadenas.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena para la transmisión HTTP. Codifica la cadena denominada `TestString`, que contiene el texto "se trata de un \<Test String >." y lo copia en la cadena denominada `EncodedString` como "se trata de un &lt;Test String&gt;.".  
  
 [!code-csharp[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.HtmlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.HtmlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre del equipo del servidor.</summary>
        <value>Nombre del equipo local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se almacena el nombre del equipo del servidor como una variable de cadena.  
  
 [!code-csharp[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se encuentra el nombre del equipo.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.MapPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function MapPath (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MapPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso virtual de la aplicación web.</param>
        <summary>Devuelve la ruta de acceso física del archivo correspondiente a la ruta de acceso virtual especificada.</summary>
        <returns>Ruta de acceso física del archivo en el servidor web correspondiente a <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `path` es `null`, el <xref:System.Web.HttpServerUtility.MapPath%2A> método devuelve la ruta de acceso física completa del directorio que contiene la solicitud de la ruta de acceso actual. La ruta de acceso relativa no necesita especificar un archivo o carpeta existente para este método devolver un valor. Sin embargo, no puede especificar una ruta de acceso fuera de la aplicación Web.  
  
> [!IMPORTANT]
>  El <xref:System.Web.HttpServerUtility.MapPath%2A> método puede contener información confidencial sobre el entorno de hospedaje. El valor devuelto no debe mostrarse a los usuarios.  
  
 Una aplicación Web que reside en `C:\ExampleSites\TestMapPath` devolvería los siguientes resultados:  
  
|Solicitud de|`path`|Valor devuelto|  
|------------------|------------|--------------------|  
|RootLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath|  
|RootLevelPage.aspx|"/DownOneLevel/DownLevelPage.aspx"|C:\ExampleSites\TestMapPath\DownOneLevel\DownLevelPage.aspx|  
|RootLevelPage.aspx|"/NotRealFolder"|C:\ExampleSites\TestMapPath\NotRealFolder|  
|RootLevelPage.aspx|".. / OutsideApplication "|<xref:System.Web.HttpException>|  
|/DownOneLevel/DownLevelPage.aspx|`null`|C:\ExampleSites\TestMapPath\DownOneLevel|  
|/DownOneLevel/DownLevelPage.aspx|"../RootLevelPage.aspx"|C:\ExampleSites\TestMapPath\RootLevelPage.aspx|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo recuperar el archivo físico de una ruta de acceso virtual relativa. El código se encuentra en el archivo de código subyacente para una página web y utiliza el valor predeterminado `Server` objeto.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/default.aspx.vb#1)]  
  
 El ejemplo siguiente es similar al ejemplo anterior, solo muestra cómo recuperar una ruta de acceso física desde dentro de una clase que no está en el archivo de código subyacente.  
  
 [!code-csharp[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.mappath/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.MapPath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.mappath/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El <see cref="T:System.Web.HttpContext" /> actual es <see langword="null" />.
        
O bien 
        
<paramref name="path" /> es una ruta de acceso física, pero se esperaba una ruta de acceso virtual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScriptTimeout">
      <MemberSignature Language="C#" Value="public int ScriptTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScriptTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpServerUtility.ScriptTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ScriptTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScriptTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene y establece el valor de tiempo de espera de las solicitudes, en segundos.</summary>
        <value>Valor de tiempo de espera de las solicitudes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> propiedad puede establecerse en el archivo Web.config estableciendo el `executionTimeout` atributo del elemento. Establecer el tiempo de espera mediante programación con el <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> propiedad tiene prioridad sobre la configuración de Web.config.  
  
> [!NOTE]
>  Si establece la `debug` atributo del elemento a `true` en el archivo Web.config, el valor de <xref:System.Web.HttpServerUtility.ScriptTimeout%2A> se pasará por alto.  
  
   
  
## Examples  
 En el ejemplo siguiente se establece el período de tiempo de espera de solicitud en 60 segundos.  
  
 [!code-csharp[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.ScriptTimeout Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.ScriptTimeout Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El <see cref="T:System.Web.HttpContext" /> actual es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">El período de tiempo de espera es <see langword="null" /> o, de lo contrario, no se pudo establecer.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Transfer">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Finaliza la ejecución de la página actual e inicia la ejecución de una nueva página para la solicitud actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la nueva página en el servidor que se va a ejecutar.</param>
        <summary>En el caso de la solicitud actual, finaliza la ejecución de la página actual e inicia la ejecución de una nueva página mediante la dirección URL de la página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La página que se transfieren a debe ser otra página aspx. Por ejemplo, una transferencia a una página .asp o .asmx no es válida. El <xref:System.Web.HttpServerUtility.Transfer%2A> método conserva el <xref:System.Web.HttpRequest.QueryString%2A> y <xref:System.Web.HttpRequest.Form%2A> colecciones.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> llamadas <xref:System.Web.HttpResponse.End%2A>, que produce una <xref:System.Threading.ThreadAbortException> excepción tras la finalización.  
  
 ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad de su aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpResponse.Redirect%2A> método realiza un redireccionamiento de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad de Internet Information Services (IIS) y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Transfer%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la nueva página en el servidor que se va a ejecutar.</param>
        <param name="preserveForm">
          <see langword="true" /> para conservar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Finaliza la ejecución de la página actual e inicia la ejecución de una nueva página mediante la dirección URL de la página. Especifica si borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La página que se transfieren a debe ser otra página aspx. Por ejemplo, una transferencia a una página .asp o .asmx no es válida.  
  
 <xref:System.Web.HttpServerUtility.Transfer%2A> llamadas <xref:System.Web.HttpResponse.End%2A>, que produce una <xref:System.Threading.ThreadAbortException> excepción tras la finalización.  
  
 Si establece la `preserveForm` parámetro `true`, la página de destino podrán tener acceso al estado de vista de la página anterior mediante el <xref:System.Web.UI.Page.PreviousPage%2A> propiedad.  
  
 Por motivos de seguridad, debe mantener la `enableViewStateMac` atributo establecido en `true`. ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método y no se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad de su aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpResponse.Redirect%2A> método realiza un redireccionamiento de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad de Internet Information Services (IIS) y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Transfer%2A> método.  
  
   
  
## Examples  
 En el ejemplo siguiente se ejecuta una nueva página en el mismo directorio que la página actual.  
  
 [!code-csharp[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.Transfer Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.Transfer Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La solicitud de página actual es una devolución de llamada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transfer">
      <MemberSignature Language="C#" Value="public void Transfer (System.Web.IHttpHandler handler, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Transfer(class System.Web.IHttpHandler handler, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.Transfer(System.Web.IHttpHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Transfer (handler As IHttpHandler, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Transfer(System::Web::IHttpHandler ^ handler, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler">Controlador HTTP que implementa la interfaz <see cref="T:System.Web.IHttpHandler" /> a la que se va a transferir la solicitud actual.</param>
        <param name="preserveForm">
          <see langword="true" /> para conservar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar las colecciones <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Finaliza la ejecución de la página actual e inicia la ejecución de una nueva solicitud utilizando un controlador HTTP personalizado que implementa la interfaz <see cref="T:System.Web.IHttpHandler" />, y especifica si se deben borrar las colecciones de <see cref="P:System.Web.HttpRequest.QueryString" /> y <see cref="P:System.Web.HttpRequest.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede escribir controladores HTTP personalizados para procesar tipos predefinidos y específicos de solicitudes HTTP en cualquier lenguaje que sea compatible con Common Language Specification (CLS). Código ejecutable que se define en las clases de controlador HTTP en lugar de las páginas ASP (también conocido como ASP clásico) convencionales o páginas ASP.NET responde a estas solicitudes específicas. Controladores HTTP permiten interactuar con los servicios de respuesta de un servidor Web que ejecuta Internet Information Services (IIS) y la solicitud de bajo nivel, y proporcionan una funcionalidad similar a las extensiones ISAPI pero con un modelo de programación más simple.  
  
 Si establece la `preserveForm` parámetro `true`, la página de destino podrán tener acceso al estado de vista de la página anterior mediante el <xref:System.Web.UI.Page.PreviousPage%2A> propiedad.  
  
 Por motivos de seguridad, debe mantener la `enableViewStateMac` atributo establecido en `true`. ASP.NET no comprueba que el usuario actual está autorizado para ver el recurso entregado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método. Aunque la lógica de autenticación y autorización de ASP.NET se ejecuta antes de que se llama al controlador de recursos original, ASP.NET llama directamente al controlador indicado por el <xref:System.Web.HttpServerUtility.Transfer%2A> método y hace que se vuelva a ejecutar la lógica de autenticación y autorización para el nuevo recurso. Si la directiva de seguridad para la aplicación requiere que los clientes tengan la autorización adecuada para tener acceso al recurso, la aplicación debe forzar vuelva a autorizarla o proporcionan un mecanismo de control de acceso personalizado.  
  
 Puede forzar vuelva a autorizarla mediante la <xref:System.Web.HttpResponse.Redirect%2A> en lugar del método la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpResponse.Redirect%2A> método realiza un redireccionamiento de cliente en el que el explorador solicita el nuevo recurso. Dado que esta redirección es una nueva solicitud entren en el sistema, se somete a la lógica de autenticación y autorización de directiva de seguridad IIS y ASP.NET.  
  
 Puede comprobar que el usuario tiene permiso para ver el recurso mediante la incorporación de un método de autorización personalizado que utiliza el <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A> método antes de la aplicación llama el <xref:System.Web.HttpServerUtility.Transfer%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">La solicitud de página actual es una devolución de llamada.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransferRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza una ejecución asincrónica de la dirección URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> se introdujo en la versión 3.5 de .NET Framework. Para información de resumen acerca de .NET Framework, vea [versiones y dependencias de](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la nueva página en el servidor que se va a ejecutar.</param>
        <summary>Realiza una ejecución asincrónica de la dirección URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llama a esta sobrecarga del método la <xref:System.Web.HttpServerUtility.TransferRequest%2A> se puede sobrecargar con el `preserveForm` parámetro establecido en `false`, `method` parámetro establecido en `null`, el `headers` parámetro establecido en `null`y el `preserveUser` parámetro establecido en `true`. Para obtener más información, vea la sección "Comentarios" en <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29> sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La solicitud requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">El servidor no está disponible para atender la solicitud.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la nueva página en el servidor que se va a ejecutar.</param>
        <param name="preserveForm">
          <see langword="true" /> para preservar la colección <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar la colección <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <summary>Realiza una ejecución asincrónica de la dirección URL especificada y conserva los parámetros de cadena de consulta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga llama a la <xref:System.Web.HttpServerUtility.TransferRequest%2A> se puede sobrecargar con el `preserveForm` parámetro establecido en el valor pasado en, el `method` parámetro establecido en `null`, el `headers` parámetro establecido en `null`y el `preserveUser` parámetro establecido en `true`. Para obtener más información, vea la sección "Comentarios" en <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 <xref:System.Web.HttpServerUtility.TransferRequest%2A> se introdujo en la versión 3.5 de .NET Framework.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La solicitud requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">El servidor no está disponible para atender la solicitud.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la nueva página en el servidor que se va a ejecutar.</param>
        <param name="preserveForm">
          <see langword="true" /> para preservar la colección <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar la colección <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Método HTTP que se va a usar en la ejecución de la nueva solicitud.</param>
        <param name="headers">
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> de encabezados de solicitud para la nueva solicitud.</param>
        <summary>Realiza una ejecución asincrónica de la dirección URL especificada mediante el método y los encabezados HTTP especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza cuando se ejecuta con el modo de canalización integrada en [!INCLUDE[iisver](~/includes/iisver-md.md)] para permitir el procesamiento de la solicitud ser transferidos desde un tipo de recurso a otro durante la ejecución de la solicitud de destino con el contexto de solicitud correcto. Por ejemplo, puede usar el <xref:System.Web.HttpServerUtility.TransferRequest%2A> método para transferir una solicitud para una página ASPX a una solicitud de una página XML.  
  
 El <xref:System.Web.HttpServerUtility.TransferRequest%2A> método realiza una ejecución secundaria asincrónica de la dirección URL especificada con las condiciones siguientes:  
  
-   Si el `path` parámetro especifica una cadena de consulta, se utilizará como la nueva cadena de consulta. Si no se incluye ninguna cadena de consulta, la cadena de consulta de la solicitud se puede volver a usar.  
  
-   Si el `method` se especifica el parámetro, se utilizará. Si es `null`, se usará el método HTTP de la solicitud original.  
  
-   Si el `preserveForm` parámetro es `true`, el cuerpo de la entidad actual de la solicitud estará disponible para la solicitud de destino. Esto permite que los envíos de formularios y carga se va a transferir.  
  
-   Si la identidad del usuario está establecida actualmente en la solicitud original, la identidad se transferirán a la nueva solicitud. Esto permite que las solicitudes autenticadas volver a usar el resultado de la autenticación para la nueva solicitud. Si no desea que el usuario se transfiera, Establece el usuario en `null` en la solicitud original antes de transferir.  
  
-   Si el `headers` se especifica el parámetro, la nueva solicitud se ejecutará con los encabezados especificados. Esto puede utilizarse para modificar los encabezados de solicitud y las cookies para la nueva solicitud, o agrega un encabezado especial que especifica donde se recibió la solicitud original.  
  
     Este método llama a la <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%2CSystem.Boolean%29> sobrecarga del método con el `preserveUser` parámetro establecido en `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La solicitud requiere que [!INCLUDE[iisver](~/includes/iisver-md.md)] se ejecute en modo integrado.</exception>
        <exception cref="T:System.Web.HttpException">El servidor no está disponible para atender la solicitud.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferRequest">
      <MemberSignature Language="C#" Value="public void TransferRequest (string path, bool preserveForm, string method, System.Collections.Specialized.NameValueCollection headers, bool preserveUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransferRequest(string path, bool preserveForm, string method, class System.Collections.Specialized.NameValueCollection headers, bool preserveUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.TransferRequest(System.String,System.Boolean,System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransferRequest (path As String, preserveForm As Boolean, method As String, headers As NameValueCollection, preserveUser As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransferRequest(System::String ^ path, bool preserveForm, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers, bool preserveUser);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="preserveForm" Type="System.Boolean" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
        <Parameter Name="preserveUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">La ruta de acceso.</param>
        <param name="preserveForm">
          <see langword="true" /> para preservar la colección <see cref="P:System.Web.HttpRequest.Form" />; <see langword="false" /> para borrar la colección <see cref="P:System.Web.HttpRequest.Form" />.</param>
        <param name="method">Método HTTP que va a usarse en la nueva solicitud.</param>
        <param name="headers">Objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> que contiene los encabezados de solicitud para la nueva solicitud.</param>
        <param name="preserveUser">
          <see langword="true" /> para conservar la identidad del usuario; si no, <see langword="false" />. Otras sobrecargas de este método llaman a esta sobrecarga con este parámetro establecido en <see langword="true" />.</param>
        <summary>Realiza una ejecución asincrónica de la dirección URL especificada mediante el método, los encabezados y la ruta de acceso HTTP indicados, y conserva opcionalmente los valores del formulario y la identidad del usuario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información, vea la sección "Comentarios" en <xref:System.Web.HttpServerUtility.TransferRequest%28System.String%2CSystem.Boolean%2CSystem.String%2CSystem.Collections.Specialized.NameValueCollection%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La solicitud requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)].</exception>
        <exception cref="T:System.Web.HttpException">El servidor no está disponible para atender la solicitud.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="path" /> no es válido.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlDecode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Descodifica una cadena que se codificó para su transmisión a través de HTTP y después se envió al servidor en una dirección URL.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <see cref="T:System.Net.WebUtility" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public string UrlDecode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlDecode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlDecode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlDecode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena de texto que se va a descodificar.</param>
        <summary>Descodifica mediante URL una cadena y devuelve la cadena descodificada.</summary>
        <returns>Texto descodificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de direcciones URL asegura que todos los exploradores transmitirán correctamente el texto de las cadenas de dirección URL. Caracteres como el signo de interrogación (?), "y" comercial (&), la barra diagonal (/) de marcar y espacios pueden truncar o dañados por algunos exploradores. Como resultado, estos caracteres deben codificarse en `<a>` etiquetas o en la consulta de cadenas donde las cadenas pueden enviarse volver a un explorador en una cadena de solicitud.  
  
 Este método es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, este método utiliza <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> para descodificar las cadenas.  
  
 En el archivo de código subyacente de una página web ASP.NET, tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase a través de la `Server` propiedad. En una clase que no está en un archivo de código subyacente, utilice `HttpContext.Current.Server` para tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase.  
  
 Fuera de una aplicación web, use la <xref:System.Net.WebUtility> clase para codificar o descodificar valores.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo descodificar a la dirección URL de un valor que se recuperan de la cadena de consulta. El código reside en el archivo de código subyacente para una página web. `ReturnPage` hace referencia a un `HyperLink` control.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/default.aspx.vb#1)]  
  
 El ejemplo siguiente es similar al ejemplo anterior, solo muestra cómo descodificar de dirección URL de un valor dentro de una clase que no está en el archivo de código subyacente.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlDecode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urldecode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlDecode">
      <MemberSignature Language="C#" Value="public void UrlDecode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlDecode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlDecode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlDecode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlDecode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Cadena HTML que se va a descodificar.</param>
        <param name="output">Flujo de salida de <see cref="T:System.IO.TextWriter" /> que contiene la cadena descodificada.</param>
        <summary>Descodifica una cadena HTML recibida en una dirección URL y envía el resultado a un flujo de salida de <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de direcciones URL asegura que todos los exploradores transmitirán correctamente el texto de las cadenas de dirección URL. Caracteres como el signo de interrogación (?), "y" comercial (&), la barra diagonal (/) de marcar y espacios pueden truncar o dañados por algunos exploradores. Como resultado, estos caracteres deben codificarse en `<a>` etiquetas o en la consulta de cadenas donde las cadenas pueden enviarse volver a un explorador en una cadena de solicitud.  
  
 <xref:System.Web.HttpServerUtility.UrlDecode%2A> es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlDecode%2A> utiliza <xref:System.Web.HttpUtility.UrlDecode%2A?displayProperty=nameWithType> para descodificar las cadenas.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 En el ejemplo siguiente, se descodifica la cadena denominada `EncodedString` (recibida en una dirección URL) en la cadena denominada `DecodedString`.  
  
 [!code-csharp[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlDecode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlDecode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UrlEncode">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Codifica una cadena para una transmisión HTTP segura desde el servidor web hasta el cliente a través de la dirección URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utiliza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> para codificar las cadenas.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <xref:System.Net.WebUtility>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public string UrlEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Texto que se va a codificar con una dirección URL.</param>
        <summary>Codifica mediante URL una cadena y devuelve la cadena codificada.</summary>
        <returns>Texto con código URL.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de direcciones URL asegura que todos los exploradores transmitirán correctamente el texto de las cadenas de dirección URL. Caracteres como el signo de interrogación (?), "y" comercial (&), la barra diagonal (/) de marcar y espacios pueden truncar o dañados por algunos exploradores. Como resultado, estos caracteres deben codificarse en `<a>` etiquetas o en la consulta de cadenas donde las cadenas pueden enviarse volver a un explorador en una cadena de solicitud.  
  
 Este método es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, este método utiliza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> para codificar las cadenas.  
  
 En el archivo de código subyacente de una página web ASP.NET, tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase a través de la `Server` propiedad. En una clase que no está en un archivo de código subyacente, utilice `HttpContext.Current.Server` para tener acceso a una instancia de la <xref:System.Web.HttpServerUtility> clase.  
  
 Fuera de una aplicación web, use la <xref:System.Net.WebUtility> clase para codificar o descodificar valores.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo codificar a la dirección URL de un valor que se utiliza como un valor de cadena de consulta de un hipervínculo. El código reside en el archivo de código subyacente para una página web. El valor para codificar está codificado de forma rígida en este ejemplo solo pretende simplificar el ejemplo y muestran al tipo de valor que se puede codificar con URL. Por lo general, lo haría con codificación de dirección URL de un valor que recibió del usuario o de la solicitud. `NextPage` hace referencia a un `HyperLink` control.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/default.aspx.cs#1)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/default.aspx.vb#1)]  
  
 El ejemplo siguiente es similar al ejemplo anterior, solo muestra cómo codificar dirección URL un valor dentro de una clase que no está en el archivo de código subyacente.  
  
 [!code-csharp[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/cs/sampleclass.cs#2)]
 [!code-vb[System.Web.HttpServerUtility.UrlEncode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.web.httpserverutility.urlencode/vb/sampleclass.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlEncode">
      <MemberSignature Language="C#" Value="public void UrlEncode (string s, System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UrlEncode(string s, class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlEncode(System.String,System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UrlEncode (s As String, output As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UrlEncode(System::String ^ s, System::IO::TextWriter ^ output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="s">Cadena de texto que se va a codificar.</param>
        <param name="output">Flujo de salida de <see cref="T:System.IO.TextWriter" /> que contiene la cadena codificada.</param>
        <summary>Codifica mediante URL una cadena y envía el resultado a un flujo de salida de <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificación de direcciones URL asegura que todos los exploradores transmitirán correctamente el texto de las cadenas de dirección URL. Caracteres como el signo de interrogación (?), "y" comercial (&), la barra diagonal (/) de marcar y espacios pueden truncar o dañados por algunos exploradores. Como resultado, estos caracteres deben codificarse en `<a>` etiquetas o en la consulta de cadenas donde las cadenas pueden enviarse volver a un explorador en una cadena de solicitud.  
  
 <xref:System.Web.HttpServerUtility.UrlEncode%2A> es una forma cómoda de obtener acceso a la <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> método en tiempo de ejecución desde una aplicación ASP.NET. Internamente, <xref:System.Web.HttpServerUtility.UrlEncode%2A> utiliza <xref:System.Web.HttpUtility.UrlEncode%2A?displayProperty=nameWithType> para codificar las cadenas.  
  
 Para codificar o descodificar valores fuera de una aplicación web, use la clase <xref:System.Net.WebUtility>.  
  
   
  
## Examples  
 En el ejemplo siguiente se codifica una cadena para la transmisión HTTP. Codifica la cadena denominada `TestString`, que contiene el texto "se trata de un \<Test String >." y lo copia en la cadena denominada `EncodedString` como "Este + es una + % 3cTest + String % 3e.".  
  
 [!code-csharp[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpServerUtility.UrlEncode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpServerUtility.UrlEncode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlPathEncode">
      <MemberSignature Language="C#" Value="public string UrlPathEncode (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string UrlPathEncode(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlPathEncode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function UrlPathEncode (s As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ UrlPathEncode(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Texto que se va a codificar con una dirección URL.</param>
        <summary>No usar; diseñado solo para la compatibilidad con el explorador. Use <see cref="M:System.Web.HttpServerUtility.UrlEncode(System.String)" />.</summary>
        <returns>Texto codificado con una dirección URL.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UrlTokenDecode">
      <MemberSignature Language="C#" Value="public static byte[] UrlTokenDecode (string input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] UrlTokenDecode(string input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenDecode (input As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ UrlTokenDecode(System::String ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">Token de cadena de dirección URL que se va a descodificar.</param>
        <summary>Descodifica un token de cadena de dirección URL en su matriz de bytes equivalente utilizando dígitos de base 64.</summary>
        <returns>Matriz de bytes que contiene el token de cadena de dirección URL descodificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> método convierte un token de cadena de dirección URL, que codifica los datos binarios como dígitos en base 64, en su representación de matriz de bytes equivalente. Use la <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> método descodificar tokens transmitida en la dirección URL y codificados mediante el <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A>.  
  
 El <xref:System.Web.HttpServerUtility.UrlTokenDecode%2A> método devolverá una matriz de bytes vacía si el `input` parámetro tiene una longitud inferior a uno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="input" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="UrlTokenEncode">
      <MemberSignature Language="C#" Value="public static string UrlTokenEncode (byte[] input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UrlTokenEncode(unsigned int8[] input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpServerUtility.UrlTokenEncode(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UrlTokenEncode (input As Byte()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UrlTokenEncode(cli::array &lt;System::Byte&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="input">Matriz de bytes que se va a codificar.</param>
        <summary>Codifica una matriz de bytes en su representación de cadena equivalente mediante dígitos de base 64, lo que permite su transmisión en la dirección URL.</summary>
        <returns>Cadena que contiene el token codificado si la *longitud* de la matriz de bytes es mayor que uno; de lo contrario, una cadena vacía ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> método convierte una matriz de bytes en una representación de cadena equivalente codificada con dígitos de base 64. El token de cadena resultante se puede transmitir en la dirección URL.  
  
 El <xref:System.Web.HttpServerUtility.UrlTokenEncode%2A> devolverá una cadena vacía si el `input` parámetro tiene una longitud inferior a uno.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor del parámetro <paramref name="input" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Convert.ToBase64String(System.Byte[])" />
        <altmember cref="M:System.Web.HttpServerUtility.UrlTokenDecode(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>