<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9894bbaba80ad2a849c8969ac12ac02519aa6b4e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37586930" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Encapsulates HTTP-response information from an ASP.NET operation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos y propiedades de la <xref:System.Web.HttpResponse> clase se exponen a través de la <xref:System.Web.HttpApplication.Response%2A> propiedad de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 Los métodos siguientes de la <xref:System.Web.HttpResponse> clase solo se admiten en escenarios de devolución y no en la publicación asincrónica hacer una copia de escenarios:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Actualizaciones parciales de página se habilitan cuando se usa <xref:System.Web.UI.UpdatePanel> controles para actualizar regiones seleccionadas de una página en lugar de actualizar toda la página con una devolución de datos. Para obtener más información, consulte [información general del Control UpdatePanel](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) y [información general de representación de página parcial](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 En el ejemplo siguiente se dibuja tres rectángulos superpuestos cuando se solicita la página. El código comienza con la configuración del <xref:System.Web.HttpResponse.ContentType%2A> propiedad en image/jpeg, para que toda la página se representará como una imagen JPEG. El código, a continuación, llama a la <xref:System.Web.HttpResponse.Clear%2A> método para asegurarse de que no se envía ningún contenido extraño con esta respuesta. A continuación, el código establece el <xref:System.Web.HttpResponse.BufferOutput%2A> propiedad en true para que la página se procesa por completo antes de enviarla al cliente solicitante. A continuación, se crean dos objetos que se usa para dibujar los rectángulos: un <xref:System.Drawing.Bitmap> y un <xref:System.Drawing.Graphics> objeto. Las variables creadas en la página sirven como coordenadas para dibujar los rectángulos y una cadena que aparece dentro del rectángulo más grande.  
  
 Cuando se dibujan los tres rectángulos y la cadena que aparece dentro de ellos, el <xref:System.Drawing.Bitmap> se guarda en el <xref:System.IO.Stream> objeto que está asociado el <xref:System.Web.HttpResponse.OutputStream%2A> propiedad y su formato se establece en JPEG. El código llama a la <xref:System.Drawing.Image.Dispose%2A> y <xref:System.Drawing.Graphics.Dispose%2A> métodos para liberar los recursos utilizados por los dos objetos de dibujos. Por último, el código llama a la <xref:System.Web.HttpResponse.Flush%2A> método envíe la respuesta almacenada en búfer al cliente solicitante.  
  
> [!NOTE]
>  En el código, el <xref:System.Web.HttpResponse> es hacer referencia al objeto mediante la palabra clave `Response`. Por ejemplo, `Response.Clear()` hace referencia a la <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> método. El <xref:System.Web.UI.Page> clase tiene una propiedad que se denomina <xref:System.Web.UI.Page.Response%2A> que expone la instancia actual de <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> object that enables custom HTTP output.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Web.HttpResponse" /> class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro admite la infraestructura de .NET Framework y no está prevista su utilización directa desde el código.  
  
 Los métodos y propiedades de la <xref:System.Web.HttpResponse> clase se exponen a través de la función intrínseca <xref:System.Web.HttpContext.Response%2A> objeto en ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">A file, cache key, or <see cref="T:System.Web.Caching.CacheDependency" /> to add to the list of application dependencies.</param>
        <summary>Associates a set of cache dependencies with the response to facilitate invalidation of the response if it is stored in the output cache and the specified dependencies change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.AddCacheDependency%2A> método permite que las dependencias se creen entre respuestas almacenadas en caché y un <xref:System.Web.Caching.CacheDependency> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear una dependencia de caché mediante el uso de la <xref:System.Web.HttpResponse.AddCacheDependency%2A> método y un <xref:System.Web.Caching.CacheDependency> objeto.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="dependencies" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">This method was called too late in the cache processing pipeline, after the cached response was already created.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Makes the validity of a cached response dependent on other items in the cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">The <see cref="T:System.Collections.ArrayList" /> that contains the keys of the items that the current cached response is dependent upon.</param>
        <summary>Makes the validity of a cached response dependent on other items in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando lo hace referencia en el `cacheKeys` parámetro se quitan de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar una página ASP.NET que se almacena en caché de resultados. El código de la página se crea un <xref:System.Collections.ArrayList> objeto de claves que están asociados con los elementos que se almacenan en la <xref:System.Web.Caching.Cache> objeto. A continuación, el código pasa el <xref:System.Collections.ArrayList> como parámetro en una llamada a la <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> método. Esto hace que la respuesta en caché de salida no es válido si alguno de los archivos especificados en el <xref:System.Collections.ArrayList> cambiar.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">An array of item keys that the cached response is dependent upon.</param>
        <summary>Makes the validity of a cached item dependent on another item in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando cualquiera de los `cacheKey`s se quitan de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">The key of the item that the cached response is dependent upon.</param>
        <summary>Makes the validity of a cached response dependent on another item in the cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el elemento correspondiente a la `cacheKey` parámetro se quita de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
   
  
## Examples  
 El ejemplo siguiente es un control de usuario ASP.NET que se almacena en caché de resultados. El código para el control llama a la <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> método con la clave de un elemento almacenado en la <xref:System.Web.Caching.Cache> objeto pasado como parámetro. Si el elemento no existe en la memoria caché, se invalida la respuesta del control que se almacenó en la caché de resultados. Esto significa que en las solicitudes posteriores, una nueva versión de la respuesta del control se agregará a la caché de resultados.  
  
 A continuación, el código comprueba si un elemento asociado a un `bookData` clave se almacena en el `Cache` de objetos y muestra uno de dos líneas de texto, según el resultado. A continuación, el código establece la <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> propiedad de un <xref:System.Web.UI.WebControls.DataGrid> control, que se denomina `dgBooks`, con una llamada a una personalizada `DataHelper` comparte clase `GetBookData` método y rellena la <xref:System.Web.UI.WebControls.DataGrid> con el <xref:System.Web.UI.Control.DataBind%2A> método.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds a group of file names to the collection of file names on which the current response is dependent.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">The collection of files to add.</param>
        <summary>Adds a group of file names to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que se almacena en caché de resultados. Crea el código de la página una <xref:System.Collections.ArrayList> de rutas de acceso de archivo y, a continuación, pasa el <xref:System.Collections.ArrayList> como parámetro en una llamada a la <xref:System.Web.HttpResponse.AddFileDependencies%2A> método. Esto hace que la salida de la respuesta almacenada en caché no válido si alguno de los archivos especificados en el <xref:System.Collections.ArrayList> los cambios.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">An array of files to add.</param>
        <summary>Adds an array of file names to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se agrega una matriz de nombres de archivo para el <xref:System.Web.HttpResponse.AddFileDependencies%2A> lista de dependencias de archivo. Si cambia los archivos, se invalida la respuesta almacenada en caché.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to add.</param>
        <summary>Adds a single file name to the collection of file names on which the current response is dependent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el <xref:System.Web.HttpResponse.AddFileDependency%2A> método para agregar una dependencia de archivo, también debe especificar mediante programación o mediante declaración la caché de resultados. Por ejemplo, para especificar mediante declaración la caché de resultados, use la directiva. Para obtener más información, consulte [Cómo: caché de resultados de página con las dependencias de archivo](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo agregar un nombre de archivo único para el <xref:System.Web.HttpResponse.AddFileDependency%2A> lista de dependencias de archivo. Si el archivo cambia, se invalida la respuesta almacenada en caché.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the HTTP header to add <c>value</c> to.</param>
        <param name="value">The string to add to the header.</param>
        <summary>Adds an HTTP header to the output stream. <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> is provided for compatibility with earlier versions of ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> es el mismo que <xref:System.Web.HttpResponse.AppendHeader%2A> y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">The callback method.</param>
        <summary>[Supported in the .NET Framework 4.5.2 and later versions]  Registers a callback that the ASP.NET runtime will invoke immediately before response headers are sent for this request.</summary>
        <returns>An <see cref="T:System.Web.ISubscriptionToken" /> object that represents the subscription to the OnSendingHeaders pseudo-event.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  No se invoca el método AddOnSendingHeaders si la respuesta vacía el módulo nativo en primer lugar.  
  
 El Pseudoevento onsendingheaders difiere de los eventos de canalización IHttpModule, que se trata de una suscripción por solicitud en lugar de una suscripción por aplicación. La intención es que la devolución de llamada puede modificar el código de estado de respuesta o puede establecer un encabezado o la cookie de respuesta. Otras notas de uso y advertencias:  
  
-   Este método es eficaz solo cuando IIS se ejecuta en la canalización de modo de canalización integrada y solo si los encabezados de respuesta aún no han sido enviados para la solicitud actual.  
  
-   El tiempo de ejecución ASP.NET no garantiza nada sobre el subproceso que invoca la devolución de llamada. Por ejemplo, la devolución de llamada se puede invocar sincrónica en un subproceso en segundo plano si se realiza un vaciado en segundo plano. <xref:System.Web.HttpContext.Current%2A> no se garantiza que esté disponible en un subproceso.  
  
-   La devolución de llamada no debe llamar a cualquier método que manipula el cuerpo de respuesta de la entidad o que da como resultado un vaciado. Por ejemplo, no debe llamar la devolución de llamada <xref:System.Web.HttpResponse.Redirect%2A>, ya que ese método puede manipular el cuerpo de respuesta de la entidad.  
  
-   La devolución de llamada debe contener sólo código sincrónico de ejecución breve. Se intentó invocar una operación asincrónica o esperar en esta operación podría provocar un interbloqueo.  
  
-   La devolución de llamada no debe producir una excepción; en caso contrario, el comportamiento es indefinido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">The <see cref="T:System.Web.HttpCookie" /> to add to the output stream.</param>
        <summary>Adds an HTTP cookie to the intrinsic cookie collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea una nueva cookie denominada `LastVisit`, Establece el valor de la cookie en la fecha y hora actuales y anexa la cookie a la colección de cookies actual. Todas las cookies de la colección de cookies se envían al cliente en el `Set-Cookie` encabezado HTTP con el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A cookie is appended after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the HTTP header to add to the output stream.</param>
        <param name="value">The string to append to the header.</param>
        <summary>Adds an HTTP header to the output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usas el <xref:System.Web.HttpResponse.AppendHeader%2A> método envíe encabezados específicos de la memoria caché y al mismo tiempo, usar el modelo de objetos de caché (<xref:System.Web.HttpResponse.Cache%2A>) para establecer la directiva de caché, los encabezados de respuesta HTTP que pertenecen al almacenamiento en caché (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, y `Vary`) podría eliminarse cuando se usa el modelo de objetos de caché. Este comportamiento permite a ASP.NET mantener la configuración más restrictiva. Por ejemplo, considere la posibilidad de una página que incluye controles de usuario. Si esos controles tienen directivas de caché en conflicto, se usará la directiva de caché más restrictiva. Si un control de usuario establece el encabezado "`Cache-Control: Public`"y otro control de usuario establece el encabezado más restrictivo"`Cache-Control: Private`" a través de llamadas a <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, el "`Cache-Control: Private`" se enviará el encabezado con la respuesta.  
  
 Para obtener una lista de encabezados HTTP/1.1 estándar, consulte la sección 14, "Definiciones de campo de encabezado", en el [Hypertext Transfer Protocol--HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) especificación en el sitio Web de World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Web.HttpResponse.AppendHeader%2A> método para agregar un encabezado personalizado a la <xref:System.Web.HttpResponse> objeto enviado al cliente solicitante.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The header is appended after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">The text to add to the log file.</param>
        <summary>Adds custom log information to the Internet Information Services (IIS) log file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para permitir la cadena especificada ser registrado en el archivo de registro, primero debe habilitar la **consulta URI** opción de la **propiedades de registro extendidas** cuadro de diálogo para el sitio que desea registrar la actividad para en IIS .  
  
 Para personalizar el registro extendido en IIS 6.0, siga estos pasos:  
  
1.  En el Administrador de IIS, expanda el nodo de equipo local, expanda la carpeta sitios Web o FTP, haga clic en el sitio Web o FTP y, a continuación, haga clic en **propiedades**.  
  
2.  Haga clic en el **sitio FTP o Web** pestaña y, a continuación, seleccione el **habilitar el registro** casilla de verificación (si no está ya seleccionada).  
  
3.  En el **formato de registro activo** cuadro, haga clic en **formato de archivo de registro extendido W3C**.  
  
4.  Haga clic en **propiedades**.  
  
5.  Haga clic en el **avanzadas** pestaña, seleccione las propiedades que desee iniciar y, a continuación, haga clic en **Aceptar**.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo anexar una cadena en el registro.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">The virtual path to a resource.</param>
        <summary>Adds a session ID to the virtual path if the session is using <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> session state and returns the combined path. If <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> session state is not used, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> returns the original virtual path.</summary>
        <returns>The <paramref name="virtualPath" /> with the session ID inserted.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> se usa solo con sesiones sin cookies para construir el carácter absoluto.  
  
   
  
## Examples  
 En el ejemplo siguiente se declara una variable de cadena denominada `urlConverted`y lo establece en el resultado de una <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> llamada al método. El código, a continuación, pasa el valor de la variable a un <xref:System.Web.UI.WebControls.HyperLink> del control <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> propiedad.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">The callback object.</param>
        <param name="state">The response state.</param>
        <summary>Sends the currently buffered response to the client.</summary>
        <returns>The asynchronous result object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si subyacente <xref:System.Web.HttpWorkerRequest> objeto admite operaciones asincrónicas de vaciado y se llama a este método desde un evento de módulo asincrónico o desde un controlador asincrónico, realiza la operación de vaciado asincrónica. En caso contrario, la operación de vaciado se realiza de forma sincrónica. Se admite vaciado asincrónico para IIS 6.0 y versiones posteriores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The response is already completed.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">The bytes to write to the output stream.</param>
        <summary>Writes a string of binary characters to the HTTP output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente lee un archivo de texto en un búfer y escribe el búfer en el flujo de salida HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to buffer output and send it after the complete response is finished processing.</summary>
        <value>
          <see langword="true" /> si la salida al cliente se va a almacenar en el búfer; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Buffer%2A> propiedad quedó obsoleta en favor de la <xref:System.Web.HttpResponse.BufferOutput%2A> propiedad y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to buffer output and send it after the complete page is finished processing.</summary>
        <value>
          <see langword="true" /> si la salida al cliente se va a almacenar en el búfer; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página completa procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the caching policy (such as expiration time, privacy settings, and vary clauses) of a Web page.</summary>
        <value>Objeto <see cref="T:System.Web.HttpCachePolicy" /> que contiene información sobre la directiva de caché de la respuesta actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se escribe las propiedades de la directiva de caché actual en el flujo de salida HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see langword="Cache-Control" /> HTTP header that matches one of the <see cref="T:System.Web.HttpCacheability" /> enumeration values.</summary>
        <value>Representación de cadena del valor de enumeración <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de `Private`, `Public`, y `No-Cache` son cadenas y debe incluirse entre comillas (""). Si el <xref:System.Web.HttpResponse.CacheControl%2A> propiedad está establecida en un valor que no coincide con uno de los <xref:System.Web.HttpCacheability> valores de enumeración, una <xref:System.ArgumentException> se produce. Si el <xref:System.Web.HttpResponse.CacheControl%2A> propiedad no está establecida, el almacenamiento en caché de la respuesta se establece en <xref:System.Web.HttpCacheability.NoCache>.  
  
 El `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, y <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> propiedades han quedado en desuso. En su lugar, los métodos de la <xref:System.Web.HttpCachePolicy> clase están disponibles a través de la <xref:System.Web.HttpResponse.Cache%2A> objeto intrínseco para controlar Internet Information Services (IIS) de salida de caché y las memorias caché de cliente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The string value set does not match one of the <see cref="T:System.Web.HttpCacheability" /> enumeration values.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP character set of the output stream.</summary>
        <value>Juego de caracteres HTTP del flujo de salida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Charset` propiedad puede establecerse en `null` para suprimir el HTTP `Content-Type` encabezado.  
  
   
  
## Examples  
 El ejemplo siguiente se comprueba si el juego de caracteres del flujo de salida es Centroeuropeo (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The <see langword="Charset" /> property was set after headers were sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all content output from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Clear%2A> método no borra la información de encabezado.  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página operación completada procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all content output from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.ClearContent%2A> método no borra la información de encabezado.  
  
   
  
## Examples  
 En el siguiente ejemplo se borra todo el contenido del flujo del búfer.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Clears all headers from the buffer stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Web.HttpResponse.ClearHeaders%2A> método para asegurarse de que se envía ningún encabezado con la respuesta actual. Esta técnica puede ser especialmente importante si la respuesta de ASP.NET genera una imagen, como un archivo JPEG. En este ejemplo el <xref:System.Web.HttpResponse.ContentType%2A> propiedad se establece en image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Headers are cleared after the HTTP headers have been sent.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Threading.CancellationToken" /> object that is tripped when the client disconnects.</summary>
        <value>Token de cancelación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta API es segura para subprocesos. Sin embargo, hay algunas restricciones sobre cómo se debe usar el token de cancelación. Uso de forma incorrecta puede conducir a condiciones de carrera, interbloqueos u otro comportamiento inesperado. Tenga en cuenta las siguientes directrices:  
  
-   Asegúrese de que no llame a esta API fuera de los límites de una sola solicitud, porque ASP.NET desecha el token de cancelación al final de la solicitud. No hay ninguna garantía de que el token nunca pasará a un estado cancelado antes de eliminarlas. Por ejemplo, si la solicitud finaliza sin el cliente tener desconectado, se eliminará el token sin tener en primer lugar se ha cancelado.  
  
-   No espera a la <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, ya que esto frustra el propósito de una notificación asincrónica y puede producir interbloqueos.  
  
-   No llame a la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> sobrecargas que invocarán la devolución de llamada en el original <xref:System.Threading.SynchronizationContext> objeto.  
  
-   No utilice el <xref:System.Web.HttpContext> objeto u otros objetos intrínsecos de ASP.NET de que no es segura para subprocesos desde dentro de la devolución de llamada proporcionada para el <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> método. La devolución de llamada puede estar ejecutando simultáneamente con otras ASP.NET o código de la aplicación.  
  
-   Mantenga los métodos de devolución de llamada ejecución breve y sin bloqueo.  
  
-   Hacer todo lo posible para evitar generar excepciones desde dentro de los métodos de devolución de llamada.  
  
 Esta propiedad solo se admite en Internet Information Service (IIS) 7.5 o posterior en el modo integrado. Si se invoca sin el derecho versión o una canalización con modo de IIS, un <xref:System.PlatformNotSupportedException> se produce. Para determinar la versión de IIS, use <xref:System.Web.HttpRuntime.IISVersion%2A>. Para determinar el modo de canalización, utilice <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the socket connection to a client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza la conexión al cliente de forma inesperada y no está pensado para procesar las solicitudes HTTP normal. El método envía un paquete de restablecer al cliente, lo que puede producir datos de respuesta que se almacena en búfer en el servidor, el cliente o en algún lugar entre ellos va a quitar.  
  
 Sin embargo, normalmente debe llamar a <xref:System.Web.HttpApplication.CompleteRequest%2A> en su lugar, si desea pasar a la <xref:System.Web.HttpApplication.EndRequest> eventos y enviar una respuesta al cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP character set of the output stream.</summary>
        <value>Objeto <see cref="T:System.Text.Encoding" /> que contiene información sobre el juego de caracteres de la respuesta actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Default `ContentEncoding` puede especificarse en un archivo de configuración de ASP.NET en el [globalización Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sección. Si <xref:System.Web.HttpResponse.ContentEncoding%2A> es especificado por el cliente, se reemplaza la configuración predeterminada.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una descripción legible del juego en el flujo de salida de codificación de caracteres.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Attempted to set <see cref="P:System.Web.HttpResponse.ContentEncoding" /> to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP MIME type of the output stream.</summary>
        <value>Tipo MIME HTTP del flujo de salida. El valor predeterminado es "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página operación completada procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The <see cref="P:System.Web.HttpResponse.ContentType" /> property is set to <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the response cookie collection.</summary>
        <value>Colección de cookies de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET incluye dos colecciones de cookies intrínseca. La colección que tiene acceso a través del <xref:System.Web.HttpRequest.Cookies%2A> colección de <xref:System.Web.HttpRequest> contiene cookies transmitidas por el cliente al servidor en el `Cookie` encabezado. La colección que tiene acceso a través del <xref:System.Web.HttpResponse.Cookies%2A> colección de <xref:System.Web.HttpResponse> contiene nuevas cookies creadas en el servidor y transmite al cliente en el `Set-Cookie` encabezado.  
  
 Después de agregar una cookie utilizando la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> colección, la cookie está inmediatamente disponible en el <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> colección, incluso si no se ha enviado la respuesta al cliente.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una nueva cookie denominada `LastVisit`, Establece el valor de la cookie en la fecha y hora actuales y agrega la cookie a la colección de cookies actual. Todas las cookies de la colección de cookies se envían al cliente en el `Set-Cookie` encabezado HTTP con el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables kernel caching for the current response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se admite el almacenamiento en caché de kernel, este método tiene ningún efecto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Disables IIS user-mode caching for this response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se admite el almacenamiento en caché de modo de usuario IIS, este método devuelve sin realizar ninguna acción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sends all currently buffered output to the client, stops execution of the page, and raises the <see cref="E:System.Web.HttpApplication.EndRequest" /> event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona únicamente por compatibilidad con ASP, es decir, para la compatibilidad con la tecnología de programación Web basado en COM que va precedido de ASP.NET. Si desea pasar a la <xref:System.Web.HttpApplication.EndRequest> eventos y enviar una respuesta al cliente, es preferible llamar a <xref:System.Web.HttpApplication.CompleteRequest%2A> en su lugar.  
  
 Para imitar el comportamiento de la `End` método en ASP, este método intenta generar un <xref:System.Threading.ThreadAbortException> excepción. Si este intento se realiza correctamente, se anulará el subproceso de llamada, que es perjudicial para el rendimiento del sitio. En ese caso, no hay código después de llamar a la <xref:System.Web.HttpResponse.End%2A> se ejecuta el método.  
  
 Si el <xref:System.Web.HttpResponse.End%2A> método no es capaz de generar un <xref:System.Threading.ThreadAbortException>, en su lugar se vacía los bytes de respuesta al cliente. Para hacerlo de forma sincrónica, que también puede ser perjudicial para el rendimiento del sitio.  
  
 En cualquier caso (o no un <xref:System.Threading.ThreadAbortException> excepción se genera correctamente), la canalización de respuesta se desplazará hasta el <xref:System.Web.HttpApplication.EndRequest> eventos.  
  
 El <xref:System.Web.HttpApplication.CompleteRequest%2A> método no produzca una excepción y de código después de llamar a la <xref:System.Web.HttpApplication.CompleteRequest%2A> se podría ejecutar el método. Si su intención es evitar la ejecución de código subsiguiente y la disminución del rendimiento de <xref:System.Web.HttpResponse.End%2A> es aceptable, puede llamar a <xref:System.Web.HttpResponse.End%2A> en lugar de <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">The call to <see cref="M:System.Web.HttpResponse.End" /> has terminated the current request.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">The asynchronous result object.</param>
        <summary>Completes an asynchronous flush operation.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Asynchronous flush is not supported and the <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Asynchronous flush is not supported and the <paramref name="asyncResult" /> parameter cannot be cast to a <c>FlushAsyncResult</c> object.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the number of minutes before a page cached on a browser expires. If the user returns to the same page before it expires, the cached version is displayed. <see cref="P:System.Web.HttpResponse.Expires" /> is provided for compatibility with earlier versions of ASP.</summary>
        <value>Minutos que deben transcurrir antes de que expire la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> y <xref:System.Web.HttpResponse.CacheControl%2A> propiedades han quedado en desuso en favor de los métodos de la <xref:System.Web.HttpCachePolicy> disponibles a través de la clase el <xref:System.Web.HttpResponse.Cache%2A> caché de resultados de un objeto intrínseco para controlar Internet Information Services (IIS) y almacena en caché de cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the absolute date and time at which to remove cached information from the cache. <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> is provided for compatibility with earlier versions of ASP.</summary>
        <value>Fecha y hora en que expira la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, y <xref:System.Web.HttpResponse.CacheControl%2A> propiedades han quedado en desuso en favor de los métodos de la <xref:System.Web.HttpCachePolicy> disponibles a través de la clase el <xref:System.Web.HttpResponse.Cache%2A> caché de resultados de un objeto intrínseco para controlar Internet Information Services (IIS) y almacena en caché de cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a wrapping filter object that is used to modify the HTTP entity body before transmission.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que actúa como filtro de salida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un `Stream` de objeto y establecer el <xref:System.Web.HttpResponse.Filter%2A> propiedad a la `Stream` objeto, todos los elementos HTTP salida enviado por <xref:System.Web.HttpResponse.Write%2A> pasa a través del filtro.  
  
   
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que establece el <xref:System.Web.HttpResponse.Filter%2A> propiedad a una nueva instancia de la `UpperCaseFilter` clase personalizada <xref:System.IO.Stream> clase que convierte todo el texto que se pasa a mayúsculas. La información acerca de la solicitud se guarda en un archivo de texto y, a continuación, el <xref:System.Web.HttpResponse.Filter%2A> se establece la propiedad. Una vez implementado el filtro de respuesta, el código llama a la <xref:System.Web.HttpRequest.MapPath%2A> método para obtener la ruta de acceso absoluta a un archivo de texto denominado `TestFile.txt` que actúa como el origen del contenido de la respuesta. El código, a continuación, crea un nuevo <xref:System.IO.StreamReader> objeto para leer el archivo de texto de principio a fin y, a continuación, llama a la <xref:System.Web.HttpResponse.Write%2A> método para mostrar el contenido del archivo en la página.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Filtering is not allowed with the entity.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sends all currently buffered output to the client.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obliga a todos los almacenados en búfer de salida para enviarla al cliente. El <xref:System.Web.HttpResponse.Flush%2A> método puede llamarse varias veces durante el procesamiento de la solicitud.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Drawing.Graphics.Save%2A> método para guardar un <xref:System.Drawing.Bitmap> de objeto para el <xref:System.Web.HttpResponse.OutputStream%2A> con formato propiedad y convierte la imagen a la imagen JPEG. El código, a continuación, llama a la `Dispose` método en el <xref:System.Drawing.Bitmap> objeto y un <xref:System.Drawing.Graphics> objeto, libera los recursos que estaban utilizando. A continuación, llama el <xref:System.Web.HttpResponse.Flush%2A> método para enviar el contenido de la respuesta al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The cache is flushed after the response has been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Asynchronously sends all currently buffered output to the client.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an <see cref="T:System.Text.Encoding" /> object that represents the encoding for the current header output stream.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> que contiene información sobre el juego de caracteres del encabezado actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad le permite deshabilitar o cambiar la <xref:System.Text.Encoding> objeto en un encabezado de respuesta mediante el uso de la <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, o <xref:System.Text.UTF8Encoding> objeto. El valor de codificación predeterminado es el <xref:System.Text.UTF8Encoding> clase.  
  
 Si cambias el tipo de la <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad, puede incrementar el riesgo de ciertos ataques malintencionados o causa datos confidenciales para enviarse a través del encabezado de respuesta. Ataques de inyección de encabezado pueden evitarse, en parte, dejando el <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad de una respuesta a la configuración predeterminada. Un ataque contra una aplicación vulnerable podría devolver datos confiados atrás como parte de un encabezado de respuesta. Si el <xref:System.Web.HttpResponse.HeaderEncoding%2A> está deshabilitada debido a un requisito para las líneas de continuación en un encabezado o si cualquier encabezado se construye a partir del resultado de los datos de confianza, los datos de encabezado deben validarse antes de enviarlos a la secuencia de respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The encoding value is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">The encoding value is <see cref="P:System.Text.Encoding.Unicode" />.  \- or -  The headers have already been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the collection of response headers.</summary>
        <value>
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> de encabezados de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Headers%2A> propiedad solo es compatible con la [!INCLUDE[iisver](~/includes/iisver-md.md)] modo de canalización integrada y al menos .NET Framework 3.0. Cuando se intenta tener acceso a la <xref:System.Web.HttpResponse.Headers%2A> propiedad y cualquiera de estas dos condiciones no se cumple, un <xref:System.PlatformNotSupportedException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires the integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework version 3.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supported in the .NET Framework 4.5.2 and later versions]  Gets a value indicating whether the response headers have been written.</summary>
        <value>
          <see langword="true" /> si se escribieron los encabezados de respuesta; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the client is still connected to the server.</summary>
        <value>
          <see langword="true" /> si el cliente está conectado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad devuelve `false` cuando las condiciones siguientes son verdaderas:  
  
-   Se terminó la conexión al cliente. Esto puede ocurrir si el <xref:System.Web.HttpResponse.Close%2A> se invocó el método, o si el cliente detuvo la ejecución de la página Web o se desplazó a otra página.  
  
-   El <xref:System.Web.HttpWorkerRequest> objeto que controla la solicitud es `null` o <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> devuelve del método `false`. Si un personalizado <xref:System.Web.HttpWorkerRequest> objeto administra la solicitud, el <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> método puede establecerse basándose en criterios personalizados. Por ejemplo, la solicitud de trabajo personalizada puede forzar un tiempo de espera tras un período de tiempo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad para comprobar si el cliente que solicita la página permanece conectado al servidor. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es true, el código llama a la <xref:System.Web.HttpResponse.Redirect%2A> método y el cliente verá otra página. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es false, el código llama a la <xref:System.Web.HttpResponse.End%2A> se finaliza el método y el procesamiento de páginas.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a Boolean value indicating whether the client is being transferred to a new location.</summary>
        <value>
          <see langword="true" /> si el valor del encabezado de respuesta de ubicación es diferente a la ubicación actual; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> propiedad con el <xref:System.Web.HttpResponse.RedirectLocation%2A> propiedad para probar y determinar si el URI absoluto que es transmite al cliente en el HTTP `Location` encabezado es diferente del URI actual y el nuevo URI al que se va a transferir a será.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enables output of text to the outgoing HTTP response stream.</summary>
        <value>Objeto <see cref="T:System.IO.TextWriter" /> que permite obtener una salida personalizada al cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que contiene un <xref:System.Web.UI.WebControls.TextBox> control que tiene su <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> propiedad establecida en <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Código de la página toma el texto que un usuario escribe en el <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, usa el <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método a HTML, codificar y el <xref:System.Web.HttpResponse.Output%2A> propiedad para mostrar la cadena codificada en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enables binary output to the outgoing HTTP content body.</summary>
        <value>
          <see cref="T:System.IO.Stream" /> de E/S que representa el contenido sin procesar del cuerpo de contenido HTTP saliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir de .NET Framework versión 2.0, cuando se usa el <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método de la secuencia de E/S devuelta por la <xref:System.Web.HttpResponse.OutputStream%2A> propiedad, se podrían producir las excepciones siguientes:  
  
-   <xref:System.ArgumentOutOfRangeException>, si la `offset` o `count` parámetro es negativo o si el `buffer` longitud del parámetro menos el `offset` parámetro es menor o igual que cero.  
  
-   <xref:System.ArgumentNullException>, si la `buffer` parámetro es `null`.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Drawing.Image.Save%2A> método para guardar un <xref:System.Drawing.Bitmap> de objeto para el <xref:System.Web.HttpResponse.OutputStream%2A> propiedad y convierte la imagen al formato JPEG. El código, a continuación, llama al método Dispose en el <xref:System.Drawing.Bitmap> objeto y un <xref:System.Drawing.Graphics> objeto, libera los recursos que estaban utilizando. Por último, el código llama a la <xref:System.Web.HttpResponse.Flush%2A> método para enviar el contenido de la respuesta al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> is not available.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to add to the <see langword="PICS-Label" /> header.</param>
        <summary>Appends a HTTP <see langword="PICS-Label" /> header to the output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plataforma para la selección de contenido de Internet (PICS) es un estándar de World Wide Web Consortium (W3C) para el etiquetado de contenido. PICS es esencialmente un lenguaje para crear un sistema de clasificación.  
  
 Cualquier valor puede ser una etiqueta PICS; ASP.NET no valida la etiqueta. La longitud máxima de la cadena es de 255 caracteres. Para obtener más información sobre la sintaxis y los estándares de PICS, consulte el [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que muestra una imagen. El código de página que llama a la <xref:System.Web.HttpResponse.Pics%2A> método para establecer el HTTP `PICS-Label` encabezado para la respuesta. La cadena que se pasa como parámetro para el <xref:System.Web.HttpResponse.Pics%2A> método representa una etiqueta de clasificación generada desde el sitio Web de Internet Content Rating Association (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promotes a promised object.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The URL of the push request. It should be the virtual path of the relative resource that the server wants to push to the client.</param>
        <summary>This API is to support applications sending push promises to HTTP 2.0 clients. You can find more details regarding to Http2 server push at [HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise es no determinista y las aplicaciones no deberían tener la lógica que dependa de él. Su único propósito es la ventaja de rendimiento en algunos casos. Hay muchas condiciones (protocolo e implementación) que pueden provocar para omitir completamente las solicitudes de inserción. Depende de la expectativa de fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">The URL of the push request. It should be the virtual path of the relative resource that the server wants to push to the client.</param>
        <param name="method">Http request method that would be used by the push request.</param>
        <param name="headers">Http request header that would be used by the push request.</param>
        <summary>This API is to support applications sending push promises to HTTP 2.0 clients. You can find more details regarding to Http2 server push at [HTTP/2 Specification Section 8.2: Server Push](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise es no determinista y las aplicaciones no deberían tener la lógica que dependa de él. Su único propósito es la ventaja de rendimiento en algunos casos. Hay muchas condiciones (protocolo e implementación) que pueden provocar para omitir completamente las solicitudes de inserción. Depende de la expectativa de fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirects a client to a new URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">The target location. This may be an application-relative virtual path.</param>
        <summary>Redirects a request to a new URL and specifies the new URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Web.HttpResponse.Redirect%2A> equivale a llamar a <xref:System.Web.HttpResponse.Redirect%2A> con el segundo parámetro establecido en `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> las llamadas <xref:System.Web.HttpResponse.End%2A> qué produce una <xref:System.Threading.ThreadAbortException> excepción tras la finalización. Esta excepción tiene un efecto negativo en el rendimiento de la aplicación Web. Por lo tanto, se recomienda que, en lugar de esta sobrecarga usa el <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga y pasar `false` para el `endResponse` parámetro y, a continuación, llame el <xref:System.Web.HttpApplication.CompleteRequest%2A> método. Para obtener más información, vea el método <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Para las páginas móviles, si la aplicación se basa en sesiones sin cookies o puede recibir solicitudes de dispositivos móviles que requieren sesiones sin cookies, uso una tilde (~) en una ruta de acceso puede producir en crear una nueva sesión y se pueden perder datos de la sesión. Para establecer una propiedad en un control móvil con una ruta de acceso como "~ / ruta de acceso", resolver la ruta de acceso mediante <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ruta de acceso" antes de asignarlo a la propiedad.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302. Una manera alternativa para transferir el control a otra página es la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpServerUtility.Transfer%2A> método normalmente es más eficaz porque no hace un ida y vuelta al cliente. Para obtener más información, consulte [Cómo: redirigir a los usuarios a otra página](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 El ejemplo siguiente fuerza un redireccionamiento incondicional a otro sitio Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A redirection is attempted after the HTTP headers have been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">The location of the target.</param>
        <param name="endResponse">Indicates whether execution of the current page should terminate.</param>
        <summary>Redirects a client to a new URL. Specifies the new URL and whether execution of the current page should terminate.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una dirección URL absoluta (por ejemplo, http://www.contoso.com/default.aspx) o se puede especificar una dirección URL relativa (por ejemplo, Default.aspx) para la ubicación de destino, pero algunos exploradores pueden rechazar una dirección URL relativa.  
  
 Cuando usa este método en un controlador de página para una solicitud de finalización para una página e inicie una nueva solicitud de otra página, establezca `endResponse` a `false` y, a continuación, llame a la <xref:System.Web.HttpApplication.CompleteRequest%2A> método. Si especifica `true` para el `endResponse` parámetro, este método llama a la <xref:System.Web.HttpResponse.End%2A> método para la solicitud original, que produce una <xref:System.Threading.ThreadAbortException> excepción cuando se complete. Esta excepción tiene un efecto negativo en el rendimiento de aplicaciones Web, motivo por el cual pasar `false` para el `endResponse` se recomienda el parámetro. Para obtener más información, vea el método <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Para las páginas móviles, si la aplicación se basa en sesiones sin cookies o puede recibir solicitudes de dispositivos móviles que requieren sesiones sin cookies, utilizando una tilde (~) en una ruta de acceso puede crear una nueva sesión y porque podría perder datos de la sesión. Para establecer una propiedad en un control móvil con una ruta de acceso como "~ / ruta de acceso", resolver la ruta de acceso mediante <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ruta de acceso" antes de asignarlo a la propiedad.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302. Una manera alternativa para transferir el control a otra página es la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpServerUtility.Transfer%2A> método normalmente es más eficaz porque no hace un ida y vuelta al cliente. Para obtener más información, consulte [Cómo: redirigir a los usuarios a otra página](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad para comprobar si el cliente que solicita la página permanece conectado al servidor. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es true, el código llama a la <xref:System.Web.HttpResponse.Redirect%2A> método y el cliente verá otra página. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es false, el código llama a la <xref:System.Web.HttpResponse.End%2A> se finaliza el método y el procesamiento de páginas.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> contains a newline character.</exception>
        <exception cref="T:System.Web.HttpException">A redirection is attempted after the HTTP headers have been sent.</exception>
        <exception cref="T:System.ApplicationException">The page request is the result of a callback.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the value of the HTTP <see langword="Location" /> header.</summary>
        <value>URI absoluto que se transmite al cliente en el encabezado HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar esta propiedad para especificar la dirección URL de redireccionamiento al codificar una redirección permanente con el código de respuesta HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">The HTTP headers have already been written.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a permanent redirection from a requested URL to a specified URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">The location to redirect the request to.</param>
        <summary>Performs a permanent redirection from the requested URL to the specified URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> sobrecarga del método proporciona un código de estado HTTP 301 en la respuesta e incluye la dirección URL para redirigir la solicitud. Un código de estado HTTP 301 es un código en una respuesta HTTP estándar. Indica que existe una redirección permanente, y proporciona la ubicación de redireccionamiento.  
  
 Una llamada a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> sobrecarga del método termina la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> includes a newline character (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">The location to redirect the request to.</param>
        <param name="endResponse">
          <see langword="true" /> to terminate the response; otherwise <see langword="false" />. The default is <see langword="false" />.</param>
        <summary>Performs a permanent redirection from the requested URL to the specified URL, and provides the option to complete the response.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> sobrecarga del método proporciona un código de estado HTTP 301 en la respuesta e incluye la dirección URL para redirigir la solicitud. Esta sobrecarga del método también proporciona la opción para especificar si desea finalizar o completar la respuesta una vez realizada la redirección. Un código de estado HTTP 301 es un código en una respuesta HTTP estándar. Indica que existe una redirección permanente, y proporciona la ubicación de redireccionamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="url" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> includes a newline character (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirects a request to a new URL by using route parameter values, a route name, or both.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <summary>Redirects a request to a new URL by using a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el nombre de ruta que se pasa en `routeName` a una dirección URL usando el <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Redirects a request to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método se llama para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values, a route name, or both.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el nombre de ruta que se pasa en `routeName` a una dirección URL usando el <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using the route parameter values and the name of the route that correspond to the new URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%2A> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">The name of the route.</param>
        <param name="routeValues">The route parameter values.</param>
        <summary>Performs a permanent redirection from a requested URL to a new URL by using route parameter values and a route name.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No route corresponds to the specified route parameters.</exception>
        <exception cref="T:System.Web.HttpException">Redirection was attempted after the HTTP headers had been sent.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Removes cached items from the output cache by using the default output-cache provider.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The virtual absolute path to the items that are removed from the cache.</param>
        <summary>Removes from the cache all cached items that are associated with the default output-cache provider. This method is static.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para quitar elementos de la caché de resultados que están asociados con el proveedor de caché de resultados predeterminado. Llame a la <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> método para quitar elementos de la caché de resultados que están asociados con los proveedores de caché de resultados personalizados que se especifican en el archivo de configuración del sitio Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is not an absolute virtual path.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The virtual absolute path of the items that are removed from the cache.</param>
        <param name="providerName">The provider that is used to remove the output-cache artifacts that are associated with the specified path.</param>
        <summary>Uses the specified output-cache provider to remove all output-cache items that are associated with the specified path.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para quitar elementos de la caché de resultados que están asociados con los proveedores de caché de resultados personalizados que se especifican en el archivo de configuración del sitio Web. Para quitar elementos de la caché de resultados que están asociados con el proveedor de caché de resultados predeterminado, llame a la <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> is null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> is an invalid path.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">The cookie in the collection to be updated.</param>
        <summary>Because the <b>HttpResponse.SetCookie</b> method is intended for internal use only, you should not call it in your code. Instead, you can call the <b>HttpResponse.Cookies.Set</b> method, as the following example shows.<br /> Updates an existing cookie in the cookie collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente actualiza el valor de una cookie existente.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Attempted to set the cookie after the HTTP headers were sent.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the <see langword="Status" /> line that is returned to the client.</summary>
        <value>Al establecer el código de estado, se devuelve al cliente una cadena que describe el estado de la salida HTTP. El valor predeterminado es 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> en desuso en favor de <xref:System.Web.HttpResponse.StatusDescription%2A> y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.StatusDescription%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Status is set to an invalid status code.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP status code of the output returned to the client.</summary>
        <value>Entero que representa el estado de la salida HTTP que se devuelve al cliente. El valor predeterminado es 200 (OK). Para obtener una lista de códigos de estado válidos, consulte [Http Status Codes] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba el código de estado del flujo de salida. Si el código de estado no es igual a 200, se ejecuta código adicional.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> is set after the HTTP headers have been sent.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the HTTP status string of the output returned to the client.</summary>
        <value>Cadena que describe el estado de la salida HTTP que se devuelve al cliente. El valor predeterminado es "OK". Para obtener una lista de códigos de estado válidos, consulte [Http Status Codes] (http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba la cadena de estado del flujo de salida. Si el estado no es igual a "Correcto", se ejecuta código adicional.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> is set after the HTTP headers have been sent.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The selected value has a length greater than 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value qualifying the status code of the response.</summary>
        <value>Un valor entero que representa el [! Código de estado de sub include[iisver](~/includes/iisver-MD.MD)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad sólo es compatible con el modo de canalización integrada en [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos la versión 3.0 de .NET Framework. Al establecer el <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad, el estado se registra [!INCLUDE[iisver](~/includes/iisver-md.md)] si se configura la traza de solicitudes con error. Independientemente de si se ha configurado el seguimiento, el código nunca se envía como parte de la respuesta final a la solicitud. Para obtener más información, consulte [solución de problemas no se pudo solicitudes Using Failed Request Tracing en IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad en un controlador de eventos para el <xref:System.Web.HttpApplication> instancia de la <xref:System.Web.HttpApplication.PostAuthenticateRequest> eventos. Coloque el archivo de código en la carpeta App_Code de la aplicación Web y configurar el archivo Web.config para registrar el módulo. Para obtener más información, consulte [Tutorial: crear y registrar un módulo de HTTP personalizado](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operation requires the integrated pipeline mode in [!INCLUDE[iisver](~/includes/iisver-md.md)] and at least the .NET Framework version 3.0.</exception>
        <exception cref="T:System.Web.HttpException">The status code is set after all HTTP headers have been sent.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the connection supports asynchronous flush operations.</summary>
        <value>
          <see langword="true" /> si la conexión admite operaciones de vaciado asincrónicas; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor de la <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to send HTTP content to the client.</summary>
        <value>
          <see langword="true" /> para suprimir la salida; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se comprueba si el <xref:System.Web.HttpRequest.IsSecureConnection%2A> propiedad está establecida en false. Si es así, el <xref:System.Web.HttpResponse.SuppressContent%2A> propiedad está establecida en true para detener el envío de la respuesta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Supported in the .NET Framework 4.5.2 and later versions]  Gets or sets a value indicating whether to suppress the default <c>Cache Control: private</c> header for the current HTTP response.</summary>
        <value>
          <see langword="true" /> Para suprimir el valor predeterminado <c>Cache Control: private</c> encabezado de la respuesta HTTP actual; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, ASP.NET envía una `Cache-Control: private` encabezado de respuesta, a menos que se ha especificado una directiva de caché explícita para esta respuesta. Esta propiedad permite suprimir este encabezado de respuesta predeterminada por solicitud. El encabezado todavía se puede suprimir para toda la aplicación estableciendo <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> en [httpRuntime Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) o [elemento outputCache para el almacenamiento en caché (ASP.NET Settings Schema)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Tenga cuidado al suprimir el valor predeterminado `Cache-Control: private` encabezado, como servidores proxy y otros intermediarios pueden tratar las respuestas sin este encabezado como almacenable en caché de forma predeterminada. Este tratamiento puede provocar el almacenamiento en caché accidental de información confidencial. Consulte [RFC 2616, s. 13.4](http://tools.ietf.org/html/rfc2616) para obtener más información.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether forms authentication redirection to the login page should be suppressed.</summary>
        <value>
          <see langword="true" /> si debe suprimirse el redireccionamiento de autenticación de formularios; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, la autenticación de formularios convierte códigos de estado HTTP 401 a 302 con el fin de redirigir a la página de inicio de sesión. Esto no es adecuado para ciertas clases de errores, por ejemplo, cuando la autenticación se realiza correctamente pero la autorización genera un error, o cuando la solicitud actual es una solicitud de servicio web o de AJAX. Esta propiedad proporciona una manera para suprimir el comportamiento de redirección y enviar el código de estado original al cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the specified file directly to an HTTP response output stream without buffering it in memory.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <summary>Writes the specified file directly to an HTTP response output stream, without buffering it in memory.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <param name="offset">The position in the file to begin to write to the HTTP output.</param>
        <param name="length">The number of bytes to be transmitted.</param>
        <summary>Writes the specified part of a file directly to an HTTP response output stream without buffering it in memory.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si especifica 0 como el `offset` parámetro y -1 como el `length` parámetro, se envía todo el archivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="offset" /> parameter is less than zero.  \- or -  The <paramref name="length" /> parameter is less than -1.  \- or -  The <paramref name="length" /> parameter specifies a number of bytes that is greater than the number of bytes the file contains minus the offset.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The out-of-process worker request is not supported.  \- or -  The response is not using an <see cref="T:System.Web.HttpWriter" /> object.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="offset" /> parameter is less than zero or greater than the file size.  \- or -  The <paramref name="length" /> parameter is less than -1 or greater than the value of the <paramref name="offset" /> parameter plus the file size.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies whether [!INCLUDE[iisver](~/includes/iisver-md.md)] custom errors are disabled.</summary>
        <value>
          <see langword="true" /> para deshabilitar los errores personalizados de IIS; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> propiedad solo se usa cuando la aplicación se hospeda en IIS 7.0. Cuando se ejecuta en modo clásico en IIS 7.0 el <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> es el valor de propiedad predeterminado `true`. Cuando se ejecuta en modo integrado, el <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> es el valor de propiedad predeterminado `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes information to an HTTP response output stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">The character to write to the HTTP output stream.</param>
        <summary>Writes a character to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una serie de constantes que se escriben en una página ASP.NET mediante el método Write. El código llama a esta versión del método de escritura para escribir las constantes de caracteres individuales en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The <see cref="T:System.Object" /> to write to the HTTP output stream.</param>
        <summary>Writes an <see cref="T:System.Object" /> to an HTTP response stream.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">The string to write to the HTTP output stream.</param>
        <summary>Writes a string to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas HTML generadas dinámicamente pueden presentar riesgos de seguridad si no se valida la entrada recibida desde clientes Web cuando se recibe desde un cliente o cuando se transmite a un cliente. Script malintencionado que está incrustado en entradas enviadas a un sitio Web y más adelante se escriben en un cliente puede parecer que proceden de un origen de confianza. Este riesgo de seguridad se conoce como un ataque XSS. Siempre debe validar los datos que se reciben desde un cliente cuando se transmitirá desde el sitio a los exploradores cliente.  
  
 Además, cada vez que se escribe con formato HTML cualquier dato que se recibió como entrada, debe codificar mediante una técnica como <xref:System.Web.HttpServerUtility.HtmlEncode%2A> o <xref:System.Web.HttpServerUtility.UrlEncode%2A> para evitar que se ejecute el script malintencionado. Esta técnica es útil para los datos que no se validaban cuando se recibió.  
  
 Al codificar o filtrar los datos, debe especificar un juego de caracteres para las páginas Web para que el filtro puede identificar y quitar cualquier secuencia de bytes que no pertenece a dicho conjunto (por ejemplo, las secuencias no alfanuméricas) y podría tener script malintencionado incrustado en ellos.  
  
 Para obtener más información sobre los ataques de scripting entre sitios, consulte el artículo Q252985, "Cómo para evitar Cross-Site Scripting problemas de seguridad" en el [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?LinkID=37115) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente devuelve el nombre del cliente al explorador del cliente. El <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método elimina cualquier script malintencionado y los caracteres no válidos que se han enviado en la `UserName` campo de entrada.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The character array to write.</param>
        <param name="index">The position in the character array where writing starts.</param>
        <param name="count">The number of characters to write, beginning at <c>index</c>.</param>
        <summary>Writes an array of characters to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una serie de constantes que se escriben en una página ASP.NET mediante el método Write. El código llama a esta versión del método de escritura para escribir las constantes de caracteres individuales en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output.</param>
        <summary>Writes the contents of the specified file directly to an HTTP response output stream as a file block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener literales HTML texto y controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write into a memory block.</param>
        <param name="readIntoMemory">Indicates whether the file will be written into a memory block.</param>
        <summary>Writes the contents of the specified file directly to an HTTP response output stream as a memory block.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe un archivo en la memoria.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">The file handle of the file to write to the HTTP output stream.</param>
        <param name="offset">The byte position in the file where writing will start.</param>
        <param name="size">The number of bytes to write to the output stream.</param>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener literales HTML texto y controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileHandler" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> is less than 0.  \- or -  <paramref name="size" /> is greater than the file size minus <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">The name of the file to write to the HTTP output stream.</param>
        <param name="offset">The byte position in the file where writing will start.</param>
        <param name="size">The number of bytes to write to the output stream.</param>
        <summary>Writes the specified file directly to an HTTP response output stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](http://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener texto literal y HTML los controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> is less than 0.  \- or -  <paramref name="size" /> is greater than the file size minus <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="filename" /> parameter is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">The method, user control, or object to substitute.</param>
        <summary>Allows insertion of response substitution blocks into the response, which allows dynamic generation of specified response regions for output cached responses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Web.HttpResponse.WriteSubstitution%2A> método para la sustitución posterior a la caché en las páginas en caché de resultados. Al pasar un <xref:System.Web.HttpContext> objeto a un método de devolución de llamada con un prescrita <xref:System.Web.HttpResponseSubstitutionCallback> firma, puede reemplazar el resultado almacenado en caché contenido en cualquier ubicación especificada en la caché de página. Para iniciar el reemplazo, llame a la <xref:System.Web.HttpResponse.WriteSubstitution%2A> método y pásele el método de devolución de llamada, que debe ser seguro para subprocesos y puede ser cualquiera de las siguientes:  
  
-   Un método estático en el control de usuario o página de contenedor.  
  
-   Estático o de instancia de método en otro objeto arbitrario.  
  
 En la primera solicitud a la página, el <xref:System.Web.HttpResponse.WriteSubstitution%2A> llamadas la <xref:System.Web.HttpResponseSubstitutionCallback> delegado para producir el resultado. A continuación, agrega un búfer de sustitución para la respuesta, que conserva el delegado al que llamar en solicitudes futuras. Por último, degrada del lado cliente se almacena en caché de pública a solo servidor, lo que garantiza las solicitudes futuras para la página vuelva a invocar el delegado no almacenar en caché en el cliente.  
  
> [!NOTE]
>  No se admite la sustitución posterior a la caché para un control de usuario almacenadas en caché que se aplica la caché de resultados en el nivel de control de usuario. Esto también se conoce como almacenamiento en caché. Para obtener más información, consulte [almacenamiento en caché algunas partes de una página ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The target of the <paramref name="callback" /> parameter is of type <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>