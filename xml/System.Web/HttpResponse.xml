<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="35fbae2126834b4e6884bd27e3392db3e0a9884e" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52209261" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <TypeSignature Language="F#" Value="type HttpResponse = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Encapsula la información de la respuesta HTTP de una operación ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos y propiedades de la <xref:System.Web.HttpResponse> clase se exponen a través de la <xref:System.Web.HttpApplication.Response%2A> propiedad de la <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, y <xref:System.Web.UI.UserControl> clases.  
  
 Los métodos siguientes de la <xref:System.Web.HttpResponse> clase solo se admiten en escenarios de devolución y no en la publicación asincrónica hacer una copia de escenarios:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Actualizaciones parciales de página se habilitan cuando se usa <xref:System.Web.UI.UpdatePanel> controles para actualizar regiones seleccionadas de una página en lugar de actualizar toda la página con una devolución de datos. Para obtener más información, consulte [información general del Control UpdatePanel](https://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) y [información general de representación de página parcial](https://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 En el ejemplo siguiente se dibuja tres rectángulos superpuestos cuando se solicita la página. El código comienza con la configuración del <xref:System.Web.HttpResponse.ContentType%2A> propiedad en image/jpeg, para que toda la página se representará como una imagen JPEG. El código, a continuación, llama a la <xref:System.Web.HttpResponse.Clear%2A> método para asegurarse de que no se envía ningún contenido extraño con esta respuesta. A continuación, el código establece el <xref:System.Web.HttpResponse.BufferOutput%2A> propiedad en true para que la página se procesa por completo antes de enviarla al cliente solicitante. A continuación, se crean dos objetos que se usa para dibujar los rectángulos: un <xref:System.Drawing.Bitmap> y un <xref:System.Drawing.Graphics> objeto. Las variables creadas en la página sirven como coordenadas para dibujar los rectángulos y una cadena que aparece dentro del rectángulo más grande.  
  
 Cuando se dibujan los tres rectángulos y la cadena que aparece dentro de ellos, el <xref:System.Drawing.Bitmap> se guarda en el <xref:System.IO.Stream> objeto que está asociado el <xref:System.Web.HttpResponse.OutputStream%2A> propiedad y su formato se establece en JPEG. El código llama a la <xref:System.Drawing.Image.Dispose%2A> y <xref:System.Drawing.Graphics.Dispose%2A> métodos para liberar los recursos utilizados por los dos objetos de dibujos. Por último, el código llama a la <xref:System.Web.HttpResponse.Flush%2A> método envíe la respuesta almacenada en búfer al cliente solicitante.  
  
> [!NOTE]
>  En el código, el <xref:System.Web.HttpResponse> es hacer referencia al objeto mediante la palabra clave `Response`. Por ejemplo, `Response.Clear()` hace referencia a la <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> método. El <xref:System.Web.UI.Page> clase tiene una propiedad que se denomina <xref:System.Web.UI.Page.Response%2A> que expone la instancia actual de <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpResponse : System.IO.TextWriter -&gt; System.Web.HttpResponse" Usage="new System.Web.HttpResponse writer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Objeto <see cref="T:System.IO.TextWriter" /> que permite obtener una salida HTTP personalizada.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro admite la infraestructura de .NET Framework y no está prevista su utilización directa desde el código.  
  
 Los métodos y propiedades de la <xref:System.Web.HttpResponse> clase se exponen a través de la función intrínseca <xref:System.Web.HttpContext.Response%2A> objeto en ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberSignature Language="F#" Value="member this.AddCacheDependency : System.Web.Caching.CacheDependency[] -&gt; unit" Usage="httpResponse.AddCacheDependency dependencies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Archivo, clave de caché o <see cref="T:System.Web.Caching.CacheDependency" /> que se agregará a la lista de dependencias de la aplicación.</param>
        <summary>Asocia un conjunto de dependencias de caché a la respuesta para facilitar la invalidación de la respuesta si se almacena en la caché de resultados y las dependencias especificadas cambian.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.AddCacheDependency%2A> método permite que las dependencias se creen entre respuestas almacenadas en caché y un <xref:System.Web.Caching.CacheDependency> objeto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear una dependencia de caché mediante el uso de la <xref:System.Web.HttpResponse.AddCacheDependency%2A> método y un <xref:System.Web.Caching.CacheDependency> objeto.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="dependencies" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se llamó a este método demasiado tarde en la canalización de procesamiento de memoria caché, una vez creada ya la respuesta almacenada en caché.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hace que la validez de una respuesta almacenada en caché dependa de otros elementos de la caché.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Objeto <see cref="T:System.Collections.ArrayList" /> que contiene las claves de los elementos de los que depende la respuesta actual almacenada en caché.</param>
        <summary>Hace que la validez de una respuesta almacenada en caché dependa de otros elementos de la caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando lo hace referencia en el `cacheKeys` parámetro se quitan de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar una página ASP.NET que se almacena en caché de resultados. El código de la página se crea un <xref:System.Collections.ArrayList> objeto de claves que están asociados con los elementos que se almacenan en la <xref:System.Web.Caching.Cache> objeto. A continuación, el código pasa el <xref:System.Collections.ArrayList> como parámetro en una llamada a la <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> método. Esto hace que la respuesta en caché de salida no es válido si alguno de los archivos especificados en el <xref:System.Collections.ArrayList> cambiar.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependencies : string[] -&gt; unit" Usage="httpResponse.AddCacheItemDependencies cacheKeys" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Matriz de claves de elemento de la que depende la respuesta almacenada en caché.</param>
        <summary>Hace que la validez de un elemento almacenado en caché dependa de otro elemento de la caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando cualquiera de los `cacheKey`s se quitan de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberSignature Language="F#" Value="member this.AddCacheItemDependency : string -&gt; unit" Usage="httpResponse.AddCacheItemDependency cacheKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Clave del elemento del que depende la respuesta almacenada en caché.</param>
        <summary>Hace que la validez de una respuesta almacenada en caché dependa de otro elemento de la caché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el elemento correspondiente a la `cacheKey` parámetro se quita de la memoria caché, la respuesta almacenada en caché del elemento actual no es válida.  
  
   
  
## Examples  
 El ejemplo siguiente es un control de usuario ASP.NET que se almacena en caché de resultados. El código para el control llama a la <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> método con la clave de un elemento almacenado en la <xref:System.Web.Caching.Cache> objeto pasado como parámetro. Si el elemento no existe en la memoria caché, se invalida la respuesta del control que se almacenó en la caché de resultados. Esto significa que en las solicitudes posteriores, una nueva versión de la respuesta del control se agregará a la caché de resultados.  
  
 A continuación, el código comprueba si un elemento asociado a un `bookData` clave se almacena en el `Cache` de objetos y muestra uno de dos líneas de texto, según el resultado. A continuación, el código establece la <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> propiedad de un <xref:System.Web.UI.WebControls.DataGrid> control, que se denomina `dgBooks`, con una llamada a una personalizada `DataHelper` comparte clase `GetBookData` método y rellena la <xref:System.Web.UI.WebControls.DataGrid> con el <xref:System.Web.UI.Control.DataBind%2A> método.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un grupo de nombres de archivo a la colección de nombres de archivo de la que depende la respuesta actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : System.Collections.ArrayList -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Colección de archivos que se va a agregar.</param>
        <summary>Agrega un grupo de nombres de archivo a la colección de nombres de archivo de la que depende la respuesta actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que se almacena en caché de resultados. Crea el código de la página una <xref:System.Collections.ArrayList> de rutas de acceso de archivo y, a continuación, pasa el <xref:System.Collections.ArrayList> como parámetro en una llamada a la <xref:System.Web.HttpResponse.AddFileDependencies%2A> método. Esto hace que la salida de la respuesta almacenada en caché no válido si alguno de los archivos especificados en el <xref:System.Collections.ArrayList> los cambios.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependencies : string[] -&gt; unit" Usage="httpResponse.AddFileDependencies filenames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Matriz de archivos que se va a agregar.</param>
        <summary>Agrega una matriz de nombres de archivo a la colección de nombres de archivo de la que depende la respuesta actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se agrega una matriz de nombres de archivo para el <xref:System.Web.HttpResponse.AddFileDependencies%2A> lista de dependencias de archivo. Si cambia los archivos, se invalida la respuesta almacenada en caché.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.AddFileDependency : string -&gt; unit" Usage="httpResponse.AddFileDependency filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se va a agregar.</param>
        <summary>Agrega un solo nombre de archivo a la colección de nombres de archivo de la que depende la respuesta actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se usa el <xref:System.Web.HttpResponse.AddFileDependency%2A> método para agregar una dependencia de archivo, también debe especificar mediante programación o mediante declaración la caché de resultados. Por ejemplo, para especificar mediante declaración la caché de resultados, use la directiva. Para obtener más información, consulte [Cómo: caché de resultados de página con las dependencias de archivo](https://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo agregar un nombre de archivo único para el <xref:System.Web.HttpResponse.AddFileDependency%2A> lista de dependencias de archivo. Si el archivo cambia, se invalida la respuesta almacenada en caché.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b(v=vs.100)">Almacenamiento en caché de páginas ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddHeader : string * string -&gt; unit" Usage="httpResponse.AddHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del encabezado HTTP al que se agregará <paramref name="value" />.</param>
        <param name="value">Cadena que se agregará al encabezado.</param>
        <summary>Agrega un encabezado HTTP al flujo de salida. Se proporciona <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> para ofrecer compatibilidad con versiones anteriores de ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> es el mismo que <xref:System.Web.HttpResponse.AppendHeader%2A> y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnSendingHeaders : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpResponse.AddOnSendingHeaders callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Método de devolución de llamada.</param>
        <summary>[Compatible con .NET Framework 4.5.2 y versiones posteriores] 
Registra una devolución de llamada que el runtime de ASP.NET invocará inmediatamente antes de enviar los encabezados de respuesta para esta solicitud.</summary>
        <returns>Objeto <see cref="T:System.Web.ISubscriptionToken" /> que representa la suscripción al pseudoevento OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  No se invoca el método AddOnSendingHeaders si la respuesta vacía el módulo nativo en primer lugar.  
  
 El Pseudoevento onsendingheaders difiere de los eventos de canalización IHttpModule, que se trata de una suscripción por solicitud en lugar de una suscripción por aplicación. La intención es que la devolución de llamada puede modificar el código de estado de respuesta o puede establecer un encabezado o la cookie de respuesta. Otras notas de uso y advertencias:  
  
-   Este método es eficaz solo cuando IIS se ejecuta en la canalización de modo de canalización integrada y solo si los encabezados de respuesta aún no han sido enviados para la solicitud actual.  
  
-   El tiempo de ejecución ASP.NET no garantiza nada sobre el subproceso que invoca la devolución de llamada. Por ejemplo, la devolución de llamada se puede invocar sincrónica en un subproceso en segundo plano si se realiza un vaciado en segundo plano. <xref:System.Web.HttpContext.Current%2A> no se garantiza que esté disponible en un subproceso.  
  
-   La devolución de llamada no debe llamar a cualquier método que manipula el cuerpo de respuesta de la entidad o que da como resultado un vaciado. Por ejemplo, no debe llamar la devolución de llamada <xref:System.Web.HttpResponse.Redirect%2A>, ya que ese método puede manipular el cuerpo de respuesta de la entidad.  
  
-   La devolución de llamada debe contener sólo código sincrónico de ejecución breve. Se intentó invocar una operación asincrónica o esperar en esta operación podría provocar un interbloqueo.  
  
-   La devolución de llamada no debe producir una excepción; en caso contrario, el comportamiento es indefinido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.AppendCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.AppendCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <see cref="T:System.Web.HttpCookie" /> que se va a agregar al flujo de salida.</param>
        <summary>Agrega una cookie HTTP a la colección de cookies intrínseca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea una nueva cookie denominada `LastVisit`, Establece el valor de la cookie en la fecha y hora actuales y anexa la cookie a la colección de cookies actual. Todas las cookies de la colección de cookies se envían al cliente en el `Set-Cookie` encabezado HTTP con el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La cookie se anexa después de haber enviado los encabezados HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendHeader : string * string -&gt; unit" Usage="httpResponse.AppendHeader (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del encabezado HTTP que se agregará al flujo de salida.</param>
        <param name="value">Cadena que se anexará al encabezado.</param>
        <summary>Agrega un encabezado HTTP al flujo de salida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si usas el <xref:System.Web.HttpResponse.AppendHeader%2A> método envíe encabezados específicos de la memoria caché y al mismo tiempo, usar el modelo de objetos de caché (<xref:System.Web.HttpResponse.Cache%2A>) para establecer la directiva de caché, los encabezados de respuesta HTTP que pertenecen al almacenamiento en caché (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, y `Vary`) podría eliminarse cuando se usa el modelo de objetos de caché. Este comportamiento permite a ASP.NET mantener la configuración más restrictiva. Por ejemplo, considere la posibilidad de una página que incluye controles de usuario. Si esos controles tienen directivas de caché en conflicto, se usará la directiva de caché más restrictiva. Si un control de usuario establece el encabezado "`Cache-Control: Public`"y otro control de usuario establece el encabezado más restrictivo"`Cache-Control: Private`" a través de llamadas a <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, el "`Cache-Control: Private`" se enviará el encabezado con la respuesta.  
  
 Para obtener una lista de encabezados HTTP/1.1 estándar, consulte la sección 14, "Definiciones de campo de encabezado", en el [Hypertext Transfer Protocol--HTTP/1.1](https://go.microsoft.com/fwlink/?LinkID=73147) especificación en el sitio Web de World Wide Web Consortium (W3C).  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Web.HttpResponse.AppendHeader%2A> método para agregar un encabezado personalizado a la <xref:System.Web.HttpResponse> objeto enviado al cliente solicitante.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">El encabezado se agrega cuando se han enviado los encabezados HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberSignature Language="F#" Value="member this.AppendToLog : string -&gt; unit" Usage="httpResponse.AppendToLog param" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Texto que se agregará al archivo del registro.</param>
        <summary>Agrega información de registro personalizada al archivo del registro de Internet Information Services (IIS).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para permitir la cadena especificada ser registrado en el archivo de registro, primero debe habilitar la **consulta URI** opción de la **propiedades de registro extendidas** cuadro de diálogo para el sitio que desea registrar la actividad para en IIS .  
  
 Para personalizar el registro extendido en IIS 6.0, siga estos pasos:  
  
1.  En el Administrador de IIS, expanda el nodo de equipo local, expanda la carpeta sitios Web o FTP, haga clic en el sitio Web o FTP y, a continuación, haga clic en **propiedades**.  
  
2.  Haga clic en el **sitio FTP o Web** pestaña y, a continuación, seleccione el **habilitar el registro** casilla de verificación (si no está ya seleccionada).  
  
3.  En el **formato de registro activo** cuadro, haga clic en **formato de archivo de registro extendido W3C**.  
  
4.  Haga clic en **propiedades**.  
  
5.  Haga clic en el **avanzadas** pestaña, seleccione las propiedades que desee iniciar y, a continuación, haga clic en **Aceptar**.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo anexar una cadena en el registro.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=36829">Ayuda del producto de Windows Server 2003</related>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberSignature Language="F#" Value="member this.ApplyAppPathModifier : string -&gt; string" Usage="httpResponse.ApplyAppPathModifier virtualPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Ruta de acceso virtual a un recurso.</param>
        <summary>Agrega un identificador de sesión a la ruta de acceso virtual si la sesión usa un estado de sesión <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> y devuelve la ruta combinada. Si no se usa el estado de sesión <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />, <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> devuelve la ruta de acceso virtual original.</summary>
        <returns>
          <paramref name="virtualPath" /> con el identificador de sesión insertado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> se usa solo con sesiones sin cookies para construir el carácter absoluto.  
  
   
  
## Examples  
 En el ejemplo siguiente se declara una variable de cadena denominada `urlConverted`y lo establece en el resultado de una <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> llamada al método. El código, a continuación, pasa el valor de la variable a un <xref:System.Web.UI.WebControls.HyperLink> del control <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> propiedad.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginFlush : AsyncCallback * obj -&gt; IAsyncResult" Usage="httpResponse.BeginFlush (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Objeto de devolución de llamada.</param>
        <param name="state">Estado de la respuesta.</param>
        <summary>Envía al cliente la respuesta almacenada actualmente en el búfer.</summary>
        <returns>Objeto del resultado asincrónico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si subyacente <xref:System.Web.HttpWorkerRequest> objeto admite operaciones asincrónicas de vaciado y se llama a este método desde un evento de módulo asincrónico o desde un controlador asincrónico, realiza la operación de vaciado asincrónica. En caso contrario, la operación de vaciado se realiza de forma sincrónica. Se admite vaciado asincrónico para IIS 6.0 y versiones posteriores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La respuesta ya se ha completado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.BinaryWrite : byte[] -&gt; unit" Usage="httpResponse.BinaryWrite buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Bytes que se van a escribir en el flujo de salida.</param>
        <summary>Escribe una cadena de caracteres binarios en el flujo de salida HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente lee un archivo de texto en un búfer y escribe el búfer en el flujo de salida HTTP.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : bool with get, set" Usage="System.Web.HttpResponse.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los resultados se van a almacenar en el búfer y se van a enviar después de que se haya terminado de procesar la respuesta completa.</summary>
        <value>
          <see langword="true" /> si la salida al cliente se va a almacenar en el búfer; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Buffer%2A> propiedad quedó obsoleta en favor de la <xref:System.Web.HttpResponse.BufferOutput%2A> propiedad y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BufferOutput : bool with get, set" Usage="System.Web.HttpResponse.BufferOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los resultados se van a almacenar en el búfer y se van a enviar después de que se haya terminado de procesar la página completa.</summary>
        <value>Es <see langword="true" /> si se van a almacenar en el búfer los resultados para el cliente; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página completa procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.HttpCachePolicy" Usage="System.Web.HttpResponse.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la directiva de caché (por ejemplo, tiempo de expiración, configuración de privacidad y cláusulas de variación) de una página web.</summary>
        <value>Objeto <see cref="T:System.Web.HttpCachePolicy" /> que contiene información sobre la directiva de caché de la respuesta actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se escribe las propiedades de la directiva de caché actual en el flujo de salida HTTP.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheControl : string with get, set" Usage="System.Web.HttpResponse.CacheControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el encabezado HTTP <see langword="Cache-Control" /> que coincide con uno de los valores de enumeración <see cref="T:System.Web.HttpCacheability" />.</summary>
        <value>Representación de cadena del valor de enumeración <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los valores de `Private`, `Public`, y `No-Cache` son cadenas y debe incluirse entre comillas (""). Si el <xref:System.Web.HttpResponse.CacheControl%2A> propiedad está establecida en un valor que no coincide con uno de los <xref:System.Web.HttpCacheability> valores de enumeración, una <xref:System.ArgumentException> se produce. Si el <xref:System.Web.HttpResponse.CacheControl%2A> propiedad no está establecida, el almacenamiento en caché de la respuesta se establece en <xref:System.Web.HttpCacheability.NoCache>.  
  
 El `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, y <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> propiedades han quedado en desuso. En su lugar, los métodos de la <xref:System.Web.HttpCachePolicy> clase están disponibles a través de la <xref:System.Web.HttpResponse.Cache%2A> objeto intrínseco para controlar Internet Information Services (IIS) de salida de caché y las memorias caché de cliente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El valor de cadena establecido no coincide con uno de los valores de enumeración <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Charset : string with get, set" Usage="System.Web.HttpResponse.Charset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el juego de caracteres HTTP del flujo de salida.</summary>
        <value>Juego de caracteres HTTP del flujo de salida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Charset` propiedad puede establecerse en `null` para suprimir el HTTP `Content-Type` encabezado.  
  
   
  
## Examples  
 El ejemplo siguiente se comprueba si el juego de caracteres del flujo de salida es Centroeuropeo (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propiedad <see langword="Charset" /> se estableció después de enviar los encabezados.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="httpResponse.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra toda la salida de contenido del flujo del búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Clear%2A> método no borra la información de encabezado.  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página operación completada procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberSignature Language="F#" Value="member this.ClearContent : unit -&gt; unit" Usage="httpResponse.ClearContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra toda la salida de contenido del flujo del búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.ClearContent%2A> método no borra la información de encabezado.  
  
   
  
## Examples  
 En el siguiente ejemplo se borra todo el contenido del flujo del búfer.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberSignature Language="F#" Value="member this.ClearHeaders : unit -&gt; unit" Usage="httpResponse.ClearHeaders " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los encabezados del flujo del búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Web.HttpResponse.ClearHeaders%2A> método para asegurarse de que se envía ningún encabezado con la respuesta actual. Esta técnica puede ser especialmente importante si la respuesta de ASP.NET genera una imagen, como un archivo JPEG. En este ejemplo el <xref:System.Web.HttpResponse.ContentType%2A> propiedad se establece en image/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Los encabezados se borran después de haber enviado los encabezados HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientDisconnectedToken : System.Threading.CancellationToken" Usage="System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Threading.CancellationToken" /> que se desencadena cuando el cliente se desconecta.</summary>
        <value>Token de cancelación.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta API es segura para subprocesos. Sin embargo, hay algunas restricciones sobre cómo se debe usar el token de cancelación. Uso de forma incorrecta puede conducir a condiciones de carrera, interbloqueos u otro comportamiento inesperado. Tenga en cuenta las siguientes directrices:  
  
-   Asegúrese de que no llame a esta API fuera de los límites de una sola solicitud, porque ASP.NET desecha el token de cancelación al final de la solicitud. No hay ninguna garantía de que el token nunca pasará a un estado cancelado antes de eliminarlas. Por ejemplo, si la solicitud finaliza sin el cliente tener desconectado, se eliminará el token sin tener en primer lugar se ha cancelado.  
  
-   No espera a la <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, ya que esto frustra el propósito de una notificación asincrónica y puede producir interbloqueos.  
  
-   No llame a la <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> sobrecargas que invocarán la devolución de llamada en el original <xref:System.Threading.SynchronizationContext> objeto.  
  
-   No utilice el <xref:System.Web.HttpContext> objeto u otros objetos intrínsecos de ASP.NET de que no es segura para subprocesos desde dentro de la devolución de llamada proporcionada para el <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> método. La devolución de llamada puede estar ejecutando simultáneamente con otras ASP.NET o código de la aplicación.  
  
-   Mantenga los métodos de devolución de llamada ejecución breve y sin bloqueo.  
  
-   Hacer todo lo posible para evitar generar excepciones desde dentro de los métodos de devolución de llamada.  
  
 Esta propiedad solo se admite en Internet Information Service (IIS) 7.5 o posterior en el modo integrado. Si se invoca sin el derecho versión o una canalización con modo de IIS, un <xref:System.PlatformNotSupportedException> se produce. Para determinar la versión de IIS, use <xref:System.Web.HttpRuntime.IISVersion%2A>. Para determinar el modo de canalización, utilice <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="httpResponse.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra la conexión del socket con un cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método finaliza la conexión al cliente de forma inesperada y no está pensado para procesar las solicitudes HTTP normal. El método envía un paquete de restablecer al cliente, lo que puede producir datos de respuesta que se almacena en búfer en el servidor, el cliente o en algún lugar entre ellos va a quitar.  
  
 Sin embargo, normalmente debe llamar a <xref:System.Web.HttpApplication.CompleteRequest%2A> en su lugar, si desea pasar a la <xref:System.Web.HttpApplication.EndRequest> eventos y enviar una respuesta al cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.ContentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el juego de caracteres HTTP del flujo de salida.</summary>
        <value>Objeto <see cref="T:System.Text.Encoding" /> que contiene información sobre el juego de caracteres de la respuesta actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Default `ContentEncoding` puede especificarse en un archivo de configuración de ASP.NET en el [globalización Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) sección. Si <xref:System.Web.HttpResponse.ContentEncoding%2A> es especificado por el cliente, se reemplaza la configuración predeterminada.  
  
   
  
## Examples  
 El ejemplo siguiente escribe una descripción legible del juego en el flujo de salida de codificación de caracteres.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se intentó establecer <see cref="P:System.Web.HttpResponse.ContentEncoding" /> en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContentType : string with get, set" Usage="System.Web.HttpResponse.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el tipo MIME HTTP del flujo de salida.</summary>
        <value>Tipo MIME HTTP del flujo de salida. El valor predeterminado es "<see langword="text/html" />".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.ContentType%2A> llama la propiedad para la respuesta en image/jpeg, el <xref:System.Web.HttpResponse.Clear%2A> método para quitar otro contenido que puede estar adjunto a la respuesta y, a continuación, Establece el <xref:System.Web.HttpResponse.BufferOutput%2A> la propiedad en true de modo que será la página operación completada procesar antes de enviar cualquier contenido al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La propiedad <see cref="P:System.Web.HttpResponse.ContentType" /> se establece en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cookies : System.Web.HttpCookieCollection" Usage="System.Web.HttpResponse.Cookies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de cookies de respuesta.</summary>
        <value>Colección de cookies de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET incluye dos colecciones de cookies intrínseca. La colección que tiene acceso a través del <xref:System.Web.HttpRequest.Cookies%2A> colección de <xref:System.Web.HttpRequest> contiene cookies transmitidas por el cliente al servidor en el `Cookie` encabezado. La colección que tiene acceso a través del <xref:System.Web.HttpResponse.Cookies%2A> colección de <xref:System.Web.HttpResponse> contiene nuevas cookies creadas en el servidor y transmite al cliente en el `Set-Cookie` encabezado.  
  
 Después de agregar una cookie utilizando la <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> colección, la cookie está inmediatamente disponible en el <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> colección, incluso si no se ha enviado la respuesta al cliente.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea una nueva cookie denominada `LastVisit`, Establece el valor de la cookie en la fecha y hora actuales y agrega la cookie a la colección de cookies actual. Todas las cookies de la colección de cookies se envían al cliente en el `Set-Cookie` encabezado HTTP con el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberSignature Language="F#" Value="member this.DisableKernelCache : unit -&gt; unit" Usage="httpResponse.DisableKernelCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshabilita el almacenamiento en caché en el kernel para la respuesta actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se admite el almacenamiento en caché de kernel, este método tiene ningún efecto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberSignature Language="F#" Value="member this.DisableUserCache : unit -&gt; unit" Usage="httpResponse.DisableUserCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshabilita el almacenamiento en caché del modo de usuario de IIS para esta respuesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se admite el almacenamiento en caché de modo de usuario IIS, este método devuelve sin realizar ninguna acción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberSignature Language="F#" Value="member this.End : unit -&gt; unit" Usage="httpResponse.End " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envía al cliente toda la salida del búfer actual, detiene la ejecución de la página y genera el evento <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona únicamente por compatibilidad con ASP, es decir, para la compatibilidad con la tecnología de programación Web basado en COM que va precedido de ASP.NET. Si desea pasar a la <xref:System.Web.HttpApplication.EndRequest> eventos y enviar una respuesta al cliente, es preferible llamar a <xref:System.Web.HttpApplication.CompleteRequest%2A> en su lugar.  
  
 Para imitar el comportamiento de la `End` método en ASP, este método intenta generar un <xref:System.Threading.ThreadAbortException> excepción. Si este intento se realiza correctamente, se anulará el subproceso de llamada, que es perjudicial para el rendimiento del sitio. En ese caso, no hay código después de llamar a la <xref:System.Web.HttpResponse.End%2A> se ejecuta el método.  
  
 Si el <xref:System.Web.HttpResponse.End%2A> método no es capaz de generar un <xref:System.Threading.ThreadAbortException>, en su lugar se vacía los bytes de respuesta al cliente. Para hacerlo de forma sincrónica, que también puede ser perjudicial para el rendimiento del sitio.  
  
 En cualquier caso (o no un <xref:System.Threading.ThreadAbortException> excepción se genera correctamente), la canalización de respuesta se desplazará hasta el <xref:System.Web.HttpApplication.EndRequest> eventos.  
  
 El <xref:System.Web.HttpApplication.CompleteRequest%2A> método no produzca una excepción y de código después de llamar a la <xref:System.Web.HttpApplication.CompleteRequest%2A> se podría ejecutar el método. Si su intención es evitar la ejecución de código subsiguiente y la disminución del rendimiento de <xref:System.Web.HttpResponse.End%2A> es aceptable, puede llamar a <xref:System.Web.HttpResponse.End%2A> en lugar de <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">La llamada a <see cref="M:System.Web.HttpResponse.End" /> ha terminado la solicitud actual.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndFlush : IAsyncResult -&gt; unit" Usage="httpResponse.EndFlush asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Objeto del resultado asincrónico.</param>
        <summary>Completa una operación de vaciado asincrónico.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El vaciado asincrónico no se admite y el parámetro de <paramref name="asyncResult" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El vaciado asincrónico no se admite y el parámetro de <paramref name="asyncResult" /> no se puede convertir a un objeto de <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Expires : int with get, set" Usage="System.Web.HttpResponse.Expires" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece los minutos que deben transcurrir antes de que expire una página almacenada en la caché de un explorador. Si el usuario vuelve a la misma página antes de que expire, aparece la versión almacenada en caché. Se proporciona <see cref="P:System.Web.HttpResponse.Expires" /> para ofrecer compatibilidad con versiones anteriores de ASP.</summary>
        <value>Minutos que deben transcurrir antes de que expire la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> y <xref:System.Web.HttpResponse.CacheControl%2A> propiedades han quedado en desuso en favor de los métodos de la <xref:System.Web.HttpCachePolicy> disponibles a través de la clase el <xref:System.Web.HttpResponse.Cache%2A> caché de resultados de un objeto intrínseco para controlar Internet Information Services (IIS) y almacena en caché de cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberSignature Language="F#" Value="member this.ExpiresAbsolute : DateTime with get, set" Usage="System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor absoluto de la fecha y la hora en que se quitará de la memoria caché la información almacenada en ella. Se proporciona <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> para ofrecer compatibilidad con versiones anteriores de ASP.</summary>
        <value>Fecha y hora en que expira la página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, y <xref:System.Web.HttpResponse.CacheControl%2A> propiedades han quedado en desuso en favor de los métodos de la <xref:System.Web.HttpCachePolicy> disponibles a través de la clase el <xref:System.Web.HttpResponse.Cache%2A> caché de resultados de un objeto intrínseco para controlar Internet Information Services (IIS) y almacena en caché de cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : System.IO.Stream with get, set" Usage="System.Web.HttpResponse.Filter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto de filtro contenedor que se emplea para modificar el cuerpo de la entidad HTTP antes de la transmisión.</summary>
        <value>Objeto <see cref="T:System.IO.Stream" /> que actúa como filtro de salida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se crea un `Stream` de objeto y establecer el <xref:System.Web.HttpResponse.Filter%2A> propiedad a la `Stream` objeto, todos los elementos HTTP salida enviado por <xref:System.Web.HttpResponse.Write%2A> pasa a través del filtro.  
  
   
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que establece el <xref:System.Web.HttpResponse.Filter%2A> propiedad a una nueva instancia de la `UpperCaseFilter` clase personalizada <xref:System.IO.Stream> clase que convierte todo el texto que se pasa a mayúsculas. La información acerca de la solicitud se guarda en un archivo de texto y, a continuación, el <xref:System.Web.HttpResponse.Filter%2A> se establece la propiedad. Una vez implementado el filtro de respuesta, el código llama a la <xref:System.Web.HttpRequest.MapPath%2A> método para obtener la ruta de acceso absoluta a un archivo de texto denominado `TestFile.txt` que actúa como el origen del contenido de la respuesta. El código, a continuación, crea un nuevo <xref:System.IO.StreamReader> objeto para leer el archivo de texto de principio a fin y, a continuación, llama a la <xref:System.Web.HttpResponse.Write%2A> método para mostrar el contenido del archivo en la página.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">No se permite el filtrado con la entidad.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberSignature Language="F#" Value="member this.Flush : unit -&gt; unit" Usage="httpResponse.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envía al cliente toda la salida almacenada en el búfer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obliga a todos los almacenados en búfer de salida para enviarla al cliente. El <xref:System.Web.HttpResponse.Flush%2A> método puede llamarse varias veces durante el procesamiento de la solicitud.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Drawing.Graphics.Save%2A> método para guardar un <xref:System.Drawing.Bitmap> de objeto para el <xref:System.Web.HttpResponse.OutputStream%2A> con formato propiedad y convierte la imagen a la imagen JPEG. El código, a continuación, llama a la `Dispose` método en el <xref:System.Drawing.Bitmap> objeto y un <xref:System.Drawing.Graphics> objeto, libera los recursos que estaban utilizando. A continuación, llama el <xref:System.Web.HttpResponse.Flush%2A> método para enviar el contenido de la respuesta al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Una vez enviada la respuesta, se vacía la caché.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberSignature Language="F#" Value="member this.FlushAsync : unit -&gt; System.Threading.Tasks.Task" Usage="httpResponse.FlushAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Envía al cliente de forma asincrónica todos los resultados almacenados en el búfer.</summary>
        <returns>Objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderEncoding : System.Text.Encoding with get, set" Usage="System.Web.HttpResponse.HeaderEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto <see cref="T:System.Text.Encoding" /> que representa la codificación del flujo de salida del encabezado actual.</summary>
        <value>
          <see cref="T:System.Text.Encoding" /> que contiene información sobre el juego de caracteres del encabezado actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad le permite deshabilitar o cambiar la <xref:System.Text.Encoding> objeto en un encabezado de respuesta mediante el uso de la <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, o <xref:System.Text.UTF8Encoding> objeto. El valor de codificación predeterminado es el <xref:System.Text.UTF8Encoding> clase.  
  
 Si cambias el tipo de la <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad, puede incrementar el riesgo de ciertos ataques malintencionados o causa datos confidenciales para enviarse a través del encabezado de respuesta. Ataques de inyección de encabezado pueden evitarse, en parte, dejando el <xref:System.Web.HttpResponse.HeaderEncoding%2A> propiedad de una respuesta a la configuración predeterminada. Un ataque contra una aplicación vulnerable podría devolver datos confiados atrás como parte de un encabezado de respuesta. Si el <xref:System.Web.HttpResponse.HeaderEncoding%2A> está deshabilitada debido a un requisito para las líneas de continuación en un encabezado o si cualquier encabezado se construye a partir del resultado de los datos de confianza, los datos de encabezado deben validarse antes de enviarlos a la secuencia de respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de codificación es <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">El valor de codificación es <see cref="P:System.Text.Encoding.Unicode" />.  
  
\- o - 
Ya se han enviado los encabezados.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Headers : System.Collections.Specialized.NameValueCollection" Usage="System.Web.HttpResponse.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la colección de encabezados de respuesta.</summary>
        <value>
          <see cref="T:System.Collections.Specialized.NameValueCollection" /> de encabezados de respuesta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.Headers%2A> propiedad solo es compatible con la [!INCLUDE[iisver](~/includes/iisver-md.md)] modo de canalización integrada y al menos .NET Framework 3.0. Cuando se intenta tener acceso a la <xref:System.Web.HttpResponse.Headers%2A> propiedad y cualquiera de estas dos condiciones no se cumple, un <xref:System.PlatformNotSupportedException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La operación requiere el modo de canalización integrada en [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos la versión 3.0 de .NET Framework.</exception>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=86952">Actualización de aplicaciones de ASP.NET a IIS 7.0: diferencias entre el modo integrado de IIS 7.0 y el modo clásico</related>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HeadersWritten : bool" Usage="System.Web.HttpResponse.HeadersWritten" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Compatible con .NET Framework 4.5.2 y versiones posteriores] 
Obtiene un valor que indica si se escribieron los encabezados de respuesta.</summary>
        <value>
          <see langword="true" /> si se escribieron los encabezados de respuesta; en caso contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClientConnected : bool" Usage="System.Web.HttpResponse.IsClientConnected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el cliente sigue conectado al servidor.</summary>
        <value>
          <see langword="true" /> si el cliente está conectado; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad devuelve `false` cuando las condiciones siguientes son verdaderas:  
  
-   Se terminó la conexión al cliente. Esto puede ocurrir si el <xref:System.Web.HttpResponse.Close%2A> se invocó el método, o si el cliente detuvo la ejecución de la página Web o se desplazó a otra página.  
  
-   El <xref:System.Web.HttpWorkerRequest> objeto que controla la solicitud es `null` o <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> devuelve del método `false`. Si un personalizado <xref:System.Web.HttpWorkerRequest> objeto administra la solicitud, el <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> método puede establecerse basándose en criterios personalizados. Por ejemplo, la solicitud de trabajo personalizada puede forzar un tiempo de espera tras un período de tiempo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad para comprobar si el cliente que solicita la página permanece conectado al servidor. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es true, el código llama a la <xref:System.Web.HttpResponse.Redirect%2A> método y el cliente verá otra página. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es false, el código llama a la <xref:System.Web.HttpResponse.End%2A> se finaliza el método y el procesamiento de páginas.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsRequestBeingRedirected : bool" Usage="System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor booleano que indica si el cliente se transfiere a una nueva ubicación.</summary>
        <value>
          <see langword="true" /> si el valor del encabezado de respuesta de ubicación es diferente a la ubicación actual; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> propiedad con el <xref:System.Web.HttpResponse.RedirectLocation%2A> propiedad para probar y determinar si el URI absoluto que es transmite al cliente en el HTTP `Location` encabezado es diferente del URI actual y el nuevo URI al que se va a transferir a será.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Output : System.IO.TextWriter with get, set" Usage="System.Web.HttpResponse.Output" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita la salida de texto al flujo de respuesta HTTP saliente.</summary>
        <value>Objeto <see cref="T:System.IO.TextWriter" /> que permite obtener una salida personalizada al cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que contiene un <xref:System.Web.UI.WebControls.TextBox> control que tiene su <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> propiedad establecida en <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Código de la página toma el texto que un usuario escribe en el <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, usa el <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método a HTML, codificar y el <xref:System.Web.HttpResponse.Output%2A> propiedad para mostrar la cadena codificada en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OutputStream : System.IO.Stream" Usage="System.Web.HttpResponse.OutputStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Habilita la salida binaria para el cuerpo de contenido HTTP saliente.</summary>
        <value>
          <see cref="T:System.IO.Stream" /> de E/S que representa el contenido sin procesar del cuerpo de contenido HTTP saliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A partir de .NET Framework versión 2.0, cuando se usa el <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método de la secuencia de E/S devuelta por la <xref:System.Web.HttpResponse.OutputStream%2A> propiedad, se podrían producir las excepciones siguientes:  
  
-   <xref:System.ArgumentOutOfRangeException>, si la `offset` o `count` parámetro es negativo o si el `buffer` longitud del parámetro menos el `offset` parámetro es menor o igual que cero.  
  
-   <xref:System.ArgumentNullException>, si la `buffer` parámetro es `null`.  
  
   
  
## Examples  
 El ejemplo siguiente se llama el <xref:System.Drawing.Image.Save%2A> método para guardar un <xref:System.Drawing.Bitmap> de objeto para el <xref:System.Web.HttpResponse.OutputStream%2A> propiedad y convierte la imagen al formato JPEG. El código, a continuación, llama al método Dispose en el <xref:System.Drawing.Bitmap> objeto y un <xref:System.Drawing.Graphics> objeto, libera los recursos que estaban utilizando. Por último, el código llama a la <xref:System.Web.HttpResponse.Flush%2A> método para enviar el contenido de la respuesta al cliente solicitante.  
  
 Para obtener un ejemplo completo, vea el <xref:System.Web.HttpResponse> clase.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="OutputStream" /> no está disponible.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Pics : string -&gt; unit" Usage="httpResponse.Pics value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Cadena que se agregará al encabezado <see langword="PICS-Label" />.</param>
        <summary>Anexa un encabezado HTTP <see langword="PICS-Label" /> al flujo de salida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plataforma para la selección de contenido de Internet (PICS) es un estándar de World Wide Web Consortium (W3C) para el etiquetado de contenido. PICS es esencialmente un lenguaje para crear un sistema de clasificación.  
  
 Cualquier valor puede ser una etiqueta PICS; ASP.NET no valida la etiqueta. La longitud máxima de la cadena es de 255 caracteres. Para obtener más información sobre la sintaxis y los estándares de PICS, consulte el [World Wide Web Consortium](https://go.microsoft.com/fwlink/?LinkID=37125) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente es una página ASP.NET que muestra una imagen. El código de página que llama a la <xref:System.Web.HttpResponse.Pics%2A> método para establecer el HTTP `PICS-Label` encabezado para la respuesta. La cadena que se pasa como parámetro para el <xref:System.Web.HttpResponse.Pics%2A> método representa una etiqueta de clasificación generada desde el sitio Web de Internet Content Rating Association (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Promueve un objeto Promise.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string -&gt; unit" Usage="httpResponse.PushPromise path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la solicitud de inserción. Debe ser la ruta de acceso virtual del recurso relativo que el servidor desea insertar en el cliente.</param>
        <summary>Esta API ofrece compatibilidad con aplicaciones que envían compromisos de inserción a los clientes HTTP 2.0. Puede encontrar más detalles relacionados con la inserción de servidores HTTP 2 en la <see href="https://http2.github.io/http2-spec/#PushResources">sección 8.2 del documento HTTP/2 Specification, Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise es no determinista y las aplicaciones no deberían tener la lógica que dependa de él. Su único propósito es la ventaja de rendimiento en algunos casos. Hay muchas condiciones (protocolo e implementación) que pueden provocar para omitir completamente las solicitudes de inserción. Depende de la expectativa de fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberSignature Language="F#" Value="member this.PushPromise : string * string * System.Collections.Specialized.NameValueCollection -&gt; unit" Usage="httpResponse.PushPromise (path, method, headers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">Dirección URL de la solicitud de inserción. Debe ser la ruta de acceso virtual del recurso relativo que el servidor desea insertar en el cliente.</param>
        <param name="method">Método de solicitud HTTP que usaría la solicitud de inserción.</param>
        <param name="headers">Encabezado de solicitud HTTP que usaría la solicitud de inserción.</param>
        <summary>Esta API ofrece compatibilidad con aplicaciones que envían compromisos de inserción a los clientes HTTP 2.0. Puede encontrar más detalles relacionados con la inserción de servidores HTTP 2 en la <see href="https://http2.github.io/http2-spec/#PushResources">sección 8.2 del documento HTTP/2 Specification, Server Push</see>.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise es no determinista y las aplicaciones no deberían tener la lógica que dependa de él. Su único propósito es la ventaja de rendimiento en algunos casos. Hay muchas condiciones (protocolo e implementación) que pueden provocar para omitir completamente las solicitudes de inserción. Depende de la expectativa de fire and forget.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirecciona un cliente a una nueva dirección URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string -&gt; unit" Usage="httpResponse.Redirect url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Ubicación de destino. Puede ser una ruta de acceso virtual relativa a la aplicación.</param>
        <summary>Redirecciona una solicitud a una nueva dirección URL y especifica la nueva URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una llamada a <xref:System.Web.HttpResponse.Redirect%2A> equivale a llamar a <xref:System.Web.HttpResponse.Redirect%2A> con el segundo parámetro establecido en `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> las llamadas <xref:System.Web.HttpResponse.End%2A> qué produce una <xref:System.Threading.ThreadAbortException> excepción tras la finalización. Esta excepción tiene un efecto negativo en el rendimiento de la aplicación Web. Por lo tanto, se recomienda que, en lugar de esta sobrecarga usa el <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga y pasar `false` para el `endResponse` parámetro y, a continuación, llame el <xref:System.Web.HttpApplication.CompleteRequest%2A> método. Para obtener más información, vea el método <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Para las páginas móviles, si la aplicación se basa en sesiones sin cookies o puede recibir solicitudes de dispositivos móviles que requieren sesiones sin cookies, uso una tilde (~) en una ruta de acceso puede producir en crear una nueva sesión y se pueden perder datos de la sesión. Para establecer una propiedad en un control móvil con una ruta de acceso como "~ / ruta de acceso", resolver la ruta de acceso mediante <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ruta de acceso" antes de asignarlo a la propiedad.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302. Una manera alternativa para transferir el control a otra página es la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpServerUtility.Transfer%2A> método normalmente es más eficaz porque no hace un ida y vuelta al cliente. Para obtener más información, consulte [Cómo: redirigir a los usuarios a otra página](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 El ejemplo siguiente fuerza un redireccionamiento incondicional a otro sitio Web.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se intentó el redireccionamiento después de enviar los encabezados HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.Redirect : string * bool -&gt; unit" Usage="httpResponse.Redirect (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Ubicación del destino.</param>
        <param name="endResponse">Indica si la ejecución de la página actual debe terminar.</param>
        <summary>Redirecciona un cliente a una nueva dirección URL. Especifica la nueva URL y si la ejecución de la página actual debe finalizar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una dirección URL absoluta (por ejemplo, http://www.contoso.com/default.aspx) o se puede especificar una dirección URL relativa (por ejemplo, Default.aspx) para la ubicación de destino, pero algunos exploradores pueden rechazar una dirección URL relativa.  
  
 Cuando usa este método en un controlador de página para una solicitud de finalización para una página e inicie una nueva solicitud de otra página, establezca `endResponse` a `false` y, a continuación, llame a la <xref:System.Web.HttpApplication.CompleteRequest%2A> método. Si especifica `true` para el `endResponse` parámetro, este método llama a la <xref:System.Web.HttpResponse.End%2A> método para la solicitud original, que produce una <xref:System.Threading.ThreadAbortException> excepción cuando se complete. Esta excepción tiene un efecto negativo en el rendimiento de aplicaciones Web, motivo por el cual pasar `false` para el `endResponse` se recomienda el parámetro. Para obtener más información, vea el método <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Para las páginas móviles, si la aplicación se basa en sesiones sin cookies o puede recibir solicitudes de dispositivos móviles que requieren sesiones sin cookies, utilizando una tilde (~) en una ruta de acceso puede crear una nueva sesión y porque podría perder datos de la sesión. Para establecer una propiedad en un control móvil con una ruta de acceso como "~ / ruta de acceso", resolver la ruta de acceso mediante <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> "~ / ruta de acceso" antes de asignarlo a la propiedad.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302. Una manera alternativa para transferir el control a otra página es la <xref:System.Web.HttpServerUtility.Transfer%2A> método. El <xref:System.Web.HttpServerUtility.Transfer%2A> método normalmente es más eficaz porque no hace un ida y vuelta al cliente. Para obtener más información, consulte [Cómo: redirigir a los usuarios a otra página](https://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Web.HttpResponse.IsClientConnected%2A> propiedad para comprobar si el cliente que solicita la página permanece conectado al servidor. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es true, el código llama a la <xref:System.Web.HttpResponse.Redirect%2A> método y el cliente verá otra página. Si <xref:System.Web.HttpResponse.IsClientConnected%2A> es false, el código llama a la <xref:System.Web.HttpResponse.End%2A> se finaliza el método y el procesamiento de páginas.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> contiene un carácter de nueva línea.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó el redireccionamiento después de enviar los encabezados HTTP.</exception>
        <exception cref="T:System.ApplicationException">La solicitud de página es el resultado de una devolución de llamada.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RedirectLocation : string with get, set" Usage="System.Web.HttpResponse.RedirectLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor del encabezado HTTP <see langword="Location" />.</summary>
        <value>URI absoluto que se transmite al cliente en el encabezado HTTP <see langword="Location" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente muestra cómo utilizar esta propiedad para especificar la dirección URL de redireccionamiento al codificar una redirección permanente con el código de respuesta HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Ya se han escrito los encabezados HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una dirección URL especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string -&gt; unit" Usage="httpResponse.RedirectPermanent url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Ubicación a la que se va a redirigir la solicitud.</param>
        <summary>Realiza un redireccionamiento permanente de la dirección URL solicitada a la dirección URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> sobrecarga del método proporciona un código de estado HTTP 301 en la respuesta e incluye la dirección URL para redirigir la solicitud. Un código de estado HTTP 301 es un código en una respuesta HTTP estándar. Indica que existe una redirección permanente, y proporciona la ubicación de redireccionamiento.  
  
 Una llamada a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> sobrecarga del método termina la respuesta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> incluye un carácter de nueva línea (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberSignature Language="F#" Value="member this.RedirectPermanent : string * bool -&gt; unit" Usage="httpResponse.RedirectPermanent (url, endResponse)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Ubicación a la que se va a redirigir la solicitud.</param>
        <param name="endResponse">
          <see langword="true" /> para finalizar la respuesta; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</param>
        <summary>Realiza un redireccionamiento permanente de la dirección URL solicitada a la dirección URL especificada y proporciona la opción para completar la respuesta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> sobrecarga del método proporciona un código de estado HTTP 301 en la respuesta e incluye la dirección URL para redirigir la solicitud. Esta sobrecarga del método también proporciona la opción para especificar si desea finalizar o completar la respuesta una vez realizada la redirección. Un código de estado HTTP 301 es un código en una respuesta HTTP estándar. Indica que existe una redirección permanente, y proporciona la ubicación de redireccionamiento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="url" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> incluye un carácter de nueva línea (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige una solicitud a una nueva dirección URL mediante los valores de parámetro de la ruta, un nombre de ruta o ambos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : obj -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Redirige una solicitud a una nueva dirección URL mediante los valores de parámetro de la ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string -&gt; unit" Usage="httpResponse.RedirectToRoute routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <summary>Redirige una solicitud a una nueva dirección URL mediante un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el nombre de ruta que se pasa en `routeName` a una dirección URL usando el <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Redirige una solicitud a una nueva dirección URL mediante los valores de parámetro de la ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Redirige una solicitud a una nueva dirección URL mediante los valores de parámetro de la ruta y un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoute : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoute (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Redirige una solicitud a una nueva dirección URL mediante los valores de parámetro de la ruta y un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método se llama para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 302.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una nueva dirección URL mediante los valores de parámetro de la ruta, un nombre de ruta o ambos.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una nueva dirección URL mediante los valores de parámetro de la ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una nueva dirección URL mediante un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el nombre de ruta que se pasa en `routeName` a una dirección URL usando el <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent routeValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una nueva dirección URL mediante los valores de parámetro de la ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta con parámetros denominados `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * obj -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Realiza un redireccionamiento permanente de la dirección URL solicitada a una nueva dirección URL mediante los valores de parámetro y el nombre de la ruta que corresponden a la nueva dirección URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.RedirectPermanent%2A> método con el segundo parámetro establecido en `false`.  
  
 Este método convierte el objeto que se pasa en `routeValues` a un <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> objeto utilizando el <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> constructor. El <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> , a continuación, se llama el método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberSignature Language="F#" Value="member this.RedirectToRoutePermanent : string * System.Web.Routing.RouteValueDictionary -&gt; unit" Usage="httpResponse.RedirectToRoutePermanent (routeName, routeValues)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Nombre de la ruta.</param>
        <param name="routeValues">Valores de parámetro de la ruta.</param>
        <summary>Realiza un redireccionamiento permanente de una dirección URL solicitada a una nueva dirección URL mediante los valores de parámetro de la ruta y un nombre de ruta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se proporciona para mayor comodidad de codificación. Equivale a llamar a la <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> método con el segundo parámetro establecido en `false`.  
  
 Este método llama a la <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método para determinar la dirección URL.  
  
 ASP.NET realiza la redirección devolviendo un código de estado HTTP 301.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo llamar a este método para redirigir a una ruta que se denomina `Product` y que tiene parámetros que se denominan `productid` y `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No existe ninguna ruta que corresponde al conjunto especificado de parámetros de ruta.</exception>
        <exception cref="T:System.Web.HttpException">Se intentó redirigir una vez enviados los encabezados HTTP.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Quita los elementos almacenados en memoria caché de la caché de resultados usando el proveedor de caché de resultados predeterminado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso virtual absoluta de los elementos que se borran de la caché.</param>
        <summary>Quita de la memoria caché todos los elementos almacenados que estén asociados al proveedor de caché de resultados predeterminado. Este método es estático.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para quitar elementos de la caché de resultados que están asociados con el proveedor de caché de resultados predeterminado. Llame a la <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> método para quitar elementos de la caché de resultados que están asociados con los proveedores de caché de resultados personalizados que se especifican en el archivo de configuración del sitio Web.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> no es una ruta virtual absoluta.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberSignature Language="F#" Value="static member RemoveOutputCacheItem : string * string -&gt; unit" Usage="System.Web.HttpResponse.RemoveOutputCacheItem (path, providerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso absoluta virtual de los elementos quitados de la memoria caché.</param>
        <param name="providerName">Proveedor que se usa para quitar los artefactos de la caché de resultados que están asociados a la ruta de acceso especificada.</param>
        <summary>Usa el proveedor de caché de resultados especificado para quitar todos los elementos de caché de resultados que están asociados a la ruta de acceso indicada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llame a este método para quitar elementos de la caché de resultados que están asociados con los proveedores de caché de resultados personalizados que se especifican en el archivo de configuración del sitio Web. Para quitar elementos de la caché de resultados que están asociados con el proveedor de caché de resultados predeterminado, llame a la <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> es null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> no es una ruta de acceso válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberSignature Language="F#" Value="member this.SetCookie : System.Web.HttpCookie -&gt; unit" Usage="httpResponse.SetCookie cookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Cookie de la colección que se va a actualizar.</param>
        <summary>Dado que el método <b>HttpResponse.SetCookie</b> está pensado solo para uso interno, no lo debe llamar en el código. En su lugar, puede llamar al método <b>HttpResponse.Cookies.Set</b>, tal como se muestra en el ejemplo siguiente.<br /> Actualiza una cookie existente en la colección de cookies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente actualiza el valor de una cookie existente.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Se ha intentado establecer la cookie después enviar los encabezados HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Status : string with get, set" Usage="System.Web.HttpResponse.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establece la línea <see langword="Status" /> que se devuelve al cliente.</summary>
        <value>Al establecer el código de estado, se devuelve al cliente una cadena que describe el estado de la salida HTTP. El valor predeterminado es 200 (OK).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> en desuso en favor de <xref:System.Web.HttpResponse.StatusDescription%2A> y se proporciona únicamente por compatibilidad con versiones anteriores de ASP. Con ASP.NET, utilice <xref:System.Web.HttpResponse.StatusDescription%2A> en su lugar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Status se establece en un código de estado no válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.StatusCode : int with get, set" Usage="System.Web.HttpResponse.StatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el código de estado HTTP de la salida que se devuelve al cliente.</summary>
        <value>Entero que representa el estado de la salida HTTP que se devuelve al cliente. El valor predeterminado es 200 (OK). Para obtener una lista de códigos de estado válidos, consulte [códigos de estado Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba el código de estado del flujo de salida. Si el código de estado no es igual a 200, se ejecuta código adicional.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.HttpResponse.StatusCode" /> se establece después de haber enviado los encabezados HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusDescription : string with get, set" Usage="System.Web.HttpResponse.StatusDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cadena de estado HTTP de la salida que se devuelve al cliente.</summary>
        <value>Cadena que describe el estado de la salida HTTP que se devuelve al cliente. El valor predeterminado es "OK". Para obtener una lista de códigos de estado válidos, consulte [códigos de estado Http](https://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente comprueba la cadena de estado del flujo de salida. Si el estado no es igual a "Correcto", se ejecuta código adicional.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="StatusDescription" /> se establece después de haber enviado los encabezados HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longitud del valor seleccionado es mayor que 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SubStatusCode : int with get, set" Usage="System.Web.HttpResponse.SubStatusCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que califica el código de estado de la respuesta.</summary>
        <value>Valor entero que representa el código de subestado de [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad sólo es compatible con el modo de canalización integrada en [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos la versión 3.0 de .NET Framework. Al establecer el <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad, el estado se registra [!INCLUDE[iisver](~/includes/iisver-md.md)] si se configura la traza de solicitudes con error. Independientemente de si se ha configurado el seguimiento, el código nunca se envía como parte de la respuesta final a la solicitud. Para obtener más información, consulte [solución de problemas no se pudo solicitudes Using Failed Request Tracing en IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 El ejemplo siguiente se establece la <xref:System.Web.HttpResponse.SubStatusCode%2A> propiedad en un controlador de eventos para el <xref:System.Web.HttpApplication> instancia de la <xref:System.Web.HttpApplication.PostAuthenticateRequest> eventos. Coloque el archivo de código en la carpeta App_Code de la aplicación Web y configurar el archivo Web.config para registrar el módulo. Para obtener más información, consulte [Tutorial: crear y registrar un módulo de HTTP personalizado](https://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La operación requiere el modo de canalización integrada en [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos la versión 3.0 de .NET Framework.</exception>
        <exception cref="T:System.Web.HttpException">El código de estado se establece después de haber enviado todos los encabezados HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAsyncFlush : bool" Usage="System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la conexión admite las operaciones de vaciado asincrónicas.</summary>
        <value>
          <see langword="true" /> si la conexión admite operaciones asincrónicas de vaciado; si no, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad devuelve el valor de la <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> propiedad.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressContent : bool with get, set" Usage="System.Web.HttpResponse.SuppressContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se debe enviar el contenido HTTP al cliente.</summary>
        <value>
          <see langword="true" /> para suprimir la salida; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente se comprueba si el <xref:System.Web.HttpRequest.IsSecureConnection%2A> propiedad está establecida en false. Si es así, el <xref:System.Web.HttpResponse.SuppressContent%2A> propiedad está establecida en true para detener el envío de la respuesta.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressDefaultCacheControlHeader : bool with get, set" Usage="System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Compatible con .NET Framework 4.5.2 y versiones posteriores] 
Obtiene o establece un valor que indica si se suprime el encabezado <c>Cache Control: private</c> predeterminado de la respuesta HTTP actual.</summary>
        <value>
          <see langword="true" /> Para suprimir el valor predeterminado <c>Cache Control: private</c> encabezado de la respuesta HTTP actual; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, ASP.NET envía una `Cache-Control: private` encabezado de respuesta, a menos que se ha especificado una directiva de caché explícita para esta respuesta. Esta propiedad permite suprimir este encabezado de respuesta predeterminada por solicitud. El encabezado todavía se puede suprimir para toda la aplicación estableciendo <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> en [httpRuntime Element (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) o [elemento outputCache para el almacenamiento en caché (ASP.NET Settings Schema)](https://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Tenga cuidado al suprimir el valor predeterminado `Cache-Control: private` encabezado, como servidores proxy y otros intermediarios pueden tratar las respuestas sin este encabezado como almacenable en caché de forma predeterminada. Este tratamiento puede provocar el almacenamiento en caché accidental de información confidencial. Consulte [RFC 2616, s. 13.4](http://tools.ietf.org/html/rfc2616) para obtener más información.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SuppressFormsAuthenticationRedirect : bool with get, set" Usage="System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si el redireccionamiento de autenticación de formularios a la página de inicio de sesión debe suprimirse.</summary>
        <value>
          <see langword="true" /> si debe suprimirse el redireccionamiento de autenticación de formularios; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, la autenticación de formularios convierte códigos de estado HTTP 401 a 302 con el fin de redirigir a la página de inicio de sesión. Esto no es adecuado para ciertas clases de errores, por ejemplo, cuando la autenticación se realiza correctamente pero la autorización genera un error, o cuando la solicitud actual es una solicitud de servicio web o de AJAX. Esta propiedad proporciona una manera para suprimir el comportamiento de redirección y enviar el código de estado original al cliente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe el archivo especificado directamente en un flujo de salida de respuesta HTTP, sin almacenarlo en búfer en memoria.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string -&gt; unit" Usage="httpResponse.TransmitFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se escribirá en la salida HTTP.</param>
        <summary>Escribe el archivo especificado directamente en un flujo de salida de respuesta HTTP, sin almacenarlo en búfer en memoria.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="filename" /> es <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberSignature Language="F#" Value="member this.TransmitFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.TransmitFile (filename, offset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se escribirá en la salida HTTP.</param>
        <param name="offset">Posición del archivo donde comenzará la escritura en la salida HTTP.</param>
        <param name="length">Número de bytes que se van a transmitir.</param>
        <summary>Escribe la parte especificada de un archivo directamente en un flujo de salida de respuesta HTTP, sin almacenarlo en búfer en memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si especifica 0 como el `offset` parámetro y -1 como el `length` parámetro, se envía todo el archivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="offset" /> es menor que cero.  
  
\- o - 
El parámetro <paramref name="length" /> es menor que -1.  
  
\- o - 
El parámetro <paramref name="length" /> especifica un número de bytes que es mayor que el número de bytes que contiene el archivo después de restarle el desplazamiento.</exception>
        <exception cref="T:System.PlatformNotSupportedException">No se admite la solicitud de trabajo fuera de proceso.  
  
\- o - 
La respuesta no usa un objeto <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="offset" /> es menor que cero o mayor que el tamaño del archivo.  
  
\- o - 
El parámetro <paramref name="length" /> es menor que -1 o mayor que el valor del parámetro <paramref name="offset" /> más el tamaño del archivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TrySkipIisCustomErrors : bool with get, set" Usage="System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si los errores personalizados de [!INCLUDE[iisver](~/includes/iisver-md.md)] están deshabilitados.</summary>
        <value>
          <see langword="true" /> para deshabilitar los errores personalizados de IIS; en caso contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> propiedad solo se usa cuando la aplicación se hospeda en IIS 7.0. Cuando se ejecuta en modo clásico en IIS 7.0 el <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> es el valor de propiedad predeterminado `true`. Cuando se ejecuta en modo integrado, el <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> es el valor de propiedad predeterminado `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe información en un flujo de salida de respuesta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberSignature Language="F#" Value="member this.Write : char -&gt; unit" Usage="httpResponse.Write ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Carácter que se va a escribir en el flujo de salida HTTP.</param>
        <summary>Escribe un carácter en un flujo de salida de respuesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una serie de constantes que se escriben en una página ASP.NET mediante el método Write. El código llama a esta versión del método de escritura para escribir las constantes de caracteres individuales en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Write : obj -&gt; unit" Usage="httpResponse.Write obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> que se va a escribir en el flujo de salida HTTP.</param>
        <summary>Escribe un <see cref="T:System.Object" /> en un flujo de respuesta HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="httpResponse.Write s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Cadena que se escribirá en el flujo de salida HTTP.</param>
        <summary>Escribe una cadena en un flujo de salida de respuesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas HTML generadas dinámicamente pueden presentar riesgos de seguridad si no se valida la entrada recibida desde clientes Web cuando se recibe desde un cliente o cuando se transmite a un cliente. Script malintencionado que está incrustado en entradas enviadas a un sitio Web y más adelante se escriben en un cliente puede parecer que proceden de un origen de confianza. Este riesgo de seguridad se conoce como un ataque XSS. Siempre debe validar los datos que se reciben desde un cliente cuando se transmitirá desde el sitio a los exploradores cliente.  
  
 Además, cada vez que se escribe con formato HTML cualquier dato que se recibió como entrada, debe codificar mediante una técnica como <xref:System.Web.HttpServerUtility.HtmlEncode%2A> o <xref:System.Web.HttpServerUtility.UrlEncode%2A> para evitar que se ejecute el script malintencionado. Esta técnica es útil para los datos que no se validaban cuando se recibió.  
  
 Al codificar o filtrar los datos, debe especificar un juego de caracteres para las páginas Web para que el filtro puede identificar y quitar cualquier secuencia de bytes que no pertenece a dicho conjunto (por ejemplo, las secuencias no alfanuméricas) y podría tener script malintencionado incrustado en ellos.  
  
 Para obtener más información sobre los ataques de scripting entre sitios, consulte el artículo Q252985, "Cómo para evitar Cross-Site Scripting problemas de seguridad" en el [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?LinkID=37115) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente devuelve el nombre del cliente al explorador del cliente. El <xref:System.Web.HttpServerUtility.HtmlEncode%2A> método elimina cualquier script malintencionado y los caracteres no válidos que se han enviado en la `UserName` campo de entrada.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="httpResponse.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Matriz de caracteres que se va a escribir.</param>
        <param name="index">Posición de la matriz de caracteres en la que se inicia la escritura.</param>
        <param name="count">Número de caracteres que se van a escribir, comenzando por <paramref name="index" />.</param>
        <summary>Escribe una matriz de caracteres en un flujo de salida de respuesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea una serie de constantes que se escriben en una página ASP.NET mediante el método Write. El código llama a esta versión del método de escritura para escribir las constantes de caracteres individuales en la página.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe el archivo especificado directamente en un flujo de salida de respuesta HTTP.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string -&gt; unit" Usage="httpResponse.WriteFile filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se escribirá en la salida HTTP.</param>
        <summary>Escribe el contenido del archivo especificado directamente en un flujo de salida de respuesta HTTP como un bloque de archivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener literales HTML texto y controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="filename" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * bool -&gt; unit" Usage="httpResponse.WriteFile (filename, readIntoMemory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se escribirá en un bloque de memoria.</param>
        <param name="readIntoMemory">Indica si el archivo se va a escribir en un bloque de memoria.</param>
        <summary>Escribe el contenido del archivo especificado directamente en un flujo de salida de respuesta HTTP como un bloque de memoria.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe un archivo en la memoria.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="filename" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : nativeint * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (fileHandle, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Identificador del archivo que se escribirá en el flujo de salida HTTP.</param>
        <param name="offset">Posición del byte en el archivo donde se iniciará la escritura.</param>
        <param name="size">Número de bytes que se va a escribir en el flujo de salida.</param>
        <summary>Escribe el archivo especificado directamente en un flujo de salida de respuesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener literales HTML texto y controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="fileHandler" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> es menor que 0.  
  
\- o - 
 El valor <paramref name="size" /> es mayor que el tamaño de archivo menos <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberSignature Language="F#" Value="member this.WriteFile : string * int64 * int64 -&gt; unit" Usage="httpResponse.WriteFile (filename, offset, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Nombre del archivo que se escribirá en el flujo de salida HTTP.</param>
        <param name="offset">Posición del byte en el archivo donde se iniciará la escritura.</param>
        <param name="size">Número de bytes que se va a escribir en el flujo de salida.</param>
        <summary>Escribe el archivo especificado directamente en un flujo de salida de respuesta HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando este método se usa con archivos grandes, una llamada al método podría generar una excepción. El tamaño del archivo que se puede usar con este método depende de la configuración de hardware del servidor Web. Para obtener más información, consulte el artículo 812406, "PRB: Response.WriteFile no se puede descargar a Large File" en el [Microsoft Knowledge Base](https://go.microsoft.com/fwlink/?linkid=149903) sitio Web.  
  
   
  
## Examples  
 El ejemplo siguiente escribe todo el contenido de un archivo de texto denominado `Login.txt` (que podría contener texto literal y HTML los controles de entrada) directamente en el flujo de salida.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <paramref name="offset" /> es menor que 0.  
  
\- o - 
 El valor <paramref name="size" /> es mayor que el tamaño de archivo menos <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="filename" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.WriteSubstitution : System.Web.HttpResponseSubstitutionCallback -&gt; unit" Usage="httpResponse.WriteSubstitution callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Método, control de usuario u objeto que se va a sustituir.</param>
        <summary>Permite la inserción de bloques de substitución de respuesta en la respuesta, lo que permite la generación dinámica de regiones de respuesta especificadas para las respuestas almacenadas en la caché de resultados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede usar el <xref:System.Web.HttpResponse.WriteSubstitution%2A> método para la sustitución posterior a la caché en las páginas en caché de resultados. Al pasar un <xref:System.Web.HttpContext> objeto a un método de devolución de llamada con un prescrita <xref:System.Web.HttpResponseSubstitutionCallback> firma, puede reemplazar el resultado almacenado en caché contenido en cualquier ubicación especificada en la caché de página. Para iniciar el reemplazo, llame a la <xref:System.Web.HttpResponse.WriteSubstitution%2A> método y pásele el método de devolución de llamada, que debe ser seguro para subprocesos y puede ser cualquiera de las siguientes:  
  
-   Un método estático en el control de usuario o página de contenedor.  
  
-   Estático o de instancia de método en otro objeto arbitrario.  
  
 En la primera solicitud a la página, el <xref:System.Web.HttpResponse.WriteSubstitution%2A> llamadas la <xref:System.Web.HttpResponseSubstitutionCallback> delegado para producir el resultado. A continuación, agrega un búfer de sustitución para la respuesta, que conserva el delegado al que llamar en solicitudes futuras. Por último, degrada del lado cliente se almacena en caché de pública a solo servidor, lo que garantiza las solicitudes futuras para la página vuelva a invocar el delegado no almacenar en caché en el cliente.  
  
> [!NOTE]
>  No se admite la sustitución posterior a la caché para un control de usuario almacenadas en caché que se aplica la caché de resultados en el nivel de control de usuario. Esto también se conoce como almacenamiento en caché. Para obtener más información, consulte [almacenamiento en caché algunas partes de una página ASP.NET](https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El destino del parámetro <paramref name="callback" /> es de tipo <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
        <related type="Article" href="https://msdn.microsoft.com/library/d5fbd79f-972d-4557-9a39-f90684b3dcd3">Establecer el almacenamiento en caché de una página</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e">Almacenamiento en caché las partes de una página ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/09c9bd9a-0d68-4a5c-aa6f-1b461c208795">Actualizar dinámicamente las partes de una página almacenada en caché</related>
      </Docs>
    </Member>
  </Members>
</Type>