<Type Name="HttpContext" FullName="System.Web.HttpContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f1598bcd6d1f0d0df8fbe457cbe419cd0e1376c8" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51888895" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpContext : IServiceProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpContext extends System.Object implements class System.IServiceProvider" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpContext" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpContext&#xA;Implements IServiceProvider" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpContext sealed : IServiceProvider" />
  <TypeSignature Language="F#" Value="type HttpContext = class&#xA;    interface IServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IServiceProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsula toda la información específica de HTTP acerca de una solicitud HTTP individual.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las clases que heredan la <xref:System.Web.IHttpModule> y <xref:System.Web.IHttpHandler> interfaces se proporcionan una referencia a un <xref:System.Web.HttpContext> objeto para la solicitud HTTP actual. El objeto proporciona acceso a la función intrínseca <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A>, y <xref:System.Web.HttpContext.Server%2A> propiedades de la solicitud.  
  
> [!IMPORTANT] 
> Este objeto está listo para la recolección cuando el <xref:System.Web.HttpRequest> se ha completado. Su uso una vez finalizada la solicitud podría provocar un comportamiento indefinido, como un <xref:System.NullReferenceException>.
>
> Este objeto solo está disponible en el subproceso controlado por ASP.NET. Uso de subprocesos en segundo plano podría provocar un comportamiento indefinido.

## Examples  
 En el ejemplo siguiente se muestra cómo obtener acceso y mostrar las propiedades de la <xref:System.Web.HttpContext> objeto. El contexto de la solicitud HTTP actual se accede mediante el <xref:System.Web.UI.Page.Context%2A> propiedad de la <xref:System.Web.UI.Page> objeto.  
  
 [!code-aspx-csharp[System.Web.HttpContext#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext/cs/httpcontextcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpContext#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext/vb/httpcontextvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Web.IHttpModule" />
    <altmember cref="T:System.Web.IHttpHandler" />
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=196730">Una cuestión de contexto</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.HttpContext" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpWorkerRequest wr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpWorkerRequest wr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpWorkerRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (wr As HttpWorkerRequest)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpWorkerRequest ^ wr);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpWorkerRequest -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext wr" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="wr" Type="System.Web.HttpWorkerRequest" />
      </Parameters>
      <Docs>
        <param name="wr">Objeto <see cref="T:System.Web.HttpWorkerRequest" /> de la solicitud HTTP actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.HttpContext" /> que usa el objeto de solicitud de trabajo especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpContext (System.Web.HttpRequest request, System.Web.HttpResponse response);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Web.HttpRequest request, class System.Web.HttpResponse response) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.#ctor(System.Web.HttpRequest,System.Web.HttpResponse)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (request As HttpRequest, response As HttpResponse)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpContext(System::Web::HttpRequest ^ request, System::Web::HttpResponse ^ response);" />
      <MemberSignature Language="F#" Value="new System.Web.HttpContext : System.Web.HttpRequest * System.Web.HttpResponse -&gt; System.Web.HttpContext" Usage="new System.Web.HttpContext (request, response)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="request" Type="System.Web.HttpRequest" />
        <Parameter Name="response" Type="System.Web.HttpResponse" />
      </Parameters>
      <Docs>
        <param name="request">Objeto <see cref="T:System.Web.HttpRequest" /> de la solicitud HTTP actual.</param>
        <param name="response">Objeto <see cref="T:System.Web.HttpResponse" /> de la solicitud HTTP actual.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.HttpContext" /> usando los objetos de solicitud y respuesta especificados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcceptWebSocketRequest">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acepta una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; -&gt; unit" Usage="httpContext.AcceptWebSocketRequest userFunc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="userFunc">Función de usuario.</param>
        <summary>Acepta una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> usando la función de usuario especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método equivale a llamar a la <xref:System.Web.HttpContext.AcceptWebSocketRequest%2A> sobrecarga del método y pasando `null` para el `options` parámetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="userFunc" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La solicitud no es una solicitud de <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptWebSocketRequest">
      <MemberSignature Language="C#" Value="public void AcceptWebSocketRequest (Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt; userFunc, System.Web.WebSockets.AspNetWebSocketOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptWebSocketRequest(class System.Func`2&lt;class System.Web.WebSockets.AspNetWebSocketContext, class System.Threading.Tasks.Task&gt; userFunc, class System.Web.WebSockets.AspNetWebSocketOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AcceptWebSocketRequest(System.Func{System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task},System.Web.WebSockets.AspNetWebSocketOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptWebSocketRequest (userFunc As Func(Of AspNetWebSocketContext, Task), options As AspNetWebSocketOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptWebSocketRequest(Func&lt;System::Web::WebSockets::AspNetWebSocketContext ^, System::Threading::Tasks::Task ^&gt; ^ userFunc, System::Web::WebSockets::AspNetWebSocketOptions ^ options);" />
      <MemberSignature Language="F#" Value="member this.AcceptWebSocketRequest : Func&lt;System.Web.WebSockets.AspNetWebSocketContext, System.Threading.Tasks.Task&gt; * System.Web.WebSockets.AspNetWebSocketOptions -&gt; unit" Usage="httpContext.AcceptWebSocketRequest (userFunc, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userFunc" Type="System.Func&lt;System.Web.WebSockets.AspNetWebSocketContext,System.Threading.Tasks.Task&gt;" />
        <Parameter Name="options" Type="System.Web.WebSockets.AspNetWebSocketOptions" />
      </Parameters>
      <Docs>
        <param name="userFunc">Función de usuario.</param>
        <param name="options">Objeto de opciones.</param>
        <summary>Acepta una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> usando la función de usuario y el objeto de opciones especificados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="userFunc" /> es <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">La solicitud no es una solicitud de <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddError">
      <MemberSignature Language="C#" Value="public void AddError (Exception errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddError(class System.Exception errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddError(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddError (errorInfo As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddError(Exception ^ errorInfo);" />
      <MemberSignature Language="F#" Value="member this.AddError : Exception -&gt; unit" Usage="httpContext.AddError errorInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorInfo" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="errorInfo">Excepción <see cref="T:System.Exception" /> que se va a agregar a la colección de excepciones.</param>
        <summary>Agrega una excepción a la colección de excepciones de la solicitud HTTP actual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnRequestCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnRequestCompleted (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnRequestCompleted(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.AddOnRequestCompleted(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnRequestCompleted (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnRequestCompleted(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberSignature Language="F#" Value="member this.AddOnRequestCompleted : Action&lt;System.Web.HttpContext&gt; -&gt; System.Web.ISubscriptionToken" Usage="httpContext.AddOnRequestCompleted callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Objeto de contexto HTTP.</param>
        <summary>Genera un evento virtual que se produce cuando finaliza la parte HTTP de la solicitud.</summary>
        <returns>Token de suscripción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se produce antes de la <xref:System.Web.WebSockets.AspNetWebSocket> comienza la conexión.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="callback" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllErrors">
      <MemberSignature Language="C#" Value="public Exception[] AllErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception[] AllErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllErrors As Exception()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Exception ^&gt; ^ AllErrors { cli::array &lt;Exception ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllErrors : Exception[]" Usage="System.Web.HttpContext.AllErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una matriz de errores acumulados al procesar una solicitud HTTP.</summary>
        <value>Matriz de objetos <see cref="T:System.Exception" /> de la solicitud HTTP actual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAsyncDuringSyncStages">
      <MemberSignature Language="C#" Value="public bool AllowAsyncDuringSyncStages { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAsyncDuringSyncStages" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowAsyncDuringSyncStages As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowAsyncDuringSyncStages { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowAsyncDuringSyncStages : bool with get, set" Usage="System.Web.HttpContext.AllowAsyncDuringSyncStages" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si las operaciones asincrónicas están permitidas durante partes del procesamiento de la solicitud ASP.NET en que no se esperan.</summary>
        <value>
          <see langword="false" /> si ASP.NET producirá una excepción cuando se use la API asincrónica en un momento en que no se espera; en caso contrario, es <see langword="true" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se establece esta marca en `true`, ASP.NET se iniciará una excepción cuando detecta que la aplicación haciendo un uso indebido de la API asincrónica. Esto puede ocurrir si intenta llamar a un método asincrónico durante una parte de la solicitud de canalización de procesamiento donde no se esperan que las operaciones asincrónicas, o si hay trabajo asincrónico todavía sobresaliente cuando un módulo asincrónico o un controlador señala la finalización. Este comportamiento está pensado como una red de seguridad que le avise desde el principio si va a escribir código asincrónico que no encaja en espera de patrones y puede tener efectos negativos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As HttpApplicationState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplicationState ^ Application { System::Web::HttpApplicationState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Application : System.Web.HttpApplicationState" Usage="System.Web.HttpContext.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpApplicationState" /> de la solicitud HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpApplicationState" /> de la solicitud HTTP actual.  
  
Para obtener el objeto <see cref="T:System.Web.HttpApplication" /> de la solicitud HTTP actual, use <see cref="P:System.Web.HttpContext.ApplicationInstance" />. (ASP.NET usa <see langword="ApplicationInstance" /> en lugar de <see langword="Application" /> como nombre de propiedad para hacer referencia a la instancia de <see cref="T:System.Web.HttpApplication" /> actual con el fin de evitar la confusión entre ASP.NET y ASP clásico. En ASP clásico, <see langword="Application" /> hace referencia al diccionario de estado de la aplicación global).</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.ApplicationInstance" />
      </Docs>
    </Member>
    <Member MemberName="ApplicationInstance">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplication ApplicationInstance { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplication ApplicationInstance" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ApplicationInstance" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationInstance As HttpApplication" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpApplication ^ ApplicationInstance { System::Web::HttpApplication ^ get(); void set(System::Web::HttpApplication ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationInstance : System.Web.HttpApplication with get, set" Usage="System.Web.HttpContext.ApplicationInstance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplication</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Web.HttpApplication" /> de la solicitud HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpApplication" /> de la solicitud HTTP actual.  
  
ASP.NET usa <see langword="ApplicationInstance" /> en lugar de <see langword="Application" /> como nombre de propiedad para hacer referencia a la instancia de <see cref="T:System.Web.HttpApplication" /> actual con el fin de evitar la confusión entre ASP.NET y ASP clásico. En ASP clásico, <see langword="Application" /> hace referencia al diccionario de estado de la aplicación global.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La aplicación web se está ejecutando bajo IIS 7.0 en modo integrado y se ha realizado un intento de cambiar el valor de propiedad de un valor no nulo a <see langword="null" />.</exception>
        <altmember cref="P:System.Web.HttpContext.Application" />
      </Docs>
    </Member>
    <Member MemberName="AsyncPreloadMode">
      <MemberSignature Language="C#" Value="public System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.Configuration.AsyncPreloadModeFlags AsyncPreloadMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.AsyncPreloadMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AsyncPreloadMode As AsyncPreloadModeFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Configuration::AsyncPreloadModeFlags AsyncPreloadMode { System::Web::Configuration::AsyncPreloadModeFlags get(); void set(System::Web::Configuration::AsyncPreloadModeFlags value); };" />
      <MemberSignature Language="F#" Value="member this.AsyncPreloadMode : System.Web.Configuration.AsyncPreloadModeFlags with get, set" Usage="System.Web.HttpContext.AsyncPreloadMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.AsyncPreloadModeFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un objeto que contiene marcas que pertenecen al modo de precarga asincrónico.</summary>
        <value>Objeto que contiene marcas que pertenecen al modo de precarga asincrónico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La primera vez que se tiene acceso a esta propiedad, el objeto que contiene los marcadores de modo de precarga asincrónico se carga desde el <xref:System.Web.Configuration.HttpRuntimeSection.AsyncPreloadMode%2A> en el archivo de configuración.  
  
 Aunque esta propiedad se puede establecer mediante programación, cambiar el valor de propiedad solo tiene efecto si se establece la propiedad antes que el paso  `ExecuteRequestHandler` en la canalización de solicitudes ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As Cache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Caching::Cache ^ Cache { System::Web::Caching::Cache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Cache : System.Web.Caching.Cache" Usage="System.Web.HttpContext.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.Caching.Cache" /> del dominio de aplicación actual.</summary>
        <value>Objeto <see cref="T:System.Web.Caching.Cache" /> del dominio de aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Hay una instancia de la <xref:System.Web.Caching.Cache> clase por dominio de aplicación. Como resultado, el <xref:System.Web.Caching.Cache> objeto devuelto por la <xref:System.Web.HttpContext.Cache%2A> propiedad es el <xref:System.Web.Caching.Cache> objeto para todas las solicitudes en el dominio de aplicación.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearError">
      <MemberSignature Language="C#" Value="public void ClearError ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.ClearError" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearError ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearError();" />
      <MemberSignature Language="F#" Value="member this.ClearError : unit -&gt; unit" Usage="httpContext.ClearError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Borra todos los errores de la solicitud HTTP actual.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.HttpContext.Error" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Web.HttpContext Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.HttpContext Current" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As HttpContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpContext ^ Current { System::Web::HttpContext ^ get(); void set(System::Web::HttpContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Web.HttpContext with get, set" Usage="System.Web.HttpContext.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Web.HttpContext" /> de la solicitud HTTP actual.</summary>
        <value>Instancia de <see cref="T:System.Web.HttpContext" /> de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad es una propiedad estática de la <xref:System.Web.HttpContext> clase. Los almacenes de propiedades el <xref:System.Web.HttpContext> instancia que se aplica a la solicitud actual. Las propiedades de esta instancia son las propiedades no estáticas de la <xref:System.Web.HttpContext> clase.  
  
 También puede usar el <xref:System.Web.UI.Page.Context%2A?displayProperty=nameWithType> propiedad para tener acceso a la <xref:System.Web.HttpContext> objeto para la solicitud HTTP actual.  
  
   
  
## Examples  
 El siguiente ejemplo de código utiliza el <xref:System.Web.HttpContext.Current%2A> propiedad para tener acceso a la <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> y <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> métodos y <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> propiedad. El ejemplo crea tres excepciones personalizadas mediante el <xref:System.Web.HttpContext.AddError%2A> método y se usa el <xref:System.Web.HttpContext.AllErrors%2A> propiedad cargar estas excepciones en una matriz. Después escribe la matriz en la página contenedora y utiliza el <xref:System.Web.HttpContext.ClearError%2A> método para borrar todos los errores desde el <xref:System.Web.UI.Page.Context%2A> propiedad.  
  
```csharp  
protected void Page_Load(object sender, EventArgs e)  
{  
    HttpContext context = HttpContext.Current;  
    Response.Write("<p>HttpContext.Current Example:</p>");  
  
    // Add three custom exceptions.  
    context.AddError(new Exception("New Exception #1"));  
    context.AddError(new Exception("New Exception #2"));  
    context.AddError(new Exception("New Exception #3"));  
  
    // Capture all the new Exceptions in an array.  
    Exception[] errs = context.AllErrors;  
  
    foreach (Exception ex in errs)  
    {  
        Response.Write("<p>" + Server.HtmlEncode(ex.ToString()) + "</p>");  
    }  
  
    // Clear the exceptions so ASP.NET won't handle them.  
    context.ClearError();  
}  
```  
  
```vb  
Protected Sub Page_Load(sender As Object, e As EventArgs)  
Dim context As HttpContext = HttpContext.Current  
Response.Write("<p>HttpContext.Current Example:</p>")  
  
' Add three custom exceptions.  
context.AddError(New Exception("New Exception #1"))  
context.AddError(New Exception("New Exception #2"))  
context.AddError(New Exception("New Exception #3"))  
  
' Capture all the new Exceptions in an array.  
Dim errs As Exception() = context.AllErrors  
  
For Each ex As Exception In errs  
Response.Write("<p>" & Server.HtmlEncode(ex.ToString()) & "</p>")  
Next  
  
' Clear the exceptions so ASP.NET won't handle them.  
context.ClearError()  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Response" />
        <altmember cref="P:System.Web.HttpContext.Request" />
      </Docs>
    </Member>
    <Member MemberName="CurrentHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler CurrentHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler CurrentHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ CurrentHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.CurrentHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.IHttpHandler" /> que representa el controlador que se ejecuta actualmente.</summary>
        <value>Objeto <see cref="T:System.Web.IHttpHandler" /> que representa el controlador que se ejecuta actualmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El controlador que se ejecuta actualmente al que hace referencia el <xref:System.Web.HttpContext.CurrentHandler%2A> propiedad puede ser diferente que el controlador al que hace referencia el <xref:System.Web.HttpContext.Handler%2A> propiedad. Esto puede ocurrir cuando se solicitó el otro controlador mediante el uso de la <xref:System.Web.HttpServerUtility.Execute%2A> método o la <xref:System.Web.HttpServerUtility.Transfer%2A> método. Cuando el controlador que se ejecuta actualmente termina el procesamiento, se restaura el controlador previamente determinado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Introducción a los módulos y controladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentNotification">
      <MemberSignature Language="C#" Value="public System.Web.RequestNotification CurrentNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.RequestNotification CurrentNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.CurrentNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentNotification As RequestNotification" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::RequestNotification CurrentNotification { System::Web::RequestNotification get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentNotification : System.Web.RequestNotification" Usage="System.Web.HttpContext.CurrentNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.RequestNotification</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor de <see cref="T:System.Web.RequestNotification" /> que indica el evento <see cref="T:System.Web.HttpApplication" /> actual que se está procesando.</summary>
        <value>Uno de los valores de <see cref="T:System.Web.RequestNotification" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos la versión 3.0 de .NET Framework. Cuando esté disponible, la propiedad devuelve un <xref:System.Web.RequestNotification> valor. El valor de la <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad indica qué evento en el <xref:System.Web.HttpApplication> instancia está procesando la solicitud.  
  
 El <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad no está pensada para establecerse. En su lugar, se establece de forma [!INCLUDE[iisver](~/includes/iisver-md.md)] durante el procesamiento de la solicitud en la canalización de ASP.NET. Establecer el <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad dará como resultado un error de compilación.  
  
 <xref:System.Web.HttpContext.CurrentNotification%2A> se introdujo en .NET Framework versión 3.5.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad para determinar qué eventos de la <xref:System.Web.HttpApplication> se está procesando el objeto que controla la solicitud actual. En el ejemplo, el controlador de eventos administra varios eventos de la <xref:System.Web.HttpApplication> objeto y el <xref:System.Web.HttpContext.CurrentNotification%2A> propiedad determina qué código se invoca para cada evento que se controla.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La operación requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)] y como mínimo la versión 3.0 de .NET Framework.</exception>
        <altmember cref="P:System.Web.HttpContext.IsPostNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="DisposeOnPipelineCompleted">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken DisposeOnPipelineCompleted (IDisposable target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken DisposeOnPipelineCompleted(class System.IDisposable target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.DisposeOnPipelineCompleted(System.IDisposable)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisposeOnPipelineCompleted (target As IDisposable) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ DisposeOnPipelineCompleted(IDisposable ^ target);" />
      <MemberSignature Language="F#" Value="member this.DisposeOnPipelineCompleted : IDisposable -&gt; System.Web.ISubscriptionToken" Usage="httpContext.DisposeOnPipelineCompleted target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.IDisposable" />
      </Parameters>
      <Docs>
        <param name="target">El objeto a cuyo método <see cref="M:System.IDisposable.Dispose" /> debe llamarse cuando se complete la parte de conexión de <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> de la solicitud.</param>
        <summary>Permite llamar al método <see cref="M:System.IDisposable.Dispose" /> de un objeto cuando se complete la parte de conexión de <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> de esta solicitud.</summary>
        <returns>Token de suscripción.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IDisposable.Dispose%2A> se llama al método del objeto de destino después de la parte HTTP de la solicitud y la <xref:System.Web.WebSockets.AspNetWebSocket> haya finalizado la conexión. La <xref:System.Web.HttpContext> objeto no está disponible para su inspección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public Exception Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception Error" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Error" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Error As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ Error { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : Exception" Usage="System.Web.HttpContext.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el primer error (si existe) acumulado durante el procesamiento de la solicitud HTTP.</summary>
        <value>Primera <see cref="T:System.Exception" /> del procesamiento de la solicitud/respuesta HTTP actual; en caso contrario, es <see langword="null" /> si no se acumuló ningún error durante el procesamiento de la solicitud HTTP. El valor predeterminado es <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.HttpContext.ClearError" />
      </Docs>
    </Member>
    <Member MemberName="GetAppConfig">
      <MemberSignature Language="C#" Value="public static object GetAppConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetAppConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetAppConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAppConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetAppConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetAppConfig : string -&gt; obj" Usage="System.Web.HttpContext.GetAppConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Etiqueta de configuración de la aplicación para la que se solicitó información.</param>
        <summary>Devuelve la información de configuración solicitada para la aplicación actual.</summary>
        <returns>Objeto que contiene la información de configuración. (Convierta la sección de configuración devuelta al tipo de configuración adecuado antes de usarla).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Web.HttpContext.GetAppConfig%2A> está desusado. Use la <xref:System.Web.Configuration.WebConfigurationManager.GetWebApplicationSection%2A> método de la <xref:System.Web.Configuration.WebConfigurationManager> clase para obtener información de configuración de la aplicación actual.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
      </Docs>
    </Member>
    <Member MemberName="GetConfig">
      <MemberSignature Language="C#" Value="public object GetConfig (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetConfig(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetConfig(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfig (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetConfig(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetConfig : string -&gt; obj" Usage="httpContext.GetConfig name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("The recommended alternative is System.Web.HttpContext.GetSection in System.Web.dll. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Etiqueta de configuración para la que se solicitó información.</param>
        <summary>Devuelve la información de configuración solicitada para la solicitud HTTP actual.</summary>
        <returns>Objeto <see cref="T:System.Configuration.ConfigurationSection" /> especificado, <see langword="null" /> si la sección no existe o un objeto interno si no se puede obtener acceso a la sección en tiempo de ejecución. (Convierta el objeto devuelto al tipo de configuración adecuado antes de usarlo).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El método <xref:System.Web.HttpContext.GetConfig%2A> está desusado. Use el <xref:System.Web.HttpContext.GetSection%2A> método para obtener información de configuración de la solicitud HTTP actual.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpContext.GetSection(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGlobalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un recurso de nivel de aplicación.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Diseño del sitio Web ASP.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="classKey">Cadena que representa la propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> del objeto de recurso solicitado.</param>
        <param name="resourceKey">Cadena que representa la propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> del objeto de recurso solicitado.</param>
        <summary>Obtiene un objeto de recurso de nivel de aplicación basado en las propiedades <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> y <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas.</summary>
        <returns>
          <see cref="T:System.Object" /> que representa el objeto de recurso de nivel de aplicación solicitado; devuelve null si no se encuentra ningún objeto de recurso o si se encuentra uno pero no tiene la propiedad solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.GetGlobalResourceObject%2A> método devuelve un recurso global mediante el uso de la referencia cultural que se especifica en el <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propiedad.  
  
> [!NOTE]
>  En algunos entornos de edición, como [!INCLUDE[vwprvw](~/includes/vwprvw-md.md)], el editor podría producir un tiempo de diseño <xref:System.Resources.MissingManifestResourceException> excepción si utiliza un punto (.) en el nombre de clave de recurso global. Sin embargo, esto no afecta a su capacidad de editar o guardar el archivo, y puede omitir el error.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">No se ha encontrado un objeto de recurso con el parámetro <paramref name="classKey" /> especificado.  
  
\- o - 
El ensamblado principal no contiene los recursos para la referencia cultural neutra y se requieren estos recursos porque falta el ensamblado satélite adecuado.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Diseño del sitio Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetar e implementar recursos</related>
      </Docs>
    </Member>
    <Member MemberName="GetGlobalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetGlobalResourceObject (string classKey, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetGlobalResourceObject(string classKey, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetGlobalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGlobalResourceObject (classKey As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetGlobalResourceObject(System::String ^ classKey, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetGlobalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetGlobalResourceObject (classKey, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="classKey" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="classKey">Cadena que representa la propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> del objeto de recurso solicitado.</param>
        <param name="resourceKey">Cadena que representa una propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> del objeto de recurso solicitado.</param>
        <param name="culture">Cadena que representa el objeto <see cref="T:System.Globalization.CultureInfo" /> del recurso solicitado.</param>
        <summary>Obtiene un objeto de recurso de nivel de aplicación basado en las propiedades <see cref="P:System.Web.Compilation.ResourceExpressionFields.ClassKey" /> y <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas, y en el objeto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>
          <see cref="T:System.Object" /> que representa el objeto de recurso de nivel de aplicación solicitado, que se adaptó a la referencia cultural especificada; es <see langword="null" /> si no se encuentra ningún objeto de recurso o si se encuentra uno pero no tiene la propiedad solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Globalization.CultureInfo> objeto representa la referencia cultural que se va a adaptar el recurso. Si no se encuentra el recurso para esta referencia cultural, la búsqueda seguirá un proceso de reserva para buscar un recurso adecuado. Para obtener más información, vea [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) (Empaquetar e implementar recursos).  
  
> [!NOTE]
>  En algunos entornos de edición, por ejemplo, Visual Web Developer, el editor podría producir un tiempo de diseño <xref:System.Resources.MissingManifestResourceException> excepción si utiliza un punto (.) en el nombre de clave de recurso global. Sin embargo, esto no afecta a su capacidad de editar o guardar el archivo, y puede omitir el error.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">Objeto de recurso para el que no se ha encontrado el parámetro <paramref name="classKey" /> especificado.  
  
\- o - 
El ensamblado principal no contiene los recursos para la referencia cultural neutra y se requieren estos recursos porque falta el ensamblado satélite adecuado.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetar e implementar recursos</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLocalResourceObject">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene un recurso de nivel de página.</summary>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Diseño del sitio Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetar e implementar recursos</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Propiedad <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> del objeto de recurso local.</param>
        <param name="resourceKey">Cadena que representa una propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> del objeto de recurso solicitado</param>
        <summary>Obtiene un objeto de recurso de nivel de página basado en las propiedades <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> y <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas.</summary>
        <returns>
          <see cref="T:System.Object" /> que representa el objeto de recurso de nivel de página solicitado; en caso contrario, es <see langword="null" /> si se encuentra un objeto de recurso correspondiente pero no un parámetro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.GetLocalResourceObject%2A> método devuelve un recurso local mediante el uso de la referencia cultural que se especifica en el <xref:System.Globalization.CultureInfo.CurrentUICulture%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">No se ha encontrado un objeto de recurso para el parámetro <paramref name="virtualPath" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="virtualPath" /> especificado no está en el directorio raíz de la aplicación actual.</exception>
        <exception cref="T:System.InvalidOperationException">No se encontró la clase de recurso para la página.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Diseño del sitio Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetar e implementar recursos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Cómo: recuperar valores de recursos mediante programación</related>
      </Docs>
    </Member>
    <Member MemberName="GetLocalResourceObject">
      <MemberSignature Language="C#" Value="public static object GetLocalResourceObject (string virtualPath, string resourceKey, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetLocalResourceObject(string virtualPath, string resourceKey, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetLocalResourceObject(System.String,System.String,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLocalResourceObject (virtualPath As String, resourceKey As String, culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetLocalResourceObject(System::String ^ virtualPath, System::String ^ resourceKey, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member GetLocalResourceObject : string * string * System.Globalization.CultureInfo -&gt; obj" Usage="System.Web.HttpContext.GetLocalResourceObject (virtualPath, resourceKey, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
        <Parameter Name="resourceKey" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Propiedad <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> del objeto de recurso local.</param>
        <param name="resourceKey">Cadena que representa una propiedad <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> del objeto de recurso solicitado.</param>
        <param name="culture">Cadena que representa el objeto <see cref="T:System.Globalization.CultureInfo" /> del objeto de recurso solicitado.</param>
        <summary>Obtiene un objeto de recurso de nivel de página basado en las propiedades <see cref="P:System.Web.Compilation.ExpressionBuilderContext.VirtualPath" /> y <see cref="P:System.Web.Compilation.ResourceExpressionFields.ResourceKey" /> especificadas y en el objeto <see cref="T:System.Globalization.CultureInfo" />.</summary>
        <returns>
          <see cref="T:System.Object" /> que representa el objeto de recurso local solicitado, que se adapta a la referencia cultural especificada; en caso contrario, es <see langword="null" /> si se encuentra un objeto de recurso correspondiente pero no un parámetro <paramref name="resourceKey" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si no se encuentra el recurso para esta referencia cultural, la búsqueda seguirá un proceso de reserva para buscar un recurso adecuado. Para obtener más información, vea [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) (Empaquetar e implementar recursos).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Resources.MissingManifestResourceException">No se ha encontrado un objeto de recurso para el parámetro <paramref name="virtualPath" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="virtualPath" /> especificado no está en el directorio raíz de la aplicación actual.</exception>
        <exception cref="T:System.InvalidOperationException">No se encontró la clase de recurso para la página.</exception>
        <altmember cref="T:System.Web.Compilation.ResourceExpressionBuilder" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ad495d4-2941-40cf-bf64-e82e85825890">Recursos de aplicaciones</related>
        <related type="Article" href="https://msdn.microsoft.com/library/345e86a7-3851-4cdc-8309-a77bdb0d0a97">Diseño del sitio Web ASP.NET</related>
        <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">Empaquetar e implementar recursos</related>
        <related type="Article" href="https://msdn.microsoft.com/library/7a06d512-6fc3-40ca-9cb6-7f41d1a9fa28">Cómo: recuperar valores de recursos mediante programación</related>
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="member this.GetSection : string -&gt; obj" Usage="httpContext.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Ruta de acceso de la sección de configuración (en formato XPath) y nombre del elemento de configuración.</param>
        <summary>Obtiene una sección de configuración especificada para la configuración predeterminada de la aplicación actual.</summary>
        <returns>Objeto <see cref="T:System.Configuration.ConfigurationSection" /> especificado, <see langword="null" /> si la sección no existe o un objeto interno si no se puede obtener acceso a la sección en tiempo de ejecución.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Handler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler Handler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler Handler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Handler" />
      <MemberSignature Language="VB.NET" Value="Public Property Handler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ Handler { System::Web::IHttpHandler ^ get(); void set(System::Web::IHttpHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Handler : System.Web.IHttpHandler with get, set" Usage="System.Web.HttpContext.Handler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el objeto <see cref="T:System.Web.IHttpHandler" /> responsable del procesamiento de la solicitud HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.IHttpHandler" /> responsable del procesamiento de la solicitud HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.Handler%2A> propiedad contiene una referencia al controlador que procesa la solicitud HTTP. El controlador puede especificarse mediante el elemento, o mediante un controlador personalizado definido en el código de usuario. Para obtener más información sobre los controladores, consulte [Introducción a los módulos y controladores HTTP](https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b).  
  
 La referencia a la <xref:System.Web.HttpContext.Handler%2A> propiedad seguirá siendo el mismo incluso después de la página actual ha sido cambiada por un método del lado servidor, como el <xref:System.Web.HttpServerUtility.Execute%2A> método o la <xref:System.Web.HttpServerUtility.Transfer%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <altmember cref="P:System.Web.HttpContext.PreviousHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Introducción a los módulos y controladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomErrorEnabled">
      <MemberSignature Language="C#" Value="public bool IsCustomErrorEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomErrorEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCustomErrorEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCustomErrorEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomErrorEnabled : bool" Usage="System.Web.HttpContext.IsCustomErrorEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se habilitaron errores personalizados para la solicitud HTTP actual.</summary>
        <value>Es <see langword="true" /> si se habilitaron errores personalizados; en caso contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDebuggingEnabled">
      <MemberSignature Language="C#" Value="public bool IsDebuggingEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDebuggingEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDebuggingEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDebuggingEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDebuggingEnabled : bool" Usage="System.Web.HttpContext.IsDebuggingEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la solicitud HTTP actual está en modo de depuración.</summary>
        <value>Es <see langword="true" /> si la solicitud está en modo de depuración; en caso contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostNotification">
      <MemberSignature Language="C#" Value="public bool IsPostNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostNotification" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsPostNotification" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPostNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPostNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPostNotification : bool" Usage="System.Web.HttpContext.IsPostNotification" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que es el punto de procesamiento actual en la canalización de ASP.NET justo después de que un evento de <see cref="T:System.Web.HttpApplication" /> haya finalizado el procesamiento.</summary>
        <value>Es <see langword="true" /> si se habilitaron errores personalizados; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad solo es compatible con el modo integrado de [!INCLUDE[iisver](~/includes/iisver-md.md)] y al menos .NET Framework 3.0. Cuando esté disponible, la propiedad devuelve un valor booleano que indica si un evento en el <xref:System.Web.HttpApplication> objeto ha finalizado su procesamiento.  
  
 El <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad no está pensada para establecerse. En su lugar, se proporciona por [!INCLUDE[iisver](~/includes/iisver-md.md)] al tiempo de ejecución ASP.NET para cada notificación. Establecer el <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad dará como resultado un error de compilación.  
  
 En escenarios donde varios eventos de la <xref:System.Web.HttpApplication> objeto se controlan mediante un controlador de eventos, puede usar el <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad en combinación con el <xref:System.Web.RequestNotification> enumeración para determinar exactamente donde se encuentra en el ciclo de vida de aplicación actual es la solicitud.  
  
 <xref:System.Web.HttpContext.IsPostNotification%2A> se introdujo en .NET Framework versión 3.5.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar el <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad para determinar cuándo un evento de la <xref:System.Web.HttpApplication> objeto ha finalizado el procesamiento de todos los controladores de eventos asociados. El controlador de eventos personalizado en este ejemplo administra varios eventos de la <xref:System.Web.HttpApplication> objeto y el <xref:System.Web.HttpContext.IsPostNotification%2A> propiedad se utiliza para determinar qué código se invoca después de que se controla un evento específico.  
  
 [!code-csharp[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.IsPostNotification#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.IsPostNotification/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">La operación requiere el modo de canalización integrada de [!INCLUDE[iisver](~/includes/iisver-md.md)] y como mínimo la versión 3.0 de .NET Framework.</exception>
        <altmember cref="P:System.Web.HttpContext.CurrentNotification" />
        <altmember cref="T:System.Web.RequestNotification" />
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequest">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequest { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequest" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequest" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequest As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequest { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequest : bool" Usage="System.Web.HttpContext.IsWebSocketRequest" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si es una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>
          <see langword="true" /> si la solicitud es una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" />; de lo contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método devuelve `true` si la solicitud contiene inicial <xref:System.Web.WebSockets.AspNetWebSocket> protocolo de enlace y el `WebSocket` módulo de IIS está activo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWebSocketRequestUpgrading">
      <MemberSignature Language="C#" Value="public bool IsWebSocketRequestUpgrading { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWebSocketRequestUpgrading" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWebSocketRequestUpgrading As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWebSocketRequestUpgrading { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWebSocketRequestUpgrading : bool" Usage="System.Web.HttpContext.IsWebSocketRequestUpgrading" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la conexión se está actualizando de una conexión HTTP a una conexión <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Es <see langword="true" /> si la conexión se está actualizando; en caso contrario, es <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Items { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.IDictionary" Usage="System.Web.HttpContext.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una colección de pares clave/valor que permite organizar y compartir datos entre una interfaz <see cref="T:System.Web.IHttpModule" /> y una interfaz <see cref="T:System.Web.IHttpHandler" /> durante una solicitud HTTP.</summary>
        <value>Colección de pares clave/valor <see cref="T:System.Collections.IDictionary" /> que proporciona acceso a un valor individual de la colección mediante una clave especificada.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms972109.aspx">Una cuestión de contexto</related>
      </Docs>
    </Member>
    <Member MemberName="PageInstrumentation">
      <MemberSignature Language="C#" Value="public System.Web.Instrumentation.PageInstrumentationService PageInstrumentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Instrumentation.PageInstrumentationService PageInstrumentation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PageInstrumentation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PageInstrumentation As PageInstrumentationService" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Instrumentation::PageInstrumentationService ^ PageInstrumentation { System::Web::Instrumentation::PageInstrumentationService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageInstrumentation : System.Web.Instrumentation.PageInstrumentationService" Usage="System.Web.HttpContext.PageInstrumentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Instrumentation.PageInstrumentationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la instancia del servicio de instrumentación de página para esta solicitud.</summary>
        <value>Instancia del servicio de instrumentación de página para esta solicitud.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousHandler">
      <MemberSignature Language="C#" Value="public System.Web.IHttpHandler PreviousHandler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.IHttpHandler PreviousHandler" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.PreviousHandler" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousHandler As IHttpHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::IHttpHandler ^ PreviousHandler { System::Web::IHttpHandler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousHandler : System.Web.IHttpHandler" Usage="System.Web.HttpContext.PreviousHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.IHttpHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.IHttpHandler" /> para el controlador primario.</summary>
        <value>Instancia de <see cref="T:System.Web.IHttpHandler" />, o <see langword="null" /> si no se encontró ningún controlador anterior.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.PreviousHandler%2A> propiedad corresponde al último controlador antes de que se ejecutó la solicitud actual.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.HttpContext.Handler" />
        <altmember cref="P:System.Web.HttpContext.CurrentHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/f540bdeb-d22e-4e1d-ba8a-fe6c9926283b">Introducción a los módulos y controladores HTTP</related>
      </Docs>
    </Member>
    <Member MemberName="Profile">
      <MemberSignature Language="C#" Value="public System.Web.Profile.ProfileBase Profile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Profile.ProfileBase Profile" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Profile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Profile As ProfileBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::Profile::ProfileBase ^ Profile { System::Web::Profile::ProfileBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Profile : System.Web.Profile.ProfileBase" Usage="System.Web.HttpContext.Profile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Profile.ProfileBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.Profile.ProfileBase" /> del perfil de usuario actual.</summary>
        <value>Objeto <see cref="T:System.Web.Profile.ProfileBase" /> si el archivo de configuración de la aplicación contiene una definición para las propiedades del perfil; de lo contrario, es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Web.HttpContext.Profile%2A> propiedad se utiliza para obtener almacenamiento persistente de datos estructurados mediante una API de seguridad de tipos. Cuando un <xref:System.Web.HttpContext.Profile%2A> se tiene acceso a propiedad, pero ningún valor está presente, se devuelve una instancia vacía; `null` no se devuelve.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Web.Profile" />
      </Docs>
    </Member>
    <Member MemberName="RemapHandler">
      <MemberSignature Language="C#" Value="public void RemapHandler (System.Web.IHttpHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemapHandler(class System.Web.IHttpHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemapHandler (handler As IHttpHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemapHandler(System::Web::IHttpHandler ^ handler);" />
      <MemberSignature Language="F#" Value="member this.RemapHandler : System.Web.IHttpHandler -&gt; unit" Usage="httpContext.RemapHandler handler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Web.IHttpHandler" />
      </Parameters>
      <Docs>
        <param name="handler">Objeto que debe procesar la solicitud.</param>
        <summary>Permite especificar un controlador para la solicitud.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si establece `handler` a `null`, el controlador predeterminado se utiliza para procesar la solicitud. Puede establecer `handler` en un controlador asincrónico o un controlador sincrónico. El controlador debe implementar la <xref:System.Web.IHttpHandler> interfaz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llamó al método <see cref="M:System.Web.HttpContext.RemapHandler(System.Web.IHttpHandler)" /> después de que se produjera el evento <see cref="E:System.Web.HttpApplication.MapRequestHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Request" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Request As HttpRequest" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpRequest ^ Request { System::Web::HttpRequest ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.Web.HttpRequest" Usage="System.Web.HttpContext.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpRequest" /> de la solicitud HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpRequest" /> de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.Request%2A> propiedad proporciona acceso mediante programación a las propiedades y métodos de la <xref:System.Web.HttpRequest> clase. Dado que las páginas ASP.NET contienen una referencia predeterminada a la <xref:System.Web> espacio de nombres (que contiene el <xref:System.Web.HttpContext> clase), puede hacer referencia a los miembros de <xref:System.Web.HttpRequest> en una página .aspx sin utilizar la referencia de clase completo a <xref:System.Web.HttpContext>. Por ejemplo, puede usar `Request.Browser` para obtener las funcionalidades del explorador del cliente. Sin embargo, si desea usar los miembros de <xref:System.Web.HttpRequest> desde un módulo de código subyacente ASP.NET, debe incluir una referencia a la <xref:System.Web> espacio de nombres en el módulo y una referencia completa al contexto de solicitud/respuesta activo actualmente y el clase <xref:System.Web> que desea usar. Por ejemplo, en una página de código subyacente debe especificar el nombre completo `HttpContext.Current.Request.Browser`.  
  
> [!NOTE]
>  ASP.NET se iniciará una excepción si intenta utilizar esta propiedad cuando la <xref:System.Web.HttpRequest> objeto no está disponible. Por ejemplo, esto sería true en el método Application_Start del archivo Global.asax o en un método que se llama desde el método Application_Start. En ese momento no se ha creado todavía ninguna solicitud HTTP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La aplicación web se está ejecutando bajo IIS 7 en modo integrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Response" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Response As HttpResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpResponse ^ Response { System::Web::HttpResponse ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Response : System.Web.HttpResponse" Usage="System.Web.HttpContext.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpResponse" /> de la respuesta HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.HttpResponse" /> de la respuesta HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.Response%2A> propiedad proporciona acceso mediante programación a las propiedades y métodos de la <xref:System.Web.HttpResponse> clase. Dado que las páginas ASP.NET contienen una referencia predeterminada a la <xref:System.Web> espacio de nombres (que contiene el <xref:System.Web.HttpContext> clase), puede hacer referencia a los miembros de <xref:System.Web.HttpContext> en una página .aspx sin utilizar la referencia de clase completo a <xref:System.Web.HttpContext>. Por ejemplo, puede usar `Response.Write("some output")` para escribir la salida en un flujo de salida HTTP. Sin embargo, si desea usar los miembros de <xref:System.Web.HttpResponse> desde un módulo de código subyacente ASP.NET, debe incluir una referencia a la <xref:System.Web> espacio de nombres en el módulo y una referencia completa para el contexto de solicitud/respuesta activo actualmente y la clase <xref:System.Web> que desea usar. Por ejemplo, en una página de código subyacente debe especificar el nombre completo `HttpContext.Current.Response.Write("some output")`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">La aplicación web se está ejecutando bajo IIS 7 en modo integrado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RewritePath">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Redirige una solicitud para un recurso a una ruta de acceso diferente de la indicada por la dirección URL solicitada. Se utiliza <see cref="Overload:System.Web.HttpContext.RewritePath" /> en el estado de sesión sin cookies para quitar los identificadores de sesión de las direcciones URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string -&gt; unit" Usage="httpContext.RewritePath path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de reescritura interna.</param>
        <summary>Reescribe la dirección URL usando la ruta de acceso dada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.RewritePath%28System.String%29> método redirige una solicitud para un recurso a otra ruta de acceso a la que se indica mediante la dirección URL solicitada. Si tiene que restablecer la ruta de acceso virtual para que se resuelvan correctamente las solicitudes del cliente para los recursos del servidor, utilice la sobrecarga de este método que toma el `rebaseClientPath` parámetro y establezca el parámetro en `false`.  
  
 Reescritura de URL es útil cuando desea reestructurar las páginas de la aplicación Web, y desea asegurarse de que las personas que han colocado un marcador de direcciones URL anteriores pueden seguir usándolos después de haber movido las páginas. Reescritura de URL le permite reenviar solicitudes a la nueva ubicación de la página de forma transparente.  
  
 Si desea permitir que un sitio utilizar direcciones URL que son más fáciles de usar y están optimizadas para los motores de búsqueda, una alternativa más robusta es usar el enrutamiento de ASP.NET. Para obtener más información, consulte [enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Web.HttpContext.RewritePath%2A> método para permitir que un sitio Web responder a las direcciones URL que no reflejan la estructura de archivos en el sitio Web. El primer bloque de código es una página Web ASP.NET que se denomina RewritePath.aspx. Requiere una cadena de consulta. Si el nombre del sitio es WebSite1, la dirección URL `http://localhost/WebSite1/RewritePath.aspx?page=1` muestra "Página 1" en el explorador. El bloque de código que sigue a la página Web es el `Application_BeginRequest` controlador de eventos en el archivo Global.asax. Este código intercepta las solicitudes para direcciones URL como `http://localhost/WebSite1/page1` y los convierte en el formulario que se requiere para RewritePath.aspx antes de ser procesados. Por lo tanto, la dirección URL `http://localhost/WebSite1/page1` invoca RewritePath.aspx con el parámetro de cadena de consulta que muestra "Página 1" en el explorador. Si una dirección URL como `http://localhost/WebSite1/page1` se recibe, una sobrecarga de <xref:System.Web.HttpContext.RewritePath%2A> se invoca que le permite proporcionar un valor para el <xref:System.Web.HttpRequest.PathInfo%2A> parámetro de cadena de propiedad, así como una consulta.  
  
 [!code-aspx-csharp[HttpContext_RewritePath#2](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/rewritepath.aspx#2)]
 [!code-aspx-vb[HttpContext_RewritePath#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/rewritepath.aspx#2)]  
  
 [!code-csharp[HttpContext_RewritePath#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpContext_ReWritePath/CS/global.asax#1)]
 [!code-vb[HttpContext_RewritePath#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpContext_ReWritePath/VB/global.asax#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">El parámetro <paramref name="path" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Tutorial: Usar el enrutamiento en una aplicación de Web Forms de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string path, bool rebaseClientPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string path, bool rebaseClientPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (path As String, rebaseClientPath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ path, bool rebaseClientPath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * bool -&gt; unit" Usage="httpContext.RewritePath (path, rebaseClientPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="rebaseClientPath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ruta de acceso de reescritura interna.</param>
        <param name="rebaseClientPath">Es <see langword="true" /> para restablecer la ruta de acceso virtual; es <see langword="false" /> para mantener si cambios la ruta de acceso virtual.</param>
        <summary>Reescribe la dirección URL usando la ruta de acceso dada y un valor booleano que especifica si se modifica la ruta de acceso virtual a los recursos del servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.RewritePath%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> llama al método el <xref:System.Web.HttpContext.RewritePath%28System.String%29?displayProperty=nameWithType> método con el `rebaseClientPath` parámetro establecido en `true`. Para asegurarse de que no se modifica la ruta de acceso virtual que se utiliza para construir las rutas de acceso a los recursos, establezca el `rebaseClientPath` parámetro `false`. Un escenario común en el que desea establecer `rebaseClientPath` a `false` es cuando necesite volver a escribir la dirección URL, y está usando los temas y redirigir la dirección URL a un recurso que se encuentra en una carpeta distinta que el recurso solicitado.  
  
 Reescritura de URL es útil cuando desea reestructurar las páginas de la aplicación Web, y desea asegurarse de que las personas que han colocado un marcador de direcciones URL anteriores pueden seguir usándolos después de haber movido las páginas. Reescritura de URL le permite reenviar solicitudes a la nueva ubicación de la página de forma transparente.  
  
 Si desea permitir que un sitio utilizar direcciones URL que son más fáciles de usar y están optimizadas para los motores de búsqueda, una alternativa más robusta es usar el enrutamiento de ASP.NET. Para obtener más información, consulte [enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea el <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">El parámetro <paramref name="path" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Tutorial: Usar el enrutamiento en una aplicación de Web Forms de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filePath">Ruta de acceso de reescritura interna.</param>
        <param name="pathInfo">Información adicional de la ruta de acceso de un recurso. Para obtener más información, vea <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Cadena de consulta de la solicitud.</param>
        <summary>Reescribe la dirección URL usando la ruta de acceso, la información de la ruta de acceso y la información de la cadena de consulta especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.RewritePath%2A> método redirige una solicitud para un recurso a otro recurso sin cambiar la dirección URL.  
  
 El `filePath` parámetro no incluye el `pathInfo` contenido del parámetro. Para la dirección URL http://www.microsoft.com/virdir/page.html/tail, `filePath` parámetro es http://www.microsoft.com/virdir/page.htmly el `pathInfo` es el parámetro final.  
  
 Reescritura de URL es útil cuando desea reestructurar las páginas de la aplicación Web, y desea asegurarse de que las personas que han colocado un marcador de direcciones URL anteriores pueden seguir usándolos después de haber movido las páginas. Reescritura de URL le permite reenviar solicitudes a la nueva ubicación de la página de forma transparente.  
  
 Si desea permitir que un sitio utilizar direcciones URL que son más fáciles de usar y están optimizadas para los motores de búsqueda, una alternativa más robusta es usar el enrutamiento de ASP.NET. Para obtener más información, consulte [enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obtener un ejemplo de código, e incluye un ejemplo de esta sobrecarga del método, consulte el <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <exception cref="T:System.Web.HttpException">El parámetro <paramref name="filePath" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Tutorial: Usar el enrutamiento en una aplicación de Web Forms de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RewritePath">
      <MemberSignature Language="C#" Value="public void RewritePath (string filePath, string pathInfo, string queryString, bool setClientFilePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RewritePath(string filePath, string pathInfo, string queryString, bool setClientFilePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.RewritePath(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RewritePath (filePath As String, pathInfo As String, queryString As String, setClientFilePath As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RewritePath(System::String ^ filePath, System::String ^ pathInfo, System::String ^ queryString, bool setClientFilePath);" />
      <MemberSignature Language="F#" Value="member this.RewritePath : string * string * string * bool -&gt; unit" Usage="httpContext.RewritePath (filePath, pathInfo, queryString, setClientFilePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filePath" Type="System.String" />
        <Parameter Name="pathInfo" Type="System.String" />
        <Parameter Name="queryString" Type="System.String" />
        <Parameter Name="setClientFilePath" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filePath">Ruta de acceso virtual al recurso que atiende la solicitud.</param>
        <param name="pathInfo">Información adicional de la ruta de acceso que se va a usar para redireccionar la dirección URL. Para obtener más información, vea <see cref="P:System.Web.HttpRequest.PathInfo" />.</param>
        <param name="queryString">Cadena de consulta de solicitud que se va a usar para redireccionar la dirección URL.</param>
        <param name="setClientFilePath">
          <see langword="true" /> para establecer la ruta de acceso que utilizan los recursos del cliente como el valor del parámetro <c>filePath</c>; en caso contrario, <see langword="false" />.</param>
        <summary>Reescribe la dirección URL usando la ruta de acceso virtual dada, la información de la ruta de acceso, la información la de cadena de consulta y un valor booleano que especifica si la ruta de acceso del archivo del cliente se establece en la ruta de acceso de reescritura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `filePath` parámetro no incluye el contenido de la `pathInfo` parámetro. Para la dirección URL http://www.microsoft.com/virdir/page.html/tail, `filePath` parámetro es http://www.microsoft.com/virdir/page.htmly el `pathInfo` es el parámetro final.  
  
 Para asegurarse de que no se modifica la ruta de acceso virtual que se utiliza para construir las rutas de acceso a los recursos, establezca el `setClientFilePath` parámetro `false`. Un escenario común en el que desea establecer `setClientFilePath` a `false` es cuando necesite volver a escribir la dirección URL, y está usando los temas y redirigir la dirección URL a un recurso que se encuentra en una carpeta distinta que el recurso solicitado.  
  
 Reescritura de URL es útil cuando desea reestructurar las páginas de la aplicación Web, y desea asegurarse de que las personas que han colocado un marcador de direcciones URL anteriores pueden seguir usándolos después de haber movido las páginas. Reescritura de URL le permite reenviar solicitudes a la nueva ubicación de la página de forma transparente.  
  
 Si desea permitir que un sitio utilizar direcciones URL que son más fáciles de usar y están optimizadas para los motores de búsqueda, una alternativa más robusta es usar el enrutamiento de ASP.NET. Para obtener más información, consulte [enrutamiento de ASP.NET](https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
   
  
## Examples  
 Para obtener un ejemplo de código, vea el <xref:System.Web.HttpContext.RewritePath%28System.String%29> sobrecarga del método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="path" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <exception cref="T:System.Web.HttpException">El parámetro <paramref name="filePath" /> no se encuentra en el directorio raíz de la aplicación actual.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a">Enrutamiento de ASP.NET</related>
        <related type="Article" href="https://msdn.microsoft.com/library/b2decba4-2400-491c-8907-89a7b9e0874c">Tutorial: Usar el enrutamiento en una aplicación de Web Forms de ASP.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As HttpServerUtility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpServerUtility ^ Server { System::Web::HttpServerUtility ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Web.HttpServerUtility" Usage="System.Web.HttpContext.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.HttpServerUtility" /> que proporciona los métodos que se usan en el procesamiento de solicitudes web.</summary>
        <value>Objeto <see cref="T:System.Web.HttpServerUtility" /> de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.Server%2A> propiedad proporciona acceso mediante programación a las propiedades y métodos de la <xref:System.Web.HttpServerUtility> clase. Dado que las páginas ASP.NET contienen una referencia predeterminada a la <xref:System.Web> espacio de nombres (que contiene el <xref:System.Web.HttpContext> clase), puede hacer referencia a los miembros de <xref:System.Web.HttpContext> en una página .aspx sin utilizar la referencia de clase completo a <xref:System.Web.HttpContext>. Por ejemplo, puede usar `Server.CreateObject("MyCOMComponent")` para crear una instancia de un objeto COM en el servidor. Sin embargo, si desea usar los miembros de <xref:System.Web.HttpServerUtility> desde un módulo de código subyacente ASP.NET, debe incluir una referencia a la <xref:System.Web> espacio de nombres en el módulo y una referencia completa al contexto de solicitud/respuesta activo actualmente y el clase <xref:System.Web> que desea usar. Por ejemplo, en una página de código subyacente debe especificar el nombre completo `HttpContext.Current.Server.CreateObject("MyCOMComponent")`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As HttpSessionState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::SessionState::HttpSessionState ^ Session { System::Web::SessionState::HttpSessionState ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Session : System.Web.SessionState.HttpSessionState" Usage="System.Web.HttpContext.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.SessionState.HttpSessionState" /> de la solicitud HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.SessionState.HttpSessionState" /> de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.Session%2A> propiedad proporciona acceso mediante programación a las propiedades y métodos de la <xref:System.Web.SessionState.HttpSessionState> clase.  
  
 Para poder usar el estado de sesión tendrá que habilitarlo. Para obtener información acerca de cómo habilitar el estado de sesión, vea **configurar el estado de sesión** en [información general sobre el estado de sesión ASP.NET](https://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
 Para obtener información acerca de cómo guardar los valores de estado de sesión, vea [Cómo: guardar los valores de estado de sesión](https://msdn.microsoft.com/library/a6cb2e3a-df49-4b12-9d9a-eed45541c165). Para obtener información acerca de cómo leer los valores de estado de sesión, vea [Cómo: leer valores del estado de sesión](https://msdn.microsoft.com/library/2ef449bc-5c17-4785-b7cf-378c601af8f5).  
  
   
  
## Examples  
 Los ejemplos siguientes muestran cómo guardar los valores de estado de sesión y cómo se leen los valores del estado de sesión.  
  
 Para estos ejemplos se necesita:  
  
-   Una aplicación ASP.NET que tiene habilitado el estado de sesión.  
  
-   Una clase de página de formularios Web Forms que tiene acceso a la <xref:System.Web.UI.Page.Session%2A?displayProperty=nameWithType> propiedad o cualquier clase que tiene acceso a la <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> propiedad.  
  
```csharp  
string firstName = "Jeff";  
string lastName = "Smith";  
string city = "Seattle";  
  
// Save to session state in a Web Forms page class.  
Session["FirstName"] = firstName;  
Session["LastName"] = lastName;  
Session["City"] = city;  
  
// Read from session state in a Web Forms page class.  
firstName = (string)(Session["FirstName"]);  
lastName = (string)(Session["LastName"]);  
city = (string)(Session["City"]);  
  
// Outside of Web Forms page class, use HttpContext.Current.  
HttpContext context = HttpContext.Current;  
context.Session["FirstName"] = firstName;  
firstName = (string)(context.Session["FirstName"]);  
  
```  
  
```vb  
Dim firstName As String = "Jeff"  
Dim lastName As String = "Smith"  
Dim city As String = "Seattle"  
  
' Save to session state in a Web Forms page class.  
Session("FirstName") = firstName  
Session("LastName") = lastName  
Session("City") = city  
  
' Read from session state in a Web Forms page class.  
firstName = DirectCast(Session("FirstName"), String)  
lastName = DirectCast(Session("LastName"), String)  
city = DirectCast(Session("City"), String)  
  
' Outside of Web Forms page class, use HttpContext.Current.  
Dim context As HttpContext = HttpContext.Current  
context.Session("FirstName") = firstName  
firstName = DirectCast(context.Session("FirstName"), String)  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSessionStateBehavior">
      <MemberSignature Language="C#" Value="public void SetSessionStateBehavior (System.Web.SessionState.SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSessionStateBehavior(valuetype System.Web.SessionState.SessionStateBehavior sessionStateBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.SetSessionStateBehavior(System.Web.SessionState.SessionStateBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSessionStateBehavior(System::Web::SessionState::SessionStateBehavior sessionStateBehavior);" />
      <MemberSignature Language="F#" Value="member this.SetSessionStateBehavior : System.Web.SessionState.SessionStateBehavior -&gt; unit" Usage="httpContext.SetSessionStateBehavior sessionStateBehavior" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionStateBehavior" Type="System.Web.SessionState.SessionStateBehavior" />
      </Parameters>
      <Docs>
        <param name="sessionStateBehavior">Uno de los valores de enumeración que especifica el tipo de comportamiento de estado de sesión que se requiere.</param>
        <summary>Establece el tipo de comportamiento de estado de sesión que se requiere para admitir una solicitud HTTP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la implementación predeterminada ASP.NET, un controlador de la solicitud HTTP indica si requiere el estado de sesión mediante la implementación de la <xref:System.Web.SessionState.IRequiresSessionState> interfaz o <xref:System.Web.SessionState.IReadOnlySessionState> interfaz. El <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> método y el <xref:System.Web.SessionState.SessionStateBehavior> enumeración permite proporcionar más detalles acerca de qué tipo de soporte técnico de estado de sesión es necesario para controlar una solicitud. Para obtener más información, vea la enumeración <xref:System.Web.SessionState.SessionStateBehavior>.  
  
 El <xref:System.Web.HttpContext.SetSessionStateBehavior%2A> método debe llamarse antes el <xref:System.Web.HttpApplication.AcquireRequestState> eventos de canalización. Las llamadas que se producen durante o después de este evento se producirá un <xref:System.InvalidOperationException> excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se llama al método después de producirse el evento <see cref="E:System.Web.HttpApplication.AcquireRequestState" />.</exception>
        <altmember cref="T:System.Web.SessionState.SessionStateBehavior" />
      </Docs>
    </Member>
    <Member MemberName="SkipAuthorization">
      <MemberSignature Language="C#" Value="public bool SkipAuthorization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipAuthorization" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.SkipAuthorization" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipAuthorization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipAuthorization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipAuthorization : bool with get, set" Usage="System.Web.HttpContext.SkipAuthorization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si el objeto <see cref="T:System.Web.Security.UrlAuthorizationModule" /> debe omitir la comprobación de autorización para la solicitud actual.</summary>
        <value>Es <see langword="true" /> si <see cref="T:System.Web.Security.UrlAuthorizationModule" /> debe omitir la comprobación de autorización; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.SkipAuthorization%2A> propiedad está pensada para uso avanzado por los módulos de autenticación que deben redirigirse a una página que permite conexiones anónimas. El módulo de autenticación de formularios y el módulo de autenticación de Passport establecen <xref:System.Web.HttpContext.SkipAuthorization%2A> al redirigir a una página de inicio de sesión configuradas. Establecer <xref:System.Web.HttpContext.SkipAuthorization%2A> requiere el `ControlPrincipal` marca debe establecerse. Para obtener información sobre la `ControlPrincipal` marca, vea <xref:System.Security.Permissions.SecurityPermissionFlag>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IServiceProvider.GetService">
      <MemberSignature Language="C#" Value="object IServiceProvider.GetService (Type service);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IServiceProvider.GetService(class System.Type service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpContext.System#IServiceProvider#GetService(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function GetService (service As Type) As Object Implements IServiceProvider.GetService" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IServiceProvider.GetService(Type ^ service) = IServiceProvider::GetService;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="service">Tipo de servicio <see cref="T:System.Web.HttpContext" /> que se va a establecer en el proveedor de servicios.</param>
        <summary>Devuelve un objeto para el tipo de servicio actual.</summary>
        <returns>Objeto <see cref="T:System.Web.HttpContext" />; es <see langword="null" /> si no se encontró ningún servicio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es útil para obtener acceso a subyacente <xref:System.Web.HttpWorkerRequest> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThreadAbortOnTimeout">
      <MemberSignature Language="C#" Value="public bool ThreadAbortOnTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThreadAbortOnTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ThreadAbortOnTimeout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThreadAbortOnTimeout { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThreadAbortOnTimeout : bool with get, set" Usage="System.Web.HttpContext.ThreadAbortOnTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si el tiempo de ejecución de ASP.NET debe llamar a <see cref="M:System.Threading.Thread.Abort" /> en el subproceso que atiende esta solicitud cuando la solicitud agota su tiempo de espera.</summary>
        <value>Es <see langword="true" /> si se llamará a <see cref="M:System.Threading.Thread.Abort" /> cuando se agote el tiempo de espera del subproceso; en caso contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En los controladores y módulos que usan el <xref:System.Web.HttpRequest.TimedOutToken%2A?displayProperty=nameWithType> propiedad que se va a implementar la cancelación cooperativa, desea deshabilitar la <xref:System.Threading.Thread.Abort%2A?displayProperty=nameWithType> comportamiento que ASP.NET realiza de forma predeterminada cuando se agota el tiempo de espera de una solicitud. Establecer esta propiedad en `false` puede ayudar a asegurarse de que las rutinas de cancelación y limpieza se ejecutarán sin que se interrumpan por ASP.NET.  
  
 Si establece esta propiedad en `false`, ASP.NET no mostrará automáticamente una página de error de "Solicitud agotado el tiempo" cuando se produce un tiempo de espera. La aplicación es responsable de establecer adecuadamente el contenido de la respuesta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timestamp">
      <MemberSignature Language="C#" Value="public DateTime Timestamp { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Timestamp" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Timestamp" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Timestamp As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime Timestamp { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.Timestamp : DateTime" Usage="System.Web.HttpContext.Timestamp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la marca de tiempo inicial de la solicitud HTTP actual.</summary>
        <value>Marca de tiempo de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La marca de tiempo devuelto desde el <xref:System.Web.HttpContext.Timestamp%2A> propiedad es la hora local del servidor y se establece durante la creación de instancias de la <xref:System.Web.HttpContext> objeto. La hora local es igual a la hora UTC más el desplazamiento de UTC.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.Trace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Trace As TraceContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::TraceContext ^ Trace { System::Web::TraceContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Trace : System.Web.TraceContext" Usage="System.Web.HttpContext.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Web.TraceContext" /> de la respuesta HTTP actual.</summary>
        <value>Objeto <see cref="T:System.Web.TraceContext" /> de la respuesta HTTP actual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.User" />
      <MemberSignature Language="VB.NET" Value="Public Property User As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IPrincipal ^ User { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.User : System.Security.Principal.IPrincipal with get, set" Usage="System.Web.HttpContext.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece información de seguridad de la solicitud HTTP actual.</summary>
        <value>Información de seguridad de la solicitud HTTP actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.HttpContext.User%2A> propiedad proporciona acceso mediante programación a las propiedades y métodos de la <xref:System.Security.Principal.IPrincipal> interfaz.  
  
 Dado que las páginas ASP.NET contienen una referencia predeterminada a la <xref:System.Web> espacio de nombres (que contiene el <xref:System.Web.HttpContext> clase), puede hacer referencia a los miembros de <xref:System.Web.HttpContext> en una página .aspx sin utilizar la referencia de clase completo a <xref:System.Web.HttpContext>. Por ejemplo, puede usar `User.Identity.Name` obtener el nombre del usuario en cuyo nombre en el proceso actual se está ejecutando. Sin embargo, si desea usar los miembros de <xref:System.Security.Principal.IPrincipal> desde un módulo de código subyacente ASP.NET, debe incluir una referencia a la <xref:System.Web> espacio de nombres en el módulo y una referencia completa al contexto de solicitud/respuesta activo actualmente y el clase <xref:System.Web> que desea usar. Por ejemplo, en una página de código subyacente debe especificar el nombre completo `HttpContext.Current.User.Identity.Name`.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener acceso a las propiedades del usuario actual a través de la <xref:System.Web.HttpContext.User%2A> propiedad. Estas propiedades se utilizan para establecer el título de la página Web.  
  
 Si la aplicación utiliza la autenticación de Windows, el nombre de usuario incluye el dominio. Por ejemplo, el título de la página sería "Página principal de dominio\nombre de usuario".  
  
 [!code-csharp[System.Web.HttpContext.User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpContext.User/cs/Default.aspx.cs#1)]
 [!code-vb[System.Web.HttpContext.User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpContext.User/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/security/using-oauth-providers-with-mvc">Usar proveedores OAuth con MVC 4</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-forms/tutorials/aspnet-45/getting-started-with-aspnet-45-web-forms/checkout-and-payment-with-paypal">Introducción a ASP.NET 4.5 Web Forms - desprotección y el pago con PayPal</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/web-api/overview/creating-web-apis/using-web-api-with-entity-framework/using-web-api-with-entity-framework,-part-6">Usar Web API con Entity Framework - parte 6</related>
        <related type="ExternalDocumentation" href="http://www.asp.net/mvc/tutorials/older-versions/nerddinner/secure-applications-using-authentication-and-authorization">Nerd cena - aplicaciones seguras mediante la autenticación y autorización</related>
      </Docs>
    </Member>
    <Member MemberName="WebSocketNegotiatedProtocol">
      <MemberSignature Language="C#" Value="public string WebSocketNegotiatedProtocol { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebSocketNegotiatedProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketNegotiatedProtocol As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ WebSocketNegotiatedProtocol { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketNegotiatedProtocol : string" Usage="System.Web.HttpContext.WebSocketNegotiatedProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el protocolo negociado que se envió desde el servidor al cliente para una conexión de <see cref="T:System.Web.WebSockets.AspNetWebSocket" />.</summary>
        <value>Protocolo negociado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WebSocketRequestedProtocols">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;string&gt; WebSocketRequestedProtocols { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;string&gt; WebSocketRequestedProtocols" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebSocketRequestedProtocols As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::String ^&gt; ^ WebSocketRequestedProtocols { System::Collections::Generic::IList&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebSocketRequestedProtocols : System.Collections.Generic.IList&lt;string&gt;" Usage="System.Web.HttpContext.WebSocketRequestedProtocols" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la lista ordenada de los protocolos solicitados por el cliente.</summary>
        <value>Protocolos solicitados, o <see langword="null" /> si no es una solicitud <see cref="T:System.Web.WebSockets.AspNetWebSocket" /> o si no hay ninguna lista.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>