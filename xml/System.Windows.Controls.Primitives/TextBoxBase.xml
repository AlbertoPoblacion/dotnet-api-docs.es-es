<Type Name="TextBoxBase" FullName="System.Windows.Controls.Primitives.TextBoxBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1ba5f622c0b780f6e8495de72238a63c56c4e2cf" />
    <Meta Name="ms.sourcegitcommit" Value="e7865e39826e7aaf54da4c7042975153813a31c7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/16/2018" />
    <Meta Name="ms.locfileid" Value="31044212" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TextBoxBase : System.Windows.Controls.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract TextBoxBase extends System.Windows.Controls.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.TextBoxBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TextBoxBase&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextBoxBase abstract : System::Windows::Controls::Control" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Text)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.TemplatePart(Name="PART_ContentHost", Type=typeof(System.Windows.FrameworkElement))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Una clase base abstracta que proporciona la funcionalidad para los controles de edición de texto, incluidos <see cref="T:System.Windows.Controls.TextBox" /> y <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar la clase derivada <xref:System.Windows.Controls.TextBox> objeto [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 En el ejemplo siguiente se muestra cómo utilizar la clase derivada <xref:System.Windows.Controls.RichTextBox> objeto en el código.  
  
 [!code-csharp[richtextboxsnippets#_RichTextBox_MouseUpDown](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_richtextbox_mouseupdown)]
 [!code-vb[richtextboxsnippets#_RichTextBox_MouseUpDown](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_richtextbox_mouseupdown)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.TextBox" />
    <altmember cref="T:System.Windows.Controls.RichTextBox" />
  </Docs>
  <Members>
    <Member MemberName="AcceptsReturn">
      <MemberSignature Language="C#" Value="public bool AcceptsReturn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsReturn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptsReturn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptsReturn { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica la forma en que responde el control de edición de texto cuando el usuario presiona la tecla ENTRAR.</summary>
        <value>
          <see langword="true" /> si al presionar la tecla ENTRAR se inserta una nueva línea en la posición actual del cursor; de lo contrario, se omite la tecla ENTRAR. El valor predeterminado es <see langword="false" /> para <see cref="T:System.Windows.Controls.TextBox" /> y <see langword="true" /> para <see cref="T:System.Windows.Controls.RichTextBox" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tecla ENTRAR corresponde a `VK_RETURN` código de tecla virtual.  
  
<a name="dependencyPropertyInfo_AcceptsReturn"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.TextBox.TextWrapping" />
      </Docs>
    </Member>
    <Member MemberName="AcceptsReturnProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AcceptsReturnProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AcceptsReturnProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturnProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AcceptsReturnProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AcceptsReturnProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsTab">
      <MemberSignature Language="C#" Value="public bool AcceptsTab { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcceptsTab" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptsTab As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AcceptsTab { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica la forma en que responde el control de edición de texto cuando el usuario presiona la tecla TAB.</summary>
        <value>
          <see langword="true" /> si al presionar la tecla TAB se inserta un carácter de tabulación en la posición actual del cursor; <see langword="false" /> si al presiona la tecla TAB se mueve el foco al siguiente control que está marcado como una posición de tabulación y no se inserta un carácter de tabulación.  
  
 El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La tecla TAB corresponde a **VK_TAB** código de tecla virtual.  
  
<a name="dependencyPropertyInfo_AcceptsTab"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptsTabProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AcceptsTabProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AcceptsTabProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTabProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AcceptsTabProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AcceptsTabProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Una cadena que especifica el texto para anexar al contenido actual del control de texto.</param>
        <summary>Anexa una cadena al contenido de un control de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Controls.Primitives.TextBoxBase.AppendText%2A> método permite al usuario anexar texto al contenido de un control de texto sin usar la concatenación de texto, que puede mejorar el rendimiento cuando se requieren muchas concatenaciones.  
  
   
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Windows.Controls.Primitives.TextBoxBase.AppendText%2A>.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase11](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase11)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase11](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que determina si cuando un usuario selecciona parte de una palabra arrastrando el mouse, se selecciona el resto de la palabra.</summary>
        <value>
          Es <see langword="true" /> si la selección automática de fuentes está habilitada; de lo contrario, es <see langword="false" />.  
  
 El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection%2A> está habilitada, cada vez que esa parte de una palabra se selecciona por el usuario arrastra sobre parte de una palabra con el mouse, la selección se expande automáticamente para incluir la palabra completa. El usuario puede invalidar la selección automática de una palabra completa invirtiendo momentáneamente la dirección en la que se arrastra el puntero del mouse que se realiza la selección. Esta acción deshace la selección automática de la palabra entera y permite al usuario seleccionar con precisión parte o la totalidad de la palabra.  
  
 Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection%2A> está deshabilitado, una selección no se expande automáticamente para incluir las palabras completas; en este caso, las selecciones precisas se determinan siempre manualmente.  
  
 **Nota:** selección automática no afecta a la primera palabra que el usuario arrastra a través de. Es solo después de que se supere este primer límite de palabras que surte efecto de selección automática.  
  
<a name="dependencyPropertyInfo_AutoWordSelection"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelectionProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AutoWordSelectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AutoWordSelectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AutoWordSelectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AutoWordSelectionProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.AutoWordSelection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginChange">
      <MemberSignature Language="C#" Value="public void BeginChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginChange ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginChange();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia un bloque de cambios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Nota:** cuando se llama a <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>, también debe llamar a <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> para completar el bloque de cambio en caso contrario, una excepción.  
  
 Un bloque de cambios lógicamente agrupa varios cambios en una unidad de deshacer única y evita que los eventos de cambio de contenido o la selección de texto que se está generando hasta después del bloque de cambios. Este modo puede realizar varias ediciones en el elemento de texto sin peligro de que el elemento de texto que se va a cambiar al mismo tiempo otro agente de escucha. Se crea un bloque de cambios mediante una llamada a la <xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A> método. Llamar a la <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A> método hace que todos los cambios posteriores que se incluirá en el bloque de cambio especificado hasta que una llamada correspondiente a la <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> se realiza el método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A> y <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> métodos para crear un bloque de cambios.  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/BeginChangeEndChangeExample.cs#beginchangeendchangecodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/beginchangeendchangeexample.vb#beginchangeendchangecodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede rehacer la acción de deshacer más reciente.</summary>
        <value>
          <see langword="true" /> si se puede rehacer la acción de deshacer más reciente; de lo contrario, <see langword="false" />.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.CanRedo%2A> propiedad para determinar si se puede rehacer la última acción de deshacer.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase9)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.CanUndo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="CanUndo">
      <MemberSignature Language="C#" Value="public bool CanUndo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanUndo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CanUndo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanUndo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanUndo { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si se puede deshacer la acción más reciente.</summary>
        <value>
          <see langword="true" /> Si la acción más reciente se puede deshacer; en caso contrario, <see langword="false" />.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.CanUndo%2A> propiedad para determinar si se puede deshacer la acción más reciente.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase8)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.CanRedo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="CaretBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush CaretBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush CaretBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property CaretBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ CaretBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el pincel que se usa para pintar el símbolo de intercalación del cuadro de texto.</summary>
        <value>Pincel que se usa para pintar el símbolo de intercalación del cuadro de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Windows.Controls.TextBox> y agrega el texto "Esto es un texto." El ejemplo se establece la <xref:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush%2A> y <xref:System.Windows.Controls.Control.Foreground%2A> propiedades de un <xref:System.Windows.Controls.TextBox> a azul.  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 El ejemplo anterior genera un resultado es similar a la siguiente ilustración.  
  
 ![TextBox con CaretBrush establecido en azul. ] (~/add/media/textboxcaretbrush.png "TextBox con CaretBrush establecido en azul.")  
TextBox con CaretBrush establecido en azul  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaretBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CaretBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CaretBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.CaretBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CaretBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CaretBrushProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.CaretBrush" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public void Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Sub Copy ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia la selección actual del control de edición de texto en <see cref="T:System.Windows.Clipboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una operación de copia copia el texto seleccionado en el <xref:System.Windows.Clipboard>. Tenga en cuenta que el texto seleccionado no se quita del control en el proceso de edición de texto. Un método similar, <xref:System.Windows.Controls.Primitives.TextBoxBase.Cut%2A>, mueve la selección actual a la <xref:System.Windows.Clipboard> y quita el texto seleccionado del control en el proceso de edición de texto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.Copy%2A> método para copiar el texto seleccionado en un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase4](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase4)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Paste" />
      </Docs>
    </Member>
    <Member MemberName="Cut">
      <MemberSignature Language="C#" Value="public void Cut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Cut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Cut" />
      <MemberSignature Language="VB.NET" Value="Public Sub Cut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Cut();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita la selección actual del control de edición de texto y lo copia en el <see cref="T:System.Windows.Clipboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una operación de corte quita la selección actual del control de edición de texto y lo copia en el <xref:System.Windows.Clipboard>. Observe que se ha quitado el texto seleccionado (corta) del control en el proceso de edición de texto. Un método similar, <xref:System.Windows.Controls.Primitives.TextBoxBase.Copy%2A>, copia la selección actual en el Portapapeles, pero no quita el texto seleccionado del control de edición de texto.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.Cut%2A> método para eliminar el texto seleccionado en un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase5](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase5)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase5)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">de plena confianza para los herederos. Este miembro no puede heredar código de confianza parcial.</permission>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Paste" />
      </Docs>
    </Member>
    <Member MemberName="DeclareChangeBlock">
      <MemberSignature Language="C#" Value="public IDisposable DeclareChangeBlock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IDisposable DeclareChangeBlock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
      <MemberSignature Language="VB.NET" Value="Public Function DeclareChangeBlock () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IDisposable ^ DeclareChangeBlock();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea un bloque de cambios.</summary>
        <returns>Un objeto <see cref="T:System.IDisposable" /> que hace referencia a un nuevo bloque de cambios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un bloque de cambios agrupa lógicamente varios cambios en una unidad de deshacer única. Se crea un bloque de cambios mediante una llamada a la <xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A> método. Llamar a la <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A> método hace que todos los cambios posteriores que se incluirá en el bloque de cambio especificado hasta que una llamada correspondiente a la <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> se realiza el método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
      </Docs>
    </Member>
    <Member MemberName="EndChange">
      <MemberSignature Language="C#" Value="public void EndChange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndChange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndChange ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndChange();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Finaliza un bloque de cambios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Nota:** cuando se llama a <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A>, también debe llamar a <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> para completar el bloque de cambio en caso contrario, una excepción.  
  
 Un bloque de cambios lógicamente agrupa varios cambios en una unidad de deshacer única y evita que los eventos de cambio de contenido o la selección de texto que se está generando hasta después del bloque de cambios. Este modo puede realizar varias ediciones en el elemento de texto sin peligro de que el elemento de texto que se va a cambiar al mismo tiempo por otro proceso. Se crea un bloque de cambios mediante una llamada a la <xref:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock%2A> método. Llamar a la <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A> método hace que todos los cambios posteriores que se incluirá en el bloque de cambio especificado hasta que una llamada correspondiente a la <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> se realiza el método.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.BeginChange%2A> y <xref:System.Windows.Controls.Primitives.TextBoxBase.EndChange%2A> métodos para crear un bloque de cambios.  
  
 [!code-csharp[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/CSharp/BeginChangeEndChangeExample.cs#beginchangeendchangecodeexampleinline1)]
 [!code-vb[TextBoxMiscSnippets_procedural_snip#BeginChangeEndChangeCodeExampleInline1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxMiscSnippets_procedural_snip/visualbasic/beginchangeendchangeexample.vb#beginchangeendchangecodeexampleinline1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      </Docs>
    </Member>
    <Member MemberName="ExtentHeight">
      <MemberSignature Language="C#" Value="public double ExtentHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño vertical del área de contenido visible.</summary>
        <value>Un valor de coma flotante que especifica el tamaño vertical del área de contenido visible, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.ExtentHeight%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ExtentWidth">
      <MemberSignature Language="C#" Value="public double ExtentWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ExtentWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtentWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ExtentWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño horizontal del área de contenido visible.</summary>
        <value>Un valor de coma flotante que especifica el tamaño horizontal del área de contenido visible, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.ExtentWidth" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffset">
      <MemberSignature Language="C#" Value="public double HorizontalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición de desplazamiento horizontal.</summary>
        <value>Un valor de coma flotante que especifica la posición del desplazamiento horizontal, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 Establecer esta propiedad hace que el control de edición de texto se desplace al desplazamiento horizontal especificado. Al leer esta propiedad, se devuelve el desplazamiento horizontal actual.  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El desplazamiento horizontal se mide desde la derecha del área de texto visible si está trabajando en modo de escritura de derecha a izquierda; en caso contrario, se mide desde la izquierda.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalOffset%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se ha intentado establecer esta propiedad en un valor negativo.</exception>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalOffset" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility HorizontalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility HorizontalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se muestra una barra de desplazamiento horizontal.</summary>
        <value>Un valor definido por la enumeración <see cref="T:System.Windows.Controls.ScrollBarVisibility" />.  
  
 El valor predeterminado es <see cref="F:System.Windows.Visibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_HorizontalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibilityProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo establecer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility%2A> propiedad mediante el uso de [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInactiveSelectionHighlightEnabled">
      <MemberSignature Language="C#" Value="public bool IsInactiveSelectionHighlightEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInactiveSelectionHighlightEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsInactiveSelectionHighlightEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInactiveSelectionHighlightEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el cuadro de texto muestra el texto seleccionado cuando el cuadro de texto no tiene el foco.</summary>
        <value>
          <see langword="true" /> si el cuadro de texto muestra el texto seleccionado cuando no tiene el foco; de lo contrario, <see langword="false" />.  
  
 El valor predeterminado registrado es <see langword="false" />. Para obtener más información sobre lo que puede afectar al valor, vea [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsInactiveSelectionHighlightEnabled"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabledProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInactiveSelectionHighlightEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsInactiveSelectionHighlightEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsInactiveSelectionHighlightEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsInactiveSelectionHighlightEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsInactiveSelectionHighlightEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsInactiveSelectionHighlightEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si el control de edición de texto es de sólo lectura para un usuario que interactúa con el control.</summary>
        <value>
          <see langword="true" /> si el contenido del control de edición de texto es de sólo lectura para un usuario; de lo contrario, el usuario puede modificar el contenido del control de edición de texto. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este valor solo afecta a un usuario que está interactuando con el control. Siempre se puede modificar mediante programación el contenido de un control de edición de texto.  
  
<a name="dependencyPropertyInfo_IsReadOnly"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyCaretVisible">
      <MemberSignature Language="C#" Value="public bool IsReadOnlyCaretVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnlyCaretVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsReadOnlyCaretVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnlyCaretVisible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si un cuadro de texto de solo lectura muestra un símbolo de intercalación.</summary>
        <value>
          Es <see langword="true" /> si un cuadro de texto de solo lectura muestra un símbolo de intercalación; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly%2A> es `true`, el usuario todavía puede seleccionar y copiar el texto. Si el <xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible%2A> propiedad también se establece en `true`, aparecerá un símbolo de intercalación en el cuadro de texto cuando el cuadro de texto tiene el foco de teclado. Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly%2A> es `false`, el <xref:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible%2A> propiedad no tiene ningún efecto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyCaretVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsReadOnlyCaretVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsReadOnlyCaretVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsReadOnlyCaretVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsReadOnlyCaretVisibleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyCaretVisible" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnlyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsReadOnlyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsReadOnlyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnlyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsReadOnlyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsReadOnlyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsReadOnly" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActive">
      <MemberSignature Language="C#" Value="public bool IsSelectionActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSelectionActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSelectionActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSelectionActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el cuadro de texto tiene el foco y texto seleccionado.</summary>
        <value>
          <see langword="true" /> si el cuadro de texto tiene el foco y texto seleccionado; si no, <see langword="false" />.  
  
 El valor predeterminado registrado es <see langword="false" />. Para obtener más información sobre lo que puede afectar al valor, vea [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsSelectionActive"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActiveProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSelectionActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsSelectionActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsSelectionActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsSelectionActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsSelectionActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsSelectionActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUndoEnabled">
      <MemberSignature Language="C#" Value="public bool IsUndoEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUndoEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsUndoEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUndoEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se habilita la función de deshacer para el control de edición de texto.</summary>
        <value>
          Es <see langword="true" /> si está habilitada la compatibilidad de deshacer; de lo contrario, es <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se establece esta propiedad en `false` borra la pila de deshacer. Por lo tanto, si deshabilita deshacer y, a continuación, volver a habilitarla, deshacer comandos todavía no funcionan porque la pila de deshacer se vació al deshabilitar deshacer.  
  
<a name="dependencyPropertyInfo_IsUndoEnabled"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabledProperty>|  
|Propiedades de metadatos establecidos en `true`|None|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled%2A> propiedad en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)].  
  
 [!code-xaml[TextBoxBase_Samp#TextBoxBase1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml#textboxbase1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
      </Docs>
    </Member>
    <Member MemberName="IsUndoEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsUndoEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsUndoEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsUndoEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsUndoEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.IsUndoEnabled" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDown">
      <MemberSignature Language="C#" Value="public void LineDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineDown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una línea hacia abajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.LineDown%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase13](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase13)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineRight" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineUp" />
      </Docs>
    </Member>
    <Member MemberName="LineLeft">
      <MemberSignature Language="C#" Value="public void LineLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una línea hacia la izquierda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.LineLeft%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase14](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase14)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase14](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineDown" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineRight" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineUp" />
      </Docs>
    </Member>
    <Member MemberName="LineRight">
      <MemberSignature Language="C#" Value="public void LineRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineRight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una línea hacia la derecha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.LineRight%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase15](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase15)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase15](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase15)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineDown" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineUp" />
      </Docs>
    </Member>
    <Member MemberName="LineUp">
      <MemberSignature Language="C#" Value="public void LineUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LineUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LineUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub LineUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LineUp();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una línea hacia arriba.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.LineUp%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase16](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase16)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase16](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LineDown" />
      </Docs>
    </Member>
    <Member MemberName="LockCurrentUndoUnit">
      <MemberSignature Language="C#" Value="public void LockCurrentUndoUnit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LockCurrentUndoUnit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      <MemberSignature Language="VB.NET" Value="Public Sub LockCurrentUndoUnit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LockCurrentUndoUnit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloquea la unidad de deshacer más reciente de la pila de deshacer de la aplicación. Esto evita que la unidad bloqueada se combine con unidades de deshacer que se agregan posteriormente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Llamar a este método cuando una unidad de deshacer no son de texto se agrega a la pila de deshacer principal de la aplicación. Esto evita que la unidad bloqueada se combine con unidades de deshacer que se agregan posteriormente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.CanRedo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se llama cuando se aplica una plantilla de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalida <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se implementa en una clase derivada, este método se invoca cuando el código de aplicación o procesos internos llaman a <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumentos del evento.</param>
        <summary>Se le llama cada vez que un evento enrutado <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> no controlado alcanza esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Todavía debe llamar a la implementación base en caso de que una clase intermedia en la herencia ha implementado este método.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: le permite controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque un elemento secundario, que no es necesariamente el elemento que invoca los controladores podría haber provocado el evento enrutado. Por lo tanto, la implementación debe tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.Controls.Primitives.TextBoxBase> puede llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta. Un escenario es tomar los argumentos del evento y marcar deliberadamente el evento como controlado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected override void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.DragEnter" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected override void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.DragLeave" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected override void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.DragOver" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected override void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.DragEnter" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected override void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.GiveFeedback" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Provoca el evento <see cref="E:System.Windows.UIElement.LostFocus" /> (utilizando los argumentos proporcionados).</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Mouse.MouseDown" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Mouse.MouseMove" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Argumentos del evento. Estos argumentos incluirán detalles sobre qué botón del mouse se presionó y sobre el estado administrado.</param>
        <summary>Se invoca siempre que un evento <see cref="E:System.Windows.Input.Mouse.MouseUp" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Los argumentos de la rueda del mouse que se asocian a este evento.</param>
        <summary>Se llama cuando un evento <see cref="E:System.Windows.UIElement.MouseWheel" /> se enruta a esta clase (o a una clase que hereda de esta clase).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.UIElement.MouseWheel> evento tiene lugar cuando se revierte la rueda del mouse.  
  
 Invalida <xref:System.Windows.UIElement.OnMouseWheel%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Se llama cuando se produce <see cref="E:System.Windows.UIElement.KeyDown" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected override void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no tiene ninguna implementación predeterminada. Aún se recomienda llamar a base() en su implementación, en caso de que una clase intermedia en la herencia implementa este método. Se puede llamar a base() antes o después de su tratamiento especial, dependiendo de los requisitos.  
  
 El propósito de este método es algo similar a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] patrón de eventos en * métodos: le permite controlar el evento correspondiente de las clases derivadas con un controlador de clase en lugar de un controlador de instancia. En este caso, el evento correspondiente es un evento enrutado. El modelo de implementación de los métodos On * es diferente para los eventos enrutados porque se ha generado el evento enrutado por un elemento secundario, que no es necesariamente el elemento que invoca los controladores. Por lo tanto, la implementación debe tener en cuenta el evento propiedades del origen de argumentos (y no debe intentar volver a generar el evento en la mayoría de los casos). Las subclases de <xref:System.Windows.Controls.Primitives.TextBoxBase> puede elegir llamar a métodos de controlador de clase privados cuando se recibe el evento a lo largo de la ruta. Un escenario es tomar los argumentos del evento y marcar el evento como controlado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected override void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Los argumentos que se asocian al evento <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />.</param>
        <summary>Se llama cuando el símbolo de intercalación o la selección actual cambia de posición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca un <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected override void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTemplateChanged (oldTemplate As ControlTemplate, newTemplate As ControlTemplate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTemplateChanged(System::Windows::Controls::ControlTemplate ^ oldTemplate, System::Windows::Controls::ControlTemplate ^ newTemplate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">Un objeto <see cref="T:System.Windows.Controls.ControlTemplate" /> que especifica la plantilla de control que está activa actualmente.</param>
        <param name="newTemplate">Un objeto <see cref="T:System.Windows.Controls.ControlTemplate" /> que especifica una nueva plantilla de control para utilizar.</param>
        <summary>Se llama cuando cambia la plantilla del control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalida <xref:System.Windows.Controls.Control.OnTemplateChanged%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (System.Windows.Controls.TextChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.Windows.Controls.TextChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTextChanged(System.Windows.Controls.TextChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As TextChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(System::Windows::Controls::TextChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.TextChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Los argumentos que se asocian al evento <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />.</param>
        <summary>Se llama cuando cambia el contenido en este control de edición.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método provoca un <xref:System.Windows.Controls.Primitives.TextBoxBase.TextChanged> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected override void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Proporciona datos sobre el evento.</param>
        <summary>Se invoca siempre que un evento enrutado asociado <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> sin controlar llega a un elemento derivado de esta clase en su ruta. Implemente este método a fin de agregar el control de clases para este evento.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="PageDown">
      <MemberSignature Language="C#" Value="public void PageDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageDown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageDown" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageDown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageDown();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una página hacia abajo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.PageDown%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase17](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase17)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase17](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageRight" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageUp" />
      </Docs>
    </Member>
    <Member MemberName="PageLeft">
      <MemberSignature Language="C#" Value="public void PageLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageLeft" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageLeft();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una página hacia la izquierda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.PageLeft%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase18](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase18)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase18](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase18)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageDown" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageRight" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageUp" />
      </Docs>
    </Member>
    <Member MemberName="PageRight">
      <MemberSignature Language="C#" Value="public void PageRight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageRight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageRight" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageRight ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageRight();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una página hacia la derecha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.PageRight%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase19](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase19)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase19](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase19)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageDown" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageUp" />
      </Docs>
    </Member>
    <Member MemberName="PageUp">
      <MemberSignature Language="C#" Value="public void PageUp ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PageUp() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.PageUp" />
      <MemberSignature Language="VB.NET" Value="Public Sub PageUp ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PageUp();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza el contenido del control una página hacia arriba.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.PageUp%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase20](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase20)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase20](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase20)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageLeft" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageRight" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.PageDown" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Paste" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pega el contenido del Portapapeles sobre la selección actual en el control de edición de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.Paste%2A> método para pegar el contenido seleccionado en un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase6](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase6)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Cut" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public bool Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Function Redo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Redo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshace el comando de deshacer más reciente. En otros términos, rehace la unidad de deshacer más reciente en la pila de deshacer.</summary>
        <returns>
          Es <see langword="true" /> si el resultado de la operación de rehacer es correcto; en caso contrario, es <see langword="false" />. Este método devuelve <see langword="false" /> si no hay ningún comando de deshacer disponible (la pila de deshacer está vacía).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Windows.Controls.Primitives.TextBoxBase.Redo%2A>.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase9)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToEnd">
      <MemberSignature Language="C#" Value="public void ScrollToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToEnd ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToEnd();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza la vista del control de edición al final del contenido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase22](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase22)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase22](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToHome">
      <MemberSignature Language="C#" Value="public void ScrollToHome ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHome() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHome ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHome();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desplaza la vista del control de edición al principio de la ventanilla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome%2A> método para desplazarse por el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase21](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase21)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase21](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase21)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToHorizontalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToHorizontalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHorizontalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToHorizontalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToHorizontalOffset(double offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Valor doble que especifica el desplazamiento horizontal al que debe desplazarse.</param>
        <summary>Desplaza el contenido del control de edición al desplazamiento vertical especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToVerticalOffset(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffset">
      <MemberSignature Language="C#" Value="public void ScrollToVerticalOffset (double offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollToVerticalOffset(float64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToVerticalOffset(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollToVerticalOffset (offset As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollToVerticalOffset(double offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="offset">Valor double que especifica el desplazamiento vertical al que debe desplazarse.</param>
        <summary>Desplaza el contenido del control de edición al desplazamiento vertical especificado.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHorizontalOffset(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="SelectAll">
      <MemberSignature Language="C#" Value="public void SelectAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SelectAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.SelectAll" />
      <MemberSignature Language="VB.NET" Value="Public Sub SelectAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SelectAll();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Selecciona todo el contenido del control de edición de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectAll%2A> método para seleccionar todo el contenido de un <xref:System.Windows.Controls.TextBox> control.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase7](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase7)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase7](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush SelectionBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush SelectionBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ SelectionBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el pincel que resalta el texto seleccionado.</summary>
        <value>Pincel que resalta el texto seleccionado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede especificar el pincel que resalta el texto seleccionado estableciendo la <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A> y <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> propiedades. El <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> propiedad especifica la opacidad de la <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A>.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Windows.Controls.TextBox> y agrega el texto "Esto es un texto." El ejemplo se establece la <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A> propiedad a color rojo y el <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> propiedad en 0,5 para personalizar la apariencia del texto seleccionado.  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 La siguiente ilustración muestra el <xref:System.Windows.Controls.TextBox> del ejemplo anterior con el texto seleccionado.  
  
 ![TextBox con SelectionBrush en rojo](~/add/media/textboxselectionbrush.png "TextBox con SelectionBrush en rojo")  
Texto seleccionado en un control TextBox con SelectionBrush establecido en rojo  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectionBrushProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ SelectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando varía la selección de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_SelectionChanged"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo controlar la <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged> eventos mediante código.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase10](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase10)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SelectionChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SelectionChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SelectionChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento enrutado <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Controls.Primitives.TextBoxBase.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="SelectionOpacity">
      <MemberSignature Language="C#" Value="public double SelectionOpacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 SelectionOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double SelectionOpacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la opacidad del objeto <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />.</summary>
        <value>La opacidad del objeto <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush" />. El valor predeterminado es 0.4.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> se establece en 0, el <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A> es transparente y no está visible. Si <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> está establecido en 1.0 o mayor, el <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A> es opaco y seleccionado no está visible el texto.  
  
   
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Windows.Controls.TextBox> y agrega el texto "Esto es un texto." El ejemplo se establece la <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionBrush%2A> propiedad a color rojo y el <xref:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity%2A> propiedad en 0,5 para personalizar la apariencia del texto seleccionado.  
  
 [!code-xaml[TextBaseSelectionBrush#TextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/textbaseselectionbrush/CS/window1.xaml#textbox)]   
  
 La siguiente ilustración muestra el <xref:System.Windows.Controls.TextBox> del ejemplo anterior con el texto seleccionado.  
  
 ![TextBox con SelectionBrush en rojo](~/add/media/textboxselectionbrush.png "TextBox con SelectionBrush en rojo")  
Texto seleccionado en un control TextBox con SelectionOpacity establecido en 0,5  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionOpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SelectionOpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SelectionOpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SelectionOpacityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SelectionOpacityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.SelectionOpacity" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SpellCheck">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.SpellCheck SpellCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.SpellCheck SpellCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.SpellCheck" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SpellCheck As SpellCheck" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::SpellCheck ^ SpellCheck { System::Windows::Controls::SpellCheck ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.SpellCheck</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Windows.Controls.SpellCheck" /> que proporciona acceso a los errores ortográficos en el contenido de texto de <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" /> o <see cref="T:System.Windows.Controls.RichTextBox" />.</summary>
        <value>Un objeto <see cref="T:System.Windows.Controls.SpellCheck" /> que proporciona acceso a los errores ortográficos en el contenido de texto de <see cref="T:System.Windows.Controls.Primitives.TextBoxBase" /> o <see cref="T:System.Windows.Controls.RichTextBox" />.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Controls.SpellingError" />
        <altmember cref="T:System.Windows.Controls.SpellingReform" />
        <altmember cref="T:System.Windows.Controls.SpellCheck" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.TextChangedEventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.TextChangedEventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As TextChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::TextChangedEventHandler ^ TextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.TextChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce cuando cambia el contenido en el elemento de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para una <xref:System.Windows.Controls.TextBox>, este evento se produce cuando cambia el texto; para un <xref:System.Windows.Controls.RichTextBox>, este evento se produce cuando se da alguna de contenido o dar formato a los cambios (por ejemplo, imágenes, tabla o color de fondo).  
  
<a name="routedEventInfo_TextChanged"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.Controls.TextChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.TextChangedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="TextChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.TextChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento enrutado <see cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Controls.Primitives.TextBoxBase.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="Undo">
      <MemberSignature Language="C#" Value="public bool Undo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Undo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.TextBoxBase.Undo" />
      <MemberSignature Language="VB.NET" Value="Public Function Undo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Undo();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deshace el comando de deshacer más reciente. En otros términos, deshace la unidad de deshacer más reciente en la pila de deshacer.</summary>
        <returns>
          Es <see langword="true" /> si el resultado de la operación de fase de reversión es correcto; en caso contrario, es <see langword="false" />. Este método devuelve <see langword="false" /> si la pila de deshacer está vacía.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el siguiente ejemplo se muestra cómo se utiliza el método <xref:System.Windows.Controls.Primitives.TextBoxBase.Undo%2A>.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase8)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.Redo" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.DeclareChangeBlock" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.LockCurrentUndoUnit" />
      </Docs>
    </Member>
    <Member MemberName="UndoLimit">
      <MemberSignature Language="C#" Value="public int UndoLimit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 UndoLimit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" />
      <MemberSignature Language="VB.NET" Value="Public Property UndoLimit As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int UndoLimit { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el número de acciones almacenadas en una cola de acciones de deshacer.</summary>
        <value>Número de acciones almacenadas en una cola de acciones de deshacer. El valor predeterminado es –1; es decir, la cola de acciones de deshacer se limita a la memoria disponible.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> borra la cola de deshacer. Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> se establece en -1, la cola de deshacer solo está limitada por la memoria que está disponible. Cuando <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> se establece en 0, deshacer está deshabilitado en el <xref:System.Windows.Controls.Primitives.TextBoxBase>.  
  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit%2A> se introdujo en la versión 3.5 de .NET Framework.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" /> se establece después de llamar a <see cref="M:System.Windows.Controls.Primitives.TextBoxBase.BeginChange" /> y antes de llamar a <see cref="M:System.Windows.Controls.Primitives.TextBoxBase.EndChange" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UndoLimitProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UndoLimitProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UndoLimitProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.UndoLimitProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UndoLimitProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UndoLimitProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.UndoLimit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.TextBoxBase.UndoLimitProperty> se introdujo en la versión 3.5 de .NET Framework. Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffset">
      <MemberSignature Language="C#" Value="public double VerticalOffset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalOffset { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la posición de desplazamiento vertical.</summary>
        <value>Un valor de coma flotante que especifica la posición del desplazamiento vertical, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 Establecer esta propiedad hace que el control de edición de texto se desplace al desplazamiento vertical especificado. Al leer esta propiedad, se devuelve el desplazamiento vertical actual.  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El desplazamiento vertical se mide desde la parte superior del área de texto visible.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalOffset%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se ha intentado establecer esta propiedad en un valor negativo.</exception>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalOffset" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToEnd" />
        <altmember cref="M:System.Windows.Controls.Primitives.TextBoxBase.ScrollToHome" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibility">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ScrollBarVisibility VerticalScrollBarVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalScrollBarVisibility As ScrollBarVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ScrollBarVisibility VerticalScrollBarVisibility { System::Windows::Controls::ScrollBarVisibility get(); void set(System::Windows::Controls::ScrollBarVisibility value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ScrollBarVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que indica si se muestra una barra de desplazamiento vertical.</summary>
        <value>Un valor definido por la enumeración <see cref="T:System.Windows.Controls.ScrollBarVisibility" />.  
  
 El valor predeterminado es <see cref="F:System.Windows.Visibility.Hidden" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_VerticalScrollBarVisibility"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo identificador|<xref:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibilityProperty>|  
|Propiedades de metadatos establecidos en `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn" />
        <altmember cref="P:System.Windows.Controls.TextBox.TextWrapping" />
        <altmember cref="T:System.Windows.Controls.ScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="VerticalScrollBarVisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalScrollBarVisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalScrollBarVisibilityProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportHeight">
      <MemberSignature Language="C#" Value="public double ViewportHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño vertical del área de contenido desplazable.</summary>
        <value>Un valor de coma flotante que especifica el tamaño vertical del área de contenido desplazable, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.ViewportHeight%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
    <Member MemberName="ViewportWidth">
      <MemberSignature Language="C#" Value="public double ViewportWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ViewportWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tamaño horizontal del área de contenido desplazable.</summary>
        <value>Un valor de coma flotante que especifica el tamaño horizontal del área de contenido desplazable, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)].  
  
 El valor de esta propiedad es 0.0 si el control de edición de texto no está configurado para admitir el desplazamiento.  
  
 Esta propiedad no tiene ningún valor predeterminado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo leer el valor de la <xref:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth%2A> propiedad.  
  
 [!code-csharp[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBoxBase_Samp/CSharp/Window1.xaml.cs#textboxbase3)]
 [!code-vb[TextBoxBase_Samp#TextBoxBase3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBoxBase_Samp/VisualBasic/Window1.xaml.vb#textboxbase3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.ViewportWidth" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.HorizontalScrollBarVisibility" />
        <altmember cref="P:System.Windows.Controls.Primitives.TextBoxBase.VerticalScrollBarVisibility" />
      </Docs>
    </Member>
  </Members>
</Type>