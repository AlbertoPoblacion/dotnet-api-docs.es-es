<Type Name="ScrollBar" FullName="System.Windows.Controls.Primitives.ScrollBar">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cef7d1b9f6caf5fdd091ceedd31775f7332d88e" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39882942" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ScrollBar : System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ScrollBar extends System.Windows.Controls.Primitives.RangeBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ScrollBar" />
  <TypeSignature Language="VB.NET" Value="Public Class ScrollBar&#xA;Inherits RangeBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ScrollBar : System::Windows::Controls::Primitives::RangeBase" />
  <TypeSignature Language="F#" Value="type ScrollBar = class&#xA;    inherit RangeBase" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.RangeBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.TemplatePart(Name="PART_Track", Type=typeof(System.Windows.Controls.Primitives.Track))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un control que proporciona una barra de desplazamiento con un control de posición (<see cref="T:System.Windows.Controls.Primitives.Thumb" />) deslizante cuya posición corresponde a un valor.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La siguiente ilustración muestra un <xref:System.Windows.Controls.Primitives.ScrollBar> control.  
  
 ![Ilustración de ScrollBar](~/add/media/scrollbar-illustration.JPG "ilustración de Scrollbar")  
  
 El <xref:System.Windows.Controls.Primitives.ScrollBar> control contiene un <xref:System.Windows.Controls.Primitives.Track> control. El <xref:System.Windows.Controls.Primitives.Track> control consta de un <xref:System.Windows.Controls.Primitives.Thumb> control y dos <xref:System.Windows.Controls.Primitives.RepeatButton> controles. Puede aumentar y disminuir el <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propiedad de la <xref:System.Windows.Controls.Primitives.ScrollBar> control presionando el <xref:System.Windows.Controls.Primitives.RepeatButton> controla o a mover el <xref:System.Windows.Controls.Primitives.Thumb>. El intervalo predeterminado de valores para el <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propiedad es de 0 a 1. El <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> representa la distancia lineal de la <xref:System.Windows.Controls.Primitives.Thumb> entre los puntos de conexión de la <xref:System.Windows.Controls.Primitives.ScrollBar>. Puede cambiar el intervalo de valores predeterminado estableciendo la <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> y <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> propiedades. El <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> propiedad determina si el <xref:System.Windows.Controls.Primitives.ScrollBar> se muestra horizontal o verticalmente, y debe definir esta propiedad para el <xref:System.Windows.Controls.Primitives.ScrollBar> control aparezca.  
  
 El <xref:System.Windows.Controls.Primitives.Track> en un <xref:System.Windows.Controls.Primitives.ScrollBar> está orientado para que los valores se incrementan de arriba abajo vertical <xref:System.Windows.Controls.Primitives.ScrollBar> o de izquierda a derecha para horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 El <xref:System.Windows.Controls.Primitives.Track> propiedades en la tabla siguiente son los destinos de enlace correspondiente <xref:System.Windows.Controls.Primitives.ScrollBar> propiedades cuando el <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propiedad no está definida explícitamente. Si se define explícitamente el <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propiedad, el enlace no se produce.  
  
|Propiedad <xref:System.Windows.Controls.Primitives.Track>|Propiedad <xref:System.Windows.Controls.Primitives.ScrollBar>|  
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Controls.Primitives.Track.Maximum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Minimum%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A?displayProperty=nameWithType>|  
|<xref:System.Windows.Controls.Primitives.Track.Value%2A?displayProperty=nameWithType>|<xref:System.Windows.Controls.Primitives.RangeBase.Value%2A?displayProperty=nameWithType>|  
  
 Puede tener acceso a la <xref:System.Windows.Controls.Primitives.Track> control de un <xref:System.Windows.Controls.Primitives.ScrollBar> control utilizando el <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propiedad.  
  
 Para mostrar <xref:System.Windows.UIElement> contenido dentro de un cuadro que tiene barras de desplazamiento, use el <xref:System.Windows.Controls.ScrollViewer> control.  
  
## <a name="customizing-the-scrollbar-control"></a>Personalizar el Control de barra de desplazamiento  
 Para aplicar la misma configuración de la propiedad a varios <xref:System.Windows.Controls.Primitives.ScrollBar> controles, utilizar el <xref:System.Windows.FrameworkElement.Style%2A> propiedad. Puede modificar el valor predeterminado <xref:System.Windows.Controls.ControlTemplate> para proporcionar el control una apariencia única. Para obtener más información acerca de cómo crear un <xref:System.Windows.Controls.ControlTemplate>, consulte [personalizar la apariencia de un Control existente creando una clase ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Para ver las partes y los Estados que son específicos de la <xref:System.Windows.Controls.Primitives.ScrollBar>, consulte [plantillas y estilos de barra de desplazamiento](~/docs/framework/wpf/controls/scrollbar-styles-and-templates.md).  
  
 Las propiedades de dependencia para este control pueden establecerse mediante el estilo del control de forma predeterminada.  Si una propiedad se establece mediante un estilo predeterminado, puede cambiar la propiedad de su valor predeterminado cuando el control aparece en la aplicación. El estilo predeterminado se determina por el tema de escritorio que se utiliza cuando se ejecuta la aplicación.  Para obtener más información, consulte [Default WPF Themes](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Establecer una propiedad visual solo tendrá un efecto si esa propiedad está presente en ambos <xref:System.Windows.Controls.Primitives.ScrollBar> control de la plantilla predeterminada y se establece mediante el uso de una. Puede encontrar una lista de propiedades visuales en la sección "Cambiar la estructura Visual de un Control" en [personalizar la apariencia de un Control existente creando una clase ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo crear una horizontal <xref:System.Windows.Controls.Primitives.ScrollBar> que tiene un intervalo de valores entre 0 y 100.  
  
 [!code-xaml[ScrollBarSnips#ScrollBar](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scrollbar)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.Primitives.RangeBase" />
    <altmember cref="T:System.Windows.Controls.Primitives.Track" />
    <altmember cref="T:System.Windows.Controls.Primitives.Thumb" />
    <altmember cref="T:System.Windows.Controls.ScrollViewer" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ScrollBar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ScrollBar();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que notifica a <see cref="T:System.Windows.Controls.ScrollViewer" /> que el usuario está arrastrando el control <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal hasta el valor que se proporciona en <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el usuario arrastra el control de posición de un <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> llamadas <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> para el <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand>. Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> devuelve `true`, el <xref:System.Windows.Controls.Primitives.ScrollBar> ese comando se ejecuta.  Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> devuelve `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> ejecuta el <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand>.  
  
 El <xref:System.Windows.Controls.ScrollViewer> usa este comando para habilitar el desplazamiento diferido. Cuando <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> es `true` y un usuario arrastra el <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>, el contenido de la <xref:System.Windows.Controls.ScrollViewer> no cambia hasta que el usuario suelta el <xref:System.Windows.Controls.Primitives.Thumb>. Si se habilita el desplazamiento diferido, el <xref:System.Windows.Controls.Primitives.ScrollBar> ejecuta el <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToHorizontalOffsetCommand> para horizontal <xref:System.Windows.Controls.Primitives.ScrollBar> cuando el usuario arrastra el <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DeferScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ DeferScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable DeferScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que notifica a <see cref="T:System.Windows.Controls.ScrollViewer" /> que el usuario está arrastrando el control <see cref="T:System.Windows.Controls.Primitives.Thumb" /> de la <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertical hasta el valor que se proporciona en <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el usuario arrastra el control de posición de un <xref:System.Windows.Controls.Primitives.ScrollBar>, <xref:System.Windows.Controls.Primitives.ScrollBar> llamadas <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> para el <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand>. Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> devuelve `true`, el <xref:System.Windows.Controls.Primitives.ScrollBar> ese comando se ejecuta.  Si <xref:System.Windows.Input.RoutedCommand.CanExecute%2A> devuelve `false`, <xref:System.Windows.Controls.Primitives.ScrollBar> ejecuta el <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand>.  
  
 El <xref:System.Windows.Controls.ScrollViewer> usa este comando para habilitar el desplazamiento diferido. Cuando <xref:System.Windows.Controls.ScrollViewer.IsDeferredScrollingEnabled%2A?displayProperty=nameWithType> es `true` y un usuario arrastra el <xref:System.Windows.Controls.Primitives.Thumb> de la <xref:System.Windows.Controls.Primitives.ScrollBar>, el contenido de la <xref:System.Windows.Controls.ScrollViewer> no cambia hasta que el usuario suelta el <xref:System.Windows.Controls.Primitives.Thumb>. Si se habilita el desplazamiento diferido, el <xref:System.Windows.Controls.Primitives.ScrollBar> ejecuta el <xref:System.Windows.Controls.Primitives.ScrollBar.DeferScrollToVerticalOffsetCommand> vertical <xref:System.Windows.Controls.Primitives.ScrollBar> cuando el usuario arrastra el <xref:System.Windows.Controls.Primitives.Thumb>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> está habilitado.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> está habilitado en <see cref="T:System.Windows.Controls.ScrollViewer" /> y el tamaño del contenido es mayor que el área de presentación; de lo contrario, <see langword="false" />. El valor predeterminado es <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación establece <xref:System.Windows.Controls.Primitives.ScrollBar.IsEnabledCore%2A> a `true` solo si el <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A> valor de la <xref:System.Windows.Controls.Primitives.ScrollBar> es mayor que el <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A> valor y el <xref:System.Windows.Controls.Primitives.ScrollBar> está habilitado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ligeramente en dirección vertical del valor creciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona la tecla flecha abajo.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_LineDownCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.LineDownCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#LineDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ligeramente en dirección horizontal del valor decreciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando disminuye el <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona la izquierda <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_LineLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.LineLeftCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#LineLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ligeramente en dirección horizontal del valor creciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona el derecho <xref:System.Windows.Controls.Primitives.RepeatButton>.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_LineRightCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.LineRightCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#LineRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#linerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      </Docs>
    </Member>
    <Member MemberName="LineUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand LineUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand LineUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ LineUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.LineUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> ligeramente en dirección vertical del valor decreciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando reduce la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.SmallChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona la tecla flecha arriba.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_LineUpCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.LineUpCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#LineUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#lineupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.LineRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public override void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="override this.OnApplyTemplate : unit -&gt; unit" Usage="scrollBar.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea el árbol visual para <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación establece también el <xref:System.Windows.Controls.Primitives.ScrollBar.Track%2A> propiedad a la <xref:System.Windows.Controls.Primitives.Track> que se define en el <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> que se produce cuando se cierra <see cref="T:System.Windows.Controls.ContextMenu" /> para <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Controls.ContextMenu> de un <xref:System.Windows.Controls.Primitives.ScrollBar> proporciona opciones para cambiar la <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="scrollBar.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> que se produce cuando se abre <see cref="T:System.Windows.Controls.ContextMenu" /> para <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Controls.ContextMenu> de un <xref:System.Windows.Controls.Primitives.ScrollBar> proporciona opciones para cambiar la <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="scrollBar.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> para este control <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <returns>
          <see cref="T:System.Windows.Automation.Peers.ScrollBarAutomationPeer" /> para el control <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona el control de clases para el evento <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación se cambia el <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> a la ubicación de la <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> evento que tiene lugar mientras el usuario presiona la tecla MAYÚS. El evento se controla estableciendo <xref:System.Windows.RoutedEventArgs.Handled%2A> en los datos del evento `e` a `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ScrollBar.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="scrollBar.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona el control de clases para el evento <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación guarda la posición del clic del mouse para que la <xref:System.Windows.Controls.Primitives.ScrollBar> puede desplazarse a esa posición en respuesta a un <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand>.  
  
   
  
## Examples  
 Un <xref:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand> se produce cuando el usuario selecciona **Desplazar aquí** en el menú que aparece cuando el usuario presiona el botón secundario del mouse sobre el <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Orientation">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Orientation Orientation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Orientation Orientation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberSignature Language="VB.NET" Value="Public Property Orientation As Orientation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Orientation Orientation { System::Windows::Controls::Orientation get(); void set(System::Windows::Controls::Orientation value); };" />
      <MemberSignature Language="F#" Value="member this.Orientation : System.Windows.Controls.Orientation with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.Orientation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Orientation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece si <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> se muestra vertical u horizontalmente.</summary>
        <value>Valor de enumeración <see cref="T:System.Windows.Controls.Orientation" /> que define si <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> se muestra horizontal o verticalmente.  El valor predeterminado es <see cref="F:System.Windows.Controls.Orientation.Vertical" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_Orientation"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Controls.Primitives.ScrollBar.Orientation%2A> propiedad para un <xref:System.Windows.Controls.Primitives.ScrollBar> control.  
  
 [!code-csharp[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#orientation)]
 [!code-vb[ScrollBarSnips#Orientation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#orientation)]
 [!code-xaml[ScrollBarSnips#Orientation](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#orientation)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Orientation" />
      </Docs>
    </Member>
    <Member MemberName="OrientationProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OrientationProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OrientationProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OrientationProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OrientationProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OrientationProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.OrientationProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ScrollBar.Orientation" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PageDownCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageDownCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageDownCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageDownCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageDownCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageDownCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> considerablemente en dirección vertical del valor creciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona la tecla AV PÁG.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_PageDownCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.PageDownCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#PageDownCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagedowncommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageLeftCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageLeftCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageLeftCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageLeftCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageLeftCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageLeftCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> considerablemente en dirección horizontal del valor decreciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando disminuye el <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona el botón de página a la izquierda de la <xref:System.Windows.Controls.Primitives.Thumb>. La siguiente ilustración muestra los botones de página en un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Las distintas partes de una barra de desplazamiento](~/add/media/scrollbarpagebutton.png "las distintas partes de una barra de desplazamiento")  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_PageLeftCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.PageLeftCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#PageLeftCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageleftcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageRightCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageRightCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageRightCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageRightCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageRightCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageRightCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> considerablemente en dirección horizontal del valor creciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando aumenta la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona el botón de página a la derecha de la <xref:System.Windows.Controls.Primitives.Thumb>. La siguiente ilustración muestra los botones de página en un <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 ![Las distintas partes de una barra de desplazamiento](~/add/media/scrollbarpagebutton.png "las distintas partes de una barra de desplazamiento")  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_PageRightCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.PageRightCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#PageRightCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pagerightcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
      </Docs>
    </Member>
    <Member MemberName="PageUpCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand PageUpCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand PageUpCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PageUpCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ PageUpCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable PageUpCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.PageUpCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que se desplaza <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> considerablemente en dirección vertical del valor decreciente de su <see cref="T:System.Windows.Controls.Primitives.Track" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando reduce la <xref:System.Windows.Controls.Primitives.Track.Value%2A> de la <xref:System.Windows.Controls.Primitives.Track> en el <xref:System.Windows.Controls.Primitives.ScrollBar> por el valor de la <xref:System.Windows.Controls.Primitives.RangeBase.LargeChange%2A> propiedad.  
  
 Este comando se produce cuando el usuario presiona la tecla RE PÁG.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_PageUpCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.PageUpCommand**`"/>`  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo especificar el <xref:System.Windows.Controls.Primitives.ScrollBar.PageUpCommand> en personalizada <xref:System.Windows.Controls.Primitives.ScrollBar> plantilla de estilo.  
  
 [!code-xaml[ScrollBarTemplateExample#PageUpCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarTemplateExample/CS/Window1.xaml#pageupcommand)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageDownCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageLeftCommand" />
        <altmember cref="F:System.Windows.Controls.Primitives.ScrollBar.PageRightCommand" />
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.Primitives.ScrollEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.Primitives.ScrollEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As ScrollEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::Primitives::ScrollEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " Usage="member this.Scroll : System.Windows.Controls.Primitives.ScrollEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.ScrollEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produce una o más veces según se desplaza el contenido en <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> cuando el usuario mueve <see cref="P:System.Windows.Controls.Primitives.Track.Thumb" /> utilizando el mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento suele producirse varias veces cuando el usuario cambia el <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> arrastrando el <xref:System.Windows.Controls.Primitives.Track.Thumb%2A>. No hay ningún límite en el número de veces que este evento se desencadena como el <xref:System.Windows.Controls.Primitives.Track.Thumb%2A> posición se arrastra.  
  
 Este evento no es se genera cuando el <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> de la <xref:System.Windows.Controls.Primitives.ScrollBar> se cambia el control de código.  
  
<a name="routedEventInfo_Scroll"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.Controls.Primitives.ScrollEventHandler>|  
  
   
  
## Examples  
 El ejemplo siguiente se muestra cómo asigna un controlador de eventos para el <xref:System.Windows.Controls.Primitives.ScrollBar.Scroll> eventos a un <xref:System.Windows.Controls.Primitives.ScrollBar> control y cómo definir el controlador de eventos en el código.  
  
 [!code-xaml[ScrollBarSnips#Scroll](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#scroll)]  
  
 [!code-csharp[ScrollBarSnips#ScrollHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#scrollhandler)]
 [!code-vb[ScrollBarSnips#ScrollHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#scrollhandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ScrollEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="ScrollEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ScrollEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ScrollEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ScrollEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento enrutado <see cref="E:System.Windows.Controls.Primitives.ScrollBar.Scroll" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollHereCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollHereCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollHereCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollHereCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollHereCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollHereCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollHereCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al punto del clic del mouse que abrió <see cref="T:System.Windows.Controls.ContextMenu" /> en <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando se produce cuando el usuario selecciona **Desplazar aquí** desde el <xref:System.Windows.Controls.ContextMenu> opciones. El <xref:System.Windows.Controls.ContextMenu> de la <xref:System.Windows.Controls.Primitives.ScrollBar> aparece cuando el usuario pausa el puntero del mouse sobre el <xref:System.Windows.Controls.Primitives.ScrollBar> y presiona el botón secundario del mouse. Este menú proporciona opciones para desplazar la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Este comando es para un <xref:System.Windows.Controls.Primitives.ScrollBar> que forma parte de un <xref:System.Windows.Controls.ScrollViewer> controlar y es ejecutado por el <xref:System.Windows.Controls.ScrollViewer>.  
  
<a name="xamlTextUsage_ScrollHereCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad* `="` **ScrollBar.ScrollHereCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToBottomCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToBottomCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToBottomCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToBottomCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToBottomCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToBottomCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToBottomCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al valor <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vertical <xref:System.Windows.Controls.Primitives.ScrollBar>, este movimiento se produce cuando el usuario presiona las teclas CTRL + fin.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_ScrollToBottomCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToBottomCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza el contenido a la esquina inferior derecha de un control <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando solo se usa con un <xref:System.Windows.Controls.ScrollViewer> control.  
  
<a name="xamlTextUsage_ScrollToEndCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHomeCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHomeCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHomeCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHomeCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHomeCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHomeCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHomeCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza el contenido a la esquina superior izquierda de un control <see cref="T:System.Windows.Controls.ScrollViewer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando solo se usa con un <xref:System.Windows.Controls.ScrollViewer> control.  
  
<a name="xamlTextUsage_ScrollToHomeCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToHomeCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToHorizontalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToHorizontalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToHorizontalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToHorizontalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToHorizontalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal en <see cref="T:System.Windows.Controls.ScrollViewer" /> al valor que se proporciona en <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando solo se usa con un <xref:System.Windows.Controls.ScrollViewer> control.  
  
<a name="xamlTextUsage_ScrollToHorizontalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToHorizontalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToLeftEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToLeftEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToLeftEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToLeftEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToLeftEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToLeftEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToLeftEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al valor <see cref="P:System.Windows.Controls.Primitives.RangeBase.Minimum" /> para una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando se produce cuando el usuario presiona las teclas CTRL+INICIO para horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_ScrollToLeftEndCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad* `="` **ScrollBar.ScrollToLeftEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToRightEndCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToRightEndCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToRightEndCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToRightEndCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToRightEndCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToRightEndCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToRightEndCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al valor <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> para una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> horizontal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando se produce cuando el usuario presiona las teclas CTRL + fin para horizontal <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_ScrollToRightEndCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad* `="` **ScrollBar.ScrollToRightEndCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToTopCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToTopCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToTopCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToTopCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToTopCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToTopCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToTopCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> al valor <see cref="P:System.Windows.Controls.Primitives.RangeBase.Maximum" /> para una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertical.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vertical <xref:System.Windows.Controls.Primitives.ScrollBar>, este movimiento se produce cuando el usuario presiona las teclas CTRL+INICIO.  
  
 Cuando se implementa un <xref:System.Windows.Controls.Primitives.ScrollBar> como parte de un <xref:System.Windows.Controls.ScrollViewer> (control), el <xref:System.Windows.Controls.ScrollViewer> ejecuta este comando.  
  
<a name="xamlTextUsage_ScrollToTopCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToTopCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollToVerticalOffsetCommand">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.Input.RoutedCommand ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ScrollToVerticalOffsetCommand As RoutedCommand " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::Input::RoutedCommand ^ ScrollToVerticalOffsetCommand;" />
      <MemberSignature Language="F#" Value=" staticval mutable ScrollToVerticalOffsetCommand : System.Windows.Input.RoutedCommand" Usage="System.Windows.Controls.Primitives.ScrollBar.ScrollToVerticalOffsetCommand" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedCommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Comando que desplaza una <see cref="T:System.Windows.Controls.Primitives.ScrollBar" /> vertical en <see cref="T:System.Windows.Controls.ScrollViewer" /> al valor que se proporciona en <see cref="P:System.Windows.Input.ExecutedRoutedEventArgs.Parameter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este comando solo se usa con un <xref:System.Windows.Controls.ScrollViewer> control.  
  
<a name="xamlTextUsage_ScrollToVerticalOffsetCommand"></a>   
## <a name="xaml-text-usage"></a>Uso de texto XAML  
 `<` *objeto* *propiedad*`="`**ScrollBar.ScrollToVerticalOffsetCommand**`"/>`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Track">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.Track Track { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.Track Track" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Track As Track" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::Track ^ Track { System::Windows::Controls::Primitives::Track ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Track : System.Windows.Controls.Primitives.Track" Usage="System.Windows.Controls.Primitives.ScrollBar.Track" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.Track</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene <see cref="T:System.Windows.Controls.Primitives.Track" /> para un control <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</summary>
        <value>
          <see cref="T:System.Windows.Controls.Primitives.Track" /> que se utiliza con un control <see cref="T:System.Windows.Controls.Primitives.ScrollBar" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una plantilla de estilo típicos para un <xref:System.Windows.Controls.Primitives.ScrollBar> control incluye una <xref:System.Windows.Controls.Primitives.Track> control rodeada a ambos lados por dos <xref:System.Windows.Controls.Button> controles.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo obtener acceso a la <xref:System.Windows.Controls.Primitives.Track> control que se usa con un <xref:System.Windows.Controls.Primitives.ScrollBar> control.  
  
 [!code-csharp[ScrollBarSnips#Track](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#track)]
 [!code-vb[ScrollBarSnips#Track](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#track)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSize">
      <MemberSignature Language="C#" Value="public double ViewportSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ViewportSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ViewportSize As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ViewportSize { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.ViewportSize : double with get, set" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la cantidad de contenido desplazable actualmente visible.</summary>
        <value>Cantidad de contenido desplazable que está actualmente visible.  El valor predeterminado es 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las unidades que se usan para <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> son las mismas unidades que se utilizan para describir la longitud del contenido. Algunos ejemplos incluyen líneas de texto o páginas de texto.  
  
 El valor de la <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> propiedad se utiliza para calcular el tamaño de la <xref:System.Windows.Controls.Primitives.Thumb> control que se muestra como indicador de valor variable en un <xref:System.Windows.Controls.Primitives.ScrollBar> control. El <xref:System.Windows.Controls.Primitives.Thumb> representa el tamaño del control de un <xref:System.Windows.Controls.ScrollViewer> contenido del control que está visible.  Si 25 por ciento de un <xref:System.Windows.Controls.ScrollViewer> contenido del control está visible, el <xref:System.Windows.Controls.Primitives.Thumb> ocupa el 25 por ciento de la pista en la <xref:System.Windows.Controls.Primitives.ScrollBar>.  
  
 Puede decidir qué unidades <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> usa.  Al establecer esta propiedad, asegúrese de que el <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Minimum%2A>, <xref:System.Windows.Controls.Primitives.RangeBase.Maximum%2A>, y <xref:System.Windows.Controls.Primitives.RangeBase.Value%2A> propiedades utilizan las mismas unidades.  
  
 La ilustración siguiente muestra cómo el <xref:System.Windows.Controls.Primitives.Thumb> tamaño refleja la cantidad de contenido visible.  
  
 ![La longitud de guía y de una barra de desplazamiento](~/add/media/scrollbarthumbsize.png "la longitud de guía y de una barra de desplazamiento")  
  
<a name="dependencyPropertyInfo_ViewportSize"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo establecer el <xref:System.Windows.Controls.Primitives.ScrollBar.ViewportSize%2A> en un <xref:System.Windows.Controls.Primitives.ScrollBar> control.  
  
 [!code-csharp[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml.cs#viewport)]
 [!code-vb[ScrollBarSnips#Viewport](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ScrollBarSnips/visualbasic/window1.xaml.vb#viewport)]
 [!code-xaml[ScrollBarSnips#Viewport](~/samples/snippets/csharp/VS_Snippets_Wpf/ScrollBarSnips/CSharp/Window1.xaml#viewport)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewportSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ViewportSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ViewportSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ViewportSizeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ViewportSizeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ViewportSizeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ScrollBar.ViewportSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ScrollBar.ViewportSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>