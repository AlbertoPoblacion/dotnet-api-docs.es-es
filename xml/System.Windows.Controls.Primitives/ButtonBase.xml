<Type Name="ButtonBase" FullName="System.Windows.Controls.Primitives.ButtonBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ec69f99ec8992aba0cba7b25892e354471c7bab7" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39939632" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Controls.ContentControl, System.Windows.Input.ICommandSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ButtonBase extends System.Windows.Controls.ContentControl implements class System.Windows.Input.ICommandSource" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Primitives.ButtonBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ButtonBase&#xA;Inherits ContentControl&#xA;Implements ICommandSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class ButtonBase abstract : System::Windows::Controls::ContentControl, System::Windows::Input::ICommandSource" />
  <TypeSignature Language="F#" Value="type ButtonBase = class&#xA;    inherit ContentControl&#xA;    interface ICommandSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Input.ICommandSource</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Button)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa la clase base para todos los controles <see cref="T:System.Windows.Controls.Button" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controlar la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos para responder cuando el usuario hace clic en un <xref:System.Windows.Controls.Primitives.ButtonBase>. El usuario puede provocar la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos mediante el uso de un <xref:System.Windows.Controls.AccessText> o presionando ENTRAR o la barra espaciadora cuando el control tiene el foco.  Cuando el usuario presiona la barra espaciadora, los conjuntos de controles <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> a `true` y captura el mouse.  Como resultado, el control generará eventos del mouse como <xref:System.Windows.UIElement.MouseEnter> y <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Tenga en cuenta que el uso del <xref:System.Windows.Controls.AccessText> o ENTRAR no cambia <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o capturar el mouse, pero provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 El <xref:System.Windows.Controls.Primitives.ButtonBase> establece la <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> propiedad adjunta `true`.  
  
 <xref:System.Windows.Controls.Primitives.ButtonBase> establece la propiedad <xref:System.Windows.UIElement.IsInputMethodEnabled%2A> en `false`.  
  
 Un <xref:System.Windows.Controls.Primitives.ButtonBase> es un <xref:System.Windows.Controls.ContentControl>, lo que significa que puede contener un único objeto de cualquier tipo (por ejemplo, una cadena, una imagen o un panel). Para obtener más información, vea la clase <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ButtonBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Windows.Controls.Primitives.ButtonBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.Primitives.ButtonBase.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.RoutedEventHandler " Usage="member this.Click : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se genera cuando se hace clic en <see cref="T:System.Windows.Controls.Button" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El usuario puede provocar la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos mediante el uso de un <xref:System.Windows.Controls.AccessText> o presionando ENTRAR o la barra espaciadora cuando el control tiene el foco.  Cuando el usuario presiona la barra espaciadora, los conjuntos de controles <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> a `true` y captura el mouse.  Como resultado, el control generará eventos del mouse como <xref:System.Windows.UIElement.MouseEnter> y <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Tenga en cuenta que el uso del <xref:System.Windows.Controls.AccessText> o ENTRAR no cambia <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o capturar el mouse, pero provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 El <xref:System.Windows.Controls.Primitives.ButtonBase> marcas el <xref:System.Windows.UIElement.MouseLeftButtonDown> evento como controlado en el <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> método y genera el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos. Por lo tanto, el <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown%2A> nunca se producirá el evento para un control que hereda de <xref:System.Windows.Controls.Primitives.ButtonBase>. En su lugar, adjuntar un controlador de eventos para el <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> llamada o evento <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` establecido en `true`.  
  
<a name="routedEventInfo_Click"></a>   
## <a name="routed-event-information"></a>Información sobre eventos enrutados  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickEvent>|  
|Estrategia de enrutamiento|Propagación|  
|delegado|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 El ejemplo siguiente muestra tres botones que responden a clics de tres maneras diferentes.  
  
-   Al mantener el mouse - el primer botón cambia de color cuando el usuario desplace el mouse sobre el botón  
  
-   Presionar: el segundo botón requiere que se presione el mouse mientras el puntero del mouse se encuentra en el botón.  
  
-   Versión: el tercero no restablece el color de fondo de los botones hasta que se presiona y suelta en el botón del mouse.  
  
 [!code-xaml[ClickModes_snip#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml#1)]  
  
 [!code-csharp[ClickModes_snip#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClickModes_snip/CSharp/Pane1.xaml.cs#2)]
 [!code-vb[ClickModes_snip#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClickModes_snip/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClickEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClickEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ClickEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica el evento enrutado <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento se corresponde con un clic del botón primario del mouse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickMode">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ClickMode ClickMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.ClickMode ClickMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ClickMode As ClickMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ClickMode ClickMode { System::Windows::Controls::ClickMode get(); void set(System::Windows::Controls::ClickMode value); };" />
      <MemberSignature Language="F#" Value="member this.ClickMode : System.Windows.Controls.ClickMode with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ClickMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece cuándo se produce el evento <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />.</summary>
        <value>Cuando se produce el evento <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />. El valor predeterminado es <see cref="F:System.Windows.Controls.ClickMode.Release" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ClickMode"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClickModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClickModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClickModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClickModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClickModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClickModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.ClickModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public System.Windows.Input.ICommand Command { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.ICommand Command" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberSignature Language="VB.NET" Value="Public Property Command As ICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::ICommand ^ Command { System::Windows::Input::ICommand ^ get(); void set(System::Windows::Input::ICommand ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Command : System.Windows.Input.ICommand with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.Command" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.ICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el comando que hay que invocar cuando se presiona este botón.</summary>
        <value>Comando que se invoca cuando se presiona este botón.  El valor predeterminado es <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad se utiliza para asociar un comando a una instancia de un botón determinado.  
  
 En [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], esta propiedad se establece con mayor frecuencia para ser un valor de comando estática de una de las bibliotecas de comandos existentes, como <xref:System.Windows.Input.ApplicationCommands> o <xref:System.Windows.Input.NavigationCommands>. Para obtener más información, consulte [información general sobre comandos](~/docs/framework/wpf/advanced/commanding-overview.md) o <xref:System.Windows.Input.ICommand>.  
  
<a name="xamlAttributeUsage_Command"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object Command="commandName"/>  
```  
  
<a name="xamlValues_Command"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *CommandName*  
 El comando que se invoca cuando se presiona este botón.  
  
<a name="dependencyPropertyInfo_Command"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandParameter">
      <MemberSignature Language="C#" Value="public object CommandParameter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CommandParameter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandParameter As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ CommandParameter { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandParameter : obj with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el parámetro que se va a pasar a la propiedad <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />.</summary>
        <value>Parámetro que se va a pasar a la propiedad <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mayoría de los comandos existentes desde las bibliotecas de comandos no usan un parámetro de comando. Los comandos que utilizan un parámetro de comando, la mayoría de ellos toman un parámetro con algún valor de tipo primitivo, como un entero o una cadena. Sin embargo, es posible crear un comando personalizado donde ese comando espera un tipo no primitivo como su parámetro de comando. Para un caso de comando personalizado como esta, opción <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> en código podría requerir una instancia de objeto nuevo o existente. Establecer <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> en el marcado pueden requerir la sintaxis de elemento de propiedad, donde el elemento de objeto que rellena la sintaxis de elemento de propiedad es un nuevo elemento del tipo esperado por ese comando. Como alternativa, la configuración en el marcado es posible que requieren una referencia a través de una extensión de marcado a un objeto existente (normalmente, estas referencias se realizan con [extensión de marcado de enlace](~/docs/framework/wpf/advanced/binding-markup-extension.md) o [StaticResource Markup Extension ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md)).  
  
<a name="xamlAttributeUsage_CommandParameter"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<object CommandParameter="commandParameter" />  
```  
  
<a name="xamlValues_CommandParameter"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *commandParameter*  
 Un valor del mismo tipo que el comando determinado especificado en el <xref:System.Windows.Controls.Primitives.ButtonBase.Command%2A> propiedad espera. Si usa un comando de biblioteca de comandos existente, consulte la documentación de la biblioteca de comandos para [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] información de uso, incluidos los tipos de <xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameter%2A> espera que el comando. Si usa un comando personalizado, vea la sección Comentarios.  
  
<a name="dependencyPropertyInfo_CommandParameter"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandParameterProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandParameterProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandParameterProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandParameterProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandParameterProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandParameterProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandParameterProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandParameter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ButtonBase.Command" /> enrutada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandTarget">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement CommandTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.IInputElement CommandTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property CommandTarget As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::IInputElement ^ CommandTarget { System::Windows::IInputElement ^ get(); void set(System::Windows::IInputElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CommandTarget : System.Windows.IInputElement with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Action")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el elemento en el que se emite el comando especificado.</summary>
        <value>Elemento en el que se va a producir un comando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> propiedad no se puede usar para definir un <xref:System.Windows.UIElement>. El <xref:System.Windows.Controls.Primitives.ButtonBase.CommandTarget%2A> propiedad proporciona una referencia a un elemento que ya está definido en alguna parte de la aplicación.  
  
<a name="xamlAttributeUsage_Target"></a>   
## <a name="xaml-attribute-usage"></a>Uso de atributos XAML  
  
```  
<ButtonBase CommandTarget="{Binding ElementName= elementName }"/>  
```  
  
<a name="xamlValues_CommandTarget"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *elementName*  
 El nombre de <xref:System.Windows.IInputElement> que recibe el comando.  
  
<a name="dependencyPropertyInfo_CommandTarget"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.ICommand" />
      </Docs>
    </Member>
    <Member MemberName="CommandTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CommandTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CommandTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CommandTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CommandTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CommandTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.CommandTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ButtonBase.CommandTarget" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected override bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.Controls.Primitives.ButtonBase.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el valor de la propiedad <see cref="P:System.Windows.ContentElement.IsEnabled" />.</summary>
        <value>Es <see langword="true" /> si el control está habilitado; en caso contrario, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si opta por reemplazar esta implementación, asegúrese de que se llame al método base.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressed">
      <MemberSignature Language="C#" Value="public bool IsPressed { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPressed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberSignature Language="VB.NET" Value="Public Property IsPressed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:  property bool IsPressed {  public:&#xA;bool get(); protected:&#xA; void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsPressed : bool with get, set" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si un control <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> está actualmente activado.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Windows.Controls.Primitives.ButtonBase" /> está activado; en caso contrario, <see langword="false" />. El valor predeterminado es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> es el estado de un botón que indica el botón primario del mouse o presionar la barra espaciadora sobre el botón. Cuando <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> es `true`, el control captura el mouse.  Como resultado, el control generará eventos del mouse como <xref:System.Windows.UIElement.MouseEnter> y <xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>. Tenga en cuenta que el uso del <xref:System.Windows.Controls.AccessText> o ENTRAR no cambia <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> o capturar el mouse, pero provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 Comenzando con la versión de .NET Framework 3.0 Service Pack 1, <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> tiene un establecedor protegido. Para usar esta funcionalidad, la aplicación debe tener como destino la versión 3.5 de .NET Framework.  Para más información, vea [Versiones y dependencias](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
<a name="dependencyPropertyInfo_IsPressed"></a>   
## <a name="dependency-property-information"></a>Información sobre propiedades de dependencia  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty>|  
|Establecen las propiedades de metadatos en `true`|None|  
  
   
  
## Examples  
 En este ejemplo se muestra cómo usar el <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> propiedad en un estilo de desencadenador.  
  
 [!code-xaml[BtnColor#9](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnColor/CSharp/Pane1.xaml#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPressedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsPressedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsPressedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsPressedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsPressedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsPressedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.Primitives.ButtonBase.IsPressedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica la propiedad de dependencia <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected override void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="buttonBase.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.Input.AccessKeyManager.AccessKeyPressed" />.</param>
        <summary>Responde cuando se llama a <see cref="P:System.Windows.Controls.AccessText.AccessKey" /> para este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Input.AccessKeyEventArgs.IsMultiple%2A> es `true`, este método llama a la implementación base, que proporciona el foco de este control.  En caso contrario, este método provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick();" />
      <MemberSignature Language="F#" Value="abstract member OnClick : unit -&gt; unit&#xA;override this.OnClick : unit -&gt; unit" Usage="buttonBase.OnClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Genera el evento enrutado <see cref="E:System.Windows.Controls.Primitives.ButtonBase.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El control provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos mediante una llamada a <xref:System.Windows.UIElement.RaiseEvent%2A>. Para obtener más información, consulte [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cuando se reemplaza <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> en una clase derivada, asegúrese de llamar a la clase base <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnClick" /> método para que los delegados registrados reciban el evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsPressedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsPressedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsPressedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsPressedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsPressedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsPressedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="buttonBase.OnIsPressedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Se llama a este método cuando cambia la propiedad de <see cref="P:System.Windows.Controls.Primitives.ButtonBase.IsPressed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.KeyDown" /> enrutado que se produce si el usuario presiona una tecla cuando este control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.KeyDown> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> no está establecido en <xref:System.Windows.Controls.ClickMode.Hover> y uno de los casos siguientes son verdaderas:  
  
-   El usuario presiona la barra espaciadora.  
  
-   El usuario presiona ENTRAR y <xref:System.Windows.Input.KeyboardNavigation.AcceptsReturn%2A> es `true` para este control.  
  
 En todos los demás casos, esta implementación no cambia el estado controlado (la <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad) de la <xref:System.Windows.UIElement.KeyDown> datos del evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyDown(System.Windows.Input.KeyEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.UIElement.KeyUp" />.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.KeyUp" /> enrutado que se produce si el usuario suelta una tecla cuando este control tiene el foco.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.KeyUp> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando el usuario suelta la barra espaciadora. En caso contrario, esta implementación no cambia el estado controlado (la <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad) de la <xref:System.Windows.UIElement.KeyUp> datos del evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnKeyUp(System.Windows.Input.KeyEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="buttonBase.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.IInputElement.LostKeyboardFocus" />.</param>
        <summary>Llamado cuando un elemento pierde el foco de teclado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected override void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" />.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.LostMouseCapture" /> enrutado que se produce cuando este control ya no está recibiendo los mensajes de eventos del mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación no cambia el estado controlado (la <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad) de la <xref:System.Windows.UIElement.LostMouseCapture> datos del evento.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.Input.Mouse.MouseEnter" />.</param>
        <summary>Proporciona control de clases para el evento <see cref="P:System.Windows.Controls.Primitives.ButtonBase.ClickMode" /> enrutado que se produce cuando el mouse entra en este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> está establecido en <xref:System.Windows.Controls.ClickMode.Hover>, esta implementación marca el <xref:System.Windows.UIElement.MouseEnter> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` y genera el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseEnter(System.Windows.Input.MouseEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos para el evento <see cref="E:System.Windows.Input.Mouse.MouseLeave" />.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.MouseLeave" /> enrutado que se produce cuando el mouse deja un elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.MouseLeave> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> está establecido en <xref:System.Windows.Controls.ClickMode.Hover>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeave(System.Windows.Input.MouseEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> enrutado que se produce cuando se presiona el botón primario mientras el puntero del mouse está sobre este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.MouseLeftButtonDown> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> no está establecido en <xref:System.Windows.Controls.ClickMode.Hover>. Para responder a la <xref:System.Windows.UIElement.MouseLeftButtonDown> eventos, adjuntar un controlador de eventos para el <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> llamada o evento <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` establecido en `true`.  
  
 Cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> está establecido en <xref:System.Windows.Controls.ClickMode.Press>, este método provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="buttonBase.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> enrutado que se produce cuando se suelta el botón primario mientras el puntero del mouse está sobre este control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.MouseLeftButtonUp> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> no está establecido en <xref:System.Windows.Controls.ClickMode.Hover>. Para responder a la <xref:System.Windows.UIElement.MouseLeftButtonUp> eventos, adjuntar un controlador de eventos para el <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> llamada o evento <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` establecido en `true`.  
  
 Cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> está establecido en <xref:System.Windows.Controls.ClickMode.Release> es <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> es `true`, este método provoca la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> eventos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Datos del evento.</param>
        <summary>Proporciona control de clases para el evento <see cref="E:System.Windows.UIElement.MouseMove" /> enrutado que se produce cuando se mueve el puntero del mouse mientras está sobre este elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta implementación marca el <xref:System.Windows.UIElement.MouseMove> evento como controlado estableciendo el <xref:System.Windows.RoutedEventArgs.Handled%2A> propiedad de los datos del evento a `true` cuando <xref:System.Windows.Controls.Primitives.ButtonBase.ClickMode%2A> no está establecido en <xref:System.Windows.Controls.ClickMode.Hover> y <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> es `true`. Para responder a la <xref:System.Windows.UIElement.MouseMove> eventos, adjuntar un controlador de eventos para el <xref:System.Windows.ContentElement.PreviewMouseMove> llamada o evento <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> con `handledEventsToo` establecido en `true`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si invalida <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" />, llame siempre a la implementación base su <see cref="M:System.Windows.Controls.Primitives.ButtonBase.OnMouseMove(System.Windows.Input.MouseEventArgs)" /> implementación. Error al llamar a la implementación base impide que las clases base controle el evento con un controlador de clase, lo que podría cambiar el comportamiento de tiempo de ejecución de la clase final. Puede llamar a la implementación base antes o después de su tratamiento especial, dependiendo de sus requisitos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="buttonBase.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Especifica los cambios de tamaño.</param>
        <summary>Llamado cuando cambia el tamaño representado de un control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalida el <xref:System.Windows.Controls.Primitives.ButtonBase.OnRenderSizeChanged%2A> método de la <xref:System.Windows.UIElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>