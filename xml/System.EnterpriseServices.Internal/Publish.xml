<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="62098ba94a2dc2da4b0569caa50b8f8bc0d65d34" />
    <Meta Name="ms.sourcegitcommit" Value="29c771f79cf4eac4f49e5fae5f1aa8b457acf146" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/21/2018" />
    <Meta Name="ms.locfileid" Value="36298637" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publica interfaces COM para aplicaciones COM+ con SOAP habilitado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish> se utiliza internamente por .NET Framework. No es necesario utilizar directamente en el código.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.EnterpriseServices.Internal.Publish" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Domain" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Dirección URL del servidor de correo raíz.</param>
        <param name="MailBox">Buzón que se va a crear.</param>
        <param name="SmtpName">Cuando este método finaliza, este parámetro contiene el nombre del servidor SMTP (Protocolo simple de transferencia de correo) que contiene el buzón.</param>
        <param name="Domain">Cuando este método finaliza, este parámetro contiene el dominio del servidor SMTP.</param>
        <param name="PhysicalPath">Cuando este método finaliza, este parámetro contiene la ruta de acceso al sistema de archivos correspondiente al buzón.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Crea un buzón de aplicación COM+ con SOAP habilitado en una dirección URL especificada. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sin implementar totalmente; no se crea un buzón. Devuelve el mensaje de error "Los servicios SOAP de COM + no se admite la publicación de SMTP."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operación que se va a realizar.</param>
        <param name="FullUrl">Dirección URL completa de la raíz virtual.</param>
        <param name="BaseUrl">Cuando este método finaliza, este parámetro contiene la dirección URL base.</param>
        <param name="VirtualRoot">Cuando este método finaliza, este parámetro contiene el nombre de la raíz virtual.</param>
        <param name="PhysicalPath">Cuando este método finaliza, este parámetro contiene la ruta de acceso al archivo de la raíz virtual.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Crea una raíz virtual de aplicación COM+ con SOAP habilitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  -o bien- El autor de llamada no tiene permiso para acceder a la información DNS (Domain Name System, Sistema de nombres de dominio).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al resolver el nombre de host local.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> está vacía.  -o bien- El esquema especificado en <paramref name="FullUrl" /> no es válido.  -o bien- <paramref name="FullUrl" /> contiene más de dos barras diagonales consecutivas.  -o bien- La contraseña especificada en <paramref name="FullUrl" /> no es válida.  -o bien- El nombre de host especificado en <paramref name="FullUrl" /> no es válido.  -o bien- El nombre de archivo especificado en <paramref name="FullUrl" /> no es válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para la configuración de la infraestructura de comunicación remota. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Dirección URL del servidor de correo raíz.</param>
        <param name="MailBox">Buzón que se va a eliminar.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Elimina un buzón de aplicación COM+ con SOAP habilitado en una dirección URL especificada. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sin implementar totalmente, no elimina el buzón. Devuelve el mensaje de error "Los servicios SOAP de COM + no se admite la publicación de SMTP."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Servidor Web raíz.</param>
        <param name="FullUrl">Dirección URL completa de la raíz virtual.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Elimina una raíz virtual de aplicación COM+ con SOAP habilitado. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La funcionalidad de <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> aún no está disponible.  
  
> [!CAUTION]
>  Actualmente, el método devuelve sin errores, pero no se elimina la raíz virtual.  
  
 Cuando la funcionalidad está disponible, el método recomendado será <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Instala un ensamblado en la memoria caché global de ensamblados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Quita un ensamblado de la memoria caché global de ensamblados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  -o bien- El llamador no dispone del permiso de detección de rutas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> está vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="AssemblyPath" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="CachePath">Cuando este método finaliza, este parámetro contiene el nombre del directorio SoapCache.</param>
        <summary>Devuelve la ruta de acceso completa de un ensamblado generado firmado con nombre seguro en el directorio SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que un no administrado componente COM + se publiquen a través de .NET remoting como un extremo SOAP, un servidor proxy debe generarse para disponer de los componentes no administrados a .NET Framework. Esto se debe realizar mediante programación los mismos pasos que el importador de la biblioteca de tipos (Tlbimp.exe), el [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] herramienta que se usa para convertir las bibliotecas de tipos COM + no administradas en ensamblados de metadatos de proxy. Sin embargo, para la activación de cliente mediante el protocolo SOAP lleve a cabo correctamente, los equipos cliente y servidor deben compartir a los mismos servidores proxy de metadatos firmados con nombre seguro. Por este motivo, cuando se genera un ensamblado proxy administrado para un componente COM + no administrado, una clave de nombre seguro es también genera y usa para firmar el ensamblado de proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">El nombre de archivo está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Acceso a <paramref name="TypeLibPath" /> denegado.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> contiene un carácter de dos puntos (:) dentro de la cadena.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer archivos. Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">Se establece en <see langword="true" /> para crear el directorio, o bien, en <see langword="false" /> para devolver la ruta de acceso sin crear el directorio.</param>
        <summary>Devuelve la ruta de acceso del directorio en el que se almacenan los archivos de configuración del cliente.</summary>
        <returns>Ruta de acceso del directorio que contiene los archivos de configuración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crea los directorios "\com\SOAPAssembly\\" en el directorio del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El llamador no dispone del permiso requerido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <summary>Refleja un ensamblado y devuelve el nombre de tipo que coincide con el identificador de programa (ProgID).</summary>
        <returns>Nombre de tipo que coincide con el identificador de programa.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">Dirección URL completa de la raíz virtual.</param>
        <param name="BaseUrl">Cuando este método finaliza, este parámetro contiene la dirección URL base.</param>
        <param name="VirtualRoot">Cuando este método finaliza, este parámetro contiene el nombre de la raíz virtual.</param>
        <summary>Analiza una dirección URL y devuelve la dirección URL base y las partes de raíz virtual.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al resolver el nombre de host local.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no tiene permiso para obtener acceso a la información DNS (Domain Name System, Sistema de nombres de dominio).</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> está vacía.  -o bien- El esquema especificado en <paramref name="FullUrl" /> no es válido.  -o bien- <paramref name="FullUrl" /> contiene demasiadas barras diagonales.  -o bien- La contraseña especificada en <paramref name="FullUrl" /> no es válida.  -o bien- El nombre de host especificado en <paramref name="FullUrl" /> no es válido.  -o bien- El nombre de archivo especificado en <paramref name="FullUrl" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <param name="SrcTlbPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="PhysicalPath">Directorio de la aplicación Web.</param>
        <param name="VRoot">Nombre de la raíz virtual.</param>
        <param name="BaseUrl">Dirección URL base que contiene la raíz virtual.</param>
        <param name="Mode">Modo de activación.</param>
        <param name="Transport">No usado. Especifique <see langword="null" /> para este parámetro.</param>
        <param name="AssemblyName">Cuando este método finaliza, este parámetro contiene el nombre para mostrar del ensamblado.</param>
        <param name="TypeName">Cuando este método finaliza, este parámetro contiene el nombre de tipo completo del ensamblado.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Procesa una biblioteca de tipos de cliente y crea un archivo de configuración en el cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza en una importación de proxy de cliente para generar un archivo de configuración de comunicación remota.  
  
 Si el `Mode` parámetro es "wellknownobject" o una cadena vacía (""), se supone que es un objeto conocido; en caso contrario, se supone la activación del cliente.  
  
 Se recomienda que <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <param name="SrcTlbPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="PhysicalPath">Directorio de la aplicación Web.</param>
        <param name="Operation">Operación que se va a realizar.</param>
        <param name="strAssemblyName">Cuando este método finaliza, este parámetro contiene el nombre para mostrar del ensamblado.</param>
        <param name="TypeName">Cuando este método finaliza, este parámetro contiene el nombre de tipo completo del ensamblado.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Procesa una biblioteca de tipos de servidor y agrega o elimina entradas de componente a los archivos Web.config y Default.disco. Genera un proxy si es necesario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> Agrega una entrada para el archivo de detección y el archivo web.config para los componentes de la biblioteca de tipos, y genera o copia un proxy en el directorio bin de componentes no administrados. Si `Operation` es igual a "delete", a continuación, se quitan las entradas de componentes de los archivos Web.config y Default.disco.  
  
 Se recomienda que <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> y <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Archivo scrobj.dll al que hace referencia el parámetro <paramref name="SrcTlbPath" />; por tanto, no se admite la publicación SOAP de los componentes de scripts.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">la capacidad tener acceso a código no administrado. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Registra un ensamblado para interoperabilidad COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A> utiliza la herramienta de registro de ensamblados (Regasm.exe) para registrar las clases que se pueden crear en el ensamblado. Para obtener más información, consulte [Regasm.exe (herramienta de registro de ensamblados)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">El ensamblado de entrada no dispone de un nombre seguro.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  -o bien- Se ha especificado un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="AssemblyPath" /> o no se ha especificado una extensión de nombre de archivo.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se ha cargado un ensamblado o módulo dos veces con dos evidencias diferentes o el nombre del ensamblado supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es <see langword="static" />.  -o bien- Hay más de un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> en un nivel determinado de la jerarquía.  -o bien- La firma del método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">la capacidad de tener acceso al registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para determinar el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer un identificador URI que comienza con "file://". Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienza con "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Anula el registro de un ensamblado de interoperabilidad COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A> utiliza la herramienta Regasm.exe para anular el registro de las clases que se pueden crear en el ensamblado. Para obtener más información, consulte [Regasm.exe (herramienta de registro de ensamblados)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  -o bien- Se ha especificado un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="AssemblyPath" /> o no se ha especificado una extensión de nombre de archivo.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se ha cargado un ensamblado o módulo dos veces con dos evidencias diferentes o el nombre del ensamblado supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es <see langword="static" />.  -o bien- Hay más de un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> en un nivel determinado de la jerarquía.  -o bien- La firma del método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es válida.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">la capacidad de tener acceso al registro. Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">para determinar el directorio actual. Enumeración asociada: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leer un identificador URI que comienza con "file://". Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para leer un URI que no comienza con "file://".</permission>
      </Docs>
    </Member>
  </Members>
</Type>