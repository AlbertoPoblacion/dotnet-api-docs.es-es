<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9812df377cbce36257f9771ffb1f187f2c55c6c1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39983372" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type IComSoapPublisher = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publica interfaces COM para aplicaciones COM+ con SOAP habilitado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación de <xref:System.EnterpriseServices.Internal.IComSoapPublisher> es <xref:System.EnterpriseServices.Internal.Publish>; consulte ese tema para obtener información específica.  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> se usa internamente por .NET Framework. No es necesario usarlo directamente en el código.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Dirección URL del servidor de correo raíz.</param>
        <param name="MailBox">Buzón que se va a crear.</param>
        <param name="SmtpName">Cuando este método finaliza, este parámetro contiene el nombre del servidor SMTP (Protocolo simple de transferencia de correo) que contiene el buzón.</param>
        <param name="Domain">Cuando este método finaliza, este parámetro contiene el dominio del servidor SMTP.</param>
        <param name="PhysicalPath">Cuando este método finaliza, este parámetro contiene la ruta de acceso al sistema de archivos correspondiente al buzón.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Crea un buzón de aplicación COM+ con SOAP habilitado en una dirección URL especificada. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado totalmente; actualmente no crea un buzón. Devuelve el mensaje de error "Servicios de COM + con SOAP no se admite la publicación de SMTP."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operación que se va a realizar.</param>
        <param name="FullUrl">Dirección URL completa de la raíz virtual.</param>
        <param name="BaseUrl">Cuando este método finaliza, este parámetro contiene la dirección URL base.</param>
        <param name="VirtualRoot">Cuando este método finaliza, este parámetro contiene el nombre de la raíz virtual.</param>
        <param name="PhysicalPath">Cuando este método finaliza, este parámetro contiene la ruta de acceso al archivo de la raíz virtual.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Crea una raíz virtual de aplicación COM+ con SOAP habilitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se recomienda que <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  
  
O bien 
El llamador no tiene permiso de acceso a la información de DNS (Sistema de nombres de dominio).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Se ha producido un error al resolver el nombre de host local.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> está vacía.  
  
O bien 
El esquema especificado en <paramref name="FullUrl" /> no es válido.  
  
O bien 
 <paramref name="FullUrl" /> contiene más de dos barras diagonales consecutivas.  
  
O bien 
La contraseña especificada en <paramref name="FullUrl" /> no es válida.  
  
O bien 
El nombre de host especificado en <paramref name="FullUrl" /> no es válido.  
  
O bien 
El nombre de archivo especificado en <paramref name="FullUrl" /> no es válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Dirección URL del servidor de correo raíz.</param>
        <param name="MailBox">Buzón que se va a eliminar.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Elimina un buzón de aplicación COM+ con SOAP habilitado en una dirección URL especificada. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No implementado totalmente; no se elimina el buzón. Devuelve el mensaje de error "Servicios de COM + con SOAP no se admite la publicación de SMTP."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Servidor Web raíz.</param>
        <param name="FullUrl">Dirección URL completa de la raíz virtual.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Elimina una raíz virtual de aplicación COM+ con SOAP habilitado. Sin implementar totalmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La funcionalidad para <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> aún no está disponible.  
  
> [!CAUTION]
>  Actualmente, el método devuelve sin errores, pero no se elimina la raíz virtual.  
  
 Cuando la funcionalidad esté disponible, el método recomendado será <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit" Usage="iComSoapPublisher.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Instala un ensamblado en la memoria caché global de ensamblados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit" Usage="iComSoapPublisher.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Quita un ensamblado de la memoria caché global de ensamblados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> está vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se ha encontrado <paramref name="AssemblyPath" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit" Usage="iComSoapPublisher.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="CachePath">Cuando este método finaliza, este parámetro contiene la ruta de acceso completa al ensamblado de proxy en el directorio SoapCache.</param>
        <summary>Devuelve la ruta de acceso completa de un ensamblado generado firmado con nombre seguro en el directorio SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para que un no administrado componente COM + se publiquen a través de .NET remoting como un punto de conexión SOAP, un servidor proxy debe generarse para disponer de los componentes no administrados de .NET Framework. Esto se hace mediante la realización mediante programación los mismos pasos que el importador de la biblioteca de tipos (Tlbimp.exe), el [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] herramienta que se usa para convertir las bibliotecas de tipos COM + no administradas a los ensamblados de metadatos de proxy. Sin embargo, para la activación de cliente a través de SOAP se realice correctamente, los equipos cliente y servidor deben compartir a los mismos servidores proxy de metadatos firmados con nombre seguro. Por este motivo, cuando se genera un ensamblado proxy administrado para un componente COM + no administrado, una clave de nombre seguro es también genera y usa para firmar el ensamblado de proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">El llamador no dispone del permiso requerido.</exception>
        <exception cref="T:System.ArgumentException">El nombre de archivo está vacío, solo contiene espacios en blanco o incluye caracteres no válidos.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Acceso a <paramref name="TypeLibPath" /> denegado.</exception>
        <exception cref="T:System.IO.PathTooLongException">La ruta de acceso especificada, el nombre de archivo o ambos superan la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> contiene un carácter de dos puntos (:) dentro de la cadena.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string" Usage="iComSoapPublisher.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <summary>Refleja un ensamblado y devuelve el nombre de tipo que coincide con el identificador de programa (ProgID).</summary>
        <returns>Nombre de tipo que coincide con el identificador de programa.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <param name="SrcTlbPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="PhysicalPath">Directorio de la aplicación Web.</param>
        <param name="VRoot">Nombre de la raíz virtual.</param>
        <param name="BaseUrl">Dirección URL base que contiene la raíz virtual.</param>
        <param name="Mode">Modo de activación.</param>
        <param name="Transport">No usado. Especifique <see langword="null" /> para este parámetro.</param>
        <param name="AssemblyName">Cuando este método finaliza, este parámetro contiene el nombre para mostrar del ensamblado.</param>
        <param name="TypeName">Cuando este método finaliza, este parámetro contiene el nombre de tipo completo del ensamblado.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Procesa una biblioteca de tipos de cliente y crea un archivo de configuración en el cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se utiliza en una importación de proxy de cliente para generar un archivo de configuración de comunicación remota.  
  
 En la implementación, si el `Mode` parámetro es "wellknownobject" o una cadena vacía (""), se supone que un objeto conocido; en caso contrario, se supone la activación del cliente.  
  
 Se recomienda que <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">El identificador de programación de la clase.</param>
        <param name="SrcTlbPath">Ruta de acceso al archivo que contiene la biblioteca de tipos.</param>
        <param name="PhysicalPath">Directorio de la aplicación Web.</param>
        <param name="Operation">Operación que se va a realizar.</param>
        <param name="AssemblyName">Cuando este método finaliza, este parámetro contiene el nombre para mostrar del ensamblado.</param>
        <param name="TypeName">Cuando este método finaliza, este parámetro contiene el nombre de tipo completo del ensamblado.</param>
        <param name="Error">Cuando se devuelve el valor del método, este parámetro contiene un mensaje de error si se detecta un problema.</param>
        <summary>Procesa una biblioteca de tipos de servidor y agrega o elimina entradas de componente a los archivos Web.config y Default.disco. Genera un proxy si es necesario.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Genera entradas del archivo Web.config y Default.disco para componentes COM +. Genera un proxy si es necesario.  
  
 Se recomienda que <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> y <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> usarse en lugar de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">Archivo scrobj.dll al que hace referencia el parámetro <paramref name="SrcTlbPath" />; por tanto, no se admite la publicación SOAP de los componentes de scripts.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Registra un ensamblado para interoperabilidad COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> usa la herramienta de registro de ensamblados (Regasm.exe) para registrar las clases que se pueden crear en el ensamblado. Para obtener más información, consulte [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">El ensamblado de entrada no dispone de un nombre seguro.</exception>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  
  
O bien 
Se ha especificado un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="AssemblyPath" /> o no se ha especificado una extensión de nombre de archivo.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se ha cargado un ensamblado o módulo dos veces con dos evidencias diferentes o el nombre del ensamblado supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es <see langword="static" />.  
  
O bien 
Hay más de un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> en un nivel determinado de la jerarquía.  
  
O bien 
La firma del método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ruta de acceso de archivo para el ensamblado.</param>
        <summary>Anula el registro de un ensamblado de interoperabilidad COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación de <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> utiliza Regasm.exe para anular el registro de las clases que se pueden crear en el ensamblado. Para obtener más información, consulte [Regasm.exe (Assembly Registration Tool)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Un llamador de la cadena de llamadas no tiene permiso para obtener acceso al código no administrado.  
  
O bien 
Se ha especificado un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra <paramref name="AssemblyPath" /> o no se ha especificado una extensión de nombre de archivo.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> no es un ensamblado válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Se ha cargado un ensamblado o módulo dos veces con dos evidencias diferentes o el nombre del ensamblado supera la longitud máxima definida por el sistema.</exception>
        <exception cref="T:System.InvalidOperationException">Un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es <see langword="static" />.  
  
O bien 
Hay más de un método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> en un nivel determinado de la jerarquía.  
  
O bien 
La firma del método marcado con <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> no es válida.</exception>
      </Docs>
    </Member>
  </Members>
</Type>