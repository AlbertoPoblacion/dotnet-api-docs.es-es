<Type Name="ConfigurationSection" FullName="System.Configuration.ConfigurationSection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="74ab7c1cf9217a3cc9abfcfac85ddcde560bb6e5" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52590171" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ConfigurationSection : System.Configuration.ConfigurationElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationSection extends System.Configuration.ConfigurationElement" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationSection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationSection&#xA;Inherits ConfigurationElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationSection abstract : System::Configuration::ConfigurationElement" />
  <TypeSignature Language="F#" Value="type ConfigurationSection = class&#xA;    inherit ConfigurationElement" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa una sección dentro de un archivo de configuración.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa el <xref:System.Configuration.ConfigurationSection> clase para implementar un tipo de sección personalizada. Ampliar la <xref:System.Configuration.ConfigurationSection> clase para proporcionar control personalizado y acceso mediante programación a secciones de configuración personalizadas. Para obtener información acerca de cómo usar las secciones de configuración personalizado, vea [How to: Create Custom Configuration Sections utilizando ConfigurationSection](https://msdn.microsoft.com/library/febaca98-c727-4017-95ed-82e2fb6cf234).  
  
 Una sección registra su tipo de control con una entrada en el `configSections` elemento. Para obtener un ejemplo, vea el fragmento de archivo de configuración que se muestra en la sección ejemplo.  
  
> [!NOTE]
>  En versiones anteriores de .NET Framework, los controladores de sección de configuración se usaron para realizar cambios en los valores de configuración mediante programación. Ahora, todas las secciones de configuración predeterminada se representan mediante las clases que extienden la <xref:System.Configuration.ConfigurationSection> clase.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo implementar una sección personalizada mediante programación.  
  
 Para obtener un ejemplo completo que muestra cómo implementar y utilizar una sección personalizada implementada mediante el modelo con atributos, vea <xref:System.Configuration.ConfigurationElement>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationSection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#1)]  
  
 El ejemplo siguiente es un extracto del archivo de configuración, tal como se aplica a del ejemplo anterior.  
  
 ```xml
<?xml version="1.0" encoding="utf-8"?>
  <configuration>  
    <configSections>
      <section name="CustomSection" type="Samples.AspNet. CustomSection, CustomConfigurationSection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" allowDefinition="Everywhere" allowExeDefinition="MachineToApplication" restartOnExternalChanges="true" />
    </configSections>  

    <CustomSection fileName="default.txt" maxUsers="1000" maxIdleTime="00:15:00" /> 
 
  </configuration>
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Puede usar una programación o un modelo de programación declarativo (con atributos) para crear secciones de configuración personalizadas: 
-Modelo mediante programación. Este modelo requiere que para cada atributo de la sección Creación de una propiedad para obtener o establecer su valor y agregarlo a la bolsa de propiedades interno de subyacente <see cref="T:System.Configuration.ConfigurationElement" /> clase base.  
  
-Modelo declarativo. Este modelo más sencillo, también denominado modelo con atributos, permite definir un atributo de sección utilizando una propiedad y representándola con atributos. Estos atributos indican el sistema de configuración de ASP.NET acerca de los tipos de propiedad y sus valores predeterminados. Con esta información, se obtiene mediante reflexión, el sistema de configuración de ASP.NET crea objetos de propiedad de la sección y realiza la inicialización necesaria.  
  
La <see cref="T:System.Configuration.Configuration" /> clase permite el acceso mediante programación para editar archivos de configuración. Puede tener acceso a estos archivos para leer o escribir como sigue: 
-Leer. Usa <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> o <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> para leer información de configuración. Tenga en cuenta que el usuario o proceso que lee debe tener los permisos siguientes: 
-Permiso de lectura en el archivo de configuración en el nivel de jerarquía de configuración actual.  
  
-Permisos de lectura en todas las principales de los archivos de configuración.  
  
Si la aplicación necesita acceso de solo lectura a su propia configuración, se recomienda que utilice el <see cref="Overload:System.Web.Configuration.WebConfigurationManager.GetSection" /> sobrecargar métodos en el caso de aplicaciones Web, o el <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> método en el caso de las aplicaciones cliente.  
  
Estos métodos proporcionan acceso a los valores de configuración almacenada en caché de la aplicación actual, que tiene un rendimiento mejor que la <see cref="T:System.Configuration.Configuration" /> clase.  
  
 <block subset="none" type="note"><para>  
 Si usa una variable static <see langword="GetSection" /> método que toma un <paramref name="path" /> parámetro, el <paramref name="path" /> parámetro debe hacer referencia a la aplicación en el que se ejecuta el código; en caso contrario, se omite el parámetro y la información de configuración para el actualmente en ejecución se devuelve la aplicación.  
  
</para></block>  
  
-Escribir. Utilice uno de los <see cref="Overload:System.Configuration.Configuration.Save" /> métodos para escribir información de configuración. Tenga en cuenta que el usuario o proceso que escribe debe tener los permisos siguientes: 
-Permiso de escritura en el archivo de configuración y el directorio en el nivel de jerarquía de configuración actual.  
  
-Permisos de lectura en todos los archivos de configuración.</para>
    </block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Configuration.SectionInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
    <related type="Article" href="https://msdn.microsoft.com/library/5696e8b2-d489-4220-aef2-f2e0ca9099b4">Introducción a la API de configuración de ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationSection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationSection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Configuration.ConfigurationSection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar el <xref:System.Configuration.ConfigurationSection.%23ctor%2A> constructor, debe definir primero un tipo de sección personalizada. Para obtener un ejemplo, vea el <xref:System.Configuration.ConfigurationSection> información general de clases.  
  
   
  
## Examples  
 El siguiente ejemplo muestra cómo se usa el constructor <xref:System.Configuration.ConfigurationSection.%23ctor%2A>. En este ejemplo se da por supuesto que ha creado una clase de sección personalizada denominada `CustomSection`. Para obtener un ejemplo de esta clase, vea el <xref:System.Configuration.ConfigurationSection> información general de clases.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationSection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeserializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual void DeserializeSection (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void DeserializeSection(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.DeserializeSection(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub DeserializeSection (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void DeserializeSection(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member DeserializeSection : System.Xml.XmlReader -&gt; unit&#xA;override this.DeserializeSection : System.Xml.XmlReader -&gt; unit" Usage="configurationSection.DeserializeSection reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Objeto <see cref="T:System.Xml.XmlReader" />, que lee el archivo de configuración.</param>
        <summary>Lee XML del archivo de configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La deserialización hace referencia a la lectura de datos XML desde un archivo de configuración, su transformación en los datos en tiempo real y su almacenamiento en un objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">
          <paramref name="reader" /> no encontró ningún elemento en el archivo de configuración.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRuntimeObject">
      <MemberSignature Language="C#" Value="protected internal virtual object GetRuntimeObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object GetRuntimeObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.GetRuntimeObject" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetRuntimeObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ GetRuntimeObject();" />
      <MemberSignature Language="F#" Value="abstract member GetRuntimeObject : unit -&gt; obj&#xA;override this.GetRuntimeObject : unit -&gt; obj" Usage="configurationSection.GetRuntimeObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un objeto personalizado cuando se reemplaza en una clase derivada.</summary>
        <returns>Objeto que representa la sección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Configuration.Configuration.GetSection%2A> se llama al método en tiempo de ejecución, el sistema de configuración crea primero una instancia adecuada de la <xref:System.Configuration.ConfigurationSection> clase y, a continuación, devuelve el objeto que se obtiene desde el <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> método.  
  
 De forma predeterminada, <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A> simplemente devuelve el objeto que representa el <xref:System.Configuration.ConfigurationSection> desde que se llama.  
  
   
  
## Examples  
 En el siguiente ejemplo, se muestra cómo utilizar el método <xref:System.Configuration.ConfigurationSection.GetRuntimeObject%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#4)]
 [!code-vb[System.Configuration.ConfigurationSection#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Puede invalidar el <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> método devuelva un tipo personalizado en tiempo de ejecución.  
  
Por ejemplo, para restringir la modificación de tiempo de ejecución de la configuración en el <see cref="T:System.Configuration.ConfigurationSection" /> (clase), puede invalidar <see cref="M:System.Configuration.ConfigurationSection.GetRuntimeObject" /> y devolver un tipo personalizado que aplica las restricciones en el que puede modificar la configuración, si existe.  
  
Si el objeto en tiempo de ejecución sólo es interno, el objeto devuelto no se puede usar fuera del ensamblado que lo define. Una manera de crear un objeto que se deriva de <see cref="T:System.Configuration.ConfigurationSection" /> y solo se puede acceder al código de su ensamblado en ejecución tiempo consiste en crear un objeto interno en tiempo de ejecución que tenga un método que devuelva su <see cref="T:System.Configuration.ConfigurationSection" /> implementación.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberSignature Language="F#" Value="override this.IsModified : unit -&gt; bool" Usage="configurationSection.IsModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si se ha modificado este elemento de configuración desde la última vez en que se guardo o cargó al implementarlo en una clase derivada.</summary>
        <returns>
          <see langword="true" /> si el elemento se ha modificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberSignature Language="F#" Value="override this.ResetModified : unit -&gt; unit" Usage="configurationSection.ResetModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor del método <see cref="M:System.Configuration.ConfigurationElement.IsModified" /> en <see langword="false" /> cuando se implementa en una clase derivada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SectionInformation">
      <MemberSignature Language="C#" Value="public System.Configuration.SectionInformation SectionInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SectionInformation SectionInformation" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SectionInformation As SectionInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Configuration::SectionInformation ^ SectionInformation { System::Configuration::SectionInformation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SectionInformation : System.Configuration.SectionInformation" Usage="System.Configuration.ConfigurationSection.SectionInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SectionInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto <see cref="T:System.Configuration.SectionInformation" /> que contiene la funcionalidad e información no personalizable del objeto <see cref="T:System.Configuration.ConfigurationSection" />.</summary>
        <value>
          <see cref="T:System.Configuration.SectionInformation" /> que contiene la funcionalidad e información no personalizable de <see cref="T:System.Configuration.ConfigurationSection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se muestra cómo usar la propiedad <xref:System.Configuration.ConfigurationSection.SectionInformation%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationSection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/CS/CustomConfigurationSection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationSection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationSection/VB/CustomConfigurationSection.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Configuration.SectionInformation" />
      </Docs>
    </Member>
    <Member MemberName="SerializeSection">
      <MemberSignature Language="C#" Value="protected internal virtual string SerializeSection (System.Configuration.ConfigurationElement parentElement, string name, System.Configuration.ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string SerializeSection(class System.Configuration.ConfigurationElement parentElement, string name, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.SerializeSection(System.Configuration.ConfigurationElement,System.String,System.Configuration.ConfigurationSaveMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SerializeSection (parentElement As ConfigurationElement, name As String, saveMode As ConfigurationSaveMode) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ SerializeSection(System::Configuration::ConfigurationElement ^ parentElement, System::String ^ name, System::Configuration::ConfigurationSaveMode saveMode);" />
      <MemberSignature Language="F#" Value="abstract member SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string&#xA;override this.SerializeSection : System.Configuration.ConfigurationElement * string * System.Configuration.ConfigurationSaveMode -&gt; string" Usage="configurationSection.SerializeSection (parentElement, name, saveMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" />
      </Parameters>
      <Docs>
        <param name="parentElement">Instancia de <see cref="T:System.Configuration.ConfigurationElement" /> que se va a utilizar como elemento primario al realizar la separación.</param>
        <param name="name">Nombre de la sección que se va a crear.</param>
        <param name="saveMode">Instancia de <see cref="T:System.Configuration.ConfigurationSaveMode" /> que se va a usar al escribir en una cadena.</param>
        <summary>Crea una cadena XML que contiene una vista separada del objeto <see cref="T:System.Configuration.ConfigurationSection" /> como una sección única para escribir en un archivo.</summary>
        <returns>Cadena XML que contiene la vista separada del objeto <see cref="T:System.Configuration.ConfigurationSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La serialización hace referencia a la transformación de datos en tiempo real, contenidos en un objeto en formato XML y su almacenamiento en un archivo de configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeElementInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeElementInTargetVersion (System.Configuration.ConfigurationElement element, string elementName, System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeElementInTargetVersion(class System.Configuration.ConfigurationElement element, string elementName, class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeElementInTargetVersion(System.Configuration.ConfigurationElement,System.String,System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeElementInTargetVersion (element As ConfigurationElement, elementName As String, targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeElementInTargetVersion(System::Configuration::ConfigurationElement ^ element, System::String ^ elementName, System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeElementInTargetVersion : System.Configuration.ConfigurationElement * string * System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeElementInTargetVersion (element, elementName, targetFramework)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="elementName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> que es un candidato para la serialización.</param>
        <param name="elementName">Nombre del objeto <see cref="T:System.Configuration.ConfigurationElement" /> tal como aparece en XML.</param>
        <param name="targetFramework">Versión de destino de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Indica si se debe serializar el elemento especificado cuando la jerarquía de objetos de configuración se serializa para la versión de destino especificada de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si <paramref name="element" /> debe serializarse; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada sección de configuración que se crea para el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y versiones posteriores explícitamente deben invalidar este método y devolver `true`, pero solo si el elemento especificado es válido para la versión especificada de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Secciones de configuración existentes que se crearon para versiones anteriores de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] no debe cambiarse.  
  
 El tipo base contiene una implementación predeterminada de este método siempre devuelve `true`. Si implementa una sección de configuración y no invalida este método, de forma predeterminada, todos los elementos de configuración que se encuentran en la sección de configuración que se va a serializar para todas las versiones de framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework como destino para proyectos web</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePropertyInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializePropertyInTargetVersion (System.Configuration.ConfigurationProperty property, string propertyName, System.Runtime.Versioning.FrameworkName targetFramework, System.Configuration.ConfigurationElement parentConfigurationElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializePropertyInTargetVersion(class System.Configuration.ConfigurationProperty property, string propertyName, class System.Runtime.Versioning.FrameworkName targetFramework, class System.Configuration.ConfigurationElement parentConfigurationElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializePropertyInTargetVersion(System.Configuration.ConfigurationProperty,System.String,System.Runtime.Versioning.FrameworkName,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializePropertyInTargetVersion (property As ConfigurationProperty, propertyName As String, targetFramework As FrameworkName, parentConfigurationElement As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializePropertyInTargetVersion(System::Configuration::ConfigurationProperty ^ property, System::String ^ propertyName, System::Runtime::Versioning::FrameworkName ^ targetFramework, System::Configuration::ConfigurationElement ^ parentConfigurationElement);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool&#xA;override this.ShouldSerializePropertyInTargetVersion : System.Configuration.ConfigurationProperty * string * System.Runtime.Versioning.FrameworkName * System.Configuration.ConfigurationElement -&gt; bool" Usage="configurationSection.ShouldSerializePropertyInTargetVersion (property, propertyName, targetFramework, parentConfigurationElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.Configuration.ConfigurationProperty" />
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
        <Parameter Name="parentConfigurationElement" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="property">Objeto <see cref="T:System.Configuration.ConfigurationProperty" /> que es un candidato para la serialización.</param>
        <param name="propertyName">Nombre del objeto <see cref="T:System.Configuration.ConfigurationProperty" /> tal como aparece en XML.</param>
        <param name="targetFramework">Versión de destino de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <param name="parentConfigurationElement">Elemento primario de la propiedad.</param>
        <summary>Indica si se debe serializar la propiedad especificada cuando la jerarquía de objetos de configuración se serializa para la versión de destino especificada de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si <paramref name="property" /> debe serializarse; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada sección de configuración que se crea para el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y versiones posteriores explícitamente deben invalidar este método y devolver `true`, pero solo si la propiedad especificada es válida para la versión especificada de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Secciones de configuración existentes que se crearon para versiones anteriores de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] no debe cambiarse.  
  
 El tipo base contiene una implementación predeterminada de este método siempre devuelve `true`. Si implementa una sección de configuración y no invalida este método, de forma predeterminada, se serializarán todas las propiedades de configuración que se encuentran en la sección de configuración para todas las versiones de framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework como destino para proyectos web</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSectionInTargetVersion">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeSectionInTargetVersion (System.Runtime.Versioning.FrameworkName targetFramework);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeSectionInTargetVersion(class System.Runtime.Versioning.FrameworkName targetFramework) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationSection.ShouldSerializeSectionInTargetVersion(System.Runtime.Versioning.FrameworkName)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeSectionInTargetVersion (targetFramework As FrameworkName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeSectionInTargetVersion(System::Runtime::Versioning::FrameworkName ^ targetFramework);" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool&#xA;override this.ShouldSerializeSectionInTargetVersion : System.Runtime.Versioning.FrameworkName -&gt; bool" Usage="configurationSection.ShouldSerializeSectionInTargetVersion targetFramework" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetFramework" Type="System.Runtime.Versioning.FrameworkName" />
      </Parameters>
      <Docs>
        <param name="targetFramework">Versión de destino de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</param>
        <summary>Indica si se debe serializar la instancia actual de <see cref="T:System.Configuration.ConfigurationSection" /> cuando la jerarquía de objetos de configuración se serializa para la versión de destino especificada de [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</summary>
        <returns>
          <see langword="true" /> si debe serializarse la sección actual; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada sección de configuración que se crea para el [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y versiones posteriores explícitamente deben invalidar este método y devolver `true`, pero solo si la sección de configuración es válida para la versión especificada de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]. Secciones de configuración existentes que se crearon para versiones anteriores de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] no debe cambiarse.  
  
 El tipo base contiene una implementación predeterminada de este método siempre devuelve `true`. Si implementa una sección de configuración y no invalida este método, de forma predeterminada la sección de configuración se serializará para todas las versiones de framework.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/8b8145a9-62f6-4fc4-8a83-47b0487cbe76">.NET Framework como destino para proyectos web</related>
      </Docs>
    </Member>
  </Members>
</Type>