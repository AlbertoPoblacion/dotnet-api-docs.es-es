<Type Name="ConfigurationElementCollection" FullName="System.Configuration.ConfigurationElementCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d81c7492346fe1e7db2937ab1a133ef8b4d2742e" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53227793" /></Metadata><TypeSignature Language="C#" Value="public abstract class ConfigurationElementCollection : System.Configuration.ConfigurationElement, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ConfigurationElementCollection extends System.Configuration.ConfigurationElement implements class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationElementCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ConfigurationElementCollection&#xA;Inherits ConfigurationElement&#xA;Implements ICollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationElementCollection abstract : System::Configuration::ConfigurationElement, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type ConfigurationElementCollection = class&#xA;    inherit ConfigurationElement&#xA;    interface ICollection&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.ConfigurationElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa un elemento de configuración que contiene una colección de elementos secundarios.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection> representa una colección de elementos dentro de un archivo de configuración.  
  
> [!NOTE]
>  Un elemento dentro de un archivo de configuración hace referencia a un elemento XML básico o una sección. Un elemento simple es una etiqueta XML con atributos relacionados, si existe. Un elemento simple constituye una sección. Las secciones complejas pueden contener uno o varios elementos simples, una colección de elementos y otras secciones.  
  
 Usa el <xref:System.Configuration.ConfigurationElementCollection> para trabajar con una colección de <xref:System.Configuration.ConfigurationElement> objetos. Implemente esta clase para agregar colecciones de personalizado <xref:System.Configuration.ConfigurationElement> elementos a un <xref:System.Configuration.ConfigurationSection>.  
  
   
  
## Examples  
 El ejemplo siguiente muestra cómo usar el <xref:System.Configuration.ConfigurationElementCollection>.  
  
 El primer ejemplo consta de tres clases: `UrlsSection`, `UrlsCollection` y `UrlConfigElement`. El `UrlsSection` clase utiliza el <xref:System.Configuration.ConfigurationCollectionAttribute> para definir una sección de configuración personalizada. Esta sección contiene una colección de dirección URL (definido por el `UrlsCollection` clase) de elementos de la dirección URL (definido por el `UrlConfigElement` clase).  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#1)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#1)]  
  
 En este segundo ejemplo de código utiliza las clases que especificó antes. Combinar estos dos ejemplos en un proyecto de aplicación de consola.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#31](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/usingconfigurationcollectionelement.cs#31)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#31](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/usingconfigurationcollectionelement.vb#31)]  
  
 Al ejecutar la aplicación de consola, una instancia de la `UrlsSection` se crea la clase y se generan los siguientes elementos de configuración en el archivo de configuración de aplicación:  
  
```xml  
<configuration>  
    <configSections>  
        <section name="MyUrls" type="UrlsSection,   
          ConfigurationElementCollection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />  
    </configSections>  
    <MyUrls>  
        <urls>  
           <add name="Contoso" url="http://www.contoso.com" port="4040 />  
        </urls>  
    </MyUrls>  
</configuration  
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>Puede usar una programación o un modelo de programación declarativo (con atributos) para crear un elemento de configuración personalizado.  
  
El modelo de programación que se requiere para cada atributo del elemento que cree una propiedad para obtener y establecer su valor y agregarlo a la bolsa de propiedades interno de subyacente <see cref="T:System.Configuration.ConfigurationElement" /> clase base.  
  
El modelo declarativo, que también se denomina el modelo atributivo, le permite definir un atributo de elemento utilizando una propiedad y configurarlo con atributos. Estos atributos indican el sistema de configuración de ASP.NET acerca de los tipos de propiedad y sus valores predeterminados. ASP.NET puede usar la reflexión para obtener esta información y, a continuación, crear el elemento de objetos de propiedad y realizar la inicialización necesaria.</para></block>
    <altmember cref="T:System.Configuration.ElementInformation" />
    <altmember cref="T:System.Configuration.ConfigurationElement" />
    <altmember cref="T:System.Configuration.ConfigurationElementCollectionType" />
    <altmember cref="T:System.Configuration.ConfigurationProperty" />
    <altmember cref="T:System.Configuration.ConfigurationPropertyCollection" />
    <altmember cref="T:System.Configuration.ConfigurationSection" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationElementCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationElementCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Crear una nueva instancia de la <xref:System.Configuration.ConfigurationElementCollection> cuando la aplicación necesita para crear un personalizado <xref:System.Configuration.ConfigurationElementCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ConfigurationElementCollection (System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.#ctor(System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ConfigurationElementCollection(System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Configuration.ConfigurationElementCollection : System.Collections.IComparer -&gt; System.Configuration.ConfigurationElementCollection" Usage="new System.Configuration.ConfigurationElementCollection comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Comparador <see cref="T:System.Collections.IComparer" /> que se va a utilizar.</param>
        <summary>Crea una nueva instancia de la clase <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.IComparer> se usa para establecer un comparador que se va a usar. Por ejemplo, puede usar a un comparador de mayúsculas y minúsculas para que la clave distingue mayúsculas de minúsculas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="comparer" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddElementName">
      <MemberSignature Language="C#" Value="protected internal string AddElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AddElementName" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.AddElementName" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property AddElementName As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::String ^ AddElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AddElementName : string with get, set" Usage="System.Configuration.ConfigurationElementCollection.AddElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a asociar a la operación de adición en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> cuando se reemplaza en una clase derivada.</summary>
        <value>Nombre del elemento.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor seleccionado empieza con el prefijo reservado "config" o "lock".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BaseAdd">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Agrega un objeto <see cref="T:System.Configuration.ConfigurationElement" /> a una instancia de <see cref="T:System.Configuration.ConfigurationElementCollection" /> cuando se reemplaza en una clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Configuration.ConfigurationElementCollection.BaseAdd%2A> método para agregar un nuevo <xref:System.Configuration.ConfigurationElement> a la colección. Reemplazar en una clase derivada si se requiere un comportamiento personalizado cuando se agrega el elemento.  
  
 Al agregar, se considera que un elemento es un duplicado de otro sólo en el caso de que sus claves sean idénticas y sus valores diferentes. Los elementos que tienen idénticas claves y valores se aceptan sin notificación alguna porque los elementos no entran en conflicto. Sin embargo, no se puede agregar un elemento que tenga la misma clave que otro pero un valor diferente porque no hay una lógica para determinar cuál de los valores en conflicto debe prevalecer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="BaseAdd">
      <MemberSignature Language="C#" Value="protected virtual void BaseAdd (System.Configuration.ConfigurationElement element);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void BaseAdd(class System.Configuration.ConfigurationElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseAdd(System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub BaseAdd (element As ConfigurationElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void BaseAdd(System::Configuration::ConfigurationElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member BaseAdd : System.Configuration.ConfigurationElement -&gt; unit&#xA;override this.BaseAdd : System.Configuration.ConfigurationElement -&gt; unit" Usage="configurationElementCollection.BaseAdd element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Configuration.ConfigurationElement" /> que se va a agregar.</param>
        <summary>Agrega un elemento de configuración a la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Configuration.ConfigurationElementCollection.BaseAdd%2A> método para agregar un nuevo <xref:System.Configuration.ConfigurationElement> a la colección. Reemplazar en una clase derivada si se requiere un comportamiento personalizado cuando se agrega el elemento.  
  
 Al agregar, se considera que un elemento es un duplicado de otro sólo en el caso de que sus claves sean idénticas y sus valores diferentes. Los elementos que tienen idénticas claves y valores se aceptan sin notificación alguna porque los elementos no entran en conflicto. Sin embargo, no se puede agregar un elemento que tenga la misma clave que otro pero un valor diferente porque no hay una lógica para determinar cuál de los valores en conflicto debe prevalecer.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Configuration.ConfigurationElementCollection.BaseAdd%2A> método y cómo llamarlo desde un `Add` método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#2)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseAdd">
      <MemberSignature Language="C#" Value="protected void BaseAdd (System.Configuration.ConfigurationElement element, bool throwIfExists);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseAdd(class System.Configuration.ConfigurationElement element, bool throwIfExists) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseAdd(System.Configuration.ConfigurationElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub BaseAdd (element As ConfigurationElement, throwIfExists As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void BaseAdd(System::Configuration::ConfigurationElement ^ element, bool throwIfExists);" />
      <MemberSignature Language="F#" Value="member this.BaseAdd : System.Configuration.ConfigurationElement * bool -&gt; unit" Usage="configurationElementCollection.BaseAdd (element, throwIfExists)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
        <Parameter Name="throwIfExists" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="element"><see cref="T:System.Configuration.ConfigurationElement" /> que se va a agregar.</param>
        <param name="throwIfExists">Es <see langword="true" /> para producir una excepción si el objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado ya está incluido en el objeto <see cref="T:System.Configuration.ConfigurationElementCollection" />; de lo contrario, es <see langword="false" />.</param>
        <summary>Agrega un elemento de configuración a la colección de elementos de configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el parámetro opcional `throwIfExists` para producir una <xref:System.Exception> excepción si especificado <xref:System.Configuration.ConfigurationElement> objeto ya existe en el <xref:System.Configuration.ConfigurationElementCollection> colección.  
  
 Un elemento se considera un duplicado sólo si las claves son idénticas, pero los valores son diferentes. Los elementos que tienen idénticas claves y valores se aceptan sin notificación alguna porque los elementos no entran en conflicto. Sin embargo, no se puede agregar un elemento que tenga la misma clave que otro pero un valor diferente porque no hay una lógica para determinar cuál de los valores en conflicto debe prevalecer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">El objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se quiere agregar ya existe en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> y el parámetro <paramref name="throwIfExists" /> es <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseAdd">
      <MemberSignature Language="C#" Value="protected virtual void BaseAdd (int index, System.Configuration.ConfigurationElement element);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void BaseAdd(int32 index, class System.Configuration.ConfigurationElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseAdd(System.Int32,System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub BaseAdd (index As Integer, element As ConfigurationElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void BaseAdd(int index, System::Configuration::ConfigurationElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member BaseAdd : int * System.Configuration.ConfigurationElement -&gt; unit&#xA;override this.BaseAdd : int * System.Configuration.ConfigurationElement -&gt; unit" Usage="configurationElementCollection.BaseAdd (index, element)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="index">Ubicación del índice en el que se va a agregar el objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado.</param>
        <param name="element"><see cref="T:System.Configuration.ConfigurationElement" /> que se va a agregar.</param>
        <summary>Agrega un elemento de configuración a la colección de elementos de configuración.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la `index` parámetro va a agregar el <xref:System.Configuration.ConfigurationElement> objeto a la <xref:System.Configuration.ConfigurationElementCollection> en una ubicación de índice específico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseClear">
      <MemberSignature Language="C#" Value="protected internal void BaseClear ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void BaseClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseClear" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub BaseClear ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void BaseClear();" />
      <MemberSignature Language="F#" Value="member this.BaseClear : unit -&gt; unit" Usage="configurationElementCollection.BaseClear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los objetos de elemento de configuración de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando el <xref:System.Configuration.ConfigurationElementCollection.BaseClear%2A> se llama al método, quita todos los <xref:System.Configuration.ConfigurationElement> objetos de la colección. También se inserta un `clear` la directiva en el archivo de configuración.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Configuration.ConfigurationElementCollection.BaseClear%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">La configuración es de solo lectura.  
  
\- o - 
Un elemento de la colección se ha bloqueado en una configuración de nivel superior.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BaseGet">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Configuration.ConfigurationElement" /> en la ubicación de índice especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BaseGet">
      <MemberSignature Language="C#" Value="protected internal System.Configuration.ConfigurationElement BaseGet (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Configuration.ConfigurationElement BaseGet(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseGet(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function BaseGet (index As Integer) As ConfigurationElement" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Configuration::ConfigurationElement ^ BaseGet(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseGet : int -&gt; System.Configuration.ConfigurationElement" Usage="configurationElementCollection.BaseGet index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Ubicación de índice del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a devolver.</param>
        <summary>Obtiene el elemento de configuración en la ubicación de índice especificada.</summary>
        <returns><see cref="T:System.Configuration.ConfigurationElement" /> en el índice especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Configuration.ConfigurationElementCollection.BaseGet%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#8](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#8)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="index" /> es menor que <see langword="0" />.  
  
\- o - 
No hay ningún objeto <see cref="T:System.Configuration.ConfigurationElement" /> en el índice <paramref name="index" /> especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseGet">
      <MemberSignature Language="C#" Value="protected internal System.Configuration.ConfigurationElement BaseGet (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Configuration.ConfigurationElement BaseGet(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseGet(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function BaseGet (key As Object) As ConfigurationElement" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Configuration::ConfigurationElement ^ BaseGet(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.BaseGet : obj -&gt; System.Configuration.ConfigurationElement" Usage="configurationElementCollection.BaseGet key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a devolver.</param>
        <summary>Devuelve el elemento de configuración con la clave especificada.</summary>
        <returns>Objeto <see cref="T:System.Configuration.ConfigurationElement" /> con la clave especificada; en caso contrario, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.BaseGet%2A> devuelve del método `null` si no hay ningún <xref:System.Configuration.ConfigurationElement> objeto con la clave especificada en la colección.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Configuration.ConfigurationElementCollection.BaseGet%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#9](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#9)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseGetAllKeys">
      <MemberSignature Language="C#" Value="protected internal object[] BaseGetAllKeys ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance object[] BaseGetAllKeys() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseGetAllKeys" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function BaseGetAllKeys () As Object()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Object ^&gt; ^ BaseGetAllKeys();" />
      <MemberSignature Language="F#" Value="member this.BaseGetAllKeys : unit -&gt; obj[]" Usage="configurationElementCollection.BaseGetAllKeys " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una matriz de claves para todos los elementos de configuración incluidos en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns>Una matriz que contiene las claves para todos los objetos <see cref="T:System.Configuration.ConfigurationElement" /> incluidos en <see cref="T:System.Configuration.ConfigurationElementCollection" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseGetKey">
      <MemberSignature Language="C#" Value="protected internal object BaseGetKey (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance object BaseGetKey(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseGetKey(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function BaseGetKey (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Object ^ BaseGetKey(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseGetKey : int -&gt; obj" Usage="configurationElementCollection.BaseGetKey index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Ubicación de índice para el objeto <see cref="T:System.Configuration.ConfigurationElement" />.</param>
        <summary>Obtiene la clave para el objeto <see cref="T:System.Configuration.ConfigurationElement" /> en la ubicación de índice especificada.</summary>
        <returns>Clave para el objeto  <see cref="T:System.Configuration.ConfigurationElement" /> especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="index" /> es menor que <see langword="0" />.  
  
\- o - 
No hay ningún objeto <see cref="T:System.Configuration.ConfigurationElement" /> en el índice <paramref name="index" /> especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseIndexOf">
      <MemberSignature Language="C#" Value="protected int BaseIndexOf (System.Configuration.ConfigurationElement element);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int32 BaseIndexOf(class System.Configuration.ConfigurationElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseIndexOf(System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Function BaseIndexOf (element As ConfigurationElement) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; int BaseIndexOf(System::Configuration::ConfigurationElement ^ element);" />
      <MemberSignature Language="F#" Value="member this.BaseIndexOf : System.Configuration.ConfigurationElement -&gt; int" Usage="configurationElementCollection.BaseIndexOf element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> para la ubicación de índice especificada.</param>
        <summary>Indica el índice del objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado.</summary>
        <returns>Índice del objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado; de lo contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Configuration.ConfigurationElementCollection.BaseIndexOf%2A> método.  
  
 [!code-vb[System.Configuration.ConfigurationElementCollection#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseIsRemoved">
      <MemberSignature Language="C#" Value="protected internal bool BaseIsRemoved (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance bool BaseIsRemoved(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseIsRemoved(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function BaseIsRemoved (key As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; bool BaseIsRemoved(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.BaseIsRemoved : obj -&gt; bool" Usage="configurationElementCollection.BaseIsRemoved key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a comprobar.</param>
        <summary>Indica si el objeto <see cref="T:System.Configuration.ConfigurationElement" /> con la clave especificada se ha quitado de la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns><see langword="true" /> si se ha quitado el objeto <see cref="T:System.Configuration.ConfigurationElement" /> con la clave especificada; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseRemove">
      <MemberSignature Language="C#" Value="protected internal void BaseRemove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void BaseRemove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseRemove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub BaseRemove (key As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void BaseRemove(System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.BaseRemove : obj -&gt; unit" Usage="configurationElementCollection.BaseRemove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Clave del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a quitar.</param>
        <summary>Quita un objeto <see cref="T:System.Configuration.ConfigurationElement" /> de la colección.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.BaseRemove%2A> método inserta un `<remove>` la directiva en el archivo de configuración para el <xref:System.Configuration.ConfigurationElement> con la clave especificada.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo llamar a la <xref:System.Configuration.ConfigurationElementCollection.BaseRemove%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#3](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#3)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">En la colección no existe un objeto <see cref="T:System.Configuration.ConfigurationElement" /> con la clave especificada, el elemento ya se ha quitado o no se puede quitar porque el valor de su propiedad <see cref="P:System.Configuration.ConfigurationProperty.Type" /> no es <see cref="F:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMap" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseRemoveAt">
      <MemberSignature Language="C#" Value="protected internal void BaseRemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void BaseRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.BaseRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub BaseRemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void BaseRemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.BaseRemoveAt : int -&gt; unit" Usage="configurationElementCollection.BaseRemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Ubicación de índice del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a quitar.</param>
        <summary>Quita el objeto <see cref="T:System.Configuration.ConfigurationElement" /> en la ubicación de índice especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.BaseRemoveAt%2A> método inserta un `<remove>` la directiva en el archivo de configuración para el elemento en el índice especificado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">La configuración es de solo lectura.  
  
\- o - 
 <paramref name="index" /> es menor que <see langword="0" /> o mayor que el número de objetos <see cref="T:System.Configuration.ConfigurationElement" /> de la colección.  
  
\- o - 
El objeto <see cref="T:System.Configuration.ConfigurationElement" /> ya se ha quitado.  
  
\- o - 
El valor del objeto <see cref="T:System.Configuration.ConfigurationElement" /> se ha bloqueado en un nivel superior.  
  
\- o - 
El objeto <see cref="T:System.Configuration.ConfigurationElement" /> se ha heredado.  
  
\- o - 
El valor de la propiedad <see cref="T:System.Configuration.ConfigurationElement" /> del objeto <see cref="P:System.Configuration.ConfigurationProperty.Type" /> no es <see cref="F:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMap" /> ni <see cref="F:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMapAlternate" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearElementName">
      <MemberSignature Language="C#" Value="protected internal string ClearElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClearElementName" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.ClearElementName" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property ClearElementName As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::String ^ ClearElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ClearElementName : string with get, set" Usage="System.Configuration.ConfigurationElementCollection.ClearElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a asociar a la operación de borrado en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> cuando se reemplaza en una clase derivada.</summary>
        <value>Nombre del elemento.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor seleccionado empieza con el prefijo reservado "config" o "lock".</exception>
      </Docs>
    </Member>
    <Member MemberName="CollectionType">
      <MemberSignature Language="C#" Value="public virtual System.Configuration.ConfigurationElementCollectionType CollectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Configuration.ConfigurationElementCollectionType CollectionType" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.CollectionType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CollectionType As ConfigurationElementCollectionType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Configuration::ConfigurationElementCollectionType CollectionType { System::Configuration::ConfigurationElementCollectionType get(); };" />
      <MemberSignature Language="F#" Value="member this.CollectionType : System.Configuration.ConfigurationElementCollectionType" Usage="System.Configuration.ConfigurationElementCollection.CollectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationElementCollectionType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <value>Enumerador <see cref="T:System.Configuration.ConfigurationElementCollectionType" /> de esta colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El tipo será un <xref:System.Configuration.ConfigurationElementCollectionType.BasicMap> o un <xref:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMap> campo. Para obtener más información, vea <xref:System.Configuration.ConfigurationElementCollectionType>.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra cómo obtener el <xref:System.Configuration.ConfigurationElementCollection.CollectionType%2A> propiedad.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#5](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#5)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Configuration.ConfigurationElement[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Configuration.ConfigurationElement[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.CopyTo(System.Configuration.ConfigurationElement[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As ConfigurationElement(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;System::Configuration::ConfigurationElement ^&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Configuration.ConfigurationElement[] * int -&gt; unit" Usage="configurationElementCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Configuration.ConfigurationElement[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Matriz en la que se va a copiar el contenido de la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</param>
        <param name="index">Ubicación de índice en la que se va a empezar a copiar.</param>
        <summary>Copia el contenido de la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> en una matriz.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Configuration.ConfigurationElementCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos de la colección.</summary>
        <value>Número de elementos de la colección.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateNewElement">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, se crea un nuevo objeto <see cref="T:System.Configuration.ConfigurationElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> método para crear personalizado <xref:System.Configuration.ConfigurationElement> objetos de un tipo específico. Cuando se carga una colección desde el archivo de configuración <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se llama para crear los elementos individuales. <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se debe invalidar en clases que derivan de la <xref:System.Configuration.ConfigurationElementCollection> clase.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateNewElement">
      <MemberSignature Language="C#" Value="protected abstract System.Configuration.ConfigurationElement CreateNewElement ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Configuration.ConfigurationElement CreateNewElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.CreateNewElement" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateNewElement () As ConfigurationElement" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Configuration::ConfigurationElement ^ CreateNewElement();" />
      <MemberSignature Language="F#" Value="abstract member CreateNewElement : unit -&gt; System.Configuration.ConfigurationElement" Usage="configurationElementCollection.CreateNewElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cuando se reemplaza en una clase derivada, se crea un nuevo objeto <see cref="T:System.Configuration.ConfigurationElement" />.</summary>
        <returns>Una celda <see cref="T:System.Configuration.ConfigurationElement" /> recién creada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> método para crear personalizado <xref:System.Configuration.ConfigurationElement> objetos de un tipo específico. Cuando se carga una colección desde el archivo de configuración <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se llama para crear los elementos individuales. <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se debe invalidar en clases que derivan de la <xref:System.Configuration.ConfigurationElementCollection> clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar el <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#6)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNewElement">
      <MemberSignature Language="C#" Value="protected virtual System.Configuration.ConfigurationElement CreateNewElement (string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Configuration.ConfigurationElement CreateNewElement(string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.CreateNewElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateNewElement (elementName As String) As ConfigurationElement" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Configuration::ConfigurationElement ^ CreateNewElement(System::String ^ elementName);" />
      <MemberSignature Language="F#" Value="abstract member CreateNewElement : string -&gt; System.Configuration.ConfigurationElement&#xA;override this.CreateNewElement : string -&gt; System.Configuration.ConfigurationElement" Usage="configurationElementCollection.CreateNewElement elementName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConfigurationElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementName">Nombre del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a crear.</param>
        <summary>Crea un nuevo objeto <see cref="T:System.Configuration.ConfigurationElement" /> cuando se reemplaza en una clase derivada.</summary>
        <returns>Un nuevo <see cref="T:System.Configuration.ConfigurationElement" /> con un nombre especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> método para crear personalizado <xref:System.Configuration.ConfigurationElement> objetos de un tipo específico. Cuando se carga una colección desde el archivo de configuración <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se llama para crear los elementos individuales. <xref:System.Configuration.ConfigurationElementCollection.CreateNewElement%2A> se debe invalidar en clases que derivan de la <xref:System.Configuration.ConfigurationElementCollection> clase.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si creas un personalizado <see cref="T:System.Configuration.ConfigurationElementCollection" /> colección que contiene heterogéneos <see cref="T:System.Configuration.ConfigurationElement" /> tipos, debe realizar estos pasos: 
-Invalidar la <see cref="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" /> método.  
  
-Asegúrese de que el <see cref="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" /> método devuelve una cadena que identifica el tipo del elemento que se creó mediante una llamada a la <see cref="M:System.Configuration.ConfigurationElementCollection.CreateNewElement(System.String)" /> método.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ElementName">
      <MemberSignature Language="C#" Value="protected virtual string ElementName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ElementName" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.ElementName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ElementName As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::String ^ ElementName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ElementName : string" Usage="System.Configuration.ConfigurationElementCollection.ElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre que se utiliza para identificar esta colección de elementos en el archivo de configuración cuando se reemplaza en una clase derivada.</summary>
        <value>Nombre de la colección; de lo contrario, una cadena vacía. El valor predeterminado es una cadena vacía.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Configuration.ConfigurationElementCollection.ElementName%2A> propiedad un nombre personalizado <xref:System.Configuration.ConfigurationElementCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EmitClear">
      <MemberSignature Language="C#" Value="public bool EmitClear { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EmitClear" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.EmitClear" />
      <MemberSignature Language="VB.NET" Value="Public Property EmitClear As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EmitClear { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EmitClear : bool with get, set" Usage="System.Configuration.ConfigurationElementCollection.EmitClear" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece un valor que especifica si se ha borrado la colección.</summary>
        <value><see langword="true" /> si la colección se ha borrado; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Establecer el <xref:System.Configuration.ConfigurationElementCollection.EmitClear%2A> propiedad `true` hace que un `<clear>` directiva se escriban en el archivo de configuración cuando se serializa la colección.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">La configuración es de solo lectura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object compareTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object compareTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (compareTo As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ compareTo);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="configurationElementCollection.Equals compareTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compareTo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="compareTo">Objeto que se va a comparar.</param>
        <summary>Compara la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> con el objeto especificado.</summary>
        <returns><see langword="true" /> si el objeto con el que se compara es igual a la instancia actual de <see cref="T:System.Configuration.ConfigurationElementCollection" />; de lo contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementKey">
      <MemberSignature Language="C#" Value="protected abstract object GetElementKey (System.Configuration.ConfigurationElement element);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object GetElementKey(class System.Configuration.ConfigurationElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetElementKey (element As ConfigurationElement) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Object ^ GetElementKey(System::Configuration::ConfigurationElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member GetElementKey : System.Configuration.ConfigurationElement -&gt; obj" Usage="configurationElementCollection.GetElementKey element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="element">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> para el que se va a devolver la clave.</param>
        <summary>Cuando se reemplaza en una clase derivada, obtiene la clave de elemento para un elemento de configuración especificado.</summary>
        <returns><see cref="T:System.Object" /> que actúa como clave para el objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar <xref:System.Configuration.ConfigurationElementCollection.GetElementKey%2A> método.  
  
 [!code-csharp[System.Configuration.ConfigurationElementCollection#7](~/samples/snippets/csharp/VS_Snippets_WebNet/system.configuration.configurationelementcollection/cs/customcollectionsection.cs#7)]
 [!code-vb[System.Configuration.ConfigurationElementCollection#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/system.configuration.configurationelementcollection/vb/customcollectionsection.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="configurationElementCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene una interfaz <see cref="T:System.Collections.IEnumerator" /> que se utiliza para recorrer en iteración la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> que se utiliza para recorrer en iteración la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="configurationElementCollection.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor único que representa la instancia de <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns>Un valor único que representa la instancia actual de <see cref="T:System.Configuration.ConfigurationElementCollection" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsElementName">
      <MemberSignature Language="C#" Value="protected virtual bool IsElementName (string elementName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsElementName(string elementName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.IsElementName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsElementName (elementName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsElementName(System::String ^ elementName);" />
      <MemberSignature Language="F#" Value="abstract member IsElementName : string -&gt; bool&#xA;override this.IsElementName : string -&gt; bool" Usage="configurationElementCollection.IsElementName elementName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementName">Nombre del elemento que se va a comprobar.</param>
        <summary>Indica si el objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado existe en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns><see langword="true" /> si el elemento está en la colección; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Configuration.ConfigurationElementCollection.IsElementName%2A> método para proporcionar un comportamiento personalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsElementRemovable">
      <MemberSignature Language="C#" Value="protected virtual bool IsElementRemovable (System.Configuration.ConfigurationElement element);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsElementRemovable(class System.Configuration.ConfigurationElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.IsElementRemovable(System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsElementRemovable (element As ConfigurationElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsElementRemovable(System::Configuration::ConfigurationElement ^ element);" />
      <MemberSignature Language="F#" Value="abstract member IsElementRemovable : System.Configuration.ConfigurationElement -&gt; bool&#xA;override this.IsElementRemovable : System.Configuration.ConfigurationElement -&gt; bool" Usage="configurationElementCollection.IsElementRemovable element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="element">Elemento que se va a comprobar.</param>
        <summary>Indica si la <see cref="T:System.Configuration.ConfigurationElement" /> se puede quitar de <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <returns><see langword="true" /> si el objeto <see cref="T:System.Configuration.ConfigurationElement" /> especificado se puede quitar de esta colección <see cref="T:System.Configuration.ConfigurationElementCollection" />; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulta <xref:System.Configuration.ConfigurationElementCollection.IsElementRemovable%2A> antes de quitar un elemento de la colección.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsModified">
      <MemberSignature Language="C#" Value="protected internal override bool IsModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool IsModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.IsModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function IsModified () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool IsModified();" />
      <MemberSignature Language="F#" Value="override this.IsModified : unit -&gt; bool" Usage="configurationElementCollection.IsModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si se ha modificado esta colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> desde la última vez en que se guardo o cargó al reemplazarla en una clase derivada.</summary>
        <returns><see langword="true" /> si se ha modificado alguno de los elementos incluidos; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Configuration.ConfigurationElement.IsModified%2A> método de cualquier <xref:System.Configuration.ConfigurationElement> dentro de un <xref:System.Configuration.ConfigurationElementCollection> devuelve `true`, el <xref:System.Configuration.ConfigurationElementCollection.IsModified%2A> devuelve el método de la colección completa `true` también.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsReadOnly();" />
      <MemberSignature Language="F#" Value="override this.IsReadOnly : unit -&gt; bool" Usage="configurationElementCollection.IsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica si la el objeto <see cref="T:System.Configuration.ConfigurationElementCollection" /> es de solo lectura.</summary>
        <returns><see langword="true" /> si la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> es de sólo lectura; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El sistema define los elementos de configuración que no se puede modificar. Llame a este método para determinar si los elementos se pueden modificar.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Configuration.ConfigurationElementCollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la colección está sincronizado.</summary>
        <value><see langword="true" /> si el acceso a la interfaz <see cref="T:System.Configuration.ConfigurationElementCollection" /> está sincronizado; de lo contrario, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializeUnrecognizedElement">
      <MemberSignature Language="C#" Value="protected override bool OnDeserializeUnrecognizedElement (string elementName, System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool OnDeserializeUnrecognizedElement(string elementName, class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.OnDeserializeUnrecognizedElement(System.String,System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnDeserializeUnrecognizedElement (elementName As String, reader As XmlReader) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool OnDeserializeUnrecognizedElement(System::String ^ elementName, System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="override this.OnDeserializeUnrecognizedElement : string * System.Xml.XmlReader -&gt; bool" Usage="configurationElementCollection.OnDeserializeUnrecognizedElement (elementName, reader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementName" Type="System.String" />
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="elementName">Nombre del elemento no reconocido.</param>
        <param name="reader">Flujo de entrada que lee XML del archivo de configuración.</param>
        <summary>Hace que el sistema de configuración produzca una excepción.</summary>
        <returns><see langword="true" /> si se ha deserializado correctamente el elemento no reconocido; en caso contrario, <see langword="false" />. De manera predeterminada, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.OnDeserializeUnrecognizedElement%2A> se llama cuando se lee un elemento de configuración no reconocidos desde un archivo de configuración.  
  
 Invalide este método para proporcionar un control personalizado de elementos de configuración no reconocidos desde un archivo de configuración. El valor predeterminado devuelve el valor, `false`, hace que el sistema de configuración produzca una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">El elemento especificado en <paramref name="elementName" /> es el elemento <see langword="&lt;clear&gt;" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementName" /> empieza con el prefijo reservado "config" o "lock".</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveElementName">
      <MemberSignature Language="C#" Value="protected internal string RemoveElementName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RemoveElementName" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.RemoveElementName" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property RemoveElementName As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::String ^ RemoveElementName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RemoveElementName : string with get, set" Usage="System.Configuration.ConfigurationElementCollection.RemoveElementName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el nombre del objeto <see cref="T:System.Configuration.ConfigurationElement" /> que se va a asociar a la operación de eliminación en la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> cuando se reemplaza en una clase derivada.</summary>
        <value>Nombre del elemento.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">El valor seleccionado empieza con el prefijo reservado "config" o "lock".</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="protected internal override void Reset (System.Configuration.ConfigurationElement parentElement);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Reset(class System.Configuration.ConfigurationElement parentElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.Reset(System.Configuration.ConfigurationElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Reset (parentElement As ConfigurationElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Reset(System::Configuration::ConfigurationElement ^ parentElement);" />
      <MemberSignature Language="F#" Value="override this.Reset : System.Configuration.ConfigurationElement -&gt; unit" Usage="configurationElementCollection.Reset parentElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" />
      </Parameters>
      <Docs>
        <param name="parentElement">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> que representa el elemento principal de colección, si existe; de lo contrario, <see langword="null" />.</param>
        <summary>Restablece la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> a su estado sin modificaciones cuando se reemplaza en una clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El comportamiento predeterminado para el <xref:System.Configuration.ConfigurationElementCollection.Reset%2A> método consiste en borrar cualquier elemento modificado una <xref:System.Configuration.ConfigurationElementCollection> contiene el objeto y establecer los elementos modificados en los valores especificados por su archivo de configuración principal. Si algún elemento de la <xref:System.Configuration.ConfigurationElementCollection> tiene elementos secundarios, <xref:System.Configuration.ConfigurationElementCollection.Reset%2A> también se denomina tales elementos secundarios.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetModified">
      <MemberSignature Language="C#" Value="protected internal override void ResetModified ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void ResetModified() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.ResetModified" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub ResetModified ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void ResetModified();" />
      <MemberSignature Language="F#" Value="override this.ResetModified : unit -&gt; unit" Usage="configurationElementCollection.ResetModified " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restablece el valor de la propiedad <see cref="M:System.Configuration.ConfigurationElementCollection.IsModified" /> en <see langword="false" /> cuando se invalida en una clase derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.ResetModified%2A> método determina si los elementos de esta colección se escribirán en el archivo de configuración cuando se actualiza la configuración.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializeElement">
      <MemberSignature Language="C#" Value="protected internal override bool SerializeElement (System.Xml.XmlWriter writer, bool serializeCollectionKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool SerializeElement(class System.Xml.XmlWriter writer, bool serializeCollectionKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.SerializeElement(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SerializeElement (writer As XmlWriter, serializeCollectionKey As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool SerializeElement(System::Xml::XmlWriter ^ writer, bool serializeCollectionKey);" />
      <MemberSignature Language="F#" Value="override this.SerializeElement : System.Xml.XmlWriter * bool -&gt; bool" Usage="configurationElementCollection.SerializeElement (writer, serializeCollectionKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="serializeCollectionKey" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">Flujo de salida que escribe código XML en el archivo de configuración.</param>
        <param name="serializeCollectionKey">Es <see langword="true" /> para serializar la clave de la colección; de lo contrario, es <see langword="false" />.</param>
        <summary>Escribe los datos de configuración en un elemento XML del archivo de configuración cuando se reemplaza en una clase derivada.</summary>
        <returns><see langword="true" /> si se ha escrito correctamente la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> en el archivo de configuración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Configuration.ConfigurationElementCollection.SerializeElement%2A> método escribe el contenido de los elementos de configuración contenidos en la colección y los elementos anidados que contienen en el archivo de configuración. Invalidar <xref:System.Configuration.ConfigurationElementCollection.SerializeElement%2A> para proporcionar una personalizada escribir procedimiento fuera del contenido de la colección y los elementos anidados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se ha agregado o reemplazado uno de los elementos de la colección y empieza con el prefijo reservado "config" o "lock".</exception>
      </Docs>
    </Member>
    <Member MemberName="SetReadOnly">
      <MemberSignature Language="C#" Value="protected internal override void SetReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void SetReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.SetReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub SetReadOnly ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void SetReadOnly();" />
      <MemberSignature Language="F#" Value="override this.SetReadOnly : unit -&gt; unit" Usage="configurationElementCollection.SetReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Establece la propiedad <see cref="M:System.Configuration.ConfigurationElementCollection.IsReadOnly" /> para el objeto <see cref="T:System.Configuration.ConfigurationElementCollection" /> y para todos los subelementos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa internamente para separar los elementos de configuración del sistema que no se puede modificar. Para determinar qué elementos son modificables, llame a la <xref:System.Configuration.ConfigurationElementCollection.IsReadOnly%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Configuration.ConfigurationElementCollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se utiliza para sincronizar el acceso a la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</summary>
        <value>Objeto que se utiliza para sincronizar el acceso a la colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (arr As Array, index As Integer) Implements ICollection.CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ arr, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Matriz en la que se va a copiar esta colección <see cref="T:System.Configuration.ConfigurationElementCollection" />.</param>
        <param name="index">Ubicación de índice en la que se va a empezar a copiar.</param>
        <summary>Copia la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> en una matriz.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowOnDuplicate">
      <MemberSignature Language="C#" Value="protected virtual bool ThrowOnDuplicate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThrowOnDuplicate" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationElementCollection.ThrowOnDuplicate" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ThrowOnDuplicate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ThrowOnDuplicate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ThrowOnDuplicate : bool" Usage="System.Configuration.ConfigurationElementCollection.ThrowOnDuplicate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el intento de agregar un objeto <see cref="T:System.Configuration.ConfigurationElement" /> duplicado a la colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> va a hacer que se produzca una excepción.</summary>
        <value><see langword="true" /> si el intento de agregar un objeto <see cref="T:System.Configuration.ConfigurationElement" /> duplicado a esta colección <see cref="T:System.Configuration.ConfigurationElementCollection" /> va a hacer que se produzca una excepción; de lo contrario, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando se agrega un elemento duplicado, se produce una excepción si el <xref:System.Configuration.ConfigurationElementCollection.CollectionType%2A> trata de un valor del elemento <xref:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMap> o <xref:System.Configuration.ConfigurationElementCollectionType.AddRemoveClearMapAlternate>.  
  
 Tenga en cuenta que los elementos que tienen idénticas claves y valores no se consideran duplicados y se aceptan sin notificación alguna. Sólo los elementos con claves idénticas pero valores diferentes se consideran duplicadas. Para obtener más información, vea la sección Comentarios para el <xref:System.Configuration.ConfigurationElementCollection.BaseAdd%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unmerge">
      <MemberSignature Language="C#" Value="protected internal override void Unmerge (System.Configuration.ConfigurationElement sourceElement, System.Configuration.ConfigurationElement parentElement, System.Configuration.ConfigurationSaveMode saveMode);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Unmerge(class System.Configuration.ConfigurationElement sourceElement, class System.Configuration.ConfigurationElement parentElement, valuetype System.Configuration.ConfigurationSaveMode saveMode) cil managed" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.Unmerge(System.Configuration.ConfigurationElement,System.Configuration.ConfigurationElement,System.Configuration.ConfigurationSaveMode)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Unmerge (sourceElement As ConfigurationElement, parentElement As ConfigurationElement, saveMode As ConfigurationSaveMode)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Unmerge(System::Configuration::ConfigurationElement ^ sourceElement, System::Configuration::ConfigurationElement ^ parentElement, System::Configuration::ConfigurationSaveMode saveMode);" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="override this.Unmerge : System.Configuration.ConfigurationElement * System.Configuration.ConfigurationElement * System.Configuration.ConfigurationSaveMode -&gt; unit" Usage="configurationElementCollection.Unmerge (sourceElement, parentElement, saveMode)" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="protected internal override void Unmerge (System.Configuration.ConfigurationElement sourceElement, System.Configuration.ConfigurationElement parentElement, System.Configuration.ConfigurationSaveMode updateMode);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Unmerge(class System.Configuration.ConfigurationElement sourceElement, class System.Configuration.ConfigurationElement parentElement, valuetype System.Configuration.ConfigurationSaveMode updateMode) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationElementCollection.Unmerge(System.Configuration.ConfigurationElement,System.Configuration.ConfigurationElement,System.Configuration.ConfigurationSaveMode)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Unmerge (sourceElement As ConfigurationElement, parentElement As ConfigurationElement, updateMode As ConfigurationSaveMode)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Unmerge(System::Configuration::ConfigurationElement ^ sourceElement, System::Configuration::ConfigurationElement ^ parentElement, System::Configuration::ConfigurationSaveMode updateMode);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.Unmerge : System.Configuration.ConfigurationElement * System.Configuration.ConfigurationElement * System.Configuration.ConfigurationSaveMode -&gt; unit" Usage="configurationElementCollection.Unmerge (sourceElement, parentElement, updateMode)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceElement" Type="System.Configuration.ConfigurationElement" Index="0" />
        <Parameter Name="parentElement" Type="System.Configuration.ConfigurationElement" Index="1" />
        <Parameter Name="saveMode" Type="System.Configuration.ConfigurationSaveMode" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="updateMode" Type="System.Configuration.ConfigurationSaveMode" Index="2" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceElement">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> en el nivel actual que contiene una vista combinada de las propiedades.</param>
        <param name="parentElement">Objeto <see cref="T:System.Configuration.ConfigurationElement" /> primario del elemento actual o <see langword="null" /> si es el nivel superior.</param>
        <param name="saveMode">Valor enumerado de <see cref="T:System.Configuration.ConfigurationSaveMode" /> que determina los valores de propiedad que se van a incluir.</param>
        <param name="updateMode">Valor enumerado de <see cref="T:System.Configuration.ConfigurationSaveMode" /> que determina los valores de propiedad que se van a incluir.</param>
        <summary>Invierte el efecto de combinar la información de configuración de distintos niveles de la jerarquía de configuración.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>