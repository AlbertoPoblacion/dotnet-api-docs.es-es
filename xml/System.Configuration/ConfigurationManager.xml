<Type Name="ConfigurationManager" FullName="System.Configuration.ConfigurationManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f2a6f055313bcbb7b7073b38f3f15a2fb903869" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36697466" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class ConfigurationManager" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ConfigurationManager extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ConfigurationManager" />
  <TypeSignature Language="VB.NET" Value="Public Class ConfigurationManager" />
  <TypeSignature Language="C++ CLI" Value="public ref class ConfigurationManager abstract sealed" />
  <TypeSignature Language="F#" Value="type ConfigurationManager = class" />
  <AssemblyInfo>
    <AssemblyName>System.Configuration</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Proporciona acceso a los archivos de configuración para las aplicaciones cliente. Esta clase no puede heredarse.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Configuration.ConfigurationManager> clase le permite al equipo de acceso, la aplicación y la información de configuración de usuario. Esta clase reemplaza el <xref:System.Configuration.ConfigurationSettings> (clase), que está en desuso. Para aplicaciones web, use la <xref:System.Web.Configuration.WebConfigurationManager> clase.  
  
 Para usar el <xref:System.Configuration.ConfigurationManager> (clase), el proyecto debe hacer referencia a la `System.Configuration` ensamblado. De forma predeterminada, algunas plantillas de proyecto, como aplicación de consola, haga referencia este ensamblado para debe consultarla manualmente.  
  
> [!NOTE]
>  El nombre y la ubicación del archivo de configuración de aplicación dependen del host de la aplicación. Para obtener más información, consulte [NIB: archivos de configuración de aplicación](http://msdn.microsoft.com/library/0d05b1b8-b18b-43d8-bb3c-526ff0c44fe0).  
  
 Puede usar las operaciones <xref:System.Configuration> tipos o derivan de ellos para controlar la información de configuración. Mediante el uso de estos tipos, puede trabajar directamente con la información de configuración y ampliar los archivos de configuración para incluir información personalizada.  
  
 La <xref:System.Configuration.ConfigurationManager> clase incluye miembros que permiten realizar las siguientes tareas:  
  
-   Leer una sección de un archivo de configuración. Para obtener acceso a información de configuración, llame a la <xref:System.Configuration.ConfigurationManager.GetSection%2A> método. Para algunas secciones como `appSettings` y `connectionStrings`, use la <xref:System.Configuration.ConfigurationManager.AppSettings%2A> y <xref:System.Configuration.ConfigurationManager.ConnectionStrings%2A> clases. Estos miembros realizan operaciones de sólo lectura, use una única instancia almacenada en caché de la configuración y están multiproceso en cuenta.  
  
-   Leer y escribir archivos de configuración como un todo. La aplicación puede leer y escribir valores de configuración en cualquier nivel, para sí mismo o para otras aplicaciones o equipos, de forma local o remota. Utilice uno de los métodos proporcionados por el <xref:System.Configuration.ConfigurationManager> clase para abrir un archivo de configuración como SampleApp.exe.config. Estos métodos devuelven un <xref:System.Configuration.Configuration> objeto que a su vez expone métodos y propiedades que puede utilizar para trabajar con los archivos de configuración asociada. Los métodos de operaciones de lectura o las operaciones de escritura y crear los datos de configuración cada vez que se escribe un archivo.  
  
-   Admite tareas de configuración. Los tipos siguientes se utilizan para admitir varias tareas de configuración:  
  
    -   <xref:System.Configuration.SectionInformation>  
  
    -   <xref:System.Configuration.PropertyInformation>  
  
    -   <xref:System.Configuration.PropertyInformationCollection>  
  
    -   <xref:System.Configuration.ElementInformation>  
  
    -   <xref:System.Configuration.ContextInformation>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroup>  
  
    -   <xref:System.Configuration.ConfigurationSectionGroupCollection>  
  
     Además de trabajar con la información de configuración existente, puede crear y trabajar con elementos de configuración personalizados mediante la extensión de los tipos de configuración integrados como la <xref:System.Configuration.ConfigurationElement>, <xref:System.Configuration.ConfigurationElementCollection>, <xref:System.Configuration.ConfigurationProperty>, y <xref:System.Configuration.ConfigurationSection> clases. Para obtener un ejemplo de cómo extender un tipo de configuración integrada mediante programación, vea <xref:System.Configuration.ConfigurationSection>. Para obtener un ejemplo de cómo extender un tipo de configuración integrada que utiliza el modelo basado en atributos, vea <xref:System.Configuration.ConfigurationElement>.  
  
   
  
## Examples  
 El primer ejemplo muestra una aplicación de consola simple que lee la configuración de la aplicación, agrega una nueva configuración y actualiza una configuración existente.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 El ejemplo anterior se supone que el proyecto tiene un archivo App.config, tal y como se muestra a continuación.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 En el ejemplo siguiente se muestra cómo utilizar una cadena de conexión para leer datos de una base de datos.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 El ejemplo anterior se supone que el proyecto tiene un archivo App.config, tal y como se muestra a continuación.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>La <see cref="T:System.Configuration.Configuration" /> clase permite el acceso mediante programación para editar archivos de configuración. Utilice uno de los métodos abiertos proporcionados por <see cref="T:System.Configuration.ConfigurationManager" />. Estos métodos devuelven un <see cref="T:System.Configuration.Configuration" /> objeto, lo que a su vez proporciona los métodos y propiedades necesarios para controlar los archivos de configuración subyacentes. Puede tener acceso a estos archivos para leer o escribir.  Para leer los archivos de configuración, utilice <see cref="M:System.Configuration.Configuration.GetSection(System.String)" /> o <see cref="M:System.Configuration.Configuration.GetSectionGroup(System.String)" /> para leer información de configuración. El usuario o proceso que lee debe tener los permisos siguientes:-permiso de lectura en el archivo de configuración en el nivel de jerarquía de configuración actual.  -Permisos de lectura en todas las principales de los archivos de configuración.  Si la aplicación necesita acceso de sólo lectura a su propia configuración, se recomienda que realice la <see cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" /> método. Este método proporciona acceso a los valores de configuración en caché para la aplicación actual, que tiene un rendimiento mejor que la <see cref="T:System.Configuration.Configuration" /> clase.  Para escribir en los archivos de configuración, utilice uno de los <see cref="Overload:System.Configuration.Configuration.Save" /> métodos. El usuario o proceso que escribe debe tener los permisos siguientes:-permiso de escritura en el archivo de configuración y el directorio en el nivel de jerarquía de configuración actual.  -Permisos de lectura en todos los archivos de configuración.</para>
    </block>
    <altmember cref="T:System.Configuration.Configuration" />
    <altmember cref="T:System.Web.Configuration.WebConfigurationManager" />
  </Docs>
  <Members>
    <Member MemberName="AppSettings">
      <MemberSignature Language="C#" Value="public static System.Collections.Specialized.NameValueCollection AppSettings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Specialized.NameValueCollection AppSettings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.AppSettings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AppSettings As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Specialized::NameValueCollection ^ AppSettings { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AppSettings : System.Collections.Specialized.NameValueCollection" Usage="System.Configuration.ConfigurationManager.AppSettings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los datos <see cref="T:System.Configuration.AppSettingsSection" /> para la configuración predeterminada de la aplicación actual.</summary>
        <value>Devuelve un objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> que incluye el contenido del objeto <see cref="T:System.Configuration.AppSettingsSection" /> para la configuración predeterminada de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Configuration.AppSettingsSection> objeto contiene el contenido del archivo de configuración `appSettings` sección.  
  
   
  
## Examples  
 El primer ejemplo muestra una aplicación de consola simple que lee la configuración de la aplicación, agrega una nueva configuración y actualiza una configuración existente.  
  
```csharp  
using System;  
using System.Configuration;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadAllSettings();  
            ReadSetting("Setting1");  
            ReadSetting("NotValid");  
            AddUpdateAppSettings("NewSetting", "May 7, 2014");  
            AddUpdateAppSettings("Setting1", "May 8, 2014");  
            ReadAllSettings();  
        }  
  
        static void ReadAllSettings()  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
  
                if (appSettings.Count == 0)  
                {  
                    Console.WriteLine("AppSettings is empty.");  
                }  
                else  
                {  
                    foreach (var key in appSettings.AllKeys)  
                    {  
                        Console.WriteLine("Key: {0} Value: {1}", key, appSettings[key]);  
                    }  
                }  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void ReadSetting(string key)  
        {  
            try  
            {  
                var appSettings = ConfigurationManager.AppSettings;  
                string result = appSettings[key] ?? "Not Found";  
                Console.WriteLine(result);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error reading app settings");  
            }  
        }  
  
        static void AddUpdateAppSettings(string key, string value)  
        {  
            try  
            {  
                var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);  
                var settings = configFile.AppSettings.Settings;  
                if (settings[key] == null)  
                {  
                    settings.Add(key, value);  
                }  
                else  
                {  
                    settings[key].Value = value;  
                }  
                configFile.Save(ConfigurationSaveMode.Modified);  
                ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);  
            }  
            catch (ConfigurationErrorsException)  
            {  
                Console.WriteLine("Error writing app settings");  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Module Module1  
  
    Sub Main()  
        ReadAllSettings()  
        ReadSetting("Setting1")  
        ReadSetting("NotValid")  
        AddUpdateAppSettings("NewSetting", "May 7, 2014")  
        AddUpdateAppSettings("Setting1", "May 8, 2014")  
        ReadAllSettings()  
    End Sub  
  
    Sub ReadAllSettings()  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
  
            If appSettings.Count = 0 Then  
                Console.WriteLine("AppSettings is empty.")  
            Else  
                For Each key As String In appSettings.AllKeys  
                    Console.WriteLine("Key: {0} Value: {1}", key, appSettings(key))  
                Next  
            End If  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub ReadSetting(key As String)  
        Try  
            Dim appSettings = ConfigurationManager.AppSettings  
            Dim result As String = appSettings(key)  
            If IsNothing(result) Then  
                result = "Not found"  
            End If  
            Console.WriteLine(result)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error reading app settings")  
        End Try  
    End Sub  
  
    Sub AddUpdateAppSettings(key As String, value As String)  
        Try  
            Dim configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None)  
            Dim settings = configFile.AppSettings.Settings  
            If IsNothing(settings(key)) Then  
                settings.Add(key, value)  
            Else  
                settings(key).Value = value  
            End If  
            configFile.Save(ConfigurationSaveMode.Modified)  
            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name)  
        Catch e As ConfigurationErrorsException  
            Console.WriteLine("Error writing app settings")  
        End Try  
    End Sub  
  
End Module  
```  
  
 El ejemplo anterior se supone que el proyecto tiene un archivo App.config, tal y como se muestra a continuación.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
  <appSettings>  
    <add key="Setting1" value="May 5, 2014"/>  
    <add key="Setting2" value="May 6, 2014"/>  
  </appSettings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo recuperar un objeto <see cref="T:System.Collections.Specialized.NameValueCollection" /> con los datos de configuración de la aplicación.</exception>
        <altmember cref="T:System.Configuration.AppSettingsSection" />
        <altmember cref="T:System.Collections.Specialized.NameValueCollection" />
      </Docs>
    </Member>
    <Member MemberName="ConnectionStrings">
      <MemberSignature Language="C#" Value="public static System.Configuration.ConnectionStringSettingsCollection ConnectionStrings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Configuration.ConnectionStringSettingsCollection ConnectionStrings" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ConnectionStrings As ConnectionStringSettingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Configuration::ConnectionStringSettingsCollection ^ ConnectionStrings { System::Configuration::ConnectionStringSettingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectionStrings : System.Configuration.ConnectionStringSettingsCollection" Usage="System.Configuration.ConfigurationManager.ConnectionStrings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.ConnectionStringSettingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene los datos <see cref="T:System.Configuration.ConnectionStringsSection" /> para la configuración predeterminada de la aplicación actual.</summary>
        <value>Devuelve un objeto <see cref="T:System.Configuration.ConnectionStringSettingsCollection" /> que incluye el contenido del objeto <see cref="T:System.Configuration.ConnectionStringsSection" /> para la configuración predeterminada de la aplicación actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Configuration.ConnectionStringsSection> objeto contiene el contenido del archivo de configuración `connectionStrings` sección.  
  
   
  
## Examples  
 En el ejemplo siguiente se muestra cómo utilizar una cadena de conexión para leer datos de una base de datos.  
  
```csharp  
using System;  
using System.Configuration;  
using System.Data.SqlClient;  
  
namespace ConsoleApplication1  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            ReadProducts();  
        }  
  
        static void ReadProducts()  
        {  
            var connectionString = ConfigurationManager.ConnectionStrings["WingtipToys"].ConnectionString;  
            string queryString = "SELECT Id, ProductName FROM dbo.Products;";  
            using (var connection = new SqlConnection(connectionString))  
            {  
                var command = new SqlCommand(queryString, connection);  
                connection.Open();  
                using (var reader = command.ExecuteReader())  
                {  
                    while (reader.Read())  
                    {  
                        Console.WriteLine(String.Format("{0}, {1}", reader[0], reader[1]));  
                    }  
                }  
            }  
        }  
    }  
}  
```  
  
```vb  
Imports System.Configuration  
Imports System.Data.SqlClient  
Module Module1  
  
    Sub Main()  
        ReadProducts()  
    End Sub  
  
    Sub ReadProducts()  
        Dim connectionString = ConfigurationManager.ConnectionStrings("WingtipToys").ConnectionString  
        Dim queryString = "SELECT Id, ProductName FROM dbo.Products;"  
        Using connection As New SqlConnection(connectionString)  
            Dim command = New SqlCommand(queryString, connection)  
            connection.Open()  
  
            Using reader As SqlDataReader = command.ExecuteReader()  
                While reader.Read()  
                    Console.WriteLine(String.Format("{0}, {1}", reader(0), reader(1)))  
                End While  
            End Using  
        End Using  
    End Sub  
  
End Module  
```  
  
 El ejemplo anterior se supone que el proyecto tiene un archivo App.config, tal y como se muestra a continuación.  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<configuration>  
    <startup>   
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5" />  
    </startup>  
    <connectionStrings>  
      <add name="WingtipToys" connectionString="Data Source=(LocalDB)\v11.0;Initial Catalog=WingtipToys;Integrated Security=True;Pooling=False" />  
    </connectionStrings>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo recuperar un objeto <see cref="T:System.Configuration.ConnectionStringSettingsCollection" />.</exception>
        <altmember cref="T:System.Configuration.ConnectionStringsSection" />
        <altmember cref="T:System.Configuration.ConnectionStringSettingsCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetSection">
      <MemberSignature Language="C#" Value="public static object GetSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSection (sectionName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member GetSection : string -&gt; obj" Usage="System.Configuration.ConfigurationManager.GetSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Ruta de acceso y nombre de la sección de configuración. Los nombres de los nodos están separados por barras diagonales, por ejemplo "system.net/mailSettings/smtp".</param>
        <summary>Recupera una sección de configuración especificada para la configuración predeterminada de la aplicación actual.</summary>
        <returns>Objeto <see cref="T:System.Configuration.ConfigurationSection" /> especificado o <see langword="null" /> si la sección no existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para aplicaciones cliente, este método recupera un archivo de configuración que se obtienen mediante la combinación del archivo de configuración de aplicación, el archivo de configuración de usuario local y el archivo de configuración móvil.  
  
 El <xref:System.Configuration.ConfigurationManager.GetSection%2A> método tiene acceso a información de configuración de tiempo de ejecución que no puede cambiar. Para cambiar la configuración, utilice el <xref:System.Configuration.Configuration.GetSection%2A> método en el archivo de configuración que se puede obtener mediante uno de los métodos Open siguientes:  
  
-   <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>  
  
-   <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A>  
  
   
  
## Examples  
 En el siguiente ejemplo, se muestra cómo utilizar el método <xref:System.Configuration.ConfigurationManager.GetSection%2A>. El ejemplo forma parte de un ejemplo mayor proporcionado para el <xref:System.Configuration.ConfigurationManager> clase.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <block subset="none" type="overrides">
          <para>Primero debe convertir el valor devuelto al tipo de configuración esperado. Para evitar posibles excepciones de conversión, debe utilizar una operación de conversión condicional como la <see langword="as" /> operador en la función en Visual Basic o C#.</para>
        </block>
        <altmember cref="T:System.Configuration.ConfigurationSection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre el archivo de configuración de cliente especificado como un objeto <see cref="T:System.Configuration.Configuration" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration userLevel" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="userLevel">Objeto <see cref="T:System.Configuration.ConfigurationUserLevel" /> para el que se está abriendo la configuración.</param>
        <summary>Abre el archivo de configuración para la aplicación actual como un objeto <see cref="T:System.Configuration.Configuration" />.</summary>
        <returns>Un objeto <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones cliente utilizan una configuración global que se aplica a todos los usuarios, configuraciones independientes que se aplican a usuarios individuales y las configuraciones que se aplican a los usuarios móviles. El `userLevel` parámetro determina la ubicación del archivo de configuración que se está abriendo indicando si no tiene ningún nivel de usuario (el archivo de configuración está en el mismo directorio que la aplicación) o si tiene un nivel por cada usuario (el archivo de configuración está en un configuración de la ruta de la aplicación determinada el nivel de usuario).  
  
 Especifique la configuración que desee obtener pasando uno de los siguientes valores para `userLevel`:  
  
-   Para obtener la <xref:System.Configuration.Configuration> establece el objeto que se aplica a todos los usuarios, `userLevel` a <xref:System.Configuration.ConfigurationUserLevel.None>.  
  
-   Para obtener la variable local <xref:System.Configuration.Configuration> establece el objeto que se aplica al usuario actual, `userLevel` a <xref:System.Configuration.ConfigurationUserLevel.PerUserRoamingAndLocal>.  
  
-   Para obtener la movilidad <xref:System.Configuration.Configuration> establece el objeto que se aplica al usuario actual, `userLevel` a <xref:System.Configuration.ConfigurationUserLevel.PerUserRoaming>.  
  
    > [!NOTE]
    >  Para obtener el <xref:System.Configuration.Configuration> del objeto de un recurso, el código debe tener permisos en todos los archivos de configuración desde el que hereda la configuración de lectura. Para actualizar un archivo de configuración, el código debe tener además permisos de escritura para el archivo de configuración y el directorio en el que existe.  
  
   
  
## Examples  
 En el ejemplo de código siguiente, se muestra cómo se utiliza el método <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#5)]
 [!code-vb[System.Configuration.ConfigurationManager#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenExeConfiguration (string exePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenExeConfiguration(string exePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenExeConfiguration(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExeConfiguration (exePath As String) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenExeConfiguration(System::String ^ exePath);" />
      <MemberSignature Language="F#" Value="static member OpenExeConfiguration : string -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenExeConfiguration exePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="exePath">Ruta de acceso del archivo ejecutable (exe).</param>
        <summary>Abre el archivo de configuración de cliente especificado como un objeto <see cref="T:System.Configuration.Configuration" />.</summary>
        <returns>Un objeto <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las aplicaciones cliente utilizan una configuración global que se aplica a todos los usuarios, configuraciones independientes que se aplican a usuarios individuales y las configuraciones que se aplican a los usuarios móviles. El `userLevel` valor determina la ubicación del archivo de configuración que se va a abrir. Indica si no tiene el nivel de usuario (el archivo de configuración está en el mismo directorio que la aplicación) o si tiene un nivel por cada usuario (el archivo de configuración está en una ruta de acceso de configuración de aplicación determinado por el tipo de nivel de usuario).  
  
 Llamar a esta sobrecarga del método es equivalente a llamar a la <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%28System.Configuration.ExeConfigurationFileMap%2CSystem.Configuration.ConfigurationUserLevel%2CSystem.Boolean%29> se puede sobrecargar con el `preLoad` parámetro establecido en `false`.  
  
   
  
## Examples  
 En el ejemplo de código siguiente, se muestra cómo se utiliza el método <xref:System.Configuration.ConfigurationManager.OpenExeConfiguration%2A>.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#6)]
 [!code-vb[System.Configuration.ConfigurationManager#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMachineConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMachineConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMachineConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMachineConfiguration () As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMachineConfiguration();" />
      <MemberSignature Language="F#" Value="static member OpenMachineConfiguration : unit -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMachineConfiguration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Abre el archivo de configuración del equipo como un objeto <see cref="T:System.Configuration.Configuration" /> en el equipo actual.</summary>
        <returns>Un objeto <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opciones de configuración de equipo se aplican a todo el equipo y todas las aplicaciones que residen en él, a menos que se invalide para la aplicación local. Opciones de configuración de máquina se leen desde el archivo Machine.config de la versión de .NET Framework que se está ejecutando. El archivo Machine.config se encuentra en el subdirectorio siguiente:  
  
 *% windir %* \Microsoft.NET\Framework\\*versión*\config  
  
> [!NOTE]
>  Para obtener el <xref:System.Configuration.Configuration> del objeto de un recurso, el código debe tener permisos en todos los archivos de configuración desde el que hereda la configuración de lectura. Para actualizar un archivo de configuración, el código debe tener además permisos de escritura para el archivo de configuración y el directorio en el que existe. No es posible tener acceso al archivo Machine.config para otras versiones de .NET Framework que pudiera estar instalado en el equipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Configuration.ConfigurationManager.OpenMachineConfiguration%2A> método para obtener todas las secciones que se encuentran en el archivo de configuración.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenMappedExeConfiguration">
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre el archivo de configuración de cliente especificado como un objeto <see cref="T:System.Configuration.Configuration" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
      </Parameters>
      <Docs>
        <param name="fileMap">Objeto <see cref="T:System.Configuration.ExeConfigurationFileMap" /> que hace referencia al archivo de configuración que se va a usar en lugar del archivo de configuración predeterminada de la aplicación.</param>
        <param name="userLevel">Objeto <see cref="T:System.Configuration.ConfigurationUserLevel" /> para el que se abre la configuración.</param>
        <summary>Abre el archivo de configuración de cliente especificado como un objeto <see cref="T:System.Configuration.Configuration" /> que utiliza la asignación de archivos y el nivel de usuario indicados.</summary>
        <returns>Objeto de configuración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Configuration.ConfigurationUserLevel> objeto determina la ubicación del archivo de configuración que se va a abrir. Indica si el archivo tiene el nivel de usuario (el archivo de configuración está en el mismo directorio que la aplicación) o si tiene un nivel por cada usuario (el archivo de configuración está en una ruta de acceso de configuración de aplicación determinado por `userLevel`).  
  
> [!NOTE]
>  Para obtener el <xref:System.Configuration.Configuration> del objeto de un recurso, el código debe tener permisos en todos los archivos de configuración desde el que hereda la configuración de lectura. Para actualizar un archivo de configuración, el código debe tener además permisos de escritura para el archivo de configuración y el directorio en el que existe.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> método para obtener todas las secciones que contiene el archivo de configuración.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#9)]
 [!code-vb[System.Configuration.ConfigurationManager#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <altmember cref="T:System.Configuration.ConfigurationUserLevel" />
        <altmember cref="T:System.Configuration.Configuration" />
      </Docs>
    </Member>
    <Member MemberName="OpenMappedExeConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedExeConfiguration (System.Configuration.ExeConfigurationFileMap fileMap, System.Configuration.ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedExeConfiguration(class System.Configuration.ExeConfigurationFileMap fileMap, valuetype System.Configuration.ConfigurationUserLevel userLevel, bool preLoad) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(System.Configuration.ExeConfigurationFileMap,System.Configuration.ConfigurationUserLevel,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedExeConfiguration (fileMap As ExeConfigurationFileMap, userLevel As ConfigurationUserLevel, preLoad As Boolean) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedExeConfiguration(System::Configuration::ExeConfigurationFileMap ^ fileMap, System::Configuration::ConfigurationUserLevel userLevel, bool preLoad);" />
      <MemberSignature Language="F#" Value="static member OpenMappedExeConfiguration : System.Configuration.ExeConfigurationFileMap * System.Configuration.ConfigurationUserLevel * bool -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedExeConfiguration (fileMap, userLevel, preLoad)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ExeConfigurationFileMap" />
        <Parameter Name="userLevel" Type="System.Configuration.ConfigurationUserLevel" />
        <Parameter Name="preLoad" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileMap">Objeto <see cref="T:System.Configuration.ExeConfigurationFileMap" /> que hace referencia al archivo de configuración que se va a utilizar en lugar del archivo de configuración de la aplicación predeterminada.</param>
        <param name="userLevel">Objeto <see cref="T:System.Configuration.ConfigurationUserLevel" /> para el que se abre la configuración.</param>
        <param name="preLoad">
          <see langword="true" /> para cargar previamente todos los grupos de secciones y secciones; si no, <see langword="false" />.</param>
        <summary>Abre el archivo de configuración de cliente especificado como un objeto <see cref="T:System.Configuration.Configuration" /> que usa la asignación de archivos, nivel de usuario y opción de carga previa especificados.</summary>
        <returns>Objeto de configuración.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Configuration.ConfigurationUserLevel> objeto determina la ubicación del archivo de configuración que se está abriendo. Indica si el archivo tiene el nivel de usuario (el archivo de configuración está en el mismo directorio que la aplicación) o si tiene un nivel por cada usuario (el archivo de configuración está en una ruta de acceso de configuración de aplicación que está determinado por `userLevel`).  
  
> [!NOTE]
>  Para obtener el <xref:System.Configuration.Configuration> del objeto de un recurso, el código debe tener permisos en todos los archivos de configuración desde el que hereda la configuración de lectura. Para actualizar un archivo de configuración, el código debe tener además permisos de escritura para el archivo de configuración y el directorio en el que existe.  
  
 Para obtener un ejemplo de código, vea el <xref:System.Configuration.ConfigurationManager.OpenMappedExeConfiguration%2A> sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenMappedMachineConfiguration">
      <MemberSignature Language="C#" Value="public static System.Configuration.Configuration OpenMappedMachineConfiguration (System.Configuration.ConfigurationFileMap fileMap);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Configuration.Configuration OpenMappedMachineConfiguration(class System.Configuration.ConfigurationFileMap fileMap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration(System.Configuration.ConfigurationFileMap)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenMappedMachineConfiguration (fileMap As ConfigurationFileMap) As Configuration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Configuration::Configuration ^ OpenMappedMachineConfiguration(System::Configuration::ConfigurationFileMap ^ fileMap);" />
      <MemberSignature Language="F#" Value="static member OpenMappedMachineConfiguration : System.Configuration.ConfigurationFileMap -&gt; System.Configuration.Configuration" Usage="System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration fileMap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.Configuration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileMap" Type="System.Configuration.ConfigurationFileMap" />
      </Parameters>
      <Docs>
        <param name="fileMap">Objeto <see cref="T:System.Configuration.ExeConfigurationFileMap" /> que hace referencia al archivo de configuración que se va a usar en lugar del archivo de configuración predeterminada de la aplicación.</param>
        <summary>Abre el archivo de configuración del equipo como un objeto <see cref="T:System.Configuration.Configuration" /> que utiliza la asignación de archivos especificada.</summary>
        <returns>Un objeto <see cref="T:System.Configuration.Configuration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opciones de configuración de equipo se aplican a todo el equipo y todas las aplicaciones que residen en él, a menos que se invalide para la aplicación local. Opciones de configuración de máquina se leen desde el archivo Machine.config de la versión de .NET Framework que se está ejecutando. El archivo Machine.config se encuentra en el subdirectorio siguiente:  
  
 *% windir %* \Microsoft.NET\Framework\\*versión*\config  
  
> [!NOTE]
>  Para obtener el <xref:System.Configuration.Configuration> del objeto de un recurso, el código debe tener permisos en todos los archivos de configuración desde el que hereda la configuración de lectura. Para actualizar un archivo de configuración, el código debe tener además permisos de escritura para el archivo de configuración y el directorio en el que existe. No es posible tener acceso al archivo Machine.config para otras versiones de .NET Framework que pudiera estar instalado en el equipo.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Configuration.ConfigurationManager.OpenMappedMachineConfiguration%2A> método para obtener todas las secciones del archivo de configuración.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#4)]
 [!code-vb[System.Configuration.ConfigurationManager#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">No se pudo cargar un archivo de configuración.</exception>
        <altmember cref="T:System.Configuration.Configuration" />
        <altmember cref="T:System.Configuration.ConfigurationFileMap" />
      </Docs>
    </Member>
    <Member MemberName="RefreshSection">
      <MemberSignature Language="C#" Value="public static void RefreshSection (string sectionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RefreshSection(string sectionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ConfigurationManager.RefreshSection(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RefreshSection (sectionName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RefreshSection(System::String ^ sectionName);" />
      <MemberSignature Language="F#" Value="static member RefreshSection : string -&gt; unit" Usage="System.Configuration.ConfigurationManager.RefreshSection sectionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Configuration</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sectionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sectionName">Nombre de la sección de configuración o ruta de acceso y nombre de sección de configuración de la sección que se va a actualizar.</param>
        <summary>Actualiza la sección con nombre para que se vuelva a leer desde el disco la próxima vez que se recupere.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método invalida la caché para la sección de configuración especificada sin afectar a otras secciones.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Configuration.ConfigurationManager.RefreshSection%2A> método para actualizar la sección de configuración de la configuración de aplicación.  
  
 [!code-csharp[System.Configuration.ConfigurationManager#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/CS/configurationmanager.cs#7)]
 [!code-vb[System.Configuration.ConfigurationManager#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Configuration.ConfigurationManager/VB/configurationmanager.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Configuration.ConfigurationManager.GetSection(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>