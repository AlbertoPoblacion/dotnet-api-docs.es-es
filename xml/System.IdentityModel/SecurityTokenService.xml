<Type Name="SecurityTokenService" FullName="System.IdentityModel.SecurityTokenService">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b5c8d93b898d628b70967d33278c8cd9f33a66bf" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="36479613" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.SecurityTokenService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenService" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenService abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenService = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>La clase base abstracta que define las propiedades y los métodos de un servicio de token de seguridad (STS).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear un STS debe derivar de la <xref:System.IdentityModel.SecurityTokenService> clase. En la clase personalizada debe, como mínimo, invalida la <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> y <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> métodos. Con estas invalidaciones, el STS creado mediante la implementación predeterminada de todos los demás métodos definidos en la clase es capaz de emitir tokens de seguridad en respuesta a la seguridad de las solicitudes de token (RST). Es decir, se implementa el enlace Issue definido en la especificación WS-Trust. Este enlace se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Ninguno de los otros enlaces de WS-Trust (renovar, Cancelar y validar) se implementan en el caso predeterminado y se devuelve un error adecuado al llamador si se encuentra una RST que corresponde a uno de estos enlaces. Por supuesto, puede invalidar los métodos adecuados (<xref:System.IdentityModel.SecurityTokenService.Renew%2A>, <xref:System.IdentityModel.SecurityTokenService.Cancel%2A>, y <xref:System.IdentityModel.SecurityTokenService.Validate%2A>) para implementar estos enlaces en los STS.  
  
> [!IMPORTANT]
>  Implementación de un STS para entornos de producción implica una cuidadosa planeación y recursos considerable para mitigar los posibles riesgos de seguridad inherentes a exponer este tipo de servicio. Mayoría de los desarrolladores mediante Windows Identity Foundation (WIF) se pueden desarrollar aplicaciones que externalizar la administración de identidad a un STS, en lugar de desarrollar a un STS de sí mismo. WIF proporciona una extensión de Visual Studio, la herramienta identidad y acceso para Visual Studio 2012, para ayudar a los desarrolladores probar soluciones en el entorno de desarrollo. Esta herramienta incluye un STS, `LocalSTS`, que se pueden configurar para dar servicio a las notificaciones específicas de la aplicación que está desarrollando. Para obtener más información acerca de la herramienta identidad y acceso, consulte [Identity and Access Tool para Visual Studio 2012](~/docs/framework/security/identity-and-access-tool-for-vs.md). En algunos escenarios, `LocalSTS` no se puede proporcionar la funcionalidad necesaria para probar la aplicación de forma adecuada; por ejemplo, en un escenario que implica desarrollar un controlador de token personalizado para su uso por una aplicación. En estos casos, puede derivar de <xref:System.IdentityModel.SecurityTokenService> para crear uno o más STS simple que se pueden implementar en el entorno de desarrollo y que se puede utilizar para probar estas características en la aplicación. El resto de esta sección se centra en los métodos expuestos por el <xref:System.IdentityModel.SecurityTokenService> clase que le permiten implementar un STS simple y ampliar la canalización de emisión de tokens.  
  
 En la lista siguiente proporciona una breve descripción de los métodos de importancia primordial al desarrollador para su uso en un entorno de desarrollo o prueba.  
  
-   Método <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>. Este método devuelve un <xref:System.IdentityModel.Scope> objeto que contiene información sobre el RP. Este objeto se usa en el resto de la canalización de emisión de tokens e incluye información sobre la firma y cifrado de credenciales para usarlos en la respuesta, así como el `AppliesTo` y `ReplyTo` (si es necesario) las direcciones. Debe invalidar este método.  
  
-   Método <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A>. Este método devuelve un <xref:System.Security.Claims.ClaimsIdentity> objeto que contiene las notificaciones para devolver al RP. Debe invalidar este método.  
  
-   Método <xref:System.IdentityModel.SecurityTokenService.Issue%2A>. Este método implementa la canalización de solicitud de token, que procesa una solicitud de token de seguridad de entrada (RST) y devuelve una respuesta (RSTR) para el llamador que contiene un token que se puede usar para autenticar con un punto de reunión. Muchos de los otros métodos definidos en el <xref:System.IdentityModel.SecurityTokenService> clase se llaman desde este método, incluidos el <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> y <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> métodos. No es necesario invalidar este método, pero una descripción de la canalización de solicitud de token que implementa pueden serle de ayuda.  
  
 Un STS se configura mediante la <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration> clase.  
  
   
  
## Examples  
 Los ejemplos de código que se usan en el <xref:System.IdentityModel.SecurityTokenService> temas se toman de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT) e incluye una implementación de un STS pasivo que es capaz de atender un token de SWT. Para obtener un ejemplo de cómo implementar un STS activo, puede ver el `Federation Metadata` ejemplo. Para obtener información acerca de estos ejemplos y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md). El código siguiente muestra la implementación de un STS pasivo mediante el <xref:System.IdentityModel.SecurityTokenService> clase.  
  
 [!code-csharp[WIFCustomTokenSTS#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#3)]  
  
 El código siguiente muestra cómo invocar un STS pasivo personalizado para procesar una solicitud de WS-Federation mediante una llamada a la <xref:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations.ProcessRequest%28System.Web.HttpRequest%2CSystem.Security.Claims.ClaimsPrincipal%2CSystem.IdentityModel.SecurityTokenService%2CSystem.Web.HttpResponse%29?displayProperty=nameWithType> método desde el código subyacente en el `default.aspx.cs` archivo.  
  
 [!code-csharp[WIFCustomTokenSTS#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/default.aspx.cs#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Debe reemplazar ambos el <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" /> y <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" /> métodos.</para>
    </block>
    <altmember cref="T:System.IdentityModel.Scope" />
    <altmember cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
    <altmember cref="T:System.IdentityModel.Services.FederatedPassiveSecurityTokenServiceOperations" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenService (System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration securityTokenServiceConfiguration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.#ctor(System.IdentityModel.Configuration.SecurityTokenServiceConfiguration)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenService(System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ securityTokenServiceConfiguration);" />
      <MemberSignature Language="F#" Value="new System.IdentityModel.SecurityTokenService : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration -&gt; System.IdentityModel.SecurityTokenService" Usage="new System.IdentityModel.SecurityTokenService securityTokenServiceConfiguration" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="securityTokenServiceConfiguration" Type="System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" />
      </Parameters>
      <Docs>
        <param name="securityTokenServiceConfiguration">
          <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> que contiene la configuración para el STS.</param>
        <summary>Llamado desde las clases derivadas para inicializar la clase <see cref="T:System.IdentityModel.SecurityTokenService" /> mediante las opciones de configuración especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para inicializar el proveedor de ámbito y el certificado de emisor del token.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="securityTokenServiceConfiguration" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginCancel">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginCancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginCancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginCancel (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginCancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginCancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginCancel (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de cancelación asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación de cancelación asincrónica.</param>
        <summary>Cuando se reemplaza en una clase derivada, comienza una solicitud asincrónica de WS-Trust Cancel.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cancelación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetOutputClaimsIdentity (principal, request, scope, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> que contiene información sobre el usuario de confianza asociado a la solicitud.</param>
        <param name="callback">El delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación asincrónica.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una llamada asincrónica para el método <see cref="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginGetScope">
      <MemberSignature Language="C#" Value="protected virtual IAsyncResult BeginGetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IAsyncResult BeginGetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function BeginGetScope (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IAsyncResult ^ BeginGetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginGetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginGetScope (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="callback">El delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación asincrónica.</param>
        <summary>Cuando se invalida en una clase derivada, comienza una llamada asincrónica para el método <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de cancelación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginIssue">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginIssue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginIssue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginIssue (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginIssue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginIssue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginIssue (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de emisión asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación de emisión asincrónica.</param>
        <summary>Cuando se reemplaza en una clase derivada, comienza una solicitud asincrónica de WS-Trust Issue.</summary>
        <returns>El objeto <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de emisión asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenew">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRenew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRenew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginRenew (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginRenew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginRenew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginRenew (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de renovación asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación de renovación asincrónica.</param>
        <summary>Cuando se reemplaza en una clase derivada, comienza una solicitud asincrónica de WS-Trust Renew.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de renovación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginValidate">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginValidate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginValidate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function BeginValidate (principal As ClaimsPrincipal, request As RequestSecurityToken, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginValidate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult&#xA;override this.BeginValidate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * AsyncCallback * obj -&gt; IAsyncResult" Usage="securityTokenService.BeginValidate (principal, request, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="callback">Delegado de <see cref="T:System.AsyncCallback" /> que recibe la notificación de la finalización de la operación de creación asincrónica.</param>
        <param name="state">Objeto que contiene la información de estado asociada a la operación de validación asincrónica.</param>
        <summary>Cuando se reemplaza en una clase derivada, comienza una solicitud asincrónica de WS-Trust Validate.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> que hace referencia a la operación de validación asincrónica.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Cancel(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Cancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Cancel (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Cancel(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Cancel : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Cancel (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <summary>Cuando se reemplaza en una clase derivada, procesa una solicitud WS-Trust Cancel.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenDescriptor CreateSecurityTokenDescriptor(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenDescriptor ^ CreateSecurityTokenDescriptor(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor&#xA;override this.CreateSecurityTokenDescriptor : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.SecurityTokenDescriptor" Usage="securityTokenService.CreateSecurityTokenDescriptor (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">Solicitud de token de entrada.</param>
        <param name="scope">Objeto <see cref="P:System.IdentityModel.SecurityTokenService.Scope" /> devuelto desde <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Crea una instancia de <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</summary>
        <returns>
          <see cref="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se invoca durante la emisión de tokens después <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> es <see langword="null" />.  
  
O bien 
 <paramref name="scope" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndCancel">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndCancel(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndCancel(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndCancel (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndCancel(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndCancel : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndCancel result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginCancel(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, completa la solicitud asincrónica de WS-Trust Cancel.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected virtual System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity EndGetOutputClaimsIdentity(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetOutputClaimsIdentity(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetOutputClaimsIdentity (result As IAsyncResult) As ClaimsIdentity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Security::Claims::ClaimsIdentity ^ EndGetOutputClaimsIdentity(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity&#xA;override this.EndGetOutputClaimsIdentity : IAsyncResult -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.EndGetOutputClaimsIdentity result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se invalida en una clase derivada, completa la llamada asincrónica para el método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope,System.AsyncCallback,System.Object)" />.</summary>
        <returns>
          <see cref="T:System.Security.Claims.ClaimsIdentity" /> que contiene la colección de reclamaciones que se coloquen en el token de seguridad emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndGetScope">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Scope EndGetScope (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope EndGetScope(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndGetScope(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function EndGetScope (result As IAsyncResult) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Scope ^ EndGetScope(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope&#xA;override this.EndGetScope : IAsyncResult -&gt; System.IdentityModel.Scope" Usage="securityTokenService.EndGetScope result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se invalida en una clase derivada, completa la llamada asincrónica para el método <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Scope" /> que encapsula información (RP) de usuario de confianza asociado con la solicitud (RST) especificada en la llamada al método de <see cref="M:System.IdentityModel.SecurityTokenService.BeginGetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.NotImplementedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndIssue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndIssue(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndIssue(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndIssue (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndIssue(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndIssue : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndIssue result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginIssue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, completa la solicitud asincrónica de WS-Trust Issue.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndRenew(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndRenew(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndRenew (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndRenew(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndRenew : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndRenew result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginRenew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, completa la solicitud asincrónica de WS-Trust Renew.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndValidate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse EndValidate(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.EndValidate(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function EndValidate (result As IAsyncResult) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ EndValidate(IAsyncResult ^ result);" />
      <MemberSignature Language="F#" Value="abstract member EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.EndValidate : IAsyncResult -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.EndValidate result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">
          <see cref="T:System.IAsyncResult" /> que se devuelve al llamar al método <see cref="M:System.IdentityModel.SecurityTokenService.BeginValidate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.AsyncCallback,System.Object)" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, completa la solicitud asincrónica de WS-Trust Validate.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIssuerName">
      <MemberSignature Language="C#" Value="protected virtual string GetIssuerName ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetIssuerName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetIssuerName" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetIssuerName () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetIssuerName();" />
      <MemberSignature Language="F#" Value="abstract member GetIssuerName : unit -&gt; string&#xA;override this.GetIssuerName : unit -&gt; string" Usage="securityTokenService.GetIssuerName " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene el nombre del servicio de token de seguridad (STS).</summary>
        <returns>Nombre del emisor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama desde el valor predeterminado la canalización de emisión de tokens se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 La implementación predeterminada devuelve el <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.TokenIssuerName%2A> propiedad de configuración que se tiene acceso a través del <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propiedad.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputClaimsIdentity">
      <MemberSignature Language="C#" Value="protected abstract System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Security.Claims.ClaimsIdentity GetOutputClaimsIdentity(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Security::Claims::ClaimsIdentity ^ GetOutputClaimsIdentity(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetOutputClaimsIdentity : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.Security.Claims.ClaimsIdentity" Usage="securityTokenService.GetOutputClaimsIdentity (principal, request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsIdentity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <param name="scope">
          <see cref="T:System.IdentityModel.Scope" /> que contiene información sobre el usuario de confianza asociado a la solicitud. Es el objeto <see cref="T:System.IdentityModel.Scope" /> devuelto por el método <see cref="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />.</param>
        <summary>Cuando se reemplaza en una clase derivada, este método devuelve una colección de asuntos de salida que se incluirán en el token emitido.</summary>
        <returns>
          <see cref="T:System.Security.Claims.ClaimsIdentity" /> que contiene la colección de reclamaciones que se coloquen en el token de seguridad emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> método se llama desde la canalización de emisión de tokens, que se implementa mediante el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Devuelve un <xref:System.Security.Claims.ClaimsIdentity> que contiene las notificaciones que se va a incluir en el token de seguridad emitido según el solicitante del token (la `principal` parámetro), el RST entrante (el `request` parámetro), y de confianza para el que el token está pensado () el `scope` parámetro). La lógica en este método se ocupa principalmente contestar las preguntas siguientes:  
  
-   **¿Tipos de notificación que deben incluirse en la respuesta según el punto de reunión que se dirige?** Normalmente, esto se decide por RP de listas de tipos de notificación necesarios para cada usuario de confianza o por solicitud examinando el <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.Claims%2A> propiedad de la solicitud. Sin embargo, la lógica y los detalles para determinar las notificaciones que se va a incluir en la respuesta es completamente hasta su implementación.  
  
-   **¿Valores de notificación que se deben asignar a las notificaciones en la respuesta?** Para un proveedor de identidades (IP-STS) Esto significa normalmente utilizando una o más notificaciones en el solicitante <xref:System.Security.Claims.ClaimsPrincipal> (proporcionado por el `principal` parámetro) para tener acceso a un almacén (u otra entidad) para devolver valores de los tipos de notificación requeridos. Para un proveedor de federación (R-STS) Esto normalmente significa realizar algún tipo de procesamiento en las notificaciones entrantes del solicitante para satisfacer la solicitud; Quizá para realizar el filtrado o transformación en algunas notificaciones presentadas por el solicitante, mientras pasa a otras personas a través sin modificar. Por supuesto, como se muestra en el caso de decidir qué notificaciones se incluyen en la respuesta, los detalles y la lógica de cómo determinar los valores de estas notificaciones es hasta su implementación.  
  
   
  
## Examples  
 El ejemplo de código que se usa en este tema se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT) e incluye una implementación de un STS pasivo que es capaz de atender un token de SWT. Para obtener un ejemplo de cómo implementar un STS activo, puede ver el `Federation Metadata` ejemplo. Para obtener información acerca de estos ejemplos y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md). El código siguiente muestra cómo invalidar el <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> método para devolver las notificaciones para su STS. En este ejemplo, se omite el mensaje de Token de seguridad de solicitud (RST) y se devuelve una colección de notificaciones en función del usuario autenticado en el STS.  
  
 [!code-csharp[WIFCustomTokenSTS#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Debe invalidar este método en la implementación de la <see cref="T:System.IdentityModel.SecurityTokenService" /> clase.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetProofToken">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.ProofDescriptor GetProofToken (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Scope scope);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.ProofDescriptor GetProofToken(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Scope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetProofToken(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Scope)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::ProofDescriptor ^ GetProofToken(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Scope ^ scope);" />
      <MemberSignature Language="F#" Value="abstract member GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor&#xA;override this.GetProofToken : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Scope -&gt; System.IdentityModel.Tokens.ProofDescriptor" Usage="securityTokenService.GetProofToken (request, scope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.ProofDescriptor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="scope" Type="System.IdentityModel.Scope" />
      </Parameters>
      <Docs>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud de token entrante (RST).</param>
        <param name="scope">La instancia de <see cref="T:System.IdentityModel.Scope" /> que encapsula información sobre el usuario de confianza.</param>
        <summary>Obtiene el token de prueba que se incluirá en la respuesta (RSTR).</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.ProofDescriptor" /> que representa el nuevo descriptor de prueba que se ha creado. El descriptor de prueba puede ser un descriptor de prueba asimétrica, un descriptor de prueba simétrica o <see langword="null" /> en el caso del token de portador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama desde el valor predeterminado la canalización de emisión de tokens se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 La implementación predeterminada devuelve un descriptor de prueba o produce una excepción adecuada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> es <see langword="null" />.  
  
O bien 
 <paramref name="scope" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetRequestorProofEncryptingCredentials">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.EncryptingCredentials GetRequestorProofEncryptingCredentials(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetRequestorProofEncryptingCredentials(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRequestorProofEncryptingCredentials (request As RequestSecurityToken) As EncryptingCredentials" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::EncryptingCredentials ^ GetRequestorProofEncryptingCredentials(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials&#xA;override this.GetRequestorProofEncryptingCredentials : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Tokens.EncryptingCredentials" Usage="securityTokenService.GetRequestorProofEncryptingCredentials request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.EncryptingCredentials</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud de token entrante (RST).</param>
        <summary>Obtiene las credenciales de cifrado de prueba del solicitante.</summary>
        <returns>Un objeto <see cref="T:System.IdentityModel.Tokens.EncryptingCredentials" /> que representa las credenciales de cifrado del solicitante.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se llama desde el <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> método.  
  
 La implementación predeterminada hace lo siguiente. Devuelve `null` si no hay ningún token de cifrado especificado en la solicitud (el <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken.ProofEncryption%2A?displayProperty=nameWithType> propiedad es `null`). En caso contrario, si puede obtener el token como un <xref:System.IdentityModel.Tokens.X509SecurityToken>, devuelve las credenciales según ese token. Si no se puede resolver el token como un <xref:System.IdentityModel.Tokens.X509SecurityToken>, un <xref:System.IdentityModel.RequestFailedException> se produce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse GetResponse(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request, class System.IdentityModel.Tokens.SecurityTokenDescriptor tokenDescriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetResponse(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken,System.IdentityModel.Tokens.SecurityTokenDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetResponse (request As RequestSecurityToken, tokenDescriptor As SecurityTokenDescriptor) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ GetResponse(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request, System::IdentityModel::Tokens::SecurityTokenDescriptor ^ tokenDescriptor);" />
      <MemberSignature Language="F#" Value="abstract member GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.GetResponse : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken * System.IdentityModel.Tokens.SecurityTokenDescriptor -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.GetResponse (request, tokenDescriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
        <Parameter Name="tokenDescriptor" Type="System.IdentityModel.Tokens.SecurityTokenDescriptor" />
      </Parameters>
      <Docs>
        <param name="request">RST que contiene el token de la solicitud.</param>
        <param name="tokenDescriptor">Descriptor de token que contiene la información para usar con el token emitido.</param>
        <summary>Crea la respuesta (RSTR) que contiene el token emitido mediante la solicitud especificada (RST) y el descriptor del token de seguridad.</summary>
        <returns>La respuesta (RSTR) o <see langword="null" /> si una respuesta no se puede crear a partir de la solicitud especificada y el descriptor de token. La implementación predeterminada devuelve <see langword="null" /> si el parámetro <paramref name="tokenDescriptor" /> es <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> método se llama como último paso desde la canalización de emisión de tokens, que se implementa mediante el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método. Crea y devuelve la respuesta (RSTR) mediante el uso de la solicitud entrante original (RST) y el descriptor de token que creó en los pasos anteriores en la canalización de emisión de tokens.  
  
 La implementación predeterminada crea el RSTR al pasar el RST especificado en el parámetro de solicitud a la <xref:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse.%23ctor%28System.IdentityModel.Protocols.WSTrust.WSTrustMessage%29?displayProperty=nameWithType> constructor, invocar el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.ApplyTo%2A?displayProperty=nameWithType> pasó el método de descriptor de token <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> para aplicar sus propiedades para el recién crea RSTR, establecer el <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.AppliesTo%2A> propiedad en el RSTR mediante el uso de la <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A> propiedad en el descriptor de token y, por último, estableciendo el <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> propiedad en el RSTR según la tabla siguiente:  
  
|Propiedad `RST.ReplyTo`|Propiedad <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>.|Propiedad `RSTR.ReplyTo`|  
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|Set|No establecido|No establecido|  
|Set|Set|<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.AppliesToAddress%2A?displayProperty=nameWithType>|  
|No establecido|Set|No establecido|  
|No establecido|No establecido|No establecido|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetScope">
      <MemberSignature Language="C#" Value="protected abstract System.IdentityModel.Scope GetScope (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Scope GetScope(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetScope(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScope (principal As ClaimsPrincipal, request As RequestSecurityToken) As Scope" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::IdentityModel::Scope ^ GetScope(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member GetScope : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Scope" Usage="securityTokenService.GetScope (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa al cliente que realiza la solicitud.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud entrante (RST).</param>
        <summary>Obtiene un objeto <see cref="T:System.IdentityModel.Scope" /> que contiene información sobre el usuario de confianza (RP) asociado a la solicitud especificada (RST). Debe reemplazar este método en la implementación de la clase <see cref="T:System.IdentityModel.SecurityTokenService" />.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Scope" /> que encapsula información de RP adjuntada a la solicitud.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> se llama al método de la canalización de emisión de tokens después de la <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método y debe devolver un <xref:System.IdentityModel.Scope> objeto configurado para la solicitud entrante. (La canalización de emisión de tokens se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.) La <xref:System.IdentityModel.Scope> objeto encapsula información sobre el RP asociado con la solicitud de token de seguridad (RST). Esto incluye información acerca de las credenciales de firmas y cifradas que se usará con el RP y si se deben cifrar todos los tokens emitidos y las claves simétricas de la respuesta. Algunas tareas habituales realizadas en el <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método son:  
  
-   Determinar si el RP que va dirigido el token es un usuario de confianza reconocida. Cómo se consigue depende de su implementación. Si el RP previsto no es un usuario de confianza válido para este STS, entonces el método debe producir una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
-   Determinar la firma de credenciales para usarse en la respuesta (RSTR) y establezca el <xref:System.IdentityModel.Scope.SigningCredentials%2A> propiedad según corresponda.  
  
-   Determinar si se deben cifrar la respuesta o las claves simétricas incluye y las credenciales que se usará para el cifrado. Establecer el <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A>, <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A>, y <xref:System.IdentityModel.Scope.EncryptingCredentials%2A> propiedades según corresponda.  
  
    > [!IMPORTANT]
    >  De forma predeterminada, el <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A> y <xref:System.IdentityModel.Scope.SymmetricKeyEncryptionRequired%2A> se establecen propiedades `true` para evitar que el STS de emisión de tokens que no son seguros. Se recomienda que nunca se establecer estas propiedades en `false` en un entorno de producción.  
  
-   Determinar la dirección a la que se debe devolver la respuesta. Establecer el <xref:System.IdentityModel.Scope.AppliesToAddress%2A> o <xref:System.IdentityModel.Scope.ReplyToAddress%2A> propiedad según corresponda.  
  
   
  
## Examples  
 El ejemplo de código que se usa en este tema se toma de la `Custom Token` ejemplo. Este ejemplo proporciona las clases personalizadas que permiten el procesamiento de Simple Web Tokens (SWT) e incluye una implementación de un STS pasivo que es capaz de atender un token de SWT. Para obtener un ejemplo de cómo implementar un STS activo, puede ver el `Federation Metadata` ejemplo. Para obtener información acerca de estos ejemplos y otros ejemplos disponibles para WIF y dónde descargarlas, consulte [índice de ejemplo de código WIF](~/docs/framework/security/wif-code-sample-index.md).  
  
 En el siguiente ejemplo de código se muestra la implementación del método <xref:System.IdentityModel.SecurityTokenService.GetScope%2A>. Esta implementación comprueba que el RP se reconoce el STS, valida el <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.ReplyTo%2A> dirección en la solicitud y establece el <xref:System.IdentityModel.Scope.ReplyToAddress%2A?displayProperty=nameWithType> propiedad según corresponda, y los conjuntos de la firma y cifrado de credenciales para usar con el punto de reunión basadas en certificados que están codificados de forma rígida en el archivo.  
  
 [!code-csharp[WIFCustomTokenSTS#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#4)]  
[!code-csharp[WIFCustomTokenSTS#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#5)]  
[!code-csharp[WIFCustomTokenSTS#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifcustomtokensts/cs/passivests/customsecuritytokenservice.cs#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Debe invalidar este método en la implementación de la <see cref="T:System.IdentityModel.SecurityTokenService" /> clase.</para>
        </block>
        <altmember cref="T:System.IdentityModel.Scope" />
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityTokenHandler">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler (string requestedTokenType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Tokens.SecurityTokenHandler GetSecurityTokenHandler(string requestedTokenType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSecurityTokenHandler (requestedTokenType As String) As SecurityTokenHandler" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Tokens::SecurityTokenHandler ^ GetSecurityTokenHandler(System::String ^ requestedTokenType);" />
      <MemberSignature Language="F#" Value="abstract member GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler&#xA;override this.GetSecurityTokenHandler : string -&gt; System.IdentityModel.Tokens.SecurityTokenHandler" Usage="securityTokenService.GetSecurityTokenHandler requestedTokenType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenHandler</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestedTokenType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestedTokenType">Cadena que contiene el URI del tipo de token solicitado.</param>
        <summary>Obtiene el controlador adecuado de token de seguridad para emitir un token de seguridad del tipo especificado.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler" /> que representa el controlador de token que se utilizará para crear el token de seguridad emitido. Devuelve <see langword="null" /> si no se admite el tipo de token solicitado (no hay ningún controlador configurado para el tipo de token especificado).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la implementación predeterminada si `requestedTokenType` es `null` o una cadena vacía, el valor predeterminado se usa el tipo de token de configuración. Esto se especifica mediante el <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenType%2A> propiedad del objeto de configuración de STS tiene acceso a través del <xref:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration%2A> propiedad.  
  
 Este método se llama desde el valor predeterminado la canalización de emisión de tokens se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="GetTokenLifetime">
      <MemberSignature Language="C#" Value="protected virtual System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime (System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.Lifetime GetTokenLifetime(class System.IdentityModel.Protocols.WSTrust.Lifetime requestLifetime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.GetTokenLifetime(System.IdentityModel.Protocols.WSTrust.Lifetime)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTokenLifetime (requestLifetime As Lifetime) As Lifetime" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::IdentityModel::Protocols::WSTrust::Lifetime ^ GetTokenLifetime(System::IdentityModel::Protocols::WSTrust::Lifetime ^ requestLifetime);" />
      <MemberSignature Language="F#" Value="abstract member GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime&#xA;override this.GetTokenLifetime : System.IdentityModel.Protocols.WSTrust.Lifetime -&gt; System.IdentityModel.Protocols.WSTrust.Lifetime" Usage="securityTokenService.GetTokenLifetime requestLifetime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.Lifetime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestLifetime" Type="System.IdentityModel.Protocols.WSTrust.Lifetime" />
      </Parameters>
      <Docs>
        <param name="requestLifetime">Objeto <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> que representa la duración solicitada.</param>
        <summary>Obtiene la información de duración del token emitido.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.Lifetime" /> que representa la duración concedida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente se llama a este método con la duración que llegaron en el RST. En la implementación predeterminada, la duración del token se calcula según la tabla siguiente.  
  
|Creado (en)|Expira (in)|Creado (en)|Expira (out)|  
|--------------------|--------------------|--------------------|---------------------|  
|`null`|`null`|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType> + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|C|`null`|C|C + <xref:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration.DefaultTokenLifetime%2A?displayProperty=nameWithType>|  
|`null`|E|<xref:System.DateTime.UtcNow%2A?displayProperty=nameWithType>|E|  
|C|E|C|E|  
  
 Este método se llama desde el valor predeterminado la canalización de emisión de tokens se implementa en el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
    <Member MemberName="Issue">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Issue(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Issue (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Issue(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Issue : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Issue (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <summary>Emite un token de seguridad.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que contiene el token de seguridad emitido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa el enlace Issue definido en la especificación WS-Trust. La implementación predeterminada de la <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método procesa la solicitud entrante (RST) a través de una canalización de emisión de token (emisión de notificaciones) y devuelve una respuesta (RSTR) que contiene un token de seguridad con las notificaciones adecuadas para autenticar el solicitante con el punto de reunión o una excepción adecuada. La canalización de emisión de tokens en la implementación predeterminada consta de las llamadas a los métodos siguientes (de la <xref:System.IdentityModel.SecurityTokenService> clase).  
  
1.  El <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método para validar la solicitud (RST).  
  
2.  El <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> método para obtener un <xref:System.IdentityModel.Scope> objeto que contiene información sobre el usuario de confianza (RP) asociado a la solicitud. Debe invalidar este método. Si <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> devuelve `null`, un <xref:System.InvalidOperationException> se produce.  
  
3.  El <xref:System.IdentityModel.SecurityTokenService.CreateSecurityTokenDescriptor%2A> método para devolver un descriptor de token de seguridad basada en el RST y <xref:System.IdentityModel.Scope> devuelve el objeto en el paso anterior. El descriptor de token de seguridad (<xref:System.IdentityModel.Tokens.SecurityTokenDescriptor>) contiene información sobre la solicitud en un formulario que puede usarse en un controlador de token. El <xref:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor%2A?displayProperty=nameWithType> propiedad está establecida en el descriptor de devuelto por la llamada. Si `null` se devuelve o si el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.SigningCredentials%2A> es propiedad del descriptor `null`, un <xref:System.InvalidOperationException> se produce. La excepción también se produce si el <xref:System.IdentityModel.Scope.TokenEncryptionRequired%2A?displayProperty=nameWithType> propiedad es `true` pero la <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.EncryptingCredentials%2A> propiedad en el descriptor devuelto es `null`.  
  
4.  El <xref:System.IdentityModel.SecurityTokenService.GetSecurityTokenHandler%2A> método para obtener el controlador de token adecuado en función del tipo de token solicitado. Si `null` se devuelve, un <xref:System.NotImplementedException> se produce.  
  
5.  El <xref:System.IdentityModel.SecurityTokenService.GetIssuerName%2A> método para obtener el nombre del emisor del token. Produce una <xref:System.InvalidOperationException> si el nombre es `null` o está vacío; en caso contrario, Establece el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.TokenIssuerName%2A> el descriptor de propiedad.  
  
6.  El <xref:System.IdentityModel.SecurityTokenService.GetTokenLifetime%2A> método para obtener la duración para el símbolo (token) y establece el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Lifetime%2A> el descriptor de propiedad.  
  
7.  El <xref:System.IdentityModel.SecurityTokenService.GetProofToken%2A> método para obtener el token de prueba debe incluir en el token emitido y establece el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Proof%2A> el descriptor de propiedad.  
  
8.  El <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> método para obtener las notificaciones que se va a incluir en el token emitido y establece el <xref:System.IdentityModel.Tokens.SecurityTokenDescriptor.Subject%2A> el descriptor de propiedad. Debe invalidar este método.  
  
9. El <xref:System.IdentityModel.SecurityTokenService.GetResponse%2A> método para crear una respuesta (RSTR) que contiene el token emitido.  
  
 Puede invalidar el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método para implementar una canalización de emisión de tokens personalizado; sin embargo esto normalmente no es necesario en los entornos de desarrollo y pruebas para las implementaciones más personalizadas de la <xref:System.IdentityModel.SecurityTokenService> pretenden clase. En muchos de estos casos es reemplazar el <xref:System.IdentityModel.SecurityTokenService.GetOutputClaimsIdentity%2A> y <xref:System.IdentityModel.SecurityTokenService.GetScope%2A> métodos y, opcionalmente, invalide el <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> método para proporcionar un STS reparables por el entorno. Si aún más la personalización es necesaria a menudo puede proporcionar invalidando los métodos que implementan cada fase de la predeterminada de canalización de emisión de tokens enumerado anteriormente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Principal">
      <MemberSignature Language="C#" Value="public System.Security.Claims.ClaimsPrincipal Principal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Claims.ClaimsPrincipal Principal" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Principal" />
      <MemberSignature Language="VB.NET" Value="Public Property Principal As ClaimsPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Claims::ClaimsPrincipal ^ Principal { System::Security::Claims::ClaimsPrincipal ^ get(); void set(System::Security::Claims::ClaimsPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Principal : System.Security.Claims.ClaimsPrincipal with get, set" Usage="System.IdentityModel.SecurityTokenService.Principal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Claims.ClaimsPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la entidad de seguridad adjuntada a la instancia actual.</summary>
        <value>
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la entidad de seguridad actual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Renew">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Renew(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Renew(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Renew (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Renew(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Renew : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Renew (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <summary>Cuando se reemplaza en una clase derivada, procesa una solicitud WS-Trust Renew.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken Request" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Request" />
      <MemberSignature Language="VB.NET" Value="Public Property Request As RequestSecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ Request { System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ get(); void set(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Request : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken with get, set" Usage="System.IdentityModel.SecurityTokenService.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene y establece la solicitud de token de seguridad (RST) con la instancia actual.</summary>
        <value>
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que contiene la solicitud.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Scope Scope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Scope Scope" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.Scope" />
      <MemberSignature Language="VB.NET" Value="Public Property Scope As Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Scope ^ Scope { System::IdentityModel::Scope ^ get(); void set(System::IdentityModel::Scope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Scope : System.IdentityModel.Scope with get, set" Usage="System.IdentityModel.SecurityTokenService.Scope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Scope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el ámbito asociado a la instancia actual.</summary>
        <value>
          <see cref="T:System.IdentityModel.Scope" /> que representa la configuración de la solicitud de emisión de tokens.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenDescriptor">
      <MemberSignature Language="C#" Value="protected System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SecurityTokenDescriptor SecurityTokenDescriptor" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberSignature Language="VB.NET" Value="Protected Property SecurityTokenDescriptor As SecurityTokenDescriptor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::IdentityModel::Tokens::SecurityTokenDescriptor ^ SecurityTokenDescriptor { System::IdentityModel::Tokens::SecurityTokenDescriptor ^ get(); void set(System::IdentityModel::Tokens::SecurityTokenDescriptor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenDescriptor : System.IdentityModel.Tokens.SecurityTokenDescriptor with get, set" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenDescriptor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityTokenDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece la <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor" /> adjuntada a la instancia actual.</summary>
        <value>El descriptor del token de seguridad asociado a la instancia actual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Se ha intentado establecer la propiedad en <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SecurityTokenServiceConfiguration">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Configuration.SecurityTokenServiceConfiguration SecurityTokenServiceConfiguration" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SecurityTokenServiceConfiguration As SecurityTokenServiceConfiguration" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ SecurityTokenServiceConfiguration { System::IdentityModel::Configuration::SecurityTokenServiceConfiguration ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityTokenServiceConfiguration : System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" Usage="System.IdentityModel.SecurityTokenService.SecurityTokenServiceConfiguration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Configuration.SecurityTokenServiceConfiguration</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la instancia de configuración del propietario.</summary>
        <value>
          <see cref="T:System.IdentityModel.Configuration.SecurityTokenServiceConfiguration" /> que contiene la configuración para la instancia actual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate (System.Security.Claims.ClaimsPrincipal principal, System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse Validate(class System.Security.Claims.ClaimsPrincipal principal, class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.Validate(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Validate (principal As ClaimsPrincipal, request As RequestSecurityToken) As RequestSecurityTokenResponse" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IdentityModel::Protocols::WSTrust::RequestSecurityTokenResponse ^ Validate(System::Security::Claims::ClaimsPrincipal ^ principal, System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse&#xA;override this.Validate : System.Security.Claims.ClaimsPrincipal * System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" Usage="securityTokenService.Validate (principal, request)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="principal">
          <see cref="T:System.Security.Claims.ClaimsPrincipal" /> que representa la identidad del solicitante del token.</param>
        <param name="request">
          <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud del token de seguridad. Esto incluye el mensaje de solicitud junto con otra información relacionada del cliente como el contexto de autorización.</param>
        <summary>Cuando se reemplaza en una clase derivada, procesa una solicitud WS-Trust Validate.</summary>
        <returns>Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityTokenResponse" /> que representa el RSTR para devolver al llamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La implementación predeterminada de este método produce una <xref:System.IdentityModel.Protocols.WSTrust.InvalidRequestException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequest">
      <MemberSignature Language="C#" Value="protected virtual void ValidateRequest (System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateRequest(class System.IdentityModel.Protocols.WSTrust.RequestSecurityToken request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.SecurityTokenService.ValidateRequest(System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateRequest (request As RequestSecurityToken)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateRequest(System::IdentityModel::Protocols::WSTrust::RequestSecurityToken ^ request);" />
      <MemberSignature Language="F#" Value="abstract member ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit&#xA;override this.ValidateRequest : System.IdentityModel.Protocols.WSTrust.RequestSecurityToken -&gt; unit" Usage="securityTokenService.ValidateRequest request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" />
      </Parameters>
      <Docs>
        <param name="request">Clase <see cref="T:System.IdentityModel.Protocols.WSTrust.RequestSecurityToken" /> que representa la solicitud.</param>
        <summary>Valida la solicitud de token de seguridad (RST) encapsulada por esta instancia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.IdentityModel.SecurityTokenService.ValidateRequest%2A> se llama al método de la canalización de emisión de tokens (el <xref:System.IdentityModel.SecurityTokenService.Issue%2A> método) para validar el RST entrante. El RST se valida comparándola con los requisitos (directiva) de STS y se produce una excepción adecuada si no es válido.  
  
 La implementación predeterminada de la <xref:System.IdentityModel.SecurityTokenService> clase admite solo el patrón de RST y RSTR y solo el enlace Issue de la especificación WS-Trust (el <xref:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType%2A> debe establecerse la propiedad de la solicitud <xref:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue?displayProperty=nameWithType>). La implementación predeterminada de este método aplica estos requisitos (y otros se indican en la sección excepciones). Puede invalidar este método si se deben aplicar los requisitos de validación diferente para el STS personalizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Protocols.WSTrust.InvalidRequestException">
          <paramref name="request" /> es <see langword="null" />.  
  
O bien 
La propiedad <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.RequestType" /> de la solicitud no está establecida en <see cref="F:System.IdentityModel.Protocols.WSTrust.RequestTypes.Issue" />.  
  
O bien 
La propiedad <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> de la solicitud no es <see langword="null" /> o una de las constantes definidas en la clase <see cref="T:System.IdentityModel.Protocols.WSTrust.KeyTypes" />.  
  
O bien 
El <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.KeyType" /> de la solicitud es <see cref="F:System.IdentityModel.Protocols.WSTrust.KeyTypes.Bearer" /> y el elemento <see langword="KeySize" /> está presente, pero su valor no es igual a cero.</exception>
        <exception cref="T:System.IdentityModel.UnsupportedTokenTypeBadRequestException">El STS no admite el tipo de token de solicitud (según el valor de la propiedad <see cref="P:System.IdentityModel.Protocols.WSTrust.WSTrustMessage.TokenType" /> de la solicitud).</exception>
        <altmember cref="M:System.IdentityModel.SecurityTokenService.Issue(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Protocols.WSTrust.RequestSecurityToken)" />
      </Docs>
    </Member>
  </Members>
</Type>