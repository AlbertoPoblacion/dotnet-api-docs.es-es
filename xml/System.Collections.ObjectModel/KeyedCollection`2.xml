<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ade3ca878e68845149c363b46ee8dd67dfc022b" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53232098" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Tipo de claves de la colección.</typeparam>
    <typeparam name="TItem">Tipo de elementos de la colección.</typeparam>
    <summary>Proporciona la clase base abstracta para una colección en la que sus claves están incrustadas en los valores.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La <xref:System.Collections.ObjectModel.KeyedCollection%602> clase proporciona una recuperación indizada de ambos o (1) y con clave de recuperación que se aproxima a o (1). Es un tipo abstracto o con más precisión, un conjunto infinito de tipos abstractos, porque cada uno de sus tipos genéricos construidos es una clase base abstracta. Para usar <xref:System.Collections.ObjectModel.KeyedCollection%602>, derivar el tipo de colección del tipo construido adecuado.  
  
 El <xref:System.Collections.ObjectModel.KeyedCollection%602> clase es un híbrido entre una colección basada en la <xref:System.Collections.Generic.IList%601> interfaz genérica y una colección en función de la <xref:System.Collections.Generic.IDictionary%602> interfaz genérica. Al igual que las colecciones basadas en la <xref:System.Collections.Generic.IList%601> interfaz genérica, <xref:System.Collections.ObjectModel.KeyedCollection%602> es una lista indizada de elementos. Al igual que las colecciones basadas en la <xref:System.Collections.Generic.IDictionary%602> interfaz genérica, <xref:System.Collections.ObjectModel.KeyedCollection%602> tiene una clave asociada con cada elemento.  
  
 A diferencia de los diccionarios, un elemento de <xref:System.Collections.ObjectModel.KeyedCollection%602> no es un par clave/valor; en su lugar, todo el elemento es el valor y la clave se incrusta dentro del valor.  Por ejemplo, un elemento de una colección derivada de `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` en Visual Basic) podría ser "John Doe Jr." donde el valor es "John Doe Jr." y la clave es "Doe"; o una colección de registros de empleados que contiene las claves de entero podría derivarse de `KeyedCollection\<int,Employee>`. El resumen <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método extrae la clave del elemento.  
  
 De forma predeterminada, el <xref:System.Collections.ObjectModel.KeyedCollection%602> incluye un diccionario de búsqueda que puede obtener con el <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> propiedad.  Cuando se agrega un elemento a la <xref:System.Collections.ObjectModel.KeyedCollection%602>, la clave del elemento se extrae una vez y se guarda en el diccionario de búsqueda para agilizar las búsquedas. Este comportamiento se invalida mediante la especificación de un umbral de creación de diccionario al crear el <xref:System.Collections.ObjectModel.KeyedCollection%602>. El diccionario de búsqueda se crea la primera vez que el número de elementos supera ese umbral.  Si se especifica -1 como el umbral, nunca se crea el diccionario de búsqueda.  
  
> [!NOTE]
>  Cuando se utiliza el diccionario de búsqueda interno, contiene referencias a todos los elementos de la colección si `TItem` es un tipo de referencia, o copia de todos los elementos de la colección si `TItem` es un tipo de valor. Por lo tanto, utilizando el diccionario de búsqueda puede no ser adecuado si `TItem` es un tipo de valor.  
  
 Puede obtener acceso a un elemento por su índice o clave mediante el <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> propiedad. Puede agregar elementos sin una clave, pero posteriormente se pueden acceder estos elementos solo por índice.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código. El primer ejemplo muestra el código mínimo necesario para derivar de <xref:System.Collections.ObjectModel.KeyedCollection%602>y muestra muchos de los métodos heredados. El segundo ejemplo muestra cómo invalidar los métodos protegidos de <xref:System.Collections.ObjectModel.KeyedCollection%602> para proporcionar un comportamiento personalizado.  
  
 **Ejemplo 1**  
  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Ejemplo 2**  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> que utiliza el comparador de igualdad predeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Collections.ObjectModel.KeyedCollection%602> creadas con este constructor utiliza el comparador de igualdad genérico predeterminado para el tipo de la clave, obtenida <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Para especificar un comparador de igualdad genérico diferente, utilice el <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> constructor o <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructor.  
  
 De forma predeterminada, el <xref:System.Collections.ObjectModel.KeyedCollection%602> incluye un diccionario de búsqueda que se crea cuando se agrega el primer elemento. Cuando se agrega un elemento a la <xref:System.Collections.ObjectModel.KeyedCollection%602>, la clave del elemento se extrae una vez y se guarda en el diccionario de búsqueda para agilizar las búsquedas. Este comportamiento puede invalidarse mediante el uso de la <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructor y especificando un umbral de creación de diccionario.  
  
> [!NOTE]
>  Dado que el <xref:System.Collections.ObjectModel.KeyedCollection%602> clase es abstracta (`MustInherit` en Visual Basic), debe derivar de ella para poder usarlo. En el constructor para su tipo derivado, llame al <xref:System.Collections.ObjectModel.KeyedCollection%602> constructor. No es necesario exponer la funcionalidad, como el comparador de igualdad o el umbral de creación de diccionario en sus constructores.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves, o <see langword="null" /> para usar el comparador de igualdad predeterminado para el tipo de clave, que se obtiene de <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> que utiliza el comparador de igualdad especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Collections.ObjectModel.KeyedCollection%602> incluye un diccionario de búsqueda que se crea cuando se agrega el primer elemento. Cuando se agrega un elemento a la <xref:System.Collections.ObjectModel.KeyedCollection%602>, la clave del elemento se extrae una vez y se guarda en el diccionario de búsqueda para agilizar las búsquedas. Este comportamiento puede invalidarse mediante el uso de la <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructor y especificando un umbral de creación de diccionario.  
  
> [!NOTE]
>  Dado que el <xref:System.Collections.ObjectModel.KeyedCollection%602> clase es abstracta (`MustInherit` en Visual Basic), debe derivar de ella para poder usarlo. En el constructor para su tipo derivado, llame al <xref:System.Collections.ObjectModel.KeyedCollection%602> constructor. No es necesario exponer la funcionalidad, como el comparador de igualdad o el umbral de creación de diccionario en sus constructores.  
  
 Este constructor es una operación o (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar al comparar claves, o <see langword="null" /> para usar el comparador de igualdad predeterminado para el tipo de clave, que se obtiene de <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Número de elementos que puede contener la colección sin crear un diccionario de búsqueda (0 crea el diccionario de búsqueda al agregar el primer elemento), o -1 para especificar que nunca se crea un diccionario de búsqueda.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> que utiliza el comparador de igualdad especificado y crea un diccionario de búsqueda cuando se supera el umbral especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Collections.ObjectModel.KeyedCollection%602> incluye un diccionario de búsqueda que se crea cuando se agrega el primer elemento. Cuando se agrega un elemento a la <xref:System.Collections.ObjectModel.KeyedCollection%602>, la clave del elemento se extrae una vez y se guarda en el diccionario de búsqueda para agilizar las búsquedas. Este constructor permite invalidar este comportamiento. Especifique 0 para crear el diccionario cuando se agrega el primer elemento, 1 para crear el diccionario cuando se agrega el segundo elemento y así sucesivamente. Si se especifica -1 como el umbral, nunca se crea el diccionario de búsqueda.  
  
 Para las colecciones muy pequeñas la mejora de la velocidad de recuperación proporcionada por el diccionario de búsqueda podría no ser que vale la pena la memoria adicional necesaria para el diccionario. Establecer un umbral permite decidir cuándo realizar esa compensación.  
  
> [!NOTE]
>  Dado que el <xref:System.Collections.ObjectModel.KeyedCollection%602> clase es abstracta (`MustInherit` en Visual Basic), debe derivar de ella para poder usarlo. En el constructor para su tipo derivado, llame al <xref:System.Collections.ObjectModel.KeyedCollection%602> constructor. No es necesario exponer la funcionalidad, como el comparador de igualdad o el umbral de creación de diccionario en sus constructores.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se usa el <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructor con un umbral de 0, por lo que el diccionario interno se crea la primera vez que un objeto se agrega a la colección.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" /> es menor que 1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Elemento cuya clave se va a cambiar.</param>
        <param name="newKey">Nueva clave para <paramref name="item" />.</param>
        <summary>Cambia la clave asociada al elemento especificado en el diccionario de búsqueda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método no modifica la clave incrustada en `item`; simplemente reemplaza la clave guardada en el diccionario de búsqueda.  Por lo tanto, si `newKey` es diferente de la clave que está incrustada en `item`, no se puede obtener acceso a `item` mediante el uso de la clave devuelta por <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Este método no hace nada si el <xref:System.Collections.ObjectModel.KeyedCollection%602> no tiene un diccionario de búsqueda.  
  
 Todas las claves de un <xref:System.Collections.ObjectModel.KeyedCollection%602> deben ser únicos. No puede ser una clave `null`.  
  
 Este método es una operación o (1).  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Antes de modificar la clave incrustada en un elemento, debe llamar a este método para actualizar la clave en el diccionario de búsqueda. Si el umbral de creación de diccionario es -1, no es necesario llamar a este método.  
  
 No exponga el <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método como un método público de una clase derivada. Uso incorrecto de este método pone el diccionario de búsqueda sin sincronizar las claves de elemento. Por ejemplo, establezca la clave en `null` y, a continuación, si se establece en otro valor agrega varias claves para un elemento en el diccionario de búsqueda. Exponer este método internamente para permitir que las claves de elemento mutable: Cuando se cambia la clave de un elemento, este método se utiliza para cambiar la clave en el diccionario de búsqueda.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="item" /> es <see langword="null" />.  
  
O bien 
 El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">No se ha encontrado <paramref name="item" />.  
  
O bien 
 <paramref name="key" /> ya existe en <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un diccionario de búsqueda, este método borra, pero no la elimina.  
  
 Si el número de elementos ha superado el umbral de creación de diccionario y la <xref:System.Collections.ObjectModel.KeyedCollection%602> es usar un diccionario de búsqueda, continuará usar un diccionario de búsqueda, aunque el número de elementos vuelve a estar debajo del umbral.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Invalide este método para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> método, hereda la <xref:System.Collections.ObjectModel.Collection%601> clase genérica.  
  
 Llame a la implementación de la clase base de este método para borrar la colección subyacente y borrar el diccionario de búsqueda.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código que muestran cómo se reemplaza el <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> método para proporcionar un comportamiento personalizado para borrar todos los objetos de la colección. El primer ejemplo agrega un evento de notificación personalizado y la segunda proporciona compatibilidad para una colección de objetos con claves mutables.  
  
 Ejemplo 1  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Ejemplo 2  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el comparador de igualdad genérico que se utiliza para determinar la igualdad de claves en la colección.</summary>
        <value>Implementación de la interfaz genérica <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se utiliza para determinar la igualdad de claves en la colección.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clave que se buscará en <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Determina si la colección contiene un elemento con la clave especificada.</summary>
        <returns><see langword="true" /> si la colección <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> contiene un elemento con la clave especificada; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el <xref:System.Collections.ObjectModel.KeyedCollection%602> tiene un diccionario de búsqueda, `key` se usa para buscar el diccionario. Si no hay ningún diccionario de búsqueda, la clave de cada elemento se extrae mediante el <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y se compara con la clave especificada.  
  
 Este método es una operación o (1) si el <xref:System.Collections.ObjectModel.KeyedCollection%602> tiene un diccionario de búsqueda; en caso contrario es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el diccionario de búsqueda de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Diccionario de búsqueda de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, si existe; de lo contrario, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, el <xref:System.Collections.ObjectModel.KeyedCollection%602> incluye un diccionario de búsqueda que se crea cuando se agrega el primer elemento. Cuando se agrega un elemento a la <xref:System.Collections.ObjectModel.KeyedCollection%602>, la clave del elemento se extrae una vez y se guarda en el diccionario de búsqueda para agilizar las búsquedas. Este comportamiento puede invalidarse mediante el uso de la <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> constructor y especificando un umbral de creación de diccionario.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Elemento del que se va a extraer la clave.</param>
        <summary>Cuando se implementa en una clase derivada, extrae la clave del elemento especificado.</summary>
        <returns>Clave para el elemento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clave en el diccionario de búsqueda es diferente de la clave que se incrusta en `item`, no se puede obtener acceso a `item` mediante el uso de la clave devuelta por <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Puede implementar este método para devolver `null` para una colección que contiene los elementos sin claves, en cuyo caso los elementos pueden tener acceso solo mediante su índice. Este método es una operación o (1).  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Debe invalidar este método para proporcionar el diccionario con una manera de extraer las claves de elementos del diccionario.  
  
 Se llama internamente a este método. No es necesario para que sea público.  
  
   
  
## Examples  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Índice basado en cero en el que debe insertarse <paramref name="item" />.</param>
        <param name="item">Objeto que se va a insertar.</param>
        <summary>Inserta un elemento en <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, en el índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `index` es igual a <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` se agrega al final de la <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> llama a la <xref:System.Collections.ObjectModel.Collection%601.Add%2A> y <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> métodos.  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Invalide este método para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A> y <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> métodos, heredados la <xref:System.Collections.ObjectModel.Collection%601> clase genérica.  
  
 Llame a la implementación de la clase base de este método para insertar el elemento en la colección subyacente y actualizar el diccionario de búsqueda.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código que muestran cómo se reemplaza el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método para proporcionar un comportamiento personalizado para agregar o insertar objetos en la colección. El primer ejemplo agrega un evento de notificación personalizado y la segunda proporciona compatibilidad para una colección de objetos con claves mutables.  
  
 Ejemplo 1  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Ejemplo 2  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> es menor que 0.  
  
O bien 
 <paramref name="index" /> es mayor que <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a obtener.</param>
        <summary>Obtiene el elemento con la clave especificada.</summary>
        <value>El elemento con la clave especificada. Si no se encuentra un elemento con la clave especificada, se produce una excepción.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona la capacidad para tener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[key]` (`myCollection(key)` en Visual Basic).  
  
> [!NOTE]
>  Esta propiedad es distinta de los heredados <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propiedad, que obtiene y establece los elementos por índice numérico. Sin embargo, si `TKey` es de tipo <xref:System.Int32>, esta propiedad enmascara la propiedad heredada. En ese caso, se puede obtener acceso a la propiedad heredada convirtiendo el <xref:System.Collections.ObjectModel.KeyedCollection%602> a su tipo base. Por ejemplo, `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` en Visual Basic, `KeyedCollection<int, MyType^>` en C++) se puede convertir en `Collection<MyType>` (`Collection(Of MyType)` en Visual Basic, `Collection<MyType^>` en C++).  
  
 Si el <xref:System.Collections.ObjectModel.KeyedCollection%602> tiene un diccionario de búsqueda, `key` se usa para recuperar el elemento del diccionario.  Si no hay ningún diccionario de búsqueda, la clave de cada elemento se extrae mediante el <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y se compara con la clave especificada.  
  
 El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar el <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 Recuperar el valor de esta propiedad es una operación o (1) si el <xref:System.Collections.ObjectModel.KeyedCollection%602> tiene un diccionario de búsqueda; en caso contrario es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El ejemplo de código llama a la <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> propiedad, que es de solo lectura y se recupera por clave, y el <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propiedad, que es configurable y recupera por índice. Muestra cómo obtener acceso a la última propiedad cuando los objetos de la colección derivada tienen claves de enteros, indistinguibles de los enteros que se usa para la recuperación indizada.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">En la colección no existe ningún elemento con la clave especificada.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Clave del elemento que se va a quitar.</param>
        <summary>Quita el elemento con la clave especificada de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>Es <see langword="true" /> si el elemento se quita correctamente; en caso contrario, es <see langword="false" />.  Este método también devuelve <see langword="false" /> si no se encuentra <paramref name="key" /> en <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 También se quita la clave del elemento del diccionario de búsqueda.  
  
 Si el número de elementos ha superado el umbral de creación de diccionario y la <xref:System.Collections.ObjectModel.KeyedCollection%602> es usar un diccionario de búsqueda, continuará usar un diccionario de búsqueda, aunque el número de elementos vuelve a estar debajo del umbral.  
  
> [!NOTE]
>  Para personalizar el comportamiento de este método, reemplace el <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> método.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Este ejemplo de código muestra el código mínimo necesario derivar una clase de colección <xref:System.Collections.ObjectModel.KeyedCollection%602>: reemplazar la <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> método y proporcionar un constructor público que delega en un constructor de clase base. El ejemplo de código también muestra muchas de las propiedades y métodos heredados de <xref:System.Collections.ObjectModel.KeyedCollection%602> y <xref:System.Collections.ObjectModel.Collection%601> clases.  
  
 El ejemplo se muestra <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> método hereda <xref:System.Collections.ObjectModel.KeyedCollection%602>, que quita el elemento con una clave especificada y también el <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> y <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> métodos heredados de <xref:System.Collections.ObjectModel.Collection%601>, que pueden quitar por objeto y por índice, respectivamente.  
  
 El `SimpleOrder` clase es una lista de entrevistas muy simple que contiene `OrderItem` objetos, cada uno de los cuales representa un elemento de línea en el orden. La clave de `OrderItem` es inmutable, una consideración importante para las clases que derivan de <xref:System.Collections.ObjectModel.KeyedCollection%602>. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="key" /> es <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice del elemento que se va a quitar.</param>
        <summary>Quita el elemento situado en el índice especificado de <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 También se quita la clave del elemento del diccionario de búsqueda.  
  
 Si el número de elementos ha superado el umbral de creación de diccionario y la <xref:System.Collections.ObjectModel.KeyedCollection%602> es usar un diccionario de búsqueda, continuará usar un diccionario de búsqueda, aunque el número de elementos vuelve a estar debajo del umbral.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Invalide este método para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> y <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> métodos, heredados la <xref:System.Collections.ObjectModel.Collection%601> clase genérica y el <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> método.  
  
 Llame a la implementación de la clase base de este método para quitar el elemento de la colección subyacente y actualizar el diccionario de búsqueda.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código que muestran cómo se reemplaza el <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> método para proporcionar un comportamiento personalizado para quitar objetos de la colección. El primer ejemplo agrega un evento de notificación personalizado y la segunda proporciona compatibilidad para una colección de objetos con claves mutables.  
  
 Ejemplo 1  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Ejemplo 2  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a reemplazar.</param>
        <param name="item">Nuevo elemento.</param>
        <summary>Reemplaza el elemento situado en el índice determinado con el elemento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El diccionario de búsqueda se actualiza en consecuencia. Es decir, la clave del elemento que se va a reemplazar se quita del diccionario de búsqueda, y se agrega la clave del nuevo elemento.  
  
 Este método es una operación o (1).  
  
## <a name="notes-for-implementers"></a>Notas para los implementadores  
 Invalide este método para proporcionar un comportamiento personalizado para la configuración de la <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad hereda el <xref:System.Collections.ObjectModel.Collection%601> clase genérica.  
  
> [!NOTE]
>  Este método no afecta al comportamiento de la <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> propiedad, que es de solo lectura.  
  
 Llame a la implementación de la clase base de este método para establecer el elemento de la colección subyacente y actualizar el diccionario de búsqueda.  
  
   
  
## Examples  
 Esta sección contiene dos ejemplos de código que muestran cómo se reemplaza el <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> método para proporcionar un comportamiento personalizado para la configuración de la <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> propiedad. El primer ejemplo agrega un evento de notificación personalizado y la segunda proporciona compatibilidad para una colección de objetos con claves mutables.  
  
 Ejemplo 1  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos, para proporcionar un comportamiento personalizado para el <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, y <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> métodos y para la configuración predeterminada <xref:System.Collections.ObjectModel.Collection%601.Item%2A> propiedad (el indizador en C#). El comportamiento personalizado que se proporciona en este ejemplo es un evento de notificación denominado `Changed`, que se produce al final de cada uno de los métodos invalidados.  
  
 El ejemplo de código se crea la `SimpleOrder` (clase), que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602> y representa un formulario de pedido simple. Contiene el formulario de pedido `OrderItem` objetos que representan los elementos ordenados. El ejemplo de código también crea un `SimpleOrderChangedEventArgs` clase que contiene la información del evento y una enumeración para identificar el tipo de cambio.  
  
 El ejemplo de código muestra el comportamiento personalizado mediante una llamada a las propiedades y métodos de la clase derivada, en el `Main` método de la `Demo` clase.  
  
 Este ejemplo de código utiliza objetos con claves inmutables. Para obtener un ejemplo de código que usa claves mutables, vea <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Ejemplo 2  
  
 En el ejemplo de código siguiente se muestra cómo invalidar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> método para admitir claves mutables y cómo reemplazar protegido <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, y <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> métodos para mantener la integridad de las claves y la colección.  
  
 El ejemplo de código se crea la `MutableKeys` colección, que se deriva de <xref:System.Collections.ObjectModel.KeyedCollection%602>y el `MutableKey` clase. El `MutableKey` clase tiene un configurables `Key` propiedad. Cuando se asigna una nueva clave a la propiedad, el establecedor de propiedad se llama a la `internal` (`Friend` en Visual Basic) `ChangeKey` método de la colección para comprobar si la nueva clave entraría en conflicto con una clave existente. Si es así, se produce una excepción y no se cambia el valor de propiedad.  
  
 Para mantener la conexión entre un `MutableKey` objeto y el `MutableKeys` colección e impedir que un objeto que se inserta en las dos colecciones, el `MutableKey` clase tiene un `internal` (`Friend` en Visual Basic) `Collection`campo. Este campo se mantiene mediante los métodos protegidos que proporcionan un comportamiento personalizado para agregar y quitar elementos de la colección, como el <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> método. El campo se establece cuando el elemento se agrega a una colección y se borra cuando se quita el elemento.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="item" Type="TItem" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>