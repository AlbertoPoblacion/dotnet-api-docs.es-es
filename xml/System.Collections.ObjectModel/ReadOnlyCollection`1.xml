<Type Name="ReadOnlyCollection&lt;T&gt;" FullName="System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="32e41671dfba0e43839fef6066748a2c7968a223" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51311300" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ReadOnlyCollection&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ReadOnlyCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class ReadOnlyCollection(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class ReadOnlyCollection : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ReadOnlyCollection&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Tipo de los elementos de la colección.</typeparam>
    <summary>Proporciona la clase base para una colección genérica de solo lectura.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una instancia de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase genérica siempre es de solo lectura.  Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  Consulte <xref:System.Collections.ObjectModel.Collection%601> para obtener una versión modificable de esta clase.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Estáticos públicos (<see langword="Shared" /> en Visual Basic) los miembros de este tipo son seguros para subprocesos. No se garantiza que los miembros de instancias sean seguros para la ejecución de subprocesos.  
  
Un <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> puede admitir varios lectores simultáneamente, siempre y cuando no se modifica la colección.  Aun así, enumerar una colección no es un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</threadsafe>
    <block subset="none" type="overrides">
      <para>Esta clase base se proporciona para facilitar a los implementadores que creen una colección personalizada genérica de solo lectura. Se recomienda para extender esta clase base en lugar de crear sus propios los implementadores.</para>
    </block>
    <altmember cref="T:System.Collections.ObjectModel.Collection`1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyCollection (System.Collections.Generic.IList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IList`1&lt;!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.#ctor(System.Collections.Generic.IList{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (list As IList(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyCollection(System::Collections::Generic::IList&lt;T&gt; ^ list);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt; : System.Collections.Generic.IList&lt;'T&gt; -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="new System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt; list" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="list" Type="System.Collections.Generic.IList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="list">Lista que se va a incluir.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> que es un contenedor de solo lectura para la lista especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificaciones en `list`, exponer `list` únicamente a través de este contenedor.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 Este constructor es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra este constructor y varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase.  
  
 El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> pasándolo al constructor.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="list" /> es <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="readOnlyCollection.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a buscar en <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Determina si un elemento se encuentra en <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> se encuentra en la matriz <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador de igualdad predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.ReadOnlyCollection`1.IndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="readOnlyCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="index">Índice de base cero de <c>array</c> donde comienza la copia.</param>
        <summary>Copia la totalidad de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> en una matriz <see cref="T:System.Array" /> unidimensional compatible, comenzando en el índice especificado de la matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar los elementos.  
  
 Los elementos se copian en el <xref:System.Array> en el mismo orden que el enumerador recorre el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">El número de elementos de la <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de elementos incluidos en la instancia de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
        <value>Número de elementos incluidos en la instancia de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;T&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="readOnlyCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración la colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
        <returns>Estructura <see cref="T:System.Collections.Generic.IEnumerator`1" /> para la colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en Visual C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. En esta posición, el valor de propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> es indefinido. No puede volver a establecer la propiedad <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el primer elemento de la colección, sino que debe crear una nueva instancia del enumerador.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se utiliza el enumerador para mostrar el contenido de un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> que ajusta un <xref:System.Collections.Generic.List%601>. El enumerador está oculto por la `foreach` instrucción (`For Each` en Visual Basic, `for each` en C++).  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="readOnlyCollection.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a buscar en <see cref="T:System.Collections.Generic.List`1" />. El valor puede ser <see langword="null" /> para los tipos de referencia.</param>
        <summary>Busca el objeto especificado y devuelve el índice de base cero de la primera aparición en todo el objeto <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
        <returns>Índice de base cero de la primera aparición de <paramref name="item" /> en la totalidad de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, si se encuentra; en caso contrario, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se buscará hacia delante a partir del primer elemento y terminando en el último elemento.  
  
 Este método determina la igualdad utilizando el comparador predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.ReadOnlyCollection`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Realizar operaciones de cadenas que no tienen en cuenta las referencias culturales en colecciones</related>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T" Usage="System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener.</param>
        <summary>Obtiene el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad proporciona la capacidad de tener acceso a un elemento específico de la colección utilizando la siguiente sintaxis de C#: `myCollection[index]` (`myCollection(index)` en Visual Basic).  
  
 El lenguaje C# utiliza la palabra clave para definir los indizadores en lugar de implementar el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero.  
  
O bien 
 <paramref name="index" /> es igual o mayor que <see cref="P:System.Collections.ObjectModel.ReadOnlyCollection`1.Count" />.</exception>
        <altmember cref="P:System.Collections.ObjectModel.ReadOnlyCollection`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IList&lt;T&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!T&gt; Items" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.Items" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Items As IList(Of T)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IList&lt;T&gt; ^ Items { System::Collections::Generic::IList&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.IList&lt;'T&gt;" Usage="System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Devuelve la interfaz <see cref="T:System.Collections.Generic.IList`1" /> incluida en la colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</summary>
        <value>Interfaz <see cref="T:System.Collections.Generic.IList`1" /> incluida en la colección <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra varios miembros de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> clase. El ejemplo de código se crea un <xref:System.Collections.Generic.List%601> de cadenas y le agrega cuatro nombres de dinosaurio. El ejemplo de código, a continuación, encapsula la lista en un <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Después de demostrar la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Contains%2A>, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Item%2A>, y <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23IndexOf%2A> miembros, el ejemplo de código muestra que el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> es simplemente un contenedor para el original <xref:System.Collections.Generic.List%601> agregando un nuevo elemento a la <xref:System.Collections.Generic.List%601> y Mostrar el contenido de la <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 Por último, el ejemplo de código crea una matriz mayor que la colección y usa el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.CopyTo%2A> método para insertar los elementos de la colección en el centro de la matriz.  
  
 [!code-cpp[generic.ReadOnlyCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/generic.ReadOnlyCollection/cpp/source.cpp#1)]
 [!code-csharp[generic.ReadOnlyCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/generic.ReadOnlyCollection/cs/source.cs#1)]
 [!code-vb[generic.ReadOnlyCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/generic.ReadOnlyCollection/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esta propiedad se proporciona para permitir el acceso directo a los miembros de la <see cref="T:System.Collections.Generic.IList`1" /> que el <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> oculta.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (value As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T value) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a agregar a <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Agrega un elemento a <see cref="T:System.Collections.Generic.ICollection`1" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#ICollection&lt;T&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of T).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Clear() = System::Collections::Generic::ICollection&lt;T&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.Generic.ICollection`1" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, esta propiedad siempre devuelve <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;T&gt;.Remove (T value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#ICollection&lt;T&gt;#Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (value As T) As Boolean Implements ICollection(Of T).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;T&gt;.Remove(T value) = System::Collections::Generic::ICollection&lt;T&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">Objeto que se va a quitar de <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Es <see langword="true" /> si <paramref name="value" /> se ha quitado correctamente de la interfaz <see cref="T:System.Collections.Generic.ICollection`1" />; en caso contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.ICollection%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;T&gt;.Insert">
      <MemberSignature Language="C#" Value="void IList&lt;T&gt;.Insert (int index, T value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;T&gt;.Insert(int32 index, !T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#IList&lt;T&gt;#Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As T) Implements IList(Of T).Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;T&gt;.Insert(int index, T value) = System::Collections::Generic::IList&lt;T&gt;::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se debe insertar <c>value</c>.</param>
        <param name="value">Objeto que se va a insertar en <see cref="T:System.Collections.Generic.IList`1" />.</param>
        <summary>Inserta un elemento en la interfaz <see cref="T:System.Collections.Generic.IList`1" />, en el índice especificado.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.IList%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;T&gt;.Item">
      <MemberSignature Language="C#" Value="T System.Collections.Generic.IList&lt;T&gt;.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Collections.Generic.IList&lt;T&gt;.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#IList&lt;T&gt;#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As T Implements IList(Of T).Item" />
      <MemberSignature Language="C++ CLI" Value="property T System::Collections::Generic::IList&lt;T&gt;::Item[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IList&lt;T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener.</param>
        <summary>Obtiene el elemento en el índice especificado. Se produce <see cref="T:System.NotSupportedException" /> si se intenta establecer el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que la colección es de solo lectura, solo puede obtener este elemento en el índice especificado. Se producirá una excepción si se intenta establecer el elemento. Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.IList%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce cuando la propiedad ya está establecida.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;T&gt;.RemoveAt">
      <MemberSignature Language="C#" Value="void IList&lt;T&gt;.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;T&gt;.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#Generic#IList&lt;T&gt;#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList(Of T).RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;T&gt;.RemoveAt(int index) = System::Collections::Generic::IList&lt;T&gt;::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento de la interfaz <see cref="T:System.Collections.Generic.IList`1" /> que se encuentra en el índice especificado.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.Generic.IList%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> unidimensional que constituye el destino de los elementos copiados de <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> debe tener una indización de base cero.</param>
        <param name="index">Índice de base cero de <c>array</c> donde comienza la copia.</param>
        <summary>Copia los elementos de <see cref="T:System.Collections.ICollection" /> en <see cref="T:System.Array" />, empezando por un índice determinado de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Si el tipo del origen de <xref:System.Collections.ICollection> no puede convertirse automáticamente al tipo del destino `array`, las implementaciones no genérica de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, mientras que las implementaciones genéricas inician <xref:System.ArgumentException>.  
  
 Este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="array" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> es menor que cero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> es multidimensional.  
  
O bien 
 <paramref name="array" /> no tiene una indización de base cero.  
  
O bien 
El número de elementos de la <see cref="T:System.Collections.ICollection" /> de origen es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.  
  
O bien 
El tipo de la <see cref="T:System.Collections.ICollection" /> de origen no puede convertirse automáticamente al tipo de la <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si el acceso a la interfaz <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos).</summary>
        <value>Es <see langword="true" /> si el acceso a <see cref="T:System.Collections.ICollection" /> está sincronizado (es seguro para subprocesos); de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, esta propiedad siempre devuelve <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Objeto que se puede usar para sincronizar el acceso a <see cref="T:System.Collections.ICollection" />.  En la implementación predeterminada de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, esta propiedad siempre devuelve la instancia actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Enumerar una colección no es intrínsecamente un procedimiento seguro para subprocesos. A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Devuelve un objeto que puede utilizarse para sincronizar el acceso a la <xref:System.Collections.ICollection>. La sincronización es eficaz solo si todos los subprocesos bloquean este objeto antes de acceder a la colección. El código siguiente muestra el uso de la <xref:System.Collections.ICollection.SyncRoot%2A> propiedad para C#, Visual C++ y Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un enumerador que recorre en iteración una colección.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> que se puede utilizar para recorrer en iteración la colección.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `foreach` instrucción del lenguaje C# (`for each` en Visual C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.  Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.  
  
 Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.  
  
 En principio, el enumerador se coloca antes del primer elemento de la colección. <xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.  En esta posición, el valor de propiedad <xref:System.Collections.IEnumerator.Current%2A> está sin definir. Por lo tanto, debe llamar a <xref:System.Collections.IEnumerator.MoveNext%2A> para adelantar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> devuelve el mismo objeto hasta que se llama a <xref:System.Collections.IEnumerator.MoveNext%2A> o a <xref:System.Collections.IEnumerator.Reset%2A>. <xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`. Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`. Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido. Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un enumerador es válido mientras la colección no cambie. Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.  
  
 El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.  A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.  Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.  
  
 Las implementaciones de colecciones en predeterminadas <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.  
  
 Este método es una operación o (1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IEnumerable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se va a agregar a <see cref="T:System.Collections.IList" />.</param>
        <summary>Agrega un elemento a <see cref="T:System.Collections.IList" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Posición en la que se insertó el nuevo elemento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quita todos los elementos de <see cref="T:System.Collections.IList" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina si <see cref="T:System.Collections.IList" /> contiene un valor específico.</summary>
        <returns>Es <see langword="true" /> si <see cref="T:System.Object" /> se encuentra en <see cref="T:System.Collections.IList" />; de lo contrario, es <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es del tipo especificado para el parámetro de tipo genérico <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a buscar en la interfaz <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina el índice de un elemento específico de <see cref="T:System.Collections.IList" />.</summary>
        <returns>Devuelve el índice de <paramref name="value" /> si se encuentra en la lista; de lo contrario, devuelve -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina la igualdad utilizando el comparador predeterminado <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>.  
  
 Este método realiza una búsqueda lineal; por lo tanto, este método es O (`n`) operación, donde `n` es <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.Count%2A>.  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> no es del tipo especificado para el parámetro de tipo genérico <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero en el que se debe insertar <c>value</c>.</param>
        <param name="value">Objeto <see cref="T:System.Object" /> que se va a insertar en <see cref="T:System.Collections.IList" />.</param>
        <summary>Inserta un elemento en la interfaz <see cref="T:System.Collections.IList" />, en el índice especificado.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> tiene un tamaño fijo; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, esta propiedad siempre devuelve <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de tamaño fijo no permite agregar o quitar elementos una vez que se ha creado, pero sí permite modificar los elementos existentes.  
  
 Una colección con un tamaño fijo es simplemente una colección con un contenedor que impide agregar y quitar elementos; por lo tanto, si se realizan cambios en la colección subyacente, incluida la adición o eliminación de elementos, la colección de tamaño fijo refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Collections.IList" /> es de solo lectura.</summary>
        <value>Es <see langword="true" /> si la interfaz <see cref="T:System.Collections.IList" /> es de solo lectura; de lo contrario, es <see langword="false" />.  En la implementación predeterminada de <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />, esta propiedad siempre devuelve <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Una colección de solo lectura no permite que se agreguen, quiten o modifiquen elementos una vez que se ha creado.  
  
 Una colección es de solo lectura es simplemente una colección con un contenedor que evita la modificación de la colección; por lo tanto, si se realizan cambios en la colección subyacente, la colección de solo lectura refleja los cambios.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a obtener.</param>
        <summary>Obtiene el elemento en el índice especificado. Se produce <see cref="T:System.NotSupportedException" /> si se intenta establecer el elemento en el índice especificado.</summary>
        <value>Elemento en el índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propiedad permite obtener acceso a un elemento específico de la colección utilizando la sintaxis siguiente: `myCollection[index]`.  
  
 El lenguaje C# utiliza la [esto](~/docs/csharp/language-reference/keywords/this.md) palabra clave para definir los indizadores en lugar de implementar el <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23Item%2A> propiedad. Visual Basic implementa <xref:System.Collections.ObjectModel.ReadOnlyCollection%601.System%23Collections%23IList%23Item%2A> como propiedad predeterminada, lo que proporciona la misma funcionalidad de indización.  
  
 La recuperación del valor de esta propiedad es una operación O(1).  
  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.IDisposable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> no es un índice válido para <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Siempre se produce cuando la propiedad ya está establecida.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> que se va a quitar de <see cref="T:System.Collections.IList" />.</param>
        <summary>Quita la primera aparición de un objeto específico de la interfaz <see cref="T:System.Collections.IList" />.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.ReadOnlyCollection`1.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Índice de base cero del elemento que se va a quitar.</param>
        <summary>Quita el elemento de la interfaz <see cref="T:System.Collections.IList" /> que se encuentra en el índice especificado.  Esta implementación siempre produce una excepción <see cref="T:System.NotSupportedException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este miembro es una implementación explícita de un miembro de interfaz. Solo se puede utilizar cuando la instancia de <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> se convierte en una interfaz <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Siempre se produce.</exception>
      </Docs>
    </Member>
  </Members>
</Type>