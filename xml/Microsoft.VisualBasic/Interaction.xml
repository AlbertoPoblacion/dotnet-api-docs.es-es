<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a258707b4384ccfe3e2a8bf0034b9587d97a5b3" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39839879" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>El módulo <see langword="Interaction" /> contiene los procedimientos que se utilizan para interactuar con objetos, aplicaciones y sistemas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este módulo admite las palabras clave del lenguaje Visual Basic y miembros de la biblioteca de tiempo de ejecución que ejecutan otros programas, llamar a un método o propiedad, un sonido desde el equipo, proporcionan una cadena de línea de comandos, manipulan objetos COM y controlan cuadros de diálogo.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Shell` función que se ejecuta una aplicación especificada por el usuario. Especificar <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> como el segundo argumento, se abre la aplicación en su tamaño normal y le da el foco.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Activa una aplicación que ya se está ejecutando.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" /> que especifica el número de identificador de proceso Win32 que se ha asignado a este proceso. Puede utilizar el identificador que devuelve <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, siempre que no sea cero.</param>
        <summary>Activa una aplicación que ya se está ejecutando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa `AppActivate` para poner la ventana activa de una aplicación en el foco. No es posible que tenga un identificador o una referencia a la ventana activa, o incluso saber qué ventana está activa en un momento dado. En tal caso, no puede usar el <xref:System.Windows.Forms.Control.Focus%2A> método.  
  
 El `AppActivate` función cambia el foco a la aplicación con nombre o la ventana, pero no afecta a si se está maximizada o minimizada. El foco se mueve fuera de la ventana de la aplicación activada cuando el usuario realiza alguna acción para cambiar el foco o cerrar la ventana. Puede usar el `Shell` función para iniciar una aplicación y establecer el estilo de ventana.  
  
 Si usas el `Title` parámetro, `AppActivate` utiliza una comparación entre mayúsculas y minúsculas, pero en caso contrario, se requiere una coincidencia exacta con el contenido de la barra de título. En primer lugar, busca a través de las ventanas de nivel superior y, a continuación, las ventanas secundarias. Si no encuentra una coincidencia, produce un <xref:System.ArgumentException>.  
  
 Puede usar `AppActivate` solo con los procesos que posee en windows. La mayoría de las aplicaciones de consola no tienen ventanas, lo que significa que no aparecen en la lista de los procesos que `AppActivate` las búsquedas. Cuando se ejecuta desde una aplicación de consola, el sistema crea un proceso independiente para ejecutar la aplicación y devuelve el resultado al proceso de la consola. Por lo tanto, cuando se solicita el identificador de proceso actual, obtendrá el identificador de proceso de ese proceso independiente, en lugar de Id. de proceso de. la aplicación de consola  
  
 En tiempo de ejecución, el `AppActivate` función activa con un título que coincide con cualquier aplicación en ejecución `Title` o con un identificador de proceso que coincida con `ProcessId`. Si no hay ninguna coincidencia exacta, se activará cualquier aplicación cuya cadena de título termina con `Title`. Si hay más de una aplicación denominada `Title`, el `AppActivate` función elige arbitrariamente una activación.  
  
> [!NOTE]
>  El `AppActivate` función requiere `UIPermission` en el <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nivel, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, vea <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 En este ejemplo se muestra varios usos de la `AppActivate` función para activar una ventana de aplicación. Si no se está ejecutando un proceso de Bloc de notas, en el ejemplo se produce un <xref:System.ArgumentException>. El `Shell` procedimiento se da por supuesto que las aplicaciones están en las rutas de acceso especificadas.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">Expresión de tipo <see langword="String" /> que especifica el título de la barra de título de la aplicación que se desea activar. Puede utilizar el título asignado a la aplicación al iniciarla.</param>
        <summary>Activa una aplicación que ya se está ejecutando.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa `AppActivate` para poner la ventana activa de una aplicación en el foco. No es posible que tenga un identificador o una referencia a la ventana activa, o incluso saber qué ventana está activa en un momento dado. En tal caso, no puede usar el <xref:System.Windows.Forms.Control.Focus%2A> método.  
  
 El `AppActivate` función cambia el foco a la aplicación con nombre o la ventana, pero no afecta a si se está maximizada o minimizada. El foco se mueve fuera de la ventana de la aplicación activada cuando el usuario realiza alguna acción para cambiar el foco o cerrar la ventana. Puede usar el `Shell` función para iniciar una aplicación y establecer el estilo de ventana.  
  
 Si usas el `Title` parámetro, `AppActivate` utiliza una comparación entre mayúsculas y minúsculas, pero en caso contrario, se requiere una coincidencia exacta con el contenido de la barra de título. En primer lugar, busca a través de las ventanas de nivel superior y, a continuación, las ventanas secundarias. Si no encuentra una coincidencia, produce un <xref:System.ArgumentException>.  
  
 Puede usar `AppActivate` solo con los procesos que posee en windows. La mayoría de las aplicaciones de consola no tienen ventanas, lo que significa que no aparecen en la lista de los procesos que `AppActivate` las búsquedas. Cuando se ejecuta desde una aplicación de consola, el sistema crea un proceso independiente para ejecutar la aplicación y devuelve el resultado al proceso de la consola. Por lo tanto, cuando se solicita el identificador de proceso actual, obtendrá el identificador de proceso de ese proceso independiente, en lugar de Id. de proceso de. la aplicación de consola  
  
 En tiempo de ejecución, el `AppActivate` función activa con un título que coincide con cualquier aplicación en ejecución `Title` o con un identificador de proceso que coincida con `ProcessId`. Si no hay ninguna coincidencia exacta, se activará cualquier aplicación cuya cadena de título termina con `Title`. Si hay más de una aplicación denominada `Title`, el `AppActivate` función elige arbitrariamente una activación.  
  
> [!NOTE]
>  El `AppActivate` función requiere `UIPermission` en el <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nivel, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, vea <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 En este ejemplo se muestra varios usos de la `AppActivate` función para activar una ventana de aplicación. Si no se está ejecutando un proceso de Bloc de notas, en el ejemplo se produce un <xref:System.ArgumentException>. El `Shell` procedimiento se da por supuesto que las aplicaciones están en las rutas de acceso especificadas.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emite un sonido a través del altavoz del equipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cabeceo y la duración del Bip dependen de su software de hardware y del sistema y, por tanto, varían entre equipos.  
  
> [!NOTE]
>  El `Beep` función requiere `UIPermission` en el <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nivel, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, vea <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Beep` función para emitir un sonido a través del altavoz del equipo.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Obligatorio. <see langword="Object" />. Puntero al objeto que expone la propiedad o el método.</param>
        <param name="ProcName">Obligatorio. <see langword="String" />. Expresión de cadena que contiene el nombre de la propiedad o del método en el objeto.</param>
        <param name="UseCallType">Obligatorio. Miembro de enumeración de tipo <see cref="T:Microsoft.VisualBasic.CallType" /> que representa el tipo de procedimiento al que se llama. El valor de <see langword="CallType" /> puede ser <see langword="Method" />, <see langword="Get" /> o <see langword="Set" />.</param>
        <param name="Args">Opcional. <see langword="ParamArray" />. Matriz de parámetros que contiene los argumentos que se van a pasar a la propiedad o al método al que se llama.</param>
        <summary>Ejecuta un método en un objeto, o bien establece o devuelve una propiedad en un objeto.</summary>
        <returns>Ejecuta un método en un objeto, o bien establece o devuelve una propiedad en un objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `CallByName` función se utiliza en tiempo de ejecución para obtener una propiedad, establecer una propiedad o invocar un método.  
  
   
  
## Examples  
 En el ejemplo siguiente, la primera línea usa `CallByName` para establecer el `Text` propiedad de un cuadro de texto, la segunda línea recupera el valor de la `Text` propiedad y la tercera línea invoca el `Move` método para mover el cuadro de texto.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 El ejemplo siguiente se usa el `CallByName` función para invocar la `Add` y `Item` métodos de un objeto de colección.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Valor <paramref name="UseCallType" /> no válido; debe ser <see langword="Method" />, <see langword="Get" /> o <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Obligatorio. <see langword="Double" />. Expresión numérica que da como resultado un valor entre 1 y el número de elementos que se pasan en el argumento <c>Choice</c>.</param>
        <param name="Choice">Obligatorio. Matriz de parámetros<see langword="Object" />. Se puede proporcionar una sola variable o expresión que se evalúa como el tipo de datos <see langword="Object" />, una lista de expresiones o variables de <see langword="Object" /> separadas por comas o una matriz unidimensional de elementos <see langword="Object" />.</param>
        <summary>Selecciona y devuelve un valor de una lista de argumentos.</summary>
        <returns>Selecciona y devuelve un valor de una lista de argumentos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Choose` función devuelve un miembro de la lista que se pasa en `Choice()`, según el valor de `Index`. El primer miembro de la lista se selecciona cuando `Index` es 1. El último miembro de la lista se selecciona cuando `Index` es `UBound`(`Choice()`). Si `Index` está fuera de estos límites, `Choose` devuelve `Nothing`.  
  
 Si `Index` no es un número entero, se redondea al número entero más cercano antes de que se va a evaluar.  
  
 Puede usar `Choose` para buscar un valor en una lista de posibilidades.  
  
> [!NOTE]
>  Las expresiones en la lista de argumentos pueden incluir llamadas a funciones. Como parte de la preparación de la lista de argumentos para la llamada a `Choose`, el compilador de Visual Basic llama a cada función en todas las expresiones. Esto significa que no se puede confiar en una función concreta no se llama si se selecciona una expresión diferente mediante `Index`.  
  
   
  
## Examples  
 Este ejemplo se usa el `Choose` función para mostrar un nombre en respuesta a un índice que se pasa al procedimiento en el `Ind` parámetro.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve la parte correspondiente a los argumentos de la línea de comandos utilizada para iniciar Visual Basic o un programa ejecutable desarrollado con Visual Basic. La característica <see langword="My" /> proporciona mayor productividad y rendimiento que la función <see langword="Command" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Devuelve la parte correspondiente a los argumentos de la línea de comandos utilizada para iniciar Visual Basic o un programa ejecutable desarrollado con Visual Basic.  
  
La característica <see langword="My" /> proporciona mayor productividad y rendimiento que la función <see langword="Command" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Después de que se devuelven los argumentos, puede buscar delimitadores comunes, como espacios, barras diagonales hacia delante o hacia atrás, guiones o comillas, para dividir la cadena de parámetros individuales o buscar.  
  
 Para las aplicaciones desarrolladas con Visual Basic y se compilan en un archivo .exe, el `Command` función devolverá todos los argumentos que aparecen después del nombre de la aplicación en la línea de comandos en este formato: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Este ejemplo se usa el `Command` función para devolver los argumentos de línea de comandos en un objeto que contiene una matriz.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Obligatorio. <see langword="String" />. Id. de programa del objeto que se va a crear.</param>
        <param name="ServerName">Opcional. <see langword="String" />. Nombre del servidor de red donde se va a crear el objeto. Si <c>ServerName</c> es una cadena vacía (""), se usa el equipo local.</param>
        <summary>Crea y devuelve una referencia a un objeto COM. <see langword="CreateObject" /> no se puede utilizar para crear instancias de clases en Visual Basic, a menos que dichas clases se expongan explícitamente como componentes COM.</summary>
        <returns>Crea y devuelve una referencia a un objeto COM. <see langword="CreateObject" /> no se puede utilizar para crear instancias de clases en Visual Basic, a menos que dichas clases se expongan explícitamente como componentes COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para crear una instancia de un componente COM, asigne el objeto devuelto por `CreateObject` a una variable de objeto:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 El tipo de variable de objeto que se usará para almacenar el objeto devuelto puede afectar al rendimiento de la aplicación. Declarar una variable de objeto con el `As Object` cláusula crea una variable que puede contener una referencia a cualquier tipo de objeto. Sin embargo, es el acceso al objeto a través de esa variable *enlazadas*, es decir, el enlace se produce cuando se ejecuta el programa. Hay muchas razones, que debe evitar el enlace en tiempo de ejecución.  
  
 Puede crear una variable de objeto que da como resultado el enlace anticipado, es decir, cuando se compila el programa de enlace. Para ello, agregue una referencia a la biblioteca de tipos para el objeto desde el **COM** pestaña de la **Agregar referencia** cuadro de diálogo en el **proyecto** menú. A continuación, declare la variable de objeto del tipo específico del objeto. En la mayoría de los casos, es más eficaz utilizar la `Dim` instrucción y un ensamblado de interoperabilidad primario para crear objetos que es utilizar el `CreateObject` función.  
  
## <a name="interacting-with-unmanaged-code"></a>Interactuar con código no administrado  
 Otro problema es que los objetos COM utilizan código no administrado, código sin la ventaja de common language runtime. Hay un buen grado de complejidad implicado en mezclar el código administrado de Visual Basic con código no administrado desde COM. Cuando se agrega una referencia a un objeto COM, Visual Basic busca un ensamblado de interoperabilidad primario (PIA) para esa biblioteca. Si encuentra uno, usará. Si no encuentra un PIA, a continuación, crea un ensamblado de interoperabilidad que contiene clases de interoperabilidad locales para cada clase en la biblioteca COM. Para obtener más información, consulte [interoperabilidad COM en aplicaciones de .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Normalmente debe usar objetos con enlace seguro y ensamblados de interoperabilidad primarios, siempre que sea posible. Los ejemplos siguientes se usa el `CreateObject` solo con fines de función con objetos de Microsoft Office para la demostración. Sin embargo, estos objetos son más fáciles de usar y más confiable cuando se usa con el ensamblado de interoperabilidad primario adecuado.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Creación de un objeto en un equipo remoto  
 Puede crear un objeto en un equipo remoto, pasando el nombre del equipo para el `ServerName` argumento de la `CreateObject` función. Ese nombre es igual a la parte del nombre de la máquina de un nombre de recurso compartido: para un recurso compartido denominado "\\\MyServer\Public," `ServerName` es "MyServer".  
  
> [!NOTE]
>  Consulte la documentación de COM (consulte la Microsoft Developer Network) para obtener más información sobre cómo crear una aplicación accesibles en un equipo remoto. Es posible que deba agregar una clave del registro para la aplicación.  
  
 El código siguiente devuelve el número de versión de una instancia de Excel que se ejecuta en un equipo remoto denominado `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Si el nombre del servidor remoto es incorrecto, o si no está disponible, se produce un error en tiempo de ejecución.  
  
> [!NOTE]
>  Use `CreateObject` cuando no hay ninguna instancia del objeto actual. Si ya se está ejecutando una instancia del objeto, se inicia una nueva instancia y se crea un objeto del tipo especificado. Para usar la instancia actual, o para iniciar la aplicación y cargar un archivo, utilice el `GetObject` función. Si un objeto ha registrado como un objeto de instancia única, solo una instancia del objeto se crea, independientemente de cómo muchas veces `CreateObject` se ejecuta.  
  
## <a name="creating-framework-objects"></a>Crear objetos de Framework  
 Puede usar el `CreateObject` función sólo para crear un objeto COM. Aunque no hay ningún mecanismo equivalente exacto para la creación de un objeto de .NET Framework, el <xref:System.Activator> en el <xref:System> espacio de nombres contiene métodos para crear objetos locales o remotos. En concreto, el <xref:System.Activator.CreateInstance%2A> método o la <xref:System.Activator.CreateInstanceFrom%2A> método podría ser útil.  
  
> [!IMPORTANT]
>  El `CreateObject` función requiere el permiso de código no administrado, lo que podría afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `CreateObject` de función para crear una hoja de cálculo de Microsoft Excel y guarda la hoja de cálculo en un archivo. Para usar este ejemplo, Excel debe instalarse en el equipo donde se ejecuta este programa. Además, debe agregar una referencia a la biblioteca de tipos de la **COM** pestaña de la **Agregar referencia** cuadro de diálogo en el **proyecto** menú. El nombre de la biblioteca de tipos varía según la versión de Excel instalado en el equipo. Por ejemplo, se denomina la biblioteca de tipos para Microsoft Excel 2002 **biblioteca de objetos de Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">El servidor no está disponible.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No existe ningún objeto del tipo especificado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la aplicación o el proyecto al que corresponde la sección o clave.</param>
        <param name="Section">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la sección de la que se va a eliminar la configuración de clave. Si se proporcionan solo <c>AppName</c> y <c>Section</c>, se elimina la sección especificada junto con todas las configuraciones de clave relacionadas.</param>
        <param name="Key">Opcional. Expresión de tipo <see langword="String" /> que contiene el nombre de la configuración de clave que se va a eliminar.</param>
        <summary>Elimina una sección o configuración de clave de la entrada de una aplicación en el Registro de Windows. La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que la función <see langword="DeleteSetting" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se proporcionan todos los argumentos, se elimina la configuración especificada. Se produce un error de tiempo de ejecución si intenta usar `DeleteSetting` en una sección que no existe o el valor de clave.  
  
 `DeleteSetting` requiere que un usuario se conecte ya que funciona bajo el `HKEY_LOCAL_USER` clave del registro, que no está activo hasta que un usuario inicia una sesión interactiva.  
  
 Configuración del registro que van a obtenerse acceso desde un proceso no interactivo (por ejemplo, Mtx.exe) debe almacenarse bajo el `HKEY_LOCAL_MACHINE\Software\` o el `HKEY_USER\DEFAULT\Software` claves del registro.  
  
   
  
## Examples  
 El ejemplo siguiente se usa primero el `SaveSetting` procedimiento para crear entradas en el registro de Windows para el `MyApp` aplicación y, a continuación, utiliza el `DeleteSetting` función para quitarlos. Dado que ningún `Key` argumento se especifica, toda la `Startup` sección se elimina, incluido el nombre de sección y todas sus claves.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El usuario no ha iniciado la sesión.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve la cadena asociada a una variable de entorno del sistema operativo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatorio. Expresión que evalúa una cadena que contiene el nombre de una variable de entorno o un entero correspondiente al orden numérico de una cadena de entorno en la tabla de cadenas de entorno.</param>
        <summary>Devuelve la cadena asociada a una variable de entorno del sistema operativo.</summary>
        <returns>Devuelve la cadena asociada a una variable de entorno del sistema operativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Expression` contiene una cadena, la <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función devuelve el texto asignado a la cadena de entorno especificada; es decir, el texto que sigue al signo igual (=) en la tabla de cadenas de entorno para esa variable de entorno. Si la cadena en `Expression` no se encuentra en la tabla de cadenas de entorno, una cadena de longitud cero ("") se devuelve.  
  
 Si `Expression` contiene un entero, la cadena que se devuelve la posición numérica de la tabla de cadenas de entorno en uso. En este caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> devuelve todo el texto, incluido el nombre de la variable de entorno. Si no hay ninguna cadena de entorno en la posición especificada, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> devuelve una cadena de longitud cero.  
  
> [!IMPORTANT]
>  El <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función requiere el permiso de entorno, lo que podría afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este ejemplo se usa el <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función para proporcionar el número de entrada y la longitud de la `PATH` instrucción desde la tabla de cadenas de entorno.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se encuentra <paramref name="Expression" />.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatorio. Expresión que evalúa una cadena que contiene el nombre de una variable de entorno o un entero correspondiente al orden numérico de una cadena de entorno en la tabla de cadenas de entorno.</param>
        <summary>Devuelve la cadena asociada a una variable de entorno del sistema operativo.</summary>
        <returns>Devuelve la cadena asociada a una variable de entorno del sistema operativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Expression` contiene una cadena, la <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función devuelve el texto asignado a la cadena de entorno especificada; es decir, el texto que sigue al signo igual (=) en la tabla de cadenas de entorno para esa variable de entorno. Si la cadena en `Expression` no se encuentra en la tabla de cadenas de entorno, una cadena de longitud cero ("") se devuelve.  
  
 Si `Expression` contiene un entero, la cadena que se devuelve la posición numérica de la tabla de cadenas de entorno en uso. En este caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> devuelve todo el texto, incluido el nombre de la variable de entorno. Si no hay ninguna cadena de entorno en la posición especificada, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> devuelve una cadena de longitud cero.  
  
> [!IMPORTANT]
>  El <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función requiere el permiso de entorno, lo que podría afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este ejemplo se usa el <xref:Microsoft.VisualBasic.Interaction.Environ%2A> función para proporcionar el número de entrada y la longitud de la `PATH` instrucción desde la tabla de cadenas de entorno.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se encuentra <paramref name="Expression" />.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la aplicación o del proyecto cuya configuración de clave se solicita.</param>
        <param name="Section">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la sección cuya configuración de clave se solicita. <see langword="GetAllSettings" /> devuelve un objeto que contiene una matriz bidimensional de cadenas. Las cadenas contienen todos las configuraciones de clave de la sección especificada, además de sus correspondientes valores.</param>
        <summary>Devuelve una lista de configuraciones de clave y sus respectivos valores (creados originalmente con <see langword="SaveSetting" />) desde la entrada de una aplicación en el Registro de Windows. La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que <see langword="GetAllSettings" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Devuelve una lista de configuraciones de clave y sus respectivos valores (creados originalmente con <see langword="SaveSetting" />) desde la entrada de una aplicación en el Registro de Windows.  
  
La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que <see langword="GetAllSettings" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Devuelve sin inicializar `Object` si `AppName` o `Section` no existe.  
  
 Dado que funciona con el `HKEY_LOCAL_USER` clave del registro, que no está activo hasta que un usuario inicia sesión interactivamente `GetAllSettings` requiere que un usuario se ha iniciado sesión.  
  
 Configuración del registro que van a obtenerse acceso desde un proceso no interactivo (por ejemplo, Mtx.exe) debe almacenarse bajo el `HKEY_LOCAL_MACHINE\Software\` o el `HKEY_USER\DEFAULT\Software` claves del registro.  
  
   
  
## Examples  
 Este ejemplo usa primero el `SaveSetting` función para crear entradas en el registro de Windows para la aplicación especificada como `AppName`, a continuación, usa el `GetAllSettings` función para mostrar la configuración. Tenga en cuenta esa aplicación nombres y `Section` nombres no se puede recuperar con `GetAllSettings`. Por último, el `DeleteSetting` función quita las entradas de la aplicación.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El usuario no ha iniciado la sesión.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcional. <see langword="String" />. Ruta de acceso completa y nombre del archivo que contiene el objeto que se va a recuperar. Si se omite <c>PathName</c>, se requiere <c>Class</c>.</param>
        <param name="Class">Es necesario si no se proporciona <c>PathName</c>. <see langword="String" />. Una cadena que representa la clase del objeto. El argumento <c>Class</c> tiene la sintaxis y las partes siguientes: 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
[1|1] Parámetro 
[1|2] Descripción 
[2|1] <c>appname</c>  
  
[2|2] Requerido. <see langword="String" />. Nombre de la aplicación que proporciona el objeto.  
  
[3|1] <c>objecttype</c>  
  
[3|2] Requerido. <see langword="String" />. Tipo o clase del objeto que se va a crear.</param>
        <summary>Devuelve una referencia a un objeto proporcionado por un componente COM.</summary>
        <returns>Devuelve una referencia a un objeto proporcionado por un componente COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `GetObject` función para cargar una instancia de un componente COM desde un archivo. Esto se ilustra en el siguiente ejemplo:  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Cuando se ejecuta este código, la aplicación asociada con los valores especificados `PathName` se inicia y se activa el objeto en el archivo especificado.  
  
## <a name="default-cases"></a>Casos predeterminados  
 Si `PathName` es una cadena de longitud cero (`""`), `GetObject` devuelve una nueva instancia de objeto del tipo de clase especificado. Si el `PathName` argumento se omite, `GetObject` devuelve un objeto activo del tipo de clase especificado en `Class`. Si no existe ningún objeto del tipo especificado, se produce un error.  
  
## <a name="accessing-a-subobject"></a>Acceso a un subobjeto  
 Algunas aplicaciones permiten activar un subobjeto asociado a un archivo. Para ello, agregue un signo de exclamación (`!`) al final del nombre de archivo y siga con una cadena que identifica la parte del archivo que desee activar. Para obtener información sobre cómo crear esta cadena, consulte la documentación de la aplicación que creó el objeto.  
  
 Por ejemplo, en una aplicación de dibujo podría tener varias capas a un dibujo que se almacenan en un archivo. Podría usar el código siguiente para activar una capa en un dibujo denominado `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Especifica una clase  
 Si no especifica el objeto `Class`, automatización determina la aplicación para iniciar y el objeto para activar, según el nombre de archivo proporcionado. Sin embargo, algunos archivos, pueden admitir más de una clase de objeto. Por ejemplo, un dibujo podría admitir tres tipos diferentes de objetos: un `Application` objeto, un `Drawing` objeto y un `Toolbar` objeto, que forman parte del mismo archivo. Para especificar qué objeto en un archivo que desea activar, use el elemento opcional `Class` argumento. Esto se ilustra en el siguiente ejemplo:  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 En el ejemplo anterior, `Figment` es el nombre de una aplicación de dibujo y `Drawing` es uno de los tipos de objeto que admite.  
  
## <a name="using-the-object"></a>Uso del objeto  
 Una vez que se activa un objeto, hacen referencia a él en el código mediante la variable de objeto que se declaró. En el ejemplo anterior, tener acceso a las propiedades y métodos del nuevo objeto mediante la variable de objeto `drawObj`. Esto se ilustra en el siguiente ejemplo:  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Use el `GetObject` funcionar cuando hay una instancia del objeto actual o si desea crear el objeto con un archivo cargado. Si no hay ninguna instancia actual y no desea que el objeto a un archivo cargado, utilice el <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> función.  
>   
>  Si un objeto ha registrado como un objeto de instancia única de ActiveX, solo una instancia del objeto se crea, independientemente de cómo muchas veces `CreateObject` se llama. Con un objeto de instancia única, `GetObject` siempre devuelve la misma instancia cuando se llama con la cadena de longitud cero (`""`) sintaxis y genera un error si el `PathName` argumento se omite. No puede usar `GetObject` para obtener una referencia a una clase creada con Visual Basic.  
  
> [!IMPORTANT]
>  El `GetObject` función requiere el permiso de código no administrado, lo que podría afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `GetObject` función para obtener una referencia a una hoja de cálculo de Excel de Microsoft específico (`excelObj`). Utiliza la hoja de cálculo `Application` propiedad para que Excel sea visible, para cerrarlo y realizar otras acciones. Mediante dos llamadas de API, el `detectExcel` procedimiento busca Excel y, si se está ejecutando, lo escribe en la tabla de objetos de ejecución. La primera llamada a `GetObject` si Excel aún no se está ejecutando, que en este ejemplo, se produce un error provoca la `excelWasNotRunning` marca se establece en `True`. La segunda llamada a `GetObject` especifica un archivo para abrirlo. Si Excel no se está ejecutando, la segunda llamada lo inicia y devuelve una referencia a la hoja de cálculo representada por el archivo especificado, `test.xls`. El archivo debe existir en la ubicación especificada; en caso contrario, Visual Basic produce una <xref:System.IO.FileNotFoundException>. A continuación, hace que el código de ejemplo, Excel y la ventana que contiene la hoja de cálculo especificada.  
  
 Este ejemplo requiere `Option Strict Off` dado que usa el enlace en tiempo de ejecución, donde los objetos se asignan a variables de tipo `Object`. Puede especificar `Option Strict On` y declarar objetos de tipos de objetos específicos si agrega una referencia a la biblioteca de tipos de Excel desde el **COM** pestaña de la **Agregar referencia** cuadro de diálogo de la ** Proyecto** menú en Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Cuando se llama a la `getExcel` función, se realiza una comprobación para ver si ya se está ejecutando Excel. Si no es así, se crea una instancia.  
  
> [!IMPORTANT]
>  Por motivos de simplicidad, en el ejemplo anterior se supone que cualquier ventana denominada `XLMAIN` pertenece a una instancia de Microsoft Excel. Si otro objeto, posiblemente iniciado por una manipulación ilícita, crea una ventana con ese nombre, recibiría todos los mensajes destinados a Excel. En una aplicación que se usará para la producción, debe incluir algunas más rigurosas pruebas para comprobar que `XLMAIN` pertenece realmente a Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">No existe ningún objeto del tipo de clase especificado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No existe ningún objeto con la ruta de acceso y el nombre de archivo especificados.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la aplicación o del proyecto cuyo valor de clave se solicita.</param>
        <param name="Section">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la sección donde se encuentra la configuración de clave.</param>
        <param name="Key">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la configuración de clave que se va a devolver.</param>
        <param name="Default">Opcional. Expresión que contiene el valor que se va a devolver si no se ha establecido ningún valor en la configuración de <c>Key</c>. Si se omite, se supone que <c>Default</c> es una cadena de longitud cero ("").</param>
        <summary>Devuelve un valor de configuración de clave desde la entrada de una aplicación en el Registro de Windows. La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que <see langword="GetAllSettings" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Devuelve un valor de configuración de clave desde la entrada de una aplicación en el Registro de Windows.  
  
La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cualquiera de los elementos con nombre en el `GetSetting` argumentos no existen, `GetSetting` devuelve un valor de `Default`.  
  
 Dado que funciona con el `HKEY_LOCAL_USER` clave del registro, que no está activo hasta que un usuario inicia sesión interactivamente `GetSetting` requiere que un usuario se ha iniciado sesión.  
  
 Configuración del registro que van a obtenerse acceso desde un proceso no interactivo (por ejemplo, Mtx.exe) debe almacenarse bajo el `HKEY_LOCAL_MACHINE\Software\` o el `HKEY_USER\DEFAULT\Software` claves del registro.  
  
 `GetSetting` requiere `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Este ejemplo usa primero el `SaveSetting` función para crear entradas en el registro de Windows para la aplicación especificada como `AppName`y, a continuación, usa el `GetSetting` función para mostrar una de las configuraciones. Dado que el `Default` argumento se especifica, se garantiza que se va a devolver algún valor. Tenga en cuenta que `Section` nombres no se puede recuperar con `GetSetting`. Por último, el `DeleteSetting` función quita todas las entradas de la aplicación.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uno o más argumentos no son expresiones <see langword="String" /> o el usuario no ha iniciado la sesión.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Obligatorio. <see langword="Boolean" />. Expresión que desea evaluar.</param>
        <param name="TruePart">Obligatorio. <see langword="Object" />. Se devuelve si <c>Expression</c> se evalúa como <see langword="True" />.</param>
        <param name="FalsePart">Obligatorio. <see langword="Object" />. Se devuelve si <c>Expression</c> se evalúa como <see langword="False" />.</param>
        <summary>Devuelve uno de dos objetos, dependiendo de la evaluación de una expresión.</summary>
        <returns>Devuelve uno de dos objetos, dependiendo de la evaluación de una expresión.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `IIf` función proporciona un equivalente para el ternario [operador condicional:?:](http://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) en Visual C++.  
  
   
  
## Examples  
 Este ejemplo se usa el `IIf` función para evaluar el `testMe` parámetro de la `checkIt` procedimiento y devuelve if "Grande" word la cantidad es mayor que 1000; en caso contrario, devuelve la palabra "Pequeño".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Observe que si `Option Strict` es `On`, debe usar el `CStr` palabra clave se debe convertir explícitamente el valor devuelto de `Object` a `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Es un parámetro necesario. Expresión de tipo <see langword="String" /> que se muestra como mensaje en el cuadro de diálogo. La longitud máxima de <c>Prompt</c> es aproximadamente de 1024 caracteres, en función del ancho de los caracteres usados. Si <c>Prompt</c> consta de más de una línea, puede separar las líneas con un carácter de retorno de carro (<see langword="Chr(" />13<see langword=")" />), un carácter de avance de línea (<see langword="Chr(" />10<see langword=")" />) o una combinación de retorno de carro/avance de línea (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre cada línea.</param>
        <param name="Title">Opcional. Expresión de tipo <see langword="String" /> que se muestra en la barra de título del cuadro de diálogo. Si se omite <c>Title</c>, aparece el nombre de la aplicación en la barra de título.</param>
        <param name="DefaultResponse">Opcional. Expresión de tipo <see langword="String" /> que se muestra en el cuadro de texto como respuesta predeterminada si no se proporciona ninguna entrada. Si se omite <c>DefaultResponse</c>, el cuadro de texto mostrado está vacío.</param>
        <param name="XPos">Opcional. Expresión numérica que especifica, en twips, la distancia entre el borde izquierdo del cuadro de diálogo y el borde izquierdo de la pantalla. Si se omite <c>XPos</c>, el cuadro de diálogo estará centrado horizontalmente.</param>
        <param name="YPos">Opcional. Expresión numérica que especifica, en twips, la distancia entre el borde superior del cuadro de diálogo y la parte superior de la pantalla. Si se omite <c>YPos</c>, el cuadro de diálogo se coloca verticalmente a aproximadamente un tercio de la parte superior de la pantalla.</param>
        <summary>Muestra un mensaje en un cuadro de diálogo, espera a que el usuario escriba texto o haga clic en un botón y, a continuación, devuelve una cadena que contiene el contenido del cuadro de texto.</summary>
        <returns>Muestra un mensaje en un cuadro de diálogo, espera a que el usuario escriba texto o haga clic en un botón y, a continuación, devuelve una cadena que contiene el contenido del cuadro de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el usuario hace clic **cancelar**, se devuelve una cadena de longitud cero.  
  
 Para especificar más que el primer argumento, se debe utilizar el `InputBox` función en una expresión. Si se omite cualquier argumento posicional, debe conservar el delimitador de coma correspondiente.  
  
> [!NOTE]
>  El `InputBox` función requiere `UIPermission` en el <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nivel, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, vea y <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 En este ejemplo se muestra varias maneras de usar el `InputBox` función para pedir al usuario que escriba un valor. Si x e y se omiten las posiciones, automáticamente se centra el cuadro de diálogo para los respectivos ejes. La variable `MyValue` contiene el valor especificado por el usuario si el usuario hace clic en Aceptar o presiona la tecla ENTRAR.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Obligatorio. Expresión de tipo <see langword="String" /> que se muestra como mensaje en el cuadro de diálogo. La longitud máxima de <c>Prompt</c> es aproximadamente de 1024 caracteres, en función del ancho de los caracteres usados. Si <c>Prompt</c> consta de más de una línea, puede separar las líneas con un carácter de retorno de carro (<see langword="Chr(" />13<see langword=")" />), un carácter de avance de línea (<see langword="Chr(" />10<see langword=")" />) o una combinación de carácter de retorno de carro/avance de línea (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre cada línea.</param>
        <param name="Buttons">Opcional. Expresión numérica que es la suma de los valores que especifican el número y el tipo de botones que se van a mostrar, el estilo de icono que se va a utilizar, la identidad del botón predeterminado y la modalidad del cuadro de mensaje. Si se omite <c>Buttons</c>, el valor predeterminado es cero.</param>
        <param name="Title">Opcional. Expresión de tipo <see langword="String" /> que se muestra en la barra de título del cuadro de diálogo. Si se omite <c>Title</c>, aparece el nombre de la aplicación en la barra de título.</param>
        <summary>Muestra un mensaje en un cuadro de diálogo, espera a que el usuario haga clic en un botón y, a continuación, devuelve un entero que indica el botón en el que el usuario ha hecho clic.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Constante </term>
              <description> Valor </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si se omite cualquier argumento posicional, debe conservar el delimitador de coma correspondiente.  
  
 Si el cuadro de diálogo muestra un **cancelar** botón, al presionar la tecla ESC tiene el mismo efecto que al hacer clic en **Cancelar**  
  
 Si el cuadro de diálogo contiene un **ayuda** botón, se proporciona ayuda contextual para el cuadro de diálogo. Sin embargo, se devuelve ningún valor hasta que se elige uno de los otros botones. En las aplicaciones de formulario de Windows, elegir el **ayuda** botón ejecuta el <xref:System.Windows.Forms.Control.HelpRequested> eventos para el formulario.  
  
> [!NOTE]
>  El `MsgBox` función requiere `UIPermission` en el <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nivel, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, vea <xref:System.Security.Permissions.UIPermission>.  
  
 El `MsgBoxStyle` valores de enumeración se enumeran en la tabla siguiente.  
  
|Miembro|Valor|Descripción|  
|-|-|-|  
|Miembro|Valor|Descripción|  
|`OKOnly`|0|Muestra el botón Aceptar sólo.|  
|`OKCancel`|1|Muestra Aceptar y cancelar botones.|  
|`AbortRetryIgnore`|2|Muestra los botones Anular, Reintentar y omitir.|  
|`YesNoCancel`|3|Muestra Yes, No y cancelar los botones.|  
|`YesNo`|4|No muestra los botones Sí y.|  
|`RetryCancel`|5|Muestra los botones Reintentar y Cancelar.|  
|`Critical`|16|Muestra el icono de mensaje crítico.|  
|`Question`|32|Muestra el icono de consulta de advertencia.|  
|`Exclamation`|48|Muestra el icono de mensaje de advertencia.|  
|`Information`|64|Muestra el icono de mensaje de información.|  
|`DefaultButton1`|0|El primer botón es el predeterminado.|  
|`DefaultButton2`|256|El segundo botón es el predeterminado.|  
|`DefaultButton3`|512|El tercer botón es el predeterminado.|  
|`ApplicationModal`|0|La aplicación es modal. El usuario debe responder al cuadro de mensaje antes de continuar trabajando en la aplicación actual.|  
|`SystemModal`|4096|El sistema es modal. Todas las aplicaciones se suspenden hasta que el usuario responde al cuadro de mensaje.|  
|`MsgBoxSetForeground`|65536|Especifica la ventana del cuadro de mensaje como la ventana de primer plano.|  
|`MsgBoxRight`|524288|Texto está alineado a la derecha.|  
|`MsgBoxRtlReading`|1048576|Especifica el texto debe aparecer como derecha a izquierda leer en los sistemas hebreo y árabe.|  
  
 El primer grupo de valores (de 0 a 5) describe el número y tipo de botones que aparecen en el cuadro de diálogo. El segundo grupo (16, 32, 48, 64) describe el estilo de icono. El tercer grupo (0, 256, 512) determina qué botón es el valor predeterminado. El cuarto grupo (0, 4096) determina la modalidad del cuadro de mensaje y el quinto grupo especifica si la ventana del cuadro de mensaje es la ventana de primer plano, junto con la alineación y la dirección del texto. Al agregar números para crear un valor final para el `Buttons` argumento, use solo un número de cada grupo.  
  
   
  
## Examples  
 Este ejemplo se usa el `MsgBox` función para mostrar un mensaje de error crítico en un cuadro de diálogo con botones Sí y No. El botón No se especifica como la respuesta predeterminada. Esto se hace mediante la combinación del `MsgBox` valores constantes en una expresión numérica. En este caso, la suma de 4 (la combinación de botones Sí/No) y 16 (la **mensaje crítico** ventana) y 256 (el segundo botón como botón predeterminado) da un total de 276. El valor devuelto por la `MsgBox` función depende del botón elegido por el usuario: Sí devuelve un valor de 6; No devuelve un valor de 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> no es una expresión <see langword="String" /> o <paramref name="Title" /> no es válido.</exception>
        <exception cref="T:System.InvalidOperationException">El proceso no se está ejecutando en modo interactivo de usuario.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Uno o más parámetros no son miembros de la enumeración <see langword="MsgBoxResult" /> o <see langword="MsgBoxStyle" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Obligatorio. <see langword="Long" />. Número entero que se va a buscar en uno de los intervalos calculados.</param>
        <param name="Start">Obligatorio. <see langword="Long" />. Número entero que indica el inicio del conjunto de intervalos calculados. El valor de <c>Start</c> no puede ser menor que 0.</param>
        <param name="Stop">Obligatorio. <see langword="Long" />. Número entero que indica el final del conjunto de intervalos calculados. <c>Stop</c> no puede ser menor o igual que <c>Start</c>.</param>
        <param name="Interval">Obligatorio. <see langword="Long" />. Número entero que indica el tamaño de cada intervalo calculado entre <c>Start</c> y <c>Stop</c>. El valor de <c>Interval</c> no puede ser menor que 1.</param>
        <summary>Devuelve una cadena que representa el intervalo calculado que contiene un número.</summary>
        <returns>Devuelve una cadena que representa el intervalo calculado que contiene un número.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Partition` función calcula un conjunto de intervalos numéricos, cada uno que contiene el número de valores especificados por `Interval`. El primer intervalo comienza en `Start`, y el último intervalo finaliza en `Stop`. El `Partition` , a continuación, la función identifica qué intervalo contiene `Number` y devuelve una cadena que describe ese intervalo. El intervalo se representa en la cadena como "*lowervalue*:*uppervalue*", donde el valor mínimo del intervalo (*lowervalue*) se separa de la gama alta (* uppervalue*) por dos puntos (:).  
  
 Si es necesario, el `Partition` función inserta espacios iniciales antes de *lowervalue* y *uppervalue* para que tengan el mismo número de caracteres que la representación de cadena del valor (() `Stop` + 1). Esto garantiza que si usa la salida de la `Partition` función con diferentes valores de `Number`, el texto resultante se controlará correctamente durante cualquier operación de ordenación posterior.  
  
 La siguiente tabla muestra algunas cadenas de ejemplo de intervalos calculados mediante tres conjuntos de `Start`, `Stop`, y `Interval`. El "Primer intervalo" y "Último intervalo" columnas muestran los intervalos mínimo y máximo posible dados los valores de `Start` y `Stop`. Las columnas "antes del primer intervalo" y "después del último intervalo" muestran las cadenas devueltas para los valores de `Number` menor `Start` y mayor `Stop`, respectivamente.  
  
|`Start`|`Stop`|`Interval`|Antes del primer intervalo|Primer intervalo|Último intervalo|Después del último intervalo|  
|-|-|-|-|-|-|-|  
|0|99|5|": -1"|"0: 4"|"95: 99"|"100:"|  
|20|199|10|": 19"|"20:29"|"190:199"|"200:"|  
|100|1010|20|": 99"|"100: 119"|"1000:1010"|"1011:"|  
  
 En la tabla anterior, la tercera línea muestra el resultado cuando `Start` y `Stop` definen un conjunto de números que no son divisibles por `Interval`. El último intervalo finaliza en `Stop`, lo que solo 11 números, aunque `Interval` es 20.  
  
 Si `Interval` es 1, el intervalo es "`Number`:`Number`", independientemente de la `Start` y `Stop` argumentos. Por ejemplo, si `Number` es 267, `Stop` es 1000, y `Interval` es 1, `Partition` devuelve "267: 267".  
  
 `Partition` puede ser útil al construir consultas de base de datos. Puede crear una consulta SELECT que muestra cuántos pedidos producen en intervalos de valores distintos, por ejemplo con valores de facturas de 1 a 1000, 1001 a 2000 y así sucesivamente.  
  
   
  
## Examples  
 El ejemplo siguiente se configura una serie de intervalos durante décadas de 1950 a 2049. Busca el valor de `year` dentro del intervalo apropiado y devuelve un `String` que muestra el intervalo. Si `year` tiene un valor de 1984, por ejemplo, `Partition` devuelve "1980: 1989".  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" /> o <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la aplicación o proyecto al que corresponde el valor.</param>
        <param name="Section">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la sección en la que se va a guardar la configuración de clave.</param>
        <param name="Key">Obligatorio. Expresión de tipo <see langword="String" /> que contiene el nombre de la configuración de clave que se va a guardar.</param>
        <param name="Setting">Obligatorio. Expresión que contiene el valor en el que se establece <c>Key</c>.</param>
        <summary>Guarda o crea una entrada de la aplicación en el Registro de Windows. La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones del Registro que <see langword="SaveSetting" />. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `SaveSetting` función agrega la clave a `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Si no se puede guardar la configuración de clave por cualquier motivo, se produce un error.  
  
 `SaveSetting` requiere que un usuario se conecte ya que funciona bajo el `HKEY_LOCAL_USER` clave del registro, que no está activo hasta que un usuario inicia una sesión interactiva.  
  
 Configuración del registro que van a obtenerse acceso desde un proceso no interactivo (por ejemplo, Mtx.exe) debe almacenarse bajo el `HKEY_LOCAL_MACHINE\Software\` o el `HKEY_USER\DEFAULT\Software` claves del registro.  
  
 `SaveSetting` requiere `Write` y `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 El ejemplo siguiente se usa primero el `SaveSetting` función para crear entradas en el registro de Windows para el `MyApp` aplicación y, a continuación, utiliza el `DeleteSetting` función para quitarlos.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">No se puede crear el Registro de clave o el usuario no ha iniciado la sesión.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (Pathname, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. <see langword="String" />. Nombre del programa que se va a ejecutar, junto con los argumentos y modificadores de línea de comandos necesarios. <c>PathName</c> también puede incluir la unidad y la ruta de acceso al directorio o la carpeta.  
  
Si se desconoce la ruta de acceso al programa, se puede utilizar <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> para buscarla. Por ejemplo, puede llamar a <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, que devuelve la ruta de acceso completa de cada archivo denominado <c>testFile.txt</c> en cualquier lugar de la unidad C:\\.</param>
        <param name="Pathname">To be added.</param>
        <param name="Style">Opcional. <see langword="AppWinStyle" />. Un valor elegido de <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> que especifica el estilo de la ventana en la que se va a ejecutar el programa. Si se omite <c>Style</c>, <see langword="Shell" /> usa <see langword="AppWinStyle.MinimizedFocus" />, que inicia el programa de manera minimizada y con foco.</param>
        <param name="Wait">Opcional. <see langword="Boolean" />. Un valor que indica si la función <see langword="Shell" /> debe esperar a que finalice el programa. Si se omite <c>Wait</c>, <see langword="Shell" /> usa <see langword="False" />.</param>
        <param name="Timeout">Opcional. <see langword="Integer" />. Número de milisegundos que se va a esperar a que finalice si el valor de <c>Wait</c> es <see langword="True" />. Si se omite <c>Timeout</c>, <see langword="Shell" /> usa -1, lo que significa que no hay tiempo de espera y <see langword="Shell" /> no devuelve ningún valor hasta que finaliza el programa. Por consiguiente, si se omite <c>Timeout</c> o se establece en -1, es posible que <see langword="Shell" /> nunca devuelva el control al programa.</param>
        <summary>Ejecuta un programa ejecutable y devuelve un entero que contiene el identificador de proceso del programa si aún se está ejecutando.</summary>
        <returns>Ejecuta un programa ejecutable y devuelve un entero que contiene el identificador de proceso del programa si aún se está ejecutando.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El valor devuelto de la `Shell` función depende de si el programa se denomina en `PathName` todavía se está ejecutando cuando `Shell` devuelve. Si establece `Wait` a `True` y el programa finaliza antes de que expire el tiempo de espera, `Shell` devuelve cero. Si se agota el tiempo de espera, o si se omite `Wait` o establézcalo en `False`, `Shell` devuelve el identificador de proceso del programa. El identificador de proceso es un número único que identifica el programa en ejecución.  
  
## <a name="failure-to-start"></a>Error al iniciar  
 Si el `Shell` función no puede iniciar el programa con nombre, un <xref:System.IO.FileNotFoundException> se produce el error. Esto puede ocurrir, por ejemplo, cuando se intenta ejecutar un programa de 16 bits, como `command.com`, desde una aplicación mediante <xref:System.Windows.Forms?displayProperty=nameWithType>. Para obtener una solución, puede ejecutar un programa de 32 bits que llama al programa de 16 bits deseado. En el caso de `command.com`, puede ejecutar `cmd.exe` como alternativa.  
  
## <a name="waiting-for-completion"></a>Esperar la finalización  
 De forma predeterminada, el `Shell` función ejecuta el programa de forma asincrónica. Esto significa que un programa iniciado con el `Shell` función no es posible que termine de ejecutarse antes de las instrucciones que siguen el `Shell` se ejecuta la función. Si desea esperar para que el programa termine antes de continuar, establezca `Wait` a `True`.  
  
## <a name="determining-the-exit-code"></a>Determinar el código de salida  
 Un proceso puede devolver un *código de salida* cuando finaliza. Sin embargo, no puede usar `Shell` para recuperar este código de salida porque `Shell` devuelve cero si espera para la terminación y también porque el proceso se ejecuta en un objeto diferente de `Shell`.  
  
 Para recuperar el código de salida de un proceso, debe escribir su propio código para iniciar el proceso y esperar a que finalice. El ejemplo siguiente muestra cómo iniciar un proceso, espere a que termine y recuperar su código de salida.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Protección de la especificación de archivo  
 Siempre debe incluir toda la especificación de ruta de acceso y comillas, como se muestra en el ejemplo siguiente.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Cada par de comillas dobles adyacentes (`" "`) dentro de la cadena literal se interpreta como carácter de una comilla doble en la cadena. Por lo tanto, en el ejemplo anterior se presenta la siguiente cadena para la `Shell` función:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Si no tenía la ruta de acceso entre comillas, Windows buscaría un archivo denominado `Program.exe` en el directorio C:\, en lugar de `display.exe` en el directorio C:\Program Files.  
  
> [!IMPORTANT]
>  Si la especificación de ruta de acceso y no se coloca entre comillas, hay un riesgo de seguridad si el nombre de archivo o un nodo de ruta de acceso contiene espacios en blanco. En el ejemplo anterior, el nodo de ruta de acceso `\Program Files` incluye un espacio. Si la especificación no estaban dentro de las comillas y un programa denominado `Program.exe` había instalado en C:\\, por ejemplo por una manipulación ilícita, Windows lo ejecutará en lugar de `display.exe`.  
  
> [!IMPORTANT]
>  El `Shell` función requiere el permiso de código no administrado, lo que podría afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Shell` función que se ejecuta una aplicación especificada por el usuario. Especificar <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> como el segundo argumento, se abre la aplicación en su tamaño normal y le da el foco.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> está fuera del intervalo comprendido entre 0 y 9, ambos inclusive.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> no puede encontrar el archivo <paramref name="PathName" />.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> es <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Obligatorio. Matriz de parámetros<see langword="Object" />. Debe tener un número par de elementos. Se puede proporcionar una lista de las expresiones o variables de <see langword="Object" /> separadas por comas o una matriz unidimensional de elementos <see langword="Object" />.</param>
        <summary>Evalúa una lista de expresiones y devuelve un valor de <see langword="Object" /> correspondiente a la primera expresión de la lista que es <see langword="True" />.</summary>
        <returns>Evalúa una lista de expresiones y devuelve un valor de <see langword="Object" /> correspondiente a la primera expresión de la lista que es <see langword="True" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El argumento proporcionado a `VarExpr` consta de pares de expresiones y valores. El `Switch` función evalúa las expresiones con numeración impar de menor a índice más alto en `VarExpr`y devuelve el valor de pares asociado con la primera expresión se evalúa como `True`. Por ejemplo, si `VarExpr(0)` es `True`, `Switch` devuelve `VarExpr(1)`y si `VarExpr(0)` es `False` pero `VarExpr(2)` es `True`, `Switch` devuelve `VarExpr(3)`, y así sucesivamente.  
  
 Si no se suministra el `VarExpr` argumento, `Switch` devuelve `Nothing`.  
  
> [!NOTE]
>  Las expresiones en la lista de argumentos pueden incluir llamadas a funciones. Como parte de la preparación de la lista de argumentos para la llamada a `Switch`, el compilador de Visual Basic llama a cada función en todas las expresiones. Esto significa que no se puede confiar en una función concreta no se llama si una expresión anterior en la lista de argumentos es `True`.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el `Switch` función para devolver el nombre de un idioma que coincide con el nombre de una ciudad. Requiere que `Option Strict` ser `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Dado que el <xref:System.Diagnostics> espacio de nombres también contiene una clase denominada <xref:System.Diagnostics.Switch>, una llamada a la `Switch` función debe calificarse con el <xref:Microsoft.VisualBasic> espacio de nombres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El número de argumentos es impar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>