<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FileSystem.xml" source-language="en-US" target-language="es-ES">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5588728944ca294baca2932f2aae0887dfd3ec4be.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">588728944ca294baca2932f2aae0887dfd3ec4be</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="FileSystem" /&gt;</ph> module contains the procedures that are used to perform file, directory or folder, and system operations.</source>
          <target state="translated">El módulo <ph id="ph1">&lt;see langword="FileSystem" /&gt;</ph> contiene los procedimientos utilizados para realizar operaciones con archivos, directorios o carpetas y del sistema.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than using the <ph id="ph2">&lt;see langword="FileSystem" /&gt;</ph> module.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona mayor productividad y rendimiento en las operaciones de E/S con archivos que el módulo <ph id="ph2">&lt;see langword="FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>This module supports the Visual Basic language keywords and run-time library members that access files and folders.</source>
          <target state="translated">Este módulo admite las palabras clave del lenguaje Visual Basic y miembros de la biblioteca de tiempo de ejecución que tienen acceso a archivos y carpetas.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>This example uses the <ph id="ph1">`GetAttr`</ph> function to determine the attributes of a file and directory or folder.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`GetAttr`</ph> función para determinar los atributos de un archivo, directorio o carpeta.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>A <ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that identifies which directory or folder becomes the new default directory or folder.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que identifica el directorio o la carpeta que se convierte en el nuevo directorio predeterminado o la nueva carpeta predeterminada.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> may include the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> puede incluir la unidad.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>If no drive is specified, <ph id="ph1">&lt;see langword="ChDir" /&gt;</ph> changes the default directory or folder on the current drive.</source>
          <target state="translated">Si no se especifica ninguna unidad, <ph id="ph1">&lt;see langword="ChDir" /&gt;</ph> cambia el directorio predeterminado o la carpeta predeterminada en la unidad actual.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>Changes the current directory or folder.</source>
          <target state="translated">Cambia el directorio o la carpeta actual.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than the <ph id="ph2">&lt;see langword="ChDir" /&gt;</ph> function.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona mayor productividad y rendimiento que la función <ph id="ph2">&lt;see langword="ChDir" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>The <ph id="ph1">`ChDir`</ph> function changes the default directory, but not the default drive.</source>
          <target state="translated">El <ph id="ph1">`ChDir`</ph> función cambia el directorio predeterminado, pero no la unidad predeterminada.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</source>
          <target state="translated">Por ejemplo, si la unidad predeterminada es C, la siguiente instrucción cambia el directorio predeterminado en la unidad D, pero C sigue siendo la unidad predeterminada:</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>You can make relative directory changes is by typing two periods, as follows:</source>
          <target state="translated">Hacer que sea relativa es cambios en el directorio, escriba dos puntos, como se indica a continuación:</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>The <ph id="ph1">`ChDir`</ph> function requires unmanaged code permission, which may affect its execution in partial-trust situations.</source>
          <target state="translated">El <ph id="ph1">`ChDir`</ph> función requiere un permiso de código no administrado, que puede afectar a su ejecución en situaciones de confianza parcial.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> y.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>This example uses the <ph id="ph1">`ChDir`</ph> function to change the current directory or folder.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`ChDir`</ph> función puede cambiar el directorio actual o una carpeta.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> está vacía.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)">
          <source>Invalid drive is specified, or drive is unavailable.</source>
          <target state="translated">Se ha especificado una unidad no válida o la unidad no está disponible.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Changes the current drive.</source>
          <target state="translated">Cambia la unidad actual.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>String expression that specifies an existing drive.</source>
          <target state="translated">Expresión de cadena que especifica una unidad existente.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>If you supply a zero-length string (""), the current drive does not change.</source>
          <target state="translated">Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> argument is a multiple-character string, <ph id="ph1">&lt;see langword="ChDrive" /&gt;</ph> uses only the first letter.</source>
          <target state="translated">Si el argumento <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> es una cadena de varios caracteres, <ph id="ph1">&lt;see langword="ChDrive" /&gt;</ph> usa solo la primera letra.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>Changes the current drive.</source>
          <target state="translated">Cambia la unidad actual.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>The <ph id="ph1">`ChDrive`</ph> function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</source>
          <target state="translated">El <ph id="ph1">`ChDrive`</ph> función requiere un permiso de código no administrado, que puede afectar a su ejecución en situaciones de confianza parcial.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and <bpt id="p1">[</bpt>Code Access Permissions<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> y <bpt id="p1">[</bpt>permisos de acceso del código<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>This example uses the <ph id="ph1">`ChDrive`</ph> function to change the current drive.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`ChDrive`</ph> función puede cambiar la unidad actual.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>The function throws an exception if the drive does not exist.</source>
          <target state="translated">La función produce una excepción si la unidad no existe.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)">
          <source>Invalid drive is specified, or drive is unavailable.</source>
          <target state="translated">Se ha especificado una unidad no válida o la unidad no está disponible.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>String expression that specifies an existing drive.</source>
          <target state="translated">Expresión de cadena que especifica una unidad existente.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>If you supply a zero-length string (""), the current drive does not change.</source>
          <target state="translated">Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> argument is a multiple-character string, <ph id="ph1">&lt;see langword="ChDrive" /&gt;</ph> uses only the first letter.</source>
          <target state="translated">Si el argumento <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> es una cadena de varios caracteres, <ph id="ph1">&lt;see langword="ChDrive" /&gt;</ph> usa solo la primera letra.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>Changes the current drive.</source>
          <target state="translated">Cambia la unidad actual.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>The <ph id="ph1">`ChDrive`</ph> function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</source>
          <target state="translated">El <ph id="ph1">`ChDrive`</ph> función requiere un permiso de código no administrado, que puede afectar a su ejecución en situaciones de confianza parcial.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> and <bpt id="p1">[</bpt>Code Access Permissions<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <ph id="ph1">&lt;xref:System.Security.Permissions.SecurityPermission&gt;</ph> y <bpt id="p1">[</bpt>permisos de acceso del código<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>This example uses the <ph id="ph1">`ChDrive`</ph> function to change the current drive.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`ChDrive`</ph> función puede cambiar la unidad actual.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>The function throws an exception if the drive does not exist.</source>
          <target state="translated">La función produce una excepción si la unidad no existe.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)">
          <source>Invalid drive is specified, or drive is unavailable.</source>
          <target state="translated">Se ha especificado una unidad no válida o la unidad no está disponible.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Returns a string representing the current path.</source>
          <target state="translated">Devuelve una cadena que representa la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> ofrece más productividad y rendimiento que <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph> en las operaciones de E/S de archivo.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir">
          <source>Returns a string representing the current path.</source>
          <target state="translated">Devuelve una cadena que representa la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> ofrece más productividad y rendimiento que <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph> en las operaciones de E/S de archivo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir">
          <source>A string representing the current path.</source>
          <target state="translated">Una cadena que representa la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.CurDir">
          <source>This example uses the <ph id="ph1">`CurDir`</ph> function to return the current path.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`CurDir`</ph> función para devolver la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source><ph id="ph1">&lt;see langword="Char" /&gt;</ph> expression that specifies an existing drive.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="Char" /&gt;</ph> que especifica una unidad existente.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>If no drive is specified, or if <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> is a zero-length string (""), <ph id="ph1">&lt;see langword="CurDir" /&gt;</ph> returns the path for the current drive.</source>
          <target state="translated">Si no se especifica ninguna unidad o si <bpt id="p1">&lt;c&gt;</bpt>Drive<ept id="p1">&lt;/c&gt;</ept> es una cadena de longitud cero (""), <ph id="ph1">&lt;see langword="CurDir" /&gt;</ph> devuelve la ruta de acceso a la unidad actual.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>Returns a string representing the current path.</source>
          <target state="translated">Devuelve una cadena que representa la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> ofrece más productividad y rendimiento que <ph id="ph2">&lt;see langword="CurDir" /&gt;</ph> en las operaciones de E/S de archivo.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>For more information, see <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>A string representing the current path.</source>
          <target state="translated">Una cadena que representa la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)">
          <source>This example uses the <ph id="ph1">`CurDir`</ph> function to return the current path.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`CurDir`</ph> función para devolver la ruta de acceso actual.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</source>
          <target state="translated">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> function.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> proporciona más productividad y rendimiento que la función <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>See <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</source>
          <target state="translated">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> function.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> proporciona más productividad y rendimiento que la función <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>See <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</source>
          <target state="translated">Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>The <ph id="ph1">`Dir`</ph> function supports the use of multiple-character (<ph id="ph2">`*`</ph>) and single-character (<ph id="ph3">`?`</ph>) wildcards to specify multiple files.</source>
          <target state="translated">El <ph id="ph1">`Dir`</ph> función admite el uso de varios caracteres (<ph id="ph2">`*`</ph>) ni un único carácter (<ph id="ph3">`?`</ph>) caracteres comodín para especificar varios archivos.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source><ph id="ph1">`VbVolume`</ph> returns the volume label for the drive instead of a specific file name.</source>
          <target state="translated"><ph id="ph1">`VbVolume`</ph> Devuelve la etiqueta de volumen de la unidad en lugar de un nombre de archivo específico.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>You must supply a <ph id="ph1">`PathName`</ph> the first time that you call the <ph id="ph2">`Dir`</ph> function.</source>
          <target state="translated">Debe proporcionar un <ph id="ph1">`PathName`</ph> la primera vez que se llama a la <ph id="ph2">`Dir`</ph> (función).</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>To retrieve the next item, you can make subsequent calls to the <ph id="ph1">`Dir`</ph> function without parameters.</source>
          <target state="translated">Para recuperar el siguiente elemento, puede realizar llamadas posteriores a la <ph id="ph1">`Dir`</ph> función sin parámetros.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>To run correctly, the <ph id="ph1">`Dir`</ph> function requires the <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph> flags of <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.</source>
          <target state="translated">Para que se ejecute correctamente, el <ph id="ph1">`Dir`</ph> función requiere el <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> y <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph> marcas de <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> va a conceder al código de ejecución.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>, and <bpt id="p1">[</bpt>Code Access Permissions<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>, y <bpt id="p1">[</bpt>permisos de acceso del código<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>The <ph id="ph1">`Attributes`</ph> argument enumeration values are as follows:</source>
          <target state="translated">El <ph id="ph1">`Attributes`</ph> valores de enumeración del argumento son los siguientes:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Constant</source>
          <target state="translated">Constante</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Default.</source>
          <target state="translated">Predeterminado</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies files without attributes.</source>
          <target state="translated">Especifica los archivos sin atributos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies read-only files, and also files without attributes.</source>
          <target state="translated">Especifica archivos de sólo lectura y también los archivos sin atributos.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies hidden files, and also files without attributes.</source>
          <target state="translated">Especifica los archivos ocultos y también los archivos sin atributos.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies system files, and also files without attributes.</source>
          <target state="translated">Especifica los archivos del sistema y también los archivos sin atributos.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies volume label; if any other attribute is specified, <ph id="ph1">`vbVolume`</ph> is ignored.</source>
          <target state="translated">Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, <ph id="ph1">`vbVolume`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>Specifies directories or folders, and also files without attributes.</source>
          <target state="translated">Especifica los directorios o carpetas y también los archivos sin atributos.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>File has changed since last backup.</source>
          <target state="translated">El archivo ha cambiado desde que se realizó la última copia de seguridad.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>File has a different name.</source>
          <target state="translated">El archivo tiene un nombre diferente.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</source>
          <target state="translated">Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden usarse en cualquier lugar en el código en lugar de los valores reales.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir">
          <source>This example uses the <ph id="ph1">`Dir`</ph> function to check if certain files and directories exist.</source>
          <target state="translated">Este ejemplo se utiliza el <ph id="ph1">`Dir`</ph> para comprobar si existen determinados archivos y directorios.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file name, directory or folder name, or drive volume label.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un nombre de archivo, directorio o carpeta, o bien, la etiqueta de volumen de la unidad.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>A zero-length string (<ph id="ph1">&lt;see langword="&amp;quot;&amp;quot;" /&gt;</ph>) is returned if <bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> is not found.</source>
          <target state="translated">Si no se encuentra <bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept>, se devuelve una cadena de longitud cero (<ph id="ph1">&lt;see langword="&amp;quot;&amp;quot;" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Enumeration or numeric expression whose value specifies file attributes.</source>
          <target state="translated">Enumeración o expresión numérica cuyo valor especifica los atributos de archivo.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>If omitted, <ph id="ph1">&lt;see langword="Dir" /&gt;</ph> returns files that match <bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> but have no attributes.</source>
          <target state="translated">Si se omite, <ph id="ph1">&lt;see langword="Dir" /&gt;</ph> devuelve archivos que coinciden con <bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> pero que no tienen ningún atributo.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</source>
          <target state="translated">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> function.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> proporciona más productividad y rendimiento que la función <ph id="ph2">&lt;see langword="Dir" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>See <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</source>
          <target state="translated">Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The <ph id="ph1">`Dir`</ph> function supports the use of multiple-character (<ph id="ph2">`*`</ph>) and single-character (<ph id="ph3">`?`</ph>) wildcards to specify multiple files.</source>
          <target state="translated">El <ph id="ph1">`Dir`</ph> función admite el uso de varios caracteres (<ph id="ph2">`*`</ph>) ni un único carácter (<ph id="ph3">`?`</ph>) caracteres comodín para especificar varios archivos.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source><ph id="ph1">`VbVolume`</ph> returns the volume label for the drive instead of a specific file name.</source>
          <target state="translated"><ph id="ph1">`VbVolume`</ph> Devuelve la etiqueta de volumen de la unidad en lugar de un nombre de archivo específico.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>You must supply a <ph id="ph1">`PathName`</ph> the first time that you call the <ph id="ph2">`Dir`</ph> function.</source>
          <target state="translated">Debe proporcionar un <ph id="ph1">`PathName`</ph> la primera vez que se llama a la <ph id="ph2">`Dir`</ph> (función).</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>To retrieve the next item, you can make subsequent calls to the <ph id="ph1">`Dir`</ph> function with no parameters.</source>
          <target state="translated">Para recuperar el siguiente elemento, puede realizar llamadas posteriores a la <ph id="ph1">`Dir`</ph> función sin parámetros.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>To run correctly, the <ph id="ph1">`Dir`</ph> function requires the <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> and <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph> flags of <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.</source>
          <target state="translated">Para que se ejecute correctamente, el <ph id="ph1">`Dir`</ph> función requiere el <ph id="ph2">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.Read&gt;</ph> y <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery&gt;</ph> marcas de <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> va a conceder al código de ejecución.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>, and <bpt id="p1">[</bpt>Code Access Permissions<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph>, <ph id="ph2">&lt;xref:System.Security.SecurityException&gt;</ph>, y <bpt id="p1">[</bpt>permisos de acceso del código<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The <ph id="ph1">`Attributes`</ph> argument enumeration values are as follows:</source>
          <target state="translated">El <ph id="ph1">`Attributes`</ph> valores de enumeración del argumento son los siguientes:</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Constant</source>
          <target state="translated">Constante</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Default.</source>
          <target state="translated">Predeterminado</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies files that have no attributes.</source>
          <target state="translated">Especifica los archivos que no tienen atributos.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies read-only files, in addition to files that have no attributes.</source>
          <target state="translated">Especifica los archivos de solo lectura, además de los archivos que no tienen atributos.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies hidden files, in addition to files that have no attributes.</source>
          <target state="translated">Especifica los archivos ocultos, además de los archivos que no tienen atributos.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies system files, in addition to files that have no attributes.</source>
          <target state="translated">Especifica los archivos del sistema, además de los archivos que no tienen atributos.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies volume label; if any other attribute is specified, <ph id="ph1">`vbVolume`</ph> is ignored.</source>
          <target state="translated">Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, <ph id="ph1">`vbVolume`</ph> se omite.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Specifies directories or folders, in addition to files that have no attributes.</source>
          <target state="translated">Especifica los directorios o carpetas, además de los archivos que no tienen atributos.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>File has changed since last backup.</source>
          <target state="translated">El archivo ha cambiado desde que se realizó la última copia de seguridad.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>File has a different name.</source>
          <target state="translated">El archivo tiene un nombre diferente.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</source>
          <target state="translated">Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden usarse en cualquier lugar del código en lugar de los valores reales.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>This example uses the <ph id="ph1">`Dir`</ph> function to check if certain files and directories exist.</source>
          <target state="translated">Este ejemplo se utiliza el <ph id="ph1">`Dir`</ph> para comprobar si existen determinados archivos y directorios.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> that contains any valid file number.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>Returns a Boolean value <ph id="ph1">&lt;see langword="True" /&gt;</ph> when the end of a file opened for <ph id="ph2">&lt;see langword="Random" /&gt;</ph> or sequential <ph id="ph3">&lt;see langword="Input" /&gt;</ph> has been reached.</source>
          <target state="translated">Devuelve un valor booleano o <ph id="ph1">&lt;see langword="True" /&gt;</ph> cuando se alcanza el final de un archivo abierto para <ph id="ph2">&lt;see langword="Random" /&gt;</ph> o <ph id="ph3">&lt;see langword="Input" /&gt;</ph> secuencial.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>Returns a Boolean value <ph id="ph1">&lt;see langword="True" /&gt;</ph> when the end of a file opened for <ph id="ph2">&lt;see langword="Random" /&gt;</ph> or sequential <ph id="ph3">&lt;see langword="Input" /&gt;</ph> has been reached.</source>
          <target state="translated">Devuelve un valor booleano o <ph id="ph1">&lt;see langword="True" /&gt;</ph> cuando se alcanza el final de un archivo abierto para <ph id="ph2">&lt;see langword="Random" /&gt;</ph> o <ph id="ph3">&lt;see langword="Input" /&gt;</ph> secuencial.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>Use <ph id="ph1">`EOF`</ph> to avoid the error generated by attempting to get input past the end of a file.</source>
          <target state="translated">Use <ph id="ph1">`EOF`</ph> para evitar el error generado al intentar obtener datos más allá del final de un archivo.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>The <ph id="ph1">`EOF`</ph> function returns <ph id="ph2">`False`</ph> until the end of the file has been reached.</source>
          <target state="translated">El <ph id="ph1">`EOF`</ph> función devuelve <ph id="ph2">`False`</ph> hasta que se ha alcanzado el final del archivo.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>With files opened for <ph id="ph1">`Random`</ph> or <ph id="ph2">`Binary`</ph> access, <ph id="ph3">`EOF`</ph> returns <ph id="ph4">`False`</ph> until the last executed <ph id="ph5">`FileGet`</ph> function is unable to read a whole record.</source>
          <target state="translated">Con archivos abiertos para <ph id="ph1">`Random`</ph> o <ph id="ph2">`Binary`</ph> acceso, <ph id="ph3">`EOF`</ph> devuelve <ph id="ph4">`False`</ph> hasta que ejecute la última <ph id="ph5">`FileGet`</ph> función es no se puede leer un registro completo.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>With files opened for <ph id="ph1">`Binary`</ph> access, an attempt to read through the file using the <ph id="ph2">`Input`</ph> function until <ph id="ph3">`EOF`</ph> returns <ph id="ph4">`True`</ph> generates an error.</source>
          <target state="translated">Con archivos abiertos para <ph id="ph1">`Binary`</ph> tener acceso a un intento de leer el archivo mediante la <ph id="ph2">`Input`</ph> funcionando hasta que <ph id="ph3">`EOF`</ph> devuelve <ph id="ph4">`True`</ph> genera un error.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>Use the <ph id="ph1">`LOF`</ph> and <ph id="ph2">`Loc`</ph> functions instead of <ph id="ph3">`EOF`</ph> when reading binary files with <ph id="ph4">`Input`</ph>, or use <ph id="ph5">`Get`</ph> when using the <ph id="ph6">`EOF`</ph> function.</source>
          <target state="translated">Utilice la <ph id="ph1">`LOF`</ph> y <ph id="ph2">`Loc`</ph> las funciones en lugar de <ph id="ph3">`EOF`</ph> al leer archivos binarios con <ph id="ph4">`Input`</ph>, o use <ph id="ph5">`Get`</ph> cuando se usa el <ph id="ph6">`EOF`</ph> función.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>With files opened for <ph id="ph1">`Output`</ph>, <ph id="ph2">`EOF`</ph> always returns <ph id="ph3">`True`</ph>.</source>
          <target state="translated">Con archivos abiertos para <ph id="ph1">`Output`</ph>, <ph id="ph2">`EOF`</ph> siempre devuelve <ph id="ph3">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>This example uses the <ph id="ph1">`EOF`</ph> function to detect the end of a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`EOF`</ph> función para detectar el final de un archivo.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>This example assumes that <ph id="ph1">`Testfile`</ph> is a text file that contains several lines of text.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`Testfile`</ph> es un archivo de texto que contiene varias líneas de texto.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;see langword="Integer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Integer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>Returns an enumeration representing the file mode for files opened using the <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve una enumeración que representa el modo de archivo de los archivos abiertos mediante la función <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than the <ph id="ph2">&lt;see langword="FileAttr" /&gt;</ph> function.</source>
          <target state="translated">El <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> proporciona más productividad y rendimiento que la función <ph id="ph2">&lt;see langword="FileAttr" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>See <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>The following enumeration values indicate the file access mode:</source>
          <target state="translated">Los siguientes valores de enumeración indican el modo de acceso al archivo:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;item&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;item&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Mode</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Modo</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> 1</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Input" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 2</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Input" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 2</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Output" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 4</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Output" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 4</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Random" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 8</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Random" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 8</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Append" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 32</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><bpt id="p1">&lt;description&gt;</bpt><ph id="ph2">&lt;see langword="OpenMode.Append" /&gt;</ph><ept id="p1">&lt;/description&gt;</ept><ph id="ph3">&lt;/item&gt;</ph><ph id="ph4">&lt;item&gt;</ph><ph id="ph5">&lt;term&gt;</ph> 32</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>This function returns an enumeration representing the file mode for files opened using the <ph id="ph1">`FileOpen`</ph> function.</source>
          <target state="translated">Esta función devuelve una enumeración que representa el modo de archivo para los archivos abiertos con el <ph id="ph1">`FileOpen`</ph> función.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)">
          <source>This example uses the <ph id="ph1">`FileAttr`</ph> function to return the file mode of an open file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileAttr`</ph> función para devolver el modo de archivo de un archivo abierto.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>Parameter array of 0 or more channels to be closed.</source>
          <target state="translated">Matriz de parámetros de 0 o más canales que se van a cerrar.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>Concludes input/output (I/O) to a file opened using the <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Concluye las operaciones de entrada/salida (E/S) en un archivo abierto con la función <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source><ph id="ph1">&lt;see langword="My" /&gt;</ph> gives you better productivity and performance in file I/O operations.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento en las operaciones de E/S de archivo.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>See <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>The <ph id="ph1">`FileClose`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`FileClose`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Read Text from Files with a StreamReader<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)</ept>,<bpt id="p2">[</bpt>How to: Write Text to Files with a StreamWriter<ept id="p2">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)</ept>, and <bpt id="p3">[</bpt>Walkthrough: Manipulating Files and Directories in Visual Basic<ept id="p3">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>Cómo: leer texto de archivos con StreamReader<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)</ept>,<bpt id="p2">[</bpt>Cómo: escribir texto en archivos con StreamReader<ept id="p2">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)</ept>, y <bpt id="p3">[</bpt>Tutorial: manipular archivos y directorios en Visual Basic<ept id="p3">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)</ept>.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>If you omit <ph id="ph1">`FileNumbers`</ph>, all active files opened by the <ph id="ph2">`FileOpen`</ph> function are closed.</source>
          <target state="translated">Si se omite <ph id="ph1">`FileNumbers`</ph>, todos los archivos activos abiertos por el <ph id="ph2">`FileOpen`</ph> función están cerrados.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>When you close files that were opened for <ph id="ph1">`Output`</ph> or <ph id="ph2">`Append`</ph>, the final buffer of output is written to the operating system buffer for that file.</source>
          <target state="translated">Cuando se cierra un archivo que se ha abierto para <ph id="ph1">`Output`</ph> o <ph id="ph2">`Append`</ph>, el último búfer de salida se escribe en el búfer del sistema operativo de ese archivo.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>All buffer space associated with the closed file is released.</source>
          <target state="translated">Todos los asociados con el cerrado de espacio en búfer se libera el archivo.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>When the <ph id="ph1">`FileClose`</ph> function is executed, the association of a file with its file number ends.</source>
          <target state="translated">Cuando el <ph id="ph1">`FileClose`</ph> se ejecuta la función, la asociación de un archivo con su número de extremos.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source>This example uses the <ph id="ph1">`FileClose`</ph> function to close a file opened for <ph id="ph2">`Input`</ph>.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileClose`</ph> función para cerrar un archivo abierto para <ph id="ph2">`Input`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])">
          <source><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> no existe.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies the name of the file to be copied.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica el nombre del archivo que se va a copiar.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>Source<ept id="p1">&lt;/c&gt;</ept> may include the directory or folder, and drive, of the source file.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>Source<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o la carpeta del archivo de origen, así como la unidad.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies the destination file name.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica el nombre del archivo de destino.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>Destination<ept id="p1">&lt;/c&gt;</ept> may include the directory or folder, and drive, of the destination file.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>Destination<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o la carpeta del archivo de destino, así como la unidad.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>Copies a file.</source>
          <target state="translated">Copia un archivo.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileCopy" /&gt;</ph>.</source>
          <target state="translated">El objeto <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> ofrece más productividad y rendimiento que <ph id="ph2">&lt;see langword="FileCopy" /&gt;</ph> en las operaciones de E/S de archivo.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>See <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /&gt;</ph> for more information.</source>
          <target state="translated">Vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /&gt;</ph> para obtener más información.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>If you try to use the <ph id="ph1">`FileCopy`</ph> function on a currently open file, an error occurs.</source>
          <target state="translated">Si intenta utilizar el <ph id="ph1">`FileCopy`</ph> funcionen en un archivo abierto actualmente, se produce un error.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><ph id="ph1">`FileCopy`</ph> requires full trust to work on the local drive.</source>
          <target state="translated"><ph id="ph1">`FileCopy`</ph> requiere plena confianza para que funcione en la unidad local.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>This example uses the <ph id="ph1">`FileCopy`</ph> function to copy one file to another.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileCopy`</ph> función para copiar un archivo a otro.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>For purposes of this example, assume that <ph id="ph1">`SrcFile`</ph> is a file that contains data.</source>
          <target state="translated">Para fines de este ejemplo, se asume que <ph id="ph1">`SrcFile`</ph> es un archivo que contiene datos.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="Source" /&gt;</ph> or <ph id="ph2">&lt;paramref name="Destination" /&gt;</ph> is invalid or not specified.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="Source" /&gt;</ph> o <ph id="ph2">&lt;paramref name="Destination" /&gt;</ph> no son válidos o no se especifican.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>File is already open.</source>
          <target state="translated">El archivo ya está abierto.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)">
          <source>File does not exist.</source>
          <target state="translated">No existe el archivo.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file name.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un nombre de archivo.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> may include the directory or folder, and the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o carpeta y la unidad.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="Date" /&gt;</ph> value that indicates the date and time a file was written to.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Date" /&gt;</ph> que indica la fecha y hora en que se escribió un archivo.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileDateTime" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileDateTime" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph></source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source><ph id="ph1">&lt;see langword="Date" /&gt;</ph> value that indicates the date and time a file was created or last modified.</source>
          <target state="translated">Valor de tipo <ph id="ph1">&lt;see langword="Date" /&gt;</ph> que indica la fecha y hora de creación o de la última modificación de un archivo.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>This example uses the <ph id="ph1">`FileDateTime`</ph> function to determine the date and time a file was created or last modified.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileDateTime`</ph> función para determinar la fecha y la hora de un archivo se creó o modificó por última vez.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>The format of the date and time displayed is based on the locale settings of the system.</source>
          <target state="translated">El formato de la fecha y hora que se muestra se basa en la configuración regional del sistema.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source><ph id="ph1">&lt;paramref name="PathName" /&gt;</ph> is invalid or contains wildcards.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="PathName" /&gt;</ph> no es válido o contiene caracteres comodín.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)">
          <source>Target file does not exist.</source>
          <target state="translated">El archivo de destino no existe.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph></source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file with <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo con <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>Reading from a file by using the<ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la<ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file with <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo con <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If the descriptor is not used.</source>
          <target state="translated">Si no se utiliza el descriptor.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Then the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">A continuación, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file with <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo con <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file with <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo con <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function,<ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función,<ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>Reading from a file by using the<ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la<ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Applies only when writing a string.</source>
          <target state="translated">Se aplica sólo al escribir una cadena.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Specifies whether to write a two-byte descriptor for the string that describes the length.</source>
          <target state="translated">Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Applies only when writing an array.</source>
          <target state="translated">Sólo se aplica al escribir una matriz.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</source>
          <target state="translated">Especifica si la matriz debe tratarse como una matriz dinámica y si es necesario un descriptor que describa el tamaño y los límites de la matriz.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Applies only when writing a string.</source>
          <target state="translated">Se aplica sólo al escribir una cadena.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Specifies whether to write a two-byte descriptor for the string that describes the length.</source>
          <target state="translated">Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGet" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Data read with <ph id="ph1">`FileGet`</ph> is usually written to a file by using <ph id="ph2">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGet`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte following the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function (or pointed to by the last <ph id="ph4">`Seek`</ph> function) is read.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte situado después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> función (o señalado por la última <ph id="ph4">`Seek`</ph> función) es de lectura.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGet`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGet`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>By default, if the variable being read into is a string, <ph id="ph1">`FileGet`</ph> reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</source>
          <target state="translated">De forma predeterminada, si la variable que se está leyendo es una cadena, <ph id="ph1">`FileGet`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</source>
          <target state="translated">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor con el tamaño y la dimensión de la matriz.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>When reading the array, you have to match the way the array was written.</source>
          <target state="translated">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If it was written with the descriptor, you have to read the descriptor.</source>
          <target state="translated">Si se escribió con el descriptor, deberá leer el descriptor.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If the descriptor is not used, the size and bounds of the array passed into <ph id="ph1">`FileGet`</ph> determine what to read.</source>
          <target state="translated">Si no se utiliza el descriptor, el tamaño y los límites de la matriz pasan en <ph id="ph1">`FileGet`</ph> determinar qué se debe leer.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The 218 bytes are distributed as follows:</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue:</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>18 bytes for the descriptor: (2 + 8 * 2)</source>
          <target state="translated">18 bytes para el descriptor: (2 + 8 * 2)</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>200 bytes for the data: (5 * 10 * 4).</source>
          <target state="translated">200 bytes para los datos: (10 * 5 * 4).</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being read into is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FileGet`</ph> reads only the variable data.</source>
          <target state="translated">Si la variable que se está leyendo en es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FileGet`</ph> lee sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being read.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePut`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePut`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>This includes any arrays and their descriptors.</source>
          <target state="translated">Esto incluye las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads all variables from disk contiguously; that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGet`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGet`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FileGet`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGet`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>Reading from a file by using the <ph id="ph1">`FileGet`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`FileGet`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Valid variable name into which data is read.</source>
          <target state="translated">Nombre de variable válido en la que se leen los datos.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which reading starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o el número de bytes (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la lectura.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Reads data from an open disk file into a variable.</source>
          <target state="translated">Lee datos de un archivo de disco abierto en una variable.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileGetObject" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileGetObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The <ph id="ph1">`FileGetObject`</ph> function is used instead of <ph id="ph2">`FileGet`</ph> to avoid ambiguities at compile time if type <ph id="ph3">`Object`</ph> is returned instead of another type, such as <ph id="ph4">`Integer`</ph>, <ph id="ph5">`Long`</ph>, <ph id="ph6">`Short`</ph>, and so forth.</source>
          <target state="translated">El <ph id="ph1">`FileGetObject`</ph> función se utiliza en lugar de <ph id="ph2">`FileGet`</ph> para evitar ambigüedades en tiempo de compilación si tipo <ph id="ph3">`Object`</ph> se devuelve en lugar de otro tipo, como <ph id="ph4">`Integer`</ph>, <ph id="ph5">`Long`</ph>, <ph id="ph6">`Short`</ph>, y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If you intend to write out the <ph id="ph1">`Variant`</ph> type, <ph id="ph2">`FileGetObject`</ph> is required.</source>
          <target state="translated">Si desea escribir el <ph id="ph1">`Variant`</ph> tipo, <ph id="ph2">`FileGetObject`</ph> es necesario.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>When in doubt, if you are using an object for the second parameter, it is always suggested that you use <ph id="ph1">`FilePutObject`</ph> and <ph id="ph2">`FileGetObject`</ph>.</source>
          <target state="translated">En caso de duda, si está usando un objeto para el segundo parámetro, se recomienda siempre que utilice <ph id="ph1">`FilePutObject`</ph> y <ph id="ph2">`FileGetObject`</ph>.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source><ph id="ph1">`FileGetObject`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FileGetObject`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Data read with <ph id="ph1">`FileGetObject`</ph> is usually written with <ph id="ph2">`FilePutObject`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`FileGetObject`</ph> normalmente se escriben con <ph id="ph2">`FilePutObject`</ph>.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, <ph id="ph2">`FileGetObject`</ph> reads the record or byte after the last <ph id="ph3">`FileGetObject`</ph> or <ph id="ph4">`FilePutObject`</ph> function (or pointed to by the last <ph id="ph5">`Seek`</ph> function).</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, <ph id="ph2">`FileGetObject`</ph> lee el registro o byte después de la última <ph id="ph3">`FileGetObject`</ph> o <ph id="ph4">`FilePutObject`</ph> función (o señalado por la última <ph id="ph5">`Seek`</ph> función).</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If the length of the data being read is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FileGetObject`</ph> reads subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FileGetObject`</ph> leerá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el principio del registro siguiente se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</source>
          <target state="translated">Dado que no se puede determinar con exactitud la cantidad de datos de relleno, es una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se va a leer.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If the variable being read into is a string, by default <ph id="ph1">`FileGetObject`</ph> reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está leyendo es una cadena, de forma predeterminada <ph id="ph1">`FileGetObject`</ph> lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija y cuando se leen en un archivo, el descriptor de longitud no se escribe.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If you want to read a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea leer una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>If the variable being read into is an array, then the record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">Si la variable que se está leyendo en es una matriz, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 * NumberOfDimensions.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk:</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco:</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2), and 100 bytes for the data (5 * 10 * 4).</source>
          <target state="translated">Los bytes 218 se distribuyen como sigue: 18 bytes para el descriptor (2 + 8 * 2) y 100 bytes para los datos (5 * 10 * 4).</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source><ph id="ph1">`FileGetObject`</ph> reads elements of structures as if each were being read individually, except that there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FileGetObject`</ph> lee los elementos de estructuras como si cada uno de ellos estuviese siendo leído individualmente, salvo que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>On disk, a dynamic array in a user-defined type (written with <ph id="ph1">`FilePutObject`</ph>) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 * NumberOfDimensions.</source>
          <target state="translated">En el disco, la matriz dinámico en un tipo definido por el usuario (escrito con <ph id="ph1">`FilePutObject`</ph>) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 * NumberOfDimensions.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales, incluidas las matrices y sus descriptores.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The <ph id="ph1">&lt;xref:Microsoft.VisualBasic.VBFixedStringAttribute&gt;</ph> class can be applied to string fields in the structures to indicate the size of string when written to disk.</source>
          <target state="translated">La <ph id="ph1">&lt;xref:Microsoft.VisualBasic.VBFixedStringAttribute&gt;</ph> clase puede aplicarse a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, all of the <ph id="ph2">`Random`</ph> rules apply, with these exceptions:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, todos los <ph id="ph2">`Random`</ph> aplican reglas, con las siguientes excepciones:</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source><ph id="ph1">`FileGetObject`</ph> reads all variables from disk contiguously, that is, with no padding between records.</source>
          <target state="translated"><ph id="ph1">`FileGetObject`</ph> lee todas las variables del disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FileGetObject`</ph> reads only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FileGetObject`</ph> leerá únicamente los datos.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>No descriptor is read.</source>
          <target state="translated">No se lee ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source><ph id="ph1">`FileGetObject`</ph> reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FileGetObject`</ph> lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The number of bytes read equals the number of characters already in the string.</source>
          <target state="translated">El número de bytes leídos es igual al número de caracteres ya se encuentran en la cadena.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>For example, a file named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)">
          <source>The following example reads a record into a test file and then retrieves it.</source>
          <target state="translated">En el ejemplo siguiente se lee un registro en un archivo de prueba y, a continuación, lo recupera.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file.</source>
          <target state="translated">Expresión <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un archivo.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> may include the directory or folder, and the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o carpeta y la unidad.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> value that specifies the length of a file in bytes.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la longitud de un archivo en bytes.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileLen" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileLen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source><ph id="ph1">&lt;see langword="Long" /&gt;</ph> value that specifies the length of a file in bytes.</source>
          <target state="translated">Valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la longitud de un archivo en bytes.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>If the specified file is open when the <ph id="ph1">`FileLen`</ph> function is called, the value returned represents the size of the file at the time it was opened.</source>
          <target state="translated">Si el archivo especificado está abierto cuando el <ph id="ph1">`FileLen`</ph> función se invoca, el valor devuelto representa el tamaño del archivo en el momento en que se abrió.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>To obtain the current length of an open file, use the <ph id="ph1">`LOF`</ph> function.</source>
          <target state="translated">Para obtener la longitud actual de un archivo abierto, utilice la <ph id="ph1">`LOF`</ph> función.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>This example uses the <ph id="ph1">`FileLen`</ph> function to return the length of a file in bytes.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileLen`</ph> función para devolver la longitud de un archivo en bytes.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>For purposes of this example, assume that <ph id="ph1">`TestFile`</ph> is a file that contains some data.</source>
          <target state="translated">Para fines de este ejemplo, se asume que <ph id="ph1">`TestFile`</ph> es un archivo que contiene algunos datos.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)">
          <source>File does not exist.</source>
          <target state="translated">No existe el archivo.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Use the <ph id="ph1">&lt;see langword="FreeFile" /&gt;</ph> function to obtain the next available file number.</source>
          <target state="translated">Utilice la función <ph id="ph1">&lt;see langword="FreeFile" /&gt;</ph> para obtener el siguiente número de archivo disponible.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file name—may include directory or folder, and drive.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un nombre de archivo y que puede incluir el directorio o la carpeta, y la unidad.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Enumeration specifying the file mode: <ph id="ph1">&lt;see langword="Append" /&gt;</ph>, <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>, <ph id="ph3">&lt;see langword="Input" /&gt;</ph>, <ph id="ph4">&lt;see langword="Output" /&gt;</ph>, or <ph id="ph5">&lt;see langword="Random" /&gt;</ph>.</source>
          <target state="translated">Enumeración que especifica el modo de archivo: <ph id="ph1">&lt;see langword="Append" /&gt;</ph>, <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>, <ph id="ph3">&lt;see langword="Input" /&gt;</ph>, <ph id="ph4">&lt;see langword="Output" /&gt;</ph> o <ph id="ph5">&lt;see langword="Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenMode" /&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenMode" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Enumeration specifying the operations permitted on the open file: <ph id="ph1">&lt;see langword="Read" /&gt;</ph>, <ph id="ph2">&lt;see langword="Write" /&gt;</ph>, or <ph id="ph3">&lt;see langword="ReadWrite" /&gt;</ph>.</source>
          <target state="translated">Enumeración que especifica las operaciones permitidas en el archivo abierto: <ph id="ph1">&lt;see langword="Read" /&gt;</ph>, <ph id="ph2">&lt;see langword="Write" /&gt;</ph> o <ph id="ph3">&lt;see langword="ReadWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Defaults to <ph id="ph1">&lt;see langword="ReadWrite" /&gt;</ph>.</source>
          <target state="translated">Tiene como valor predeterminado <ph id="ph1">&lt;see langword="ReadWrite" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenAccess" /&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Enumeration specifying the operations not permitted on the open file by other processes: <ph id="ph1">&lt;see langword="Shared" /&gt;</ph>, <ph id="ph2">&lt;see langword="Lock Read" /&gt;</ph>, <ph id="ph3">&lt;see langword="Lock Write" /&gt;</ph>, and <ph id="ph4">&lt;see langword="Lock Read Write" /&gt;</ph>.</source>
          <target state="translated">Enumeración que especifica las operaciones no permitidas en el archivo abierto por otros procesos: <ph id="ph1">&lt;see langword="Shared" /&gt;</ph>, <ph id="ph2">&lt;see langword="Lock Read" /&gt;</ph>, <ph id="ph3">&lt;see langword="Lock Write" /&gt;</ph> y <ph id="ph4">&lt;see langword="Lock Read Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Defaults to <ph id="ph1">&lt;see langword="Lock Read Write" /&gt;</ph>.</source>
          <target state="translated">Tiene como valor predeterminado <ph id="ph1">&lt;see langword="Lock Read Write" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenShare" /&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.OpenShare" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Number less than or equal to 32,767 (bytes).</source>
          <target state="translated">Número menor o igual que 32.767 (bytes).</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For files opened for random access, this value is the record length.</source>
          <target state="translated">En el caso de los archivos abiertos para el acceso aleatorio, este valor es la longitud de registro.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For sequential files, this value is the number of characters buffered.</source>
          <target state="translated">En el caso de los archivos secuenciales, este valor es el número de caracteres almacenados en búfer.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Opens a file for input or output.</source>
          <target state="translated">Abre un archivo para operaciones de entrada o salida.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The <ph id="ph1">`FileOpen`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`FileOpen`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>You must open a file before any I/O operation can be performed on it.</source>
          <target state="translated">Debe abrir un archivo para poder realizar cualquier operación de E/S en ella.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source><ph id="ph1">`FileOpen`</ph> allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</source>
          <target state="translated"><ph id="ph1">`FileOpen`</ph> asigna un búfer de E/S al archivo y determina el modo de acceso para utilizar con el búfer.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</source>
          <target state="translated">Al escribir en un archivo, puede que una aplicación crear un archivo, si no existe el archivo al que está intentando escribir.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>To do so, it needs permission for the directory in which the file is to be created.</source>
          <target state="translated">Para ello, necesita permiso para el directorio en el que se creará el archivo.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>However, if the file specified by <ph id="ph1">`FileName`</ph> does exist, the application needs <ph id="ph2">`Write`</ph> permission only to the file itself.</source>
          <target state="translated">Sin embargo, si el archivo especificado por <ph id="ph1">`FileName`</ph> existe, las necesidades de la aplicación <ph id="ph2">`Write`</ph> permiso sólo para el propio archivo.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Wherever possible, to help improve security, create the file during deployment and grant <ph id="ph1">`Write`</ph> permission to that file only, instead of to the whole directory.</source>
          <target state="translated">Siempre que sea posible, para ayudar a mejorar la seguridad, cree el archivo durante la implementación y conceder <ph id="ph1">`Write`</ph> permiso a ese archivo únicamente, en lugar de a todo el directorio.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</source>
          <target state="translated">Para ayudar a mejorar la seguridad, escribir datos en los directorios de usuario en lugar de en el directorio raíz o el directorio de archivos de programa.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The channel to open can be found by using the <ph id="ph1">`FreeFile()`</ph> function.</source>
          <target state="translated">Puede encontrar el canal que se va a abrir mediante el <ph id="ph1">`FreeFile()`</ph> función.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The <ph id="ph1">`FileOpen`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration, which may affect its execution in partial trust situations.</source>
          <target state="translated">El <ph id="ph1">`FileOpen`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración, que puede afectar a su ejecución en situaciones de confianza parcial.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>This example illustrates various uses of the <ph id="ph1">`FileOpen`</ph> function to enable input and output to a file.</source>
          <target state="translated">En este ejemplo se muestra varios usos de la <ph id="ph1">`FileOpen`</ph> función para habilitar la entrada y salida a un archivo.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The following code opens the file <ph id="ph1">`TestFile`</ph> in <ph id="ph2">`Input`</ph> mode.</source>
          <target state="translated">El código siguiente abre el archivo <ph id="ph1">`TestFile`</ph> en <ph id="ph2">`Input`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>This example opens the file in <ph id="ph1">`Binary`</ph> mode for writing operations only.</source>
          <target state="translated">En este ejemplo se abre el archivo en <ph id="ph1">`Binary`</ph> modo para solo operaciones de escritura.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The following example opens the file in <ph id="ph1">`Random`</ph> mode.</source>
          <target state="translated">En el ejemplo siguiente se abre el archivo en <ph id="ph1">`Random`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>The file contains records of the structure <ph id="ph1">`Person`</ph>.</source>
          <target state="translated">El archivo contiene registros de la estructura <ph id="ph1">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>This code example opens the file in <ph id="ph1">`Output`</ph> mode; any process can read or write to file.</source>
          <target state="translated">Este ejemplo de código abre el archivo en <ph id="ph1">`Output`</ph> modo: cualquier proceso puede leer o escribir en el archivo.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>This code example opens the file in <ph id="ph1">`Binary`</ph> mode for reading; other processes cannot read file.</source>
          <target state="translated">Este ejemplo de código abre el archivo en <ph id="ph1">`Binary`</ph> el modo de lectura; otros procesos no pueden leer el archivo.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source>Record length is negative (and not equal to -1).</source>
          <target state="translated">La longitud del registro es negativa (y no es igual a ‑1).</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="FileName" /&gt;</ph> is already open, or <ph id="ph2">&lt;paramref name="FileName" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="FileName" /&gt;</ph> ya está abierto o <ph id="ph2">&lt;paramref name="FileName" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>F For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea la clase <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the<ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el<ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the<ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el<ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Applies only when writing a string.</source>
          <target state="translated">Se aplica sólo al escribir una cadena.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Specifies whether to write a two-byte string length descriptor for the string to the file.</source>
          <target state="translated">Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>..</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Applies only when writing an array.</source>
          <target state="translated">Sólo se aplica al escribir una matriz.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</source>
          <target state="translated">Especifica si la matriz se va a tratar como una matriz dinámica y si se va a escribir un descriptor de matriz para la cadena que describe la longitud.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Applies only when writing a string.</source>
          <target state="translated">Se aplica sólo al escribir una cadena.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Specifies whether to write a two-byte string length descriptor for the string to the file.</source>
          <target state="translated">Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The default is <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</source>
          <target state="translated">El valor predeterminado es <ph id="ph1">&lt;see langword="False" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePut" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Data written with <ph id="ph1">`FilePut`</ph> is usually read from a file by using <ph id="ph2">`FileGet`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePut`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGet`</ph>.</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, the next record or byte after the last <ph id="ph2">`FileGet`</ph> or <ph id="ph3">`FilePut`</ph> function or pointed to by the last <ph id="ph4">`Seek`</ph> function is written.</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, el siguiente registro o byte después de la última <ph id="ph2">`FileGet`</ph> o <ph id="ph3">`FilePut`</ph> de función o señalado por la última <ph id="ph4">`Seek`</ph> se escribe la función.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePut`</ph>, you have to do the same with <ph id="ph5">`FileGet`</ph>, and you have to make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePut`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGet`</ph>, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePut`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePut`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar la cantidad de datos de relleno con certeza, resulta una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception will be thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se producirá una excepción.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being written is a string, <ph id="ph1">`FilePut`</ph> writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entra en la variable.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Therefore, the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual length of the string.</source>
          <target state="translated">Por lo tanto, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePut`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePut`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePut`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePut`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePut`</ph> writes a two byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePut`</ph> escribe un descriptor de dos bytes que identifica el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, tiene una opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</source>
          <target state="translated">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica, pero no para una matriz de tamaño fijo.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Visual Basic 2005 defaults to not writing the descriptor.</source>
          <target state="translated">De manera predeterminada, Visual Basic 2005 no escribe el descriptor.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>To write the descriptor, set the <ph id="ph1">`ArrayIsDynamic`</ph> parameter to <ph id="ph2">`True`</ph>.</source>
          <target state="translated">Para escribir el descriptor, establezca el <ph id="ph1">`ArrayIsDynamic`</ph> parámetro <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</source>
          <target state="translated">Al escribir la matriz, se tiene que coincidir con la forma en que se leerán la matriz; Si se va a leer con el descriptor, deberá escribir el descriptor.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For example, the following array declaration requires 218 bytes when the array is written to disk.</source>
          <target state="translated">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>If the variable being written is any other type of variable (not a variable-length string or an object), <ph id="ph1">`FilePut`</ph> writes only the variable data.</source>
          <target state="translated">Si la variable que se está escribiendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), <ph id="ph1">`FilePut`</ph> escribe sólo los datos de la variable.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the length of the data being written.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual que la longitud de los datos que se va a escribir.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes elements of structures as if each were written individually, except there is no padding between elements.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> Escribe los elementos de estructuras como si cada uno de ellos estuviese escrito por separado, excepto que no hay ningún relleno entre los elementos.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`VBFixedString`</ph> attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</source>
          <target state="translated">El <ph id="ph1">`VBFixedString`</ph> atributo se puede aplicar a campos de cadena en las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>String fields that have more bytes than specified by the <ph id="ph1">`VBFixedString`</ph> attribute are truncated when written to disk,</source>
          <target state="translated">Cadena de campos que tienen más bytes que el especificado por el <ph id="ph1">`VBFixedString`</ph> atributo se truncan cuando se escribe en el disco,</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, most of the <ph id="ph2">`Random`</ph> mode rules apply, with some exceptions.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Binary`</ph> modo, la mayoría de los <ph id="ph2">`Random`</ph> aplican reglas de modo, con algunas excepciones.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The following rules for files opened in <ph id="ph1">`Binary`</ph> mode differ from the rules for <ph id="ph2">`Random`</ph> mode:</source>
          <target state="translated">Las siguientes reglas para los archivos abiertos en <ph id="ph1">`Binary`</ph> modo difieren de las reglas de <ph id="ph2">`Random`</ph> modo:</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For any array other than an array in a structure, <ph id="ph1">`FilePut`</ph> writes only the data.</source>
          <target state="translated">Para cualquier matriz que no sea una matriz en una estructura, <ph id="ph1">`FilePut`</ph> sólo escribirá los datos.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>No descriptor is written.</source>
          <target state="translated">Se escribirá ningún descriptor.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`FilePut`</ph> writes variable-length strings that are not elements of structures without the two-byte length descriptor.</source>
          <target state="translated"><ph id="ph1">`FilePut`</ph> escribe las cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>The number of bytes written equals the number of characters in the string.</source>
          <target state="translated">El número de bytes escritos es igual al número de caracteres de la cadena.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>For example, the following statements write 11 bytes to file number 1:</source>
          <target state="translated">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Writing to a file by using the <ph id="ph1">`FilePut`</ph> function requires <ph id="ph2">`Write`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`FilePut`</ph> función requiere <ph id="ph2">`Write`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>This example uses the <ph id="ph1">`FilePut`</ph> function to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePut`</ph> función para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>Five records of the structure <ph id="ph1">`Person`</ph> are written to the file.</source>
          <target state="translated">Cinco registros de la estructura <ph id="ph1">`Person`</ph> se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 and not equal to -1.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="RecordNumber" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 1 y no es igual a -1.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Valid variable name that contains data written to disk.</source>
          <target state="translated">Nombre válido de variable que contiene los datos escritos en disco.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Record number (<ph id="ph1">&lt;see langword="Random" /&gt;</ph> mode files) or byte number (<ph id="ph2">&lt;see langword="Binary" /&gt;</ph> mode files) at which writing starts.</source>
          <target state="translated">Número de registro (archivos en modo <ph id="ph1">&lt;see langword="Random" /&gt;</ph>) o número de byte (archivos en modo <ph id="ph2">&lt;see langword="Binary" /&gt;</ph>) en el que comienza la escritura.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Writes data from a variable to a disk file.</source>
          <target state="translated">Escribe los datos de una variable en un archivo de disco.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FilePutObject" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FilePutObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The <ph id="ph1">`FilePutObject`</ph> function is used instead of <ph id="ph2">`FilePut`</ph> to avoid ambiguities at compile time if type <ph id="ph3">`Object`</ph> is passed instead of another type, such as <ph id="ph4">`Integer`</ph>, <ph id="ph5">`Long`</ph>, <ph id="ph6">`Short`</ph>, and so forth.</source>
          <target state="translated">El <ph id="ph1">`FilePutObject`</ph> función se utiliza en lugar de <ph id="ph2">`FilePut`</ph> para evitar ambigüedades en tiempo de compilación si tipo <ph id="ph3">`Object`</ph> se pasa en lugar de otro tipo, como <ph id="ph4">`Integer`</ph>, <ph id="ph5">`Long`</ph>, <ph id="ph6">`Short`</ph>, y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source><ph id="ph1">`FilePutObject`</ph> writes and reads descriptors that describe the object.</source>
          <target state="translated"><ph id="ph1">`FilePutObject`</ph> escribe y lee descriptores que describen el objeto.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If you intend to write out the <ph id="ph1">`Variant`</ph> type, <ph id="ph2">`FilePutObject`</ph> is required.</source>
          <target state="translated">Si desea escribir el <ph id="ph1">`Variant`</ph> tipo, <ph id="ph2">`FilePutObject`</ph> es necesario.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>When in doubt, if you are using an object for the second parameter, we recommend that you always use <ph id="ph1">`FilePutObject`</ph> and <ph id="ph2">`FileGetObject`</ph>.</source>
          <target state="translated">En caso de duda, si está usando un objeto para el segundo parámetro, se recomienda usar siempre <ph id="ph1">`FilePutObject`</ph> y <ph id="ph2">`FileGetObject`</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source><ph id="ph1">`FilePutObject`</ph> is valid only in <ph id="ph2">`Random`</ph> and <ph id="ph3">`Binary`</ph> mode.</source>
          <target state="translated"><ph id="ph1">`FilePutObject`</ph> solo es válido en <ph id="ph2">`Random`</ph> y <ph id="ph3">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Data written with <ph id="ph1">`FilePutObject`</ph> is usually read from a file by using <ph id="ph2">`FileGetObject`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`FilePutObject`</ph> normalmente se leen desde un archivo mediante <ph id="ph2">`FileGetObject`</ph>.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</source>
          <target state="translated">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte que se encuentra en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If you omit <ph id="ph1">`RecordNumber`</ph>, <ph id="ph2">`FilePutObject`</ph> writes the next record or byte after the last <ph id="ph3">`FileGetObject`</ph> or <ph id="ph4">`FilePutObject`</ph> function (or the record or byte pointed to by the last <ph id="ph5">`Seek`</ph> function).</source>
          <target state="translated">Si se omite <ph id="ph1">`RecordNumber`</ph>, <ph id="ph2">`FilePutObject`</ph> escribe el siguiente registro o byte después de la última <ph id="ph3">`FileGetObject`</ph> o <ph id="ph4">`FilePutObject`</ph> función (o el registro o byte señalado por la última <ph id="ph5">`Seek`</ph> función).</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The <ph id="ph1">`StringIsFixedLength`</ph> argument controls whether the function interprets strings as variable or fixed length.</source>
          <target state="translated">El <ph id="ph1">`StringIsFixedLength`</ph> argumento controla si la función interpreta las cadenas como de longitud fija o variable.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source><ph id="ph1">`FilePutObject`</ph> does not write the length descriptor when the argument is <ph id="ph2">`True`</ph>.</source>
          <target state="translated"><ph id="ph1">`FilePutObject`</ph> no escribe el descriptor de longitud cuando el argumento es <ph id="ph2">`True`</ph>.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If you use <ph id="ph1">`StringIsFixedLength`</ph><ph id="ph2"> = </ph><ph id="ph3">`True`</ph> with <ph id="ph4">`FilePutObject`</ph>, you have to do the same with <ph id="ph5">`FileGetObject`</ph>, and you must also make sure that the string is initialized to the length expected.</source>
          <target state="translated">Si usa <ph id="ph1">`StringIsFixedLength`</ph> <ph id="ph2"> = </ph> <ph id="ph3">`True`</ph> con <ph id="ph4">`FilePutObject`</ph>, tendrá que hacer lo mismo con <ph id="ph5">`FileGetObject`</ph>, y también debe asegurarse de que la cadena se inicializa con la longitud esperada.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Random Mode</source>
          <target state="translated">Modo aleatorio</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, the following rules apply:</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, se aplican las reglas siguientes:</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If the length of the data being written is less than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, <ph id="ph3">`FilePutObject`</ph> writes subsequent records on record-length boundaries.</source>
          <target state="translated">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, <ph id="ph3">`FilePutObject`</ph> escribirá los registros posteriores en los límites de longitud de registro.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</source>
          <target state="translated">El espacio entre el final de un registro y el inicio del siguiente registro que se rellena con el contenido existente del búfer del archivo.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</source>
          <target state="translated">Dado que no se puede determinar con exactitud la cantidad de datos de relleno, suele ser una buena idea hacer que la longitud del registro coincida con la longitud de los datos que se escriben.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If the length of the data being written is greater than the length specified in the <ph id="ph1">`RecordLength`</ph> clause of the <ph id="ph2">`FileOpen`</ph> function, an exception is thrown.</source>
          <target state="translated">Si la longitud de los datos que se escriben es mayor que la longitud especificada en el <ph id="ph1">`RecordLength`</ph> cláusula de la <ph id="ph2">`FileOpen`</ph> función, se produce una excepción.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If the variable being written is an object that contains a numeric type, <ph id="ph1">`FilePutObject`</ph> writes two bytes identifying the <ph id="ph2">`VarType`</ph> of the object and then writes the variable.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, <ph id="ph1">`FilePutObject`</ph> escribirá dos bytes para identificar el <ph id="ph2">`VarType`</ph> del objeto y, a continuación, escribe la variable.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>For example, when writing an object that contains an integer, <ph id="ph1">`FilePutObject`</ph> writes six bytes: two bytes that identify the object as <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) and four bytes that contain the data.</source>
          <target state="translated">Por ejemplo, al escribir un objeto que contiene un entero, <ph id="ph1">`FilePutObject`</ph> escribe seis bytes: dos bytes que identifican el objeto como <ph id="ph2">`VarType(3)`</ph> (<ph id="ph3">`Integer`</ph>) y cuatro bytes que contienen los datos.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least two bytes greater than the actual number of bytes required to store the variable.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser al menos dos bytes mayor que el número real de bytes necesarios para almacenar la variable.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If the variable being written is an object that contains a string, <ph id="ph1">`FilePutObject`</ph> writes a two-byte descriptor identifying the <ph id="ph2">`VarType(8)`</ph> of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</source>
          <target state="translated">Si la variable que se está escribiendo es un objeto que contiene una cadena, <ph id="ph1">`FilePutObject`</ph> escribirá un descriptor de dos bytes para identificar el <ph id="ph2">`VarType(8)`</ph> del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The record length specified by the <ph id="ph1">`RecordLength`</ph> parameter in the <ph id="ph2">`FileOpen`</ph> function must be at least four bytes greater than the actual length of the string.</source>
          <target state="translated">La longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> parámetro en el <ph id="ph2">`FileOpen`</ph> función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If you want to put a string without the descriptor, you should pass <ph id="ph1">`True`</ph> to the <ph id="ph2">`StringIsFixedLength`</ph> parameter, and the string you read into should be the correct length.</source>
          <target state="translated">Si desea escribir una cadena sin el descriptor, debería pasar <ph id="ph1">`True`</ph> a la <ph id="ph2">`StringIsFixedLength`</ph> parámetro y la cadena que lea debería tener la longitud correcta.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>If the variable being written is an array, then the record length specified by the <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</source>
          <target state="translated">Si la variable que se está escribiendo es una matriz, la longitud de registro especificada por el <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de la matriz.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</source>
          <target state="translated">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Its length equals 2 plus 8 times the number of dimensions: (2 + 8 * NumberOfDimensions).</source>
          <target state="translated">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>Binary Mode</source>
          <target state="translated">Modo binario</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>For files opened in <ph id="ph1">`Binary`</ph> mode, all the <ph id="ph2">`Random`</ph> mode rules apply, except:</source>
          <target state="translated">De archivos abiertos en <ph id="ph1">`Binary`</ph> modo, todos los <ph id="ph2">`Random`</ph> se aplican reglas de modo excepto:</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>The <ph id="ph1">`RecordLength`</ph> clause in the <ph id="ph2">`FileOpen`</ph> function has no effect.</source>
          <target state="translated">El <ph id="ph1">`RecordLength`</ph> cláusula en la <ph id="ph2">`FileOpen`</ph> función no tiene ningún efecto.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source><ph id="ph1">`FilePutObject`</ph> writes all variables to disk contiguously, that is, without padding between records.</source>
          <target state="translated"><ph id="ph1">`FilePutObject`</ph> escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)">
          <source>This example uses the <ph id="ph1">`FilePutObject`</ph> function to write a string to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FilePutObject`</ph> función para escribir una cadena en un archivo.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</source>
          <target state="translated">Expresión numérica del 0 al 255, inclusive, que indica el número de caracteres que aparecen en una línea antes de que se inicie una nueva línea.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>RecordWidth<ept id="p1">&lt;/c&gt;</ept> equals 0, there is no limit to the length of a line.</source>
          <target state="translated">Si el valor de <bpt id="p1">&lt;c&gt;</bpt>RecordWidth<ept id="p1">&lt;/c&gt;</ept> es 0, la longitud de línea no tiene límite.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>The default value for <bpt id="p1">&lt;c&gt;</bpt>RecordWidth<ept id="p1">&lt;/c&gt;</ept> is 0.</source>
          <target state="translated">El valor predeterminado de <bpt id="p1">&lt;c&gt;</bpt>RecordWidth<ept id="p1">&lt;/c&gt;</ept> es 0.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>Assigns an output line width to a file opened by using the <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Asigna un ancho de línea de salida a un archivo abierto mediante la función <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>This example uses the <ph id="ph1">`FileWidth`</ph> function to set the output line width for a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FileWidth`</ph> función para establecer el ancho de línea de salida de un archivo.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>Returns an <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> value that represents the next file number available for use by the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que representa el siguiente número de archivo disponible para la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>Returns an <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> value that represents the next file number available for use by the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que representa el siguiente número de archivo disponible para la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>Use <ph id="ph1">`FreeFile`</ph> to supply a file number that is not already being used.</source>
          <target state="translated">Use <ph id="ph1">`FreeFile`</ph> para proporcionar un número de archivo que ya no se utiliza.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>This example uses the <ph id="ph1">`FreeFile`</ph> function to return the next available file number.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`FreeFile`</ph> función para devolver el siguiente número de archivo disponibles.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>Five files are opened for output within the loop, and some sample data is written to each.</source>
          <target state="translated">Se abren cinco archivos para salida dentro del bucle, y algunos datos de ejemplo se escriben en cada uno de ellos.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.FreeFile">
          <source>More than 255 files are in use.</source>
          <target state="translated">Hay más de 255 archivos en uso.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file, directory, or folder name.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un nombre de archivo, directorio o carpeta.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> can include the directory or folder, and the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o la carpeta y la unidad.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>Returns a <ph id="ph1">&lt;see langword="FileAttribute" /&gt;</ph> value that represents the attributes of a file, directory, or folder.</source>
          <target state="translated">Devuelve un valor de <ph id="ph1">&lt;see langword="FileAttribute" /&gt;</ph> que representa los atributos de un archivo, un directorio o una carpeta.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="FileAttribute" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="FileAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>The value returned by <ph id="ph1">&lt;see langword="GetAttr" /&gt;</ph> is the sum of the following enumeration values:</source>
          <target state="translated">El valor devuelto por <ph id="ph1">&lt;see langword="GetAttr" /&gt;</ph> es la suma de los siguientes valores de enumeración:</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;item&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;item&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Constant</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Constante</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Description</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Descripción</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Normal" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbNormal" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Normal.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Normal" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbNormal" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Normal.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="ReadOnly" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbReadOnly" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Read-only.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="ReadOnly" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbReadOnly" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Solo lectura.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Hidden" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbHidden" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Hidden.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Hidden" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbHidden" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Oculto.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="System" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbSystem" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> System file.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="System" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbSystem" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Archivo de sistema.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Directory" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbDirectory" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Directory or folder.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Directory" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbDirectory" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> Directorio o carpeta.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Archive" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbArchive" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> File has changed since last backup.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Archive" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbArchive" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> El archivo ha cambiado desde que la realización de la última copia de seguridad.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Alias" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbAlias" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> File has a different name.</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see langword="Alias" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><bpt id="p2">&lt;description&gt;</bpt><ph id="ph5">&lt;see langword="vbAlias" /&gt;</ph><ept id="p2">&lt;/description&gt;</ept><ph id="ph6">&lt;description&gt;</ph> El archivo tiene un nombre diferente.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>These enumerations are specified by the Visual Basic language.</source>
          <target state="translated">El lenguaje de Visual Basic especifica estas enumeraciones.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>The names can be used anywhere in your code in place of the actual values.</source>
          <target state="translated">Se pueden utilizar los nombres en cualquier lugar del código en vez de los valores reales.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>To determine which attributes are set, use the <ph id="ph1">`And`</ph> operator to perform a bitwise comparison of the value returned by the <ph id="ph2">`GetAttr`</ph> function and the value of the individual file attribute you want.</source>
          <target state="translated">Para determinar qué atributos se establecen, utilice el <ph id="ph1">`And`</ph> operador que se va a realizar una comparación bit a bit del valor devuelto por la <ph id="ph2">`GetAttr`</ph> función y el valor del atributo de archivo individual que desee.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>If the result is not zero, that attribute is set for the named file.</source>
          <target state="translated">Si el resultado no es cero, ese atributo se establece para el archivo con nombre.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>For example, the return value of the following <ph id="ph1">`And`</ph> expression is zero if the <ph id="ph2">`Archive`</ph> attribute is not set:</source>
          <target state="translated">Por ejemplo, el valor devuelto de las siguientes acciones <ph id="ph1">`And`</ph> expresión es cero si la <ph id="ph2">`Archive`</ph> atributo no está establecido:</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>A nonzero value is returned if the <ph id="ph1">`Archive`</ph> attribute is set.</source>
          <target state="translated">Se devuelve un valor distinto de cero si la <ph id="ph1">`Archive`</ph> atributo está establecido.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>This example uses the <ph id="ph1">`GetAttr`</ph> function to determine the attributes of a file and directory or folder.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`GetAttr`</ph> función para determinar los atributos de un archivo, directorio o carpeta.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source><ph id="ph1">&lt;paramref name="Pathname" /&gt;</ph> is invalid or contains wildcards.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="Pathname" /&gt;</ph> no es válido o contiene caracteres comodín.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)">
          <source>Target file does not exist.</source>
          <target state="translated">El archivo de destino no existe.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has some lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene algunas líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has some lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene algunas líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, dado que se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Variable that is assigned the values read from the file—cannot be an array or object variable.</source>
          <target state="translated">La variable a la que se han asignado los valores leídos del archivo no puede ser una variable de objeto o matriz.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Reads data from an open sequential file and assigns the data to variables.</source>
          <target state="translated">Lee los datos de un archivo secuencial abierto y los asigna a variables.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>The <ph id="ph1">`Input`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Data read with <ph id="ph1">`Input`</ph> is usually written to a file by using <ph id="ph2">`Write`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`Input`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Write`</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>When reading from files, do not make decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic 2005.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>When read, standard string or numeric data is assigned to variables without modification.</source>
          <target state="translated">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>The following table illustrates how other input data is treated.</source>
          <target state="translated">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Data</source>
          <target state="translated">Datos</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Value assigned to variable</source>
          <target state="translated">Valor asignado a la variable</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Delimiting comma or blank line</source>
          <target state="translated">Delimita una coma o línea en blanco</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Empty</source>
          <target state="translated">Empty</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>#NULL#</source>
          <target state="translated">#NULL#</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>#TRUE# or #FALSE#</source>
          <target state="translated"># TRUE o FALSE #</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source><ph id="ph1">`True`</ph> or <ph id="ph2">`False`</ph></source>
          <target state="translated"><ph id="ph1">`True`</ph> o <ph id="ph2">`False`</ph></target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>The date and/or time represented by the expression</source>
          <target state="translated">La fecha y hora representadas por la expresión</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></source>
          <target state="translated">#ERROR <ph id="ph1">`errornumber`</ph><ph id="ph2">#</ph></target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source><ph id="ph1">`errornumber`</ph> (variable is an object tagged as an error)</source>
          <target state="translated"><ph id="ph1">`errornumber`</ph> (la variable es un objeto etiquetado como error)</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</source>
          <target state="translated">Si se llega al final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>The <ph id="ph1">`Input`</ph> function is not localized.</source>
          <target state="translated">El <ph id="ph1">`Input`</ph> no se encuentra la función.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</source>
          <target state="translated">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variables en lugar de como un separador decimal.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>Reading from a file by using the <ph id="ph1">`Input`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`Input`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>This example uses the <ph id="ph1">`Input`</ph> function to read data from a file into two variables.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Input`</ph> función para leer datos desde un archivo en dos variables.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a file that has several lines of data written to it using the <ph id="ph2">`Write`</ph> function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo que tiene varias líneas de datos escritos en él con el <ph id="ph2">`Write`</ph> funcione, cada línea que contenga una cadena entre comillas y un número separados por una coma, por ejemplo: ("Hola", 234).</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Any valid numeric expression specifying the number of characters to read.</source>
          <target state="translated">Cualquier expresión numérica válida que especifique el número de caracteres que se van a leer.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Returns <ph id="ph1">&lt;see langword="String" /&gt;</ph> value that contains characters from a file opened in <ph id="ph2">&lt;see langword="Input" /&gt;</ph> or <ph id="ph3">&lt;see langword="Binary" /&gt;</ph> mode.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que contiene los caracteres de un archivo abierto en modo <ph id="ph2">&lt;see langword="Input" /&gt;</ph> o <ph id="ph3">&lt;see langword="Binary" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="InputString" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="InputString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Returns <ph id="ph1">&lt;see langword="String" /&gt;</ph> value that contains characters from a file opened in <ph id="ph2">&lt;see langword="Input" /&gt;</ph> or <ph id="ph3">&lt;see langword="Binary" /&gt;</ph> mode.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que contiene los caracteres de un archivo abierto en modo <ph id="ph2">&lt;see langword="Input" /&gt;</ph> o <ph id="ph3">&lt;see langword="Binary" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="InputString" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="InputString" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>The <ph id="ph1">`InputString`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`InputString`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Data read with the <ph id="ph1">`InputString`</ph> function is usually written to a file by using <ph id="ph2">`Print`</ph> or <ph id="ph3">`FilePut`</ph>.</source>
          <target state="translated">Los datos leídos con la <ph id="ph1">`InputString`</ph> función normalmente se escribe en un archivo mediante el uso de <ph id="ph2">`Print`</ph> o <ph id="ph3">`FilePut`</ph>.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Use this function only with files opened in <ph id="ph1">`Input`</ph> or <ph id="ph2">`Binary`</ph> mode.</source>
          <target state="translated">Utilice esta función únicamente con archivos abiertos en <ph id="ph1">`Input`</ph> o <ph id="ph2">`Binary`</ph> modo.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Unlike the <ph id="ph1">`Input`</ph> function, the <ph id="ph2">`InputString`</ph> function returns all the characters it reads.</source>
          <target state="translated">A diferencia de la <ph id="ph1">`Input`</ph> función, el <ph id="ph2">`InputString`</ph> función devuelve todos los caracteres que lee.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</source>
          <target state="translated">Esto incluye comas, retornos de carro, saltos de línea, comillas y espacios iniciales.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>With files opened for <ph id="ph1">`Binary`</ph> access, an attempt to read through the file by using the <ph id="ph2">`InputString`</ph> function until <ph id="ph3">`EOF`</ph> returns <ph id="ph4">`True`</ph> generates an error.</source>
          <target state="translated">Con archivos abiertos para <ph id="ph1">`Binary`</ph> tener acceso a un intento de leer el archivo mediante el uso de la <ph id="ph2">`InputString`</ph> funcionando hasta que <ph id="ph3">`EOF`</ph> devuelve <ph id="ph4">`True`</ph> genera un error.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>Use the <ph id="ph1">`LOF`</ph> and <ph id="ph2">`Loc`</ph> functions instead of <ph id="ph3">`EOF`</ph> when you read binary files by using <ph id="ph4">`InputString`</ph>, or use <ph id="ph5">`FileGet`</ph> when you use the <ph id="ph6">`EOF`</ph> function.</source>
          <target state="translated">Utilice la <ph id="ph1">`LOF`</ph> y <ph id="ph2">`Loc`</ph> las funciones en lugar de <ph id="ph3">`EOF`</ph> al leer archivos binarios mediante <ph id="ph4">`InputString`</ph>, o usar <ph id="ph5">`FileGet`</ph> cuando se usa el <ph id="ph6">`EOF`</ph> función.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>When reading from files, do not make security decisions about the contents of the file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, no tomar decisiones de seguridad sobre el contenido del archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>For example, a file named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>This example uses the <ph id="ph1">`InputString`</ph> function to read one character at a time from a file and print it to the <ph id="ph2">`Output`</ph> window.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`InputString`</ph> función para leer un carácter a la vez desde un archivo e imprimirlo en la <ph id="ph2">`Output`</ph> ventana.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source>This example assumes that <ph id="ph1">`MyFile`</ph> is a text file that has several lines of sample data.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`MyFile`</ph> es un archivo de texto que tiene varias líneas de datos de ejemplo.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> no existe.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="CharCount" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0 or <ph id="ph3">&amp;gt;</ph> 214.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="CharCount" /&gt;</ph> <ph id="ph2">&amp;lt;</ph> 0 o <ph id="ph3">&amp;gt;</ph> 214.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies one or more file names to be deleted.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica uno o varios nombres de archivo que se van a eliminar.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> can include the directory or folder, and the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o la carpeta y la unidad.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>Deletes files from a disk.</source>
          <target state="translated">Elimina archivos de un disco.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Kill" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Kill" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source><ph id="ph1">`Kill`</ph> supports the use of multiple-character (<ph id="ph2">`*`</ph>) and single-character (<ph id="ph3">`?`</ph>) wildcards to specify multiple files.</source>
          <target state="translated"><ph id="ph1">`Kill`</ph> admite el uso de varios caracteres (<ph id="ph2">`*`</ph>) ni un único carácter (<ph id="ph3">`?`</ph>) caracteres comodín para especificar varios archivos.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source><bpt id="p1">**</bpt>Security Note<ept id="p1">**</ept> In order to execute, the <ph id="ph1">`Kill`</ph> function requires <ph id="ph2">`Read`</ph> and <ph id="ph3">`PathDiscovery`</ph> flags of <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> to be granted to the executing code.</source>
          <target state="translated"><bpt id="p1">**</bpt>Nota de seguridad<ept id="p1">**</ept> para ejecutarse, la <ph id="ph1">`Kill`</ph> función requiere <ph id="ph2">`Read`</ph> y <ph id="ph3">`PathDiscovery`</ph> marcas de <ph id="ph4">&lt;xref:System.Security.Permissions.FileIOPermission&gt;</ph> va a conceder al código de ejecución.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph><bpt id="p1">[</bpt>Code Access Permissions<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept></source>
          <target state="translated">Para obtener más información, consulte <ph id="ph1">&lt;xref:System.Security.SecurityException&gt;</ph> <bpt id="p1">[</bpt>permisos de acceso del código<ept id="p1">](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</ept></target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>This example uses the <ph id="ph1">`Kill`</ph> function to delete a file from a disk.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Kill`</ph> función para eliminar un archivo desde un disco.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>Target file(s) open.</source>
          <target state="translated">El archivo o los archivos de destino están abiertos.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>Target file(s) not found.</source>
          <target state="translated">No se encuentra el archivo o los archivos de destino.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)">
          <source>Permission denied.</source>
          <target state="translated">Permiso denegado.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Reads a single line from an open sequential file and assigns it to a <ph id="ph1">&lt;see langword="String" /&gt;</ph> variable.</source>
          <target state="translated">Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <ph id="ph1">&lt;see langword="String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Reads a single line from an open sequential file and assigns it to a <ph id="ph1">&lt;see langword="String" /&gt;</ph> variable.</source>
          <target state="translated">Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <ph id="ph1">&lt;see langword="String" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>The <ph id="ph1">`LineInput`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`LineInput`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Data read with <ph id="ph1">`LineInput`</ph> is usually written to a file by using <ph id="ph2">`Print`</ph>.</source>
          <target state="translated">Los datos leídos con <ph id="ph1">`LineInput`</ph> se escriben normalmente en un archivo mediante el uso de <ph id="ph2">`Print`</ph>.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>When reading from files, do not make decisions about the contents of a file based on the file name extension.</source>
          <target state="translated">Al leer de archivos, tome ninguna decisión sobre el contenido de un archivo basándose en la extensión de nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>For example, a file that is named Form1.vb may not be a Visual Basic source file.</source>
          <target state="translated">Por ejemplo, un archivo denominado Form1.vb puede no ser un archivo de código fuente de Visual Basic.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>The <ph id="ph1">`LineInput`</ph> function reads from a file one character at a time until it encounters a carriage return (<ph id="ph2">`Chr(13)`</ph>) or carriage return/line feed (<ph id="ph3">`Chr(13) + Chr(10)`</ph>) sequence.</source>
          <target state="translated">El <ph id="ph1">`LineInput`</ph> función lee de un carácter de un archivo a la vez hasta que encuentra un retorno de carro (<ph id="ph2">`Chr(13)`</ph>) o avance de línea y retorno de carro (<ph id="ph3">`Chr(13) + Chr(10)`</ph>) secuencia.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Carriage return/line feed sequences are skipped instead of appended to the character string.</source>
          <target state="translated">Carro retorno estas secuencias se omiten en lugar de anexar a la cadena de caracteres.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>Reading from a file by using the <ph id="ph1">`LineInput`</ph> function requires <ph id="ph2">`Read`</ph> access from the <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeration.</source>
          <target state="translated">Leer un archivo mediante el uso de la <ph id="ph1">`LineInput`</ph> función requiere <ph id="ph2">`Read`</ph> acceder desde el <ph id="ph3">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>This example uses the <ph id="ph1">`LineInput`</ph> function to read a line from a sequential file and assign it to a variable.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`LineInput`</ph> función para leer una línea de un archivo secuencial y asignarla a una variable.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a text file that has several lines of sample data.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo de texto que tiene varias líneas de datos de ejemplo.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source>End of file reached.</source>
          <target state="translated">Se ha llegado al final del archivo.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="FileNumber" /&gt;</ph> no existe.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Any valid <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> file number.</source>
          <target state="translated">Cualquier número de archivo válido de tipo <ph id="ph1">&lt;see langword="Integer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> value that specifies the current read/write position in an open file.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la actual posición de lectura y escritura en un archivo abierto.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> value that specifies the current read/write position in an open file.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la actual posición de lectura y escritura en un archivo abierto.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>The <ph id="ph1">`Loc`</ph> function is zero-based; using it to retrieve the first byte in a file will return 0.</source>
          <target state="translated">El <ph id="ph1">`Loc`</ph> función está basado en cero; se utiliza para recuperar el primer byte en un archivo, devuelve 0.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>The <ph id="ph1">`Loc`</ph> function is provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Loc`</ph> función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>The following describes the return value for each file access mode:</source>
          <target state="translated">A continuación describe el valor devuelto para cada modo de acceso de archivo:</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Mode</source>
          <target state="translated">Modo</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Return value</source>
          <target state="translated">Valor devuelto</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Number of the last record read from or written to the file.</source>
          <target state="translated">Número del último registro leído o escrito en el archivo.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Current byte position in the file divided by 128.</source>
          <target state="translated">Posición de byte actual en el archivo dividido por 128.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>However, information returned by <ph id="ph1">`Loc`</ph> for sequential files is neither used nor required.</source>
          <target state="translated">Sin embargo, información devuelta por <ph id="ph1">`Loc`</ph> para archivos secuenciales no se utiliza ni se requiere.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>Position of the last byte read or written.</source>
          <target state="translated">Posición del último byte leído o escrito.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>This example uses the <ph id="ph1">`Loc`</ph> function to return the current read/write position in an open file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Loc`</ph> función para devolver la posición de lectura/escritura actual en un archivo abierto.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>This example assumes that <ph id="ph1">`MyFile`</ph> is a text file that has several lines of sample data.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`MyFile`</ph> es un archivo de texto que tiene varias líneas de datos de ejemplo.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>Number of the only record or byte to lock or unlock</source>
          <target state="translated">Número del único registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Number of the first record or byte to lock or unlock.</source>
          <target state="translated">Número del primer registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Number of the last record or byte to lock or unlock.</source>
          <target state="translated">Número del último registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> that contains a valid file number.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene un número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> representing the size, in bytes, of a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que representa el tamaño, en bytes, de un archivo abierto mediante la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="LOF" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="LOF" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> representing the size, in bytes, of a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor de tipo <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que representa el tamaño, en bytes, de un archivo abierto mediante la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="LOF" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="LOF" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>Use the <ph id="ph1">`FileLen`</ph> function to obtain the length of a file that is not open.</source>
          <target state="translated">Use la <ph id="ph1">`FileLen`</ph> función para obtener la longitud de un archivo que no está abierto.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>This example uses the <ph id="ph1">`LOF`</ph> function to determine the size of an open file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`LOF`</ph> función para determinar el tamaño de un archivo abierto.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>This example assumes that <ph id="ph1">`TestFile`</ph> is a text file that contains sample data.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`TestFile`</ph> es un archivo de texto que contiene datos de ejemplo.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that identifies the directory to be created.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que identifica el directorio que se va a crear.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> may include the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> puede incluir la unidad.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>If no drive is specified, <ph id="ph1">&lt;see langword="MkDir" /&gt;</ph> creates the new directory on the current drive.</source>
          <target state="translated">Si no hay ninguna unidad especificada, <ph id="ph1">&lt;see langword="MkDir" /&gt;</ph> crea el nuevo directorio en la unidad actual.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>Creates a new directory.</source>
          <target state="translated">Crea un directorio nuevo.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="MkDir" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="MkDir" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>This function creates a new directory.</source>
          <target state="translated">Esta función crea un nuevo directorio.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>This example uses the <ph id="ph1">`MkDir`</ph> function to create a directory.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`MkDir`</ph> función para crear un directorio.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>If the drive is not specified, the new directory is created on the current drive.</source>
          <target state="translated">Si no se especifica la unidad, se crea el nuevo directorio en la unidad actual.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> is not specified or is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> no se ha especificado o está vacío.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>Permission denied.</source>
          <target state="translated">Permiso denegado.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)">
          <source>Directory already exists.</source>
          <target state="translated">El directorio ya existe.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Zero or more comma-delimited expressions to write to a file.</source>
          <target state="translated">Cero o más expresiones delimitadas por comas para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>Output<ept id="p1">&lt;/c&gt;</ept> argument settings are:</source>
          <target state="translated">La configuración del argumento <bpt id="p1">&lt;c&gt;</bpt>Output<ept id="p1">&lt;/c&gt;</ept> es:</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: File mode is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: <bpt id="p1">&lt;c&gt;</bpt>FileNumber<ept id="p1">&lt;/c&gt;</ept> does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: <bpt id="p1">&lt;c&gt;</bpt>FileNumber<ept id="p1">&lt;/c&gt;</ept> no existe.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Writes display-formatted data to a sequential file.</source>
          <target state="translated">Escribe los datos con formato de presentación en un archivo secuencial.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintLine`</ph> functions are provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Print`</ph> y <ph id="ph2">`PrintLine`</ph> funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source><ph id="ph1">`Print`</ph> does not include a line feed at the end of a line; however, <ph id="ph2">`PrintLine`</ph> does include a line feed.</source>
          <target state="translated"><ph id="ph1">`Print`</ph> no incluye una avance de línea al final de una línea; Sin embargo, <ph id="ph2">`PrintLine`</ph> incluyen un avance de línea.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Data written with <ph id="ph1">`Print`</ph> is usually read from a file by using <ph id="ph2">`LineInput`</ph> or <ph id="ph3">`Input`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`Print`</ph> normalmente se leen desde un archivo mediante el uso de <ph id="ph2">`LineInput`</ph> o <ph id="ph3">`Input`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>If you omit <ph id="ph1">`Output`</ph> for <ph id="ph2">`PrintLine`</ph>, a blank line is printed to the file; for <ph id="ph3">`Print`</ph>, nothing is output.</source>
          <target state="translated">Si se omite <ph id="ph1">`Output`</ph> para <ph id="ph2">`PrintLine`</ph>, se imprime una línea en blanco en el archivo; para <ph id="ph3">`Print`</ph>, nada es de salida.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and <ph id="ph1">`TAB`</ph> may cause inconsistent results.</source>
          <target state="translated">Varias expresiones separadas con una coma se alinearán en los límites de tabulación, pero la combinación de comas y <ph id="ph1">`TAB`</ph> puede causar resultados incoherentes.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Boolean`</ph> data, either <ph id="ph2">`True`</ph> or <ph id="ph3">`False`</ph> is printed.</source>
          <target state="translated">Para <ph id="ph1">`Boolean`</ph> datos, ya sea <ph id="ph2">`True`</ph> o <ph id="ph3">`False`</ph> se imprime.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`True`</ph> and <ph id="ph2">`False`</ph> keywords are not translated, regardless of the locale.</source>
          <target state="translated">El <ph id="ph1">`True`</ph> y <ph id="ph2">`False`</ph> palabras clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Date data is written to the file by using the standard short date format recognized by your system.</source>
          <target state="translated">Datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>When either the date or the time component is missing or zero, only the part provided is written to the file.</source>
          <target state="translated">Cuando la fecha o el componente de hora falta o es cero, solo la parte siempre se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Nothing is written to the file if <ph id="ph1">`Output`</ph> data is empty.</source>
          <target state="translated">Se escribirá nada en el archivo si <ph id="ph1">`Output`</ph> datos están vacíos.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>However, if <ph id="ph1">`Output`</ph> list data is <ph id="ph2">`DBNull`</ph>, <ph id="ph3">`Null`</ph> is written to the file.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`Output`</ph> datos de lista son <ph id="ph2">`DBNull`</ph>, <ph id="ph3">`Null`</ph> se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Error`</ph> data, the output appears as <ph id="ph2">`Error errorcode`</ph>.</source>
          <target state="translated">Para <ph id="ph1">`Error`</ph> aparece de la salida de datos, como <ph id="ph2">`Error errorcode`</ph>.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Error`</ph> keyword is not translated regardless of the locale.</source>
          <target state="translated">El <ph id="ph1">`Error`</ph> palabra clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>All data written to the file by using <ph id="ph1">`Print`</ph> is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</source>
          <target state="translated">Todos los datos escritos en el archivo mediante el uso de <ph id="ph1">`Print`</ph> es compatible con internacionalmente; es decir, los datos tiene el formato correcto con el separador decimal adecuado.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>If the user wishes to output data for use by multiple locales, <ph id="ph1">`Write`</ph> should be used.</source>
          <target state="translated">Si el usuario desea mostrar datos aptos para varias configuraciones regionales, <ph id="ph1">`Write`</ph> debe utilizarse.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>Writing to a file by using the <ph id="ph1">`Print`</ph> or <ph id="ph2">`PrintLine`</ph> functions requires <ph id="ph3">`Write`</ph> access from the <ph id="ph4">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`Print`</ph> o <ph id="ph2">`PrintLine`</ph> funciones requiere <ph id="ph3">`Write`</ph> acceder desde el <ph id="ph4">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])">
          <source>This example uses the <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintLine`</ph> functions to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Print`</ph> y <ph id="ph2">`PrintLine`</ph> funciones para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Zero or more comma-delimited expressions to write to a file.</source>
          <target state="translated">Cero o más expresiones delimitadas por comas para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>The <bpt id="p1">&lt;c&gt;</bpt>Output<ept id="p1">&lt;/c&gt;</ept> argument settings are:</source>
          <target state="translated">La configuración del argumento <bpt id="p1">&lt;c&gt;</bpt>Output<ept id="p1">&lt;/c&gt;</ept> es:</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: File mode is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: <bpt id="p1">&lt;c&gt;</bpt>FileNumber<ept id="p1">&lt;/c&gt;</ept> does not exist.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="T:System.IO.IOException" /&gt;</ph>: <bpt id="p1">&lt;c&gt;</bpt>FileNumber<ept id="p1">&lt;/c&gt;</ept> no existe.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Writes display-formatted data to a sequential file.</source>
          <target state="translated">Escribe los datos con formato de presentación en un archivo secuencial.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintLine`</ph> functions are provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Print`</ph> y <ph id="ph2">`PrintLine`</ph> funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source><ph id="ph1">`Print`</ph> does not include a line feed at the end of a line; however,<ph id="ph2">`PrintLine`</ph> does include a line feed.</source>
          <target state="translated"><ph id="ph1">`Print`</ph> no incluye una avance de línea al final de una línea; Sin embargo,<ph id="ph2">`PrintLine`</ph> incluyen un avance de línea.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Data written with <ph id="ph1">`Print`</ph> is usually read from a file by using <ph id="ph2">`LineInput`</ph> or <ph id="ph3">`Input`</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">`Print`</ph> normalmente se leen desde un archivo mediante el uso de <ph id="ph2">`LineInput`</ph> o <ph id="ph3">`Input`</ph>.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>If you omit <ph id="ph1">`Output`</ph> for <ph id="ph2">`PrintLine`</ph>, a blank line is printed to the file; for <ph id="ph3">`Print`</ph>, nothing is output.</source>
          <target state="translated">Si se omite <ph id="ph1">`Output`</ph> para <ph id="ph2">`PrintLine`</ph>, se imprime una línea en blanco en el archivo; para <ph id="ph3">`Print`</ph>, nada es de salida.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and <ph id="ph1">`TAB`</ph> may cause inconsistent results.</source>
          <target state="translated">Varias expresiones separadas con una coma se alinearán en los límites de tabulación, pero la combinación de comas y <ph id="ph1">`TAB`</ph> puede causar resultados incoherentes.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Boolean`</ph> data, either <ph id="ph2">`True`</ph> or <ph id="ph3">`False`</ph> is printed.</source>
          <target state="translated">Para <ph id="ph1">`Boolean`</ph> datos, ya sea <ph id="ph2">`True`</ph> o <ph id="ph3">`False`</ph> se imprime.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`True`</ph> and <ph id="ph2">`False`</ph> keywords are not translated, regardless of the locale.</source>
          <target state="translated">El <ph id="ph1">`True`</ph> y <ph id="ph2">`False`</ph> palabras clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Date data is written to the file by using the standard short date format recognized by the system.</source>
          <target state="translated">Datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>When either the date or the time component is missing or zero, only the part provided is written to the file.</source>
          <target state="translated">Cuando la fecha o el componente de hora falta o es cero, solo la parte siempre se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Nothing is written to the file if <ph id="ph1">`Output`</ph> data is empty.</source>
          <target state="translated">Se escribirá nada en el archivo si <ph id="ph1">`Output`</ph> datos están vacíos.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>However, if <ph id="ph1">`Output`</ph> list data is <ph id="ph2">`DBNull`</ph>, <ph id="ph3">`Null`</ph> is written to the file.</source>
          <target state="translated">Sin embargo, si <ph id="ph1">`Output`</ph> datos de lista son <ph id="ph2">`DBNull`</ph>, <ph id="ph3">`Null`</ph> se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Error`</ph> data, the output appears as <ph id="ph2">`Error errorcode`</ph>.</source>
          <target state="translated">Para <ph id="ph1">`Error`</ph> aparece de la salida de datos, como <ph id="ph2">`Error errorcode`</ph>.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Error`</ph> keyword is not translated regardless of the locale.</source>
          <target state="translated">El <ph id="ph1">`Error`</ph> palabra clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>All data written to the file by using <ph id="ph1">`Print`</ph> is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</source>
          <target state="translated">Todos los datos escritos en el archivo mediante el uso de <ph id="ph1">`Print`</ph> es compatible con internacionalmente; es decir, los datos tiene el formato correcto con el separador decimal adecuado.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>If the user wishes to output data for use by multiple locales, <ph id="ph1">`Write`</ph> should be used.</source>
          <target state="translated">Si el usuario desea mostrar datos aptos para varias configuraciones regionales, <ph id="ph1">`Write`</ph> debe utilizarse.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>Writing to a file by using the <ph id="ph1">`Print`</ph> or <ph id="ph2">`PrintLine`</ph> functions requires <ph id="ph3">`Write`</ph> access from the <ph id="ph4">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`Print`</ph> o <ph id="ph2">`PrintLine`</ph> funciones requiere <ph id="ph3">`Write`</ph> acceder desde el <ph id="ph4">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])">
          <source>This example uses the <ph id="ph1">`Print`</ph> and <ph id="ph2">`PrintLine`</ph> functions to write data to a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Print`</ph> y <ph id="ph2">`PrintLine`</ph> funciones para escribir datos en un archivo.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies the existing file name and location.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica el nombre y la ubicación de archivo existentes.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>OldPath<ept id="p1">&lt;/c&gt;</ept> may include the directory, and drive, of the file.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>OldPath<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio y la unidad del archivo.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies the new file name and location.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica el nuevo nombre de archivo y la nueva ubicación.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>NewPath<ept id="p1">&lt;/c&gt;</ept> may include directory and drive of the destination location.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>NewPath<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio y la unidad de la ubicación de destino.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>The file name specified by <bpt id="p1">&lt;c&gt;</bpt>NewPath<ept id="p1">&lt;/c&gt;</ept> cannot already exist.</source>
          <target state="translated">El nombre de archivo especificado por <bpt id="p1">&lt;c&gt;</bpt>NewPath<ept id="p1">&lt;/c&gt;</ept> no puede existir.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Renames a disk file or directory.</source>
          <target state="translated">Cambia el nombre de un archivo o directorio ubicado en el disco.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Rename" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Rename" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>The<ph id="ph1">`Rename`</ph> function renames a file and moves it to a different directory, if it is required.</source>
          <target state="translated">El<ph id="ph1">`Rename`</ph> función cambia el nombre de un archivo y lo mueve a un directorio diferente, si es necesario.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>The <ph id="ph1">`Rename`</ph> function can move a file across drives, but it can only rename an existing directory when both <ph id="ph2">`NewPath`</ph> and <ph id="ph3">`OldPath`</ph> are located on the same drive.</source>
          <target state="translated">El <ph id="ph1">`Rename`</ph> función puede mover un archivo a través de unidades, pero sólo puede cambiar el nombre de un directorio existente cuando ambos <ph id="ph2">`NewPath`</ph> y <ph id="ph3">`OldPath`</ph> se encuentran en la misma unidad.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><ph id="ph1">`Rename`</ph> cannot create a new file or directory.</source>
          <target state="translated"><ph id="ph1">`Rename`</ph> no se puede crear un nuevo archivo o directorio.</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Using the <ph id="ph1">`Rename`</ph> function on an open file produces an error.</source>
          <target state="translated">Mediante el <ph id="ph1">`Rename`</ph> función en un archivo abierto genera un error.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>You must close an open file before renaming it.</source>
          <target state="translated">Debe cerrar un archivo abierto antes de cambiarle el nombre.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><ph id="ph1">`Rename`</ph> arguments cannot include multiple-character (*) and single-character (?) wildcards.</source>
          <target state="translated"><ph id="ph1">`Rename`</ph> argumentos no pueden incluir caracteres comodines de carácter único (?) y varios caracteres (*).</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>When using <ph id="ph1">`Rename`</ph> to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</source>
          <target state="translated">Cuando se usa <ph id="ph1">`Rename`</ph> para copiar un archivo desde una ubicación no protegida en una ubicación protegida, el archivo conserva los derechos menos restrictivos.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Check to make sure that you are not introducing a possible security risk.</source>
          <target state="translated">Comprobación para asegurarse de que no están introduciendo un posible riesgo de seguridad.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>This example uses the <ph id="ph1">`Rename`</ph> function to rename a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Rename`</ph> función para cambiar el nombre de un archivo.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>For purposes of this example, assume that the directories that are specified already exist.</source>
          <target state="translated">Para fines de este ejemplo, suponga que los directorios especificados ya existen.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Path is invalid.</source>
          <target state="translated">La ruta de acceso no es válida.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="OldPath" /&gt;</ph> file does not exist.</source>
          <target state="translated">El archivo <ph id="ph1">&lt;paramref name="OldPath" /&gt;</ph> no existe.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)">
          <source>Cannot rename to different device.</source>
          <target state="translated">No se puede cambiar el nombre en un dispositivo diferente.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>Closes all disk files opened by using the <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Cierra todos los archivos ubicados en el disco que se han abierto mediante la función <ph id="ph1">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Reset" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Reset" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>The <ph id="ph1">`Reset`</ph> function closes all active files opened by the <ph id="ph2">`FileOpen`</ph> function and has the same function as <ph id="ph3">`FileClose()`</ph> without any parameters.</source>
          <target state="translated">El <ph id="ph1">`Reset`</ph> función cierra todos los archivos activos abiertos por la <ph id="ph2">`FileOpen`</ph> función y tiene la misma función que <ph id="ph3">`FileClose()`</ph> sin ningún parámetro.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>This example uses the <ph id="ph1">`Reset`</ph> function to close all open files and write the contents of all file buffers to disk.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Reset`</ph> función para cerrar todos los archivos abiertos y escribir el contenido de todos los búferes de archivo en el disco.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Reset">
          <source>Note the use of the <ph id="ph1">`Object`</ph> variable <ph id="ph2">`FileNumber`</ph> as both a string and a number.</source>
          <target state="translated">Tenga en cuenta el uso de la <ph id="ph1">`Object`</ph> variable <ph id="ph2">`FileNumber`</ph> como una cadena y un número.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that identifies the directory or folder to be removed.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que identifica el directorio o la carpeta que se va a quitar.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source><bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> can include the drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>Path<ept id="p1">&lt;/c&gt;</ept> puede incluir la unidad.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>If no drive is specified, <ph id="ph1">&lt;see langword="RmDir" /&gt;</ph> removes the directory on the current drive.</source>
          <target state="translated">Si no hay ninguna unidad especificada, <ph id="ph1">&lt;see langword="RmDir" /&gt;</ph> quita el directorio de la unidad actual.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>Removes an existing directory.</source>
          <target state="translated">Quita un directorio existente.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="RmDir" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="RmDir" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>For more information, see <ph id="ph1">&lt;see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>An error occurs if you try to use <ph id="ph1">`RmDir`</ph> on a directory that contains files.</source>
          <target state="translated">Se produce un error si intenta utilizar <ph id="ph1">`RmDir`</ph> en un directorio que contiene los archivos.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>Use the <ph id="ph1">`Kill`</ph> function to delete all files before you try to remove a directory.</source>
          <target state="translated">Use la <ph id="ph1">`Kill`</ph> función para eliminar todos los archivos antes de intentar quitar un directorio.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>This example uses the <ph id="ph1">`RmDir`</ph> function to remove an existing directory.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`RmDir`</ph> function para quitar un directorio existente.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> is not specified or is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="Path" /&gt;</ph> no se ha especificado o está vacío.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>Target directory contains files.</source>
          <target state="translated">El directorio de destino contiene archivos.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)">
          <source>Directory does not exist.</source>
          <target state="translated">El directorio no existe.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> specifying the current read/write position in a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> that contains a valid file number.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene un número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> specifying the current read/write position in a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> specifying the current read/write position in a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source><ph id="ph1">`Seek`</ph> returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</source>
          <target state="translated"><ph id="ph1">`Seek`</ph> Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 – 1), ambos inclusive.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>The following describes the return values for each file access mode:</source>
          <target state="translated">A continuación describe los valores devueltos para cada modo de acceso de archivo:</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Mode</source>
          <target state="translated">Modo</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Return Value</source>
          <target state="translated">Valor devuelto</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Number of the next record read or written</source>
          <target state="translated">Número del siguiente registro leído o escrito</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source><ph id="ph1">`Binary`</ph>, <ph id="ph2">`Input`</ph>, <ph id="ph3">`Output`</ph>, <ph id="ph4">`Append`</ph></source>
          <target state="translated"><ph id="ph1">`Binary`</ph>, <ph id="ph2">`Input`</ph>, <ph id="ph3">`Output`</ph>, <ph id="ph4">`Append`</ph></target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Byte position at which the next operation occurs.</source>
          <target state="translated">Posición del byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>The first byte in a file is at position 1, the second byte is at position 2, and so on.</source>
          <target state="translated">El primer byte en un archivo está en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>This example uses the <ph id="ph1">`Seek`</ph> function to return the current file position.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Seek`</ph> función para devolver la posición actual del archivo.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>The example assumes <ph id="ph1">`TestFile`</ph> is a file that contains records of the structure <ph id="ph2">`Record`</ph>.</source>
          <target state="translated">En el ejemplo se da por supuesto <ph id="ph1">`TestFile`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Record`</ph>.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> returns the number of next record.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> devuelve el número del siguiente registro.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>For files opened in modes other than <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> returns the byte position at which the next operation occurs.</source>
          <target state="translated">Para los archivos abiertos en modos distintos de <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> devuelve la posición de byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Assume <ph id="ph1">`TestFile`</ph> is a file that contains several lines of text.</source>
          <target state="translated">Suponga <ph id="ph1">`TestFile`</ph> es un archivo que contiene varias líneas de texto.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>This example uses the <ph id="ph1">`Seek`</ph> function to set the position for the next read or write in a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Seek`</ph> función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>For files opened in modes other than <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> sets the byte position at which the next operation occurs.</source>
          <target state="translated">Para los archivos abiertos en modos distintos de <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> establece la posición de byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>Assume <ph id="ph1">`TestFile`</ph> is a file that contains several lines of text.</source>
          <target state="translated">Suponga <ph id="ph1">`TestFile`</ph> es un archivo que contiene varias líneas de texto.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> that contains a valid file number.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene un número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</source>
          <target state="translated">Número del 1 al 2.147.483.647, incluido, que indica dónde debe llevarse a cabo la siguiente operación de lectura o escritura.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Returns a <ph id="ph1">&lt;see langword="Long" /&gt;</ph> specifying the current read/write position in a file opened by using the <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> function, or sets the position for the next read/write operation in a file opened by using the <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph> function.</source>
          <target state="translated">Devuelve un valor <ph id="ph1">&lt;see langword="Long" /&gt;</ph> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <ph id="ph2">&lt;see langword="FileOpen" /&gt;</ph> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <ph id="ph3">&lt;see langword="FileOpen" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="Seek" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source><ph id="ph1">`Seek`</ph> returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</source>
          <target state="translated"><ph id="ph1">`Seek`</ph> Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 – 1), ambos inclusive.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>The following describes the return values for each file access mode:</source>
          <target state="translated">A continuación describe los valores devueltos para cada modo de acceso de archivo:</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Mode</source>
          <target state="translated">Modo</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Return Value</source>
          <target state="translated">Valor devuelto</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Number of the next record read or written</source>
          <target state="translated">Número del siguiente registro leído o escrito</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source><ph id="ph1">`Binary`</ph>, <ph id="ph2">`Input`</ph>, <ph id="ph3">`Output`</ph>, <ph id="ph4">`Append`</ph></source>
          <target state="translated"><ph id="ph1">`Binary`</ph>, <ph id="ph2">`Input`</ph>, <ph id="ph3">`Output`</ph>, <ph id="ph4">`Append`</ph></target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Byte position at which the next operation occurs.</source>
          <target state="translated">Posición del byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>The first byte in a file is at position 1, the second byte is at position 2, and so on.</source>
          <target state="translated">El primer byte en un archivo está en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>This example uses the <ph id="ph1">`Seek`</ph> function to return the current file position.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Seek`</ph> función para devolver la posición actual del archivo.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>The example assumes <ph id="ph1">`TestFile`</ph> is a file that contains records of the structure <ph id="ph2">`Record`</ph>.</source>
          <target state="translated">En el ejemplo se da por supuesto <ph id="ph1">`TestFile`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Record`</ph>.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>For files opened in <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> returns the number of next record.</source>
          <target state="translated">Para abren archivos en <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> devuelve el número del siguiente registro.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>For files opened in modes other than <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> returns the byte position at which the next operation occurs.</source>
          <target state="translated">Para los archivos abiertos en modos distintos de <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> devuelve la posición de byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Assume <ph id="ph1">`TestFile`</ph> is a file that contains several lines of text.</source>
          <target state="translated">Suponga <ph id="ph1">`TestFile`</ph> es un archivo que contiene varias líneas de texto.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>This example uses the <ph id="ph1">`Seek`</ph> function to set the position for the next read or write in a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Seek`</ph> función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>For files opened in modes other than <ph id="ph1">`Random`</ph> mode, <ph id="ph2">`Seek`</ph> sets the byte position at which the next operation occurs.</source>
          <target state="translated">Para los archivos abiertos en modos distintos de <ph id="ph1">`Random`</ph> modo, <ph id="ph2">`Seek`</ph> establece la posición de byte en el que se produce la siguiente operación.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>Assume <ph id="ph1">`TestFile`</ph> is a file that contains several lines of text.</source>
          <target state="translated">Suponga <ph id="ph1">`TestFile`</ph> es un archivo que contiene varias líneas de texto.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source><ph id="ph1">&lt;see langword="String" /&gt;</ph> expression that specifies a file name.</source>
          <target state="translated">Expresión de tipo <ph id="ph1">&lt;see langword="String" /&gt;</ph> que especifica un nombre de archivo.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> can include directory or folder, and drive.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>PathName<ept id="p1">&lt;/c&gt;</ept> puede incluir el directorio o la carpeta y la unidad.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Constant or numeric expression, whose sum specifies file attributes.</source>
          <target state="translated">Constante o expresión numérica, cuya suma especifica los atributos de un archivo.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Sets attribute information for a file.</source>
          <target state="translated">Establece la información de atributos de un archivo.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="SetAttr" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <ph id="ph2">&lt;see langword="SetAttr" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>A run-time error occurs if you try to set the attributes of an open file.</source>
          <target state="translated">Se produce un error de tiempo de ejecución si se intenta establecer los atributos de un archivo abierto.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The <ph id="ph1">`Attributes`</ph> argument enumeration values are as follows:</source>
          <target state="translated">El <ph id="ph1">`Attributes`</ph> valores de enumeración del argumento son los siguientes:</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Value</source>
          <target state="translated">Valor</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Constant</source>
          <target state="translated">Constante</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Description</source>
          <target state="translated">Descripción</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Normal (default).</source>
          <target state="translated">Normal (predeterminado).</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Read-only.</source>
          <target state="translated">Sólo lectura.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Hidden.</source>
          <target state="translated">Oculto.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>System file.</source>
          <target state="translated">Archivo de sistema.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Volume label</source>
          <target state="translated">Etiqueta de volumen</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>Directory or folder.</source>
          <target state="translated">Directorio o carpeta.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>File has changed since last backup.</source>
          <target state="translated">El archivo ha cambiado desde que se realizó la última copia de seguridad.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>File has a different name.</source>
          <target state="translated">El archivo tiene un nombre diferente.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>These enumerations are specified by the Visual Basic language.</source>
          <target state="translated">El lenguaje de Visual Basic especifica estas enumeraciones.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>The names can be used anywhere in your code instead of the actual values.</source>
          <target state="translated">Los nombres se pueden usar en cualquier parte del código en lugar de los valores reales.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source>This example uses the <ph id="ph1">`SetAttr`</ph> function to set attributes for a file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`SetAttr`</ph> función para establecer los atributos de un archivo.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)">
          <source><ph id="ph1">&lt;paramref name="Attribute" /&gt;</ph> type is invalid.</source>
          <target state="translated">El tipo de <ph id="ph1">&lt;paramref name="Attribute" /&gt;</ph> no es válido.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>The number of spaces to insert before displaying or printing the next expression in a list.</source>
          <target state="translated">Número de espacios que se van a insertar antes de mostrar o imprimir la siguiente expresión en una lista.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> function to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar la salida.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> function to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar la salida.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>If <ph id="ph1">`Count`</ph> is less than the output line width, the next print position immediately follows the number of spaces printed.</source>
          <target state="translated">Si <ph id="ph1">`Count`</ph> es menor que el ancho de línea de salida, la siguiente posición de impresión inmediatamente sigue el número de espacios impresos.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>If<ph id="ph1">`Count`</ph> is greater than the output line width, <ph id="ph2">`SPC`</ph> calculates the next print position using the formula:</source>
          <target state="translated">Si<ph id="ph1">`Count`</ph> es mayor que el ancho de línea de salida, <ph id="ph2">`SPC`</ph> calcula la siguiente posición de impresión mediante la fórmula:</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source><ph id="ph1">`currentprintposition`</ph>(+(<ph id="ph2">`Count``Mod``width`</ph>))</source>
          <target state="translated"><ph id="ph1">`currentprintposition`</ph>(+(<ph id="ph2">`Count``Mod``width`</ph>))</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>For example, if the current print position is 24, the output line width is 80, and you specify <ph id="ph1">`SPC(90)`</ph>, the next print will start at position 34 (current print position + the remainder of 90/80).</source>
          <target state="translated">Por ejemplo, si la actual posición de impresión es 24, el ancho de línea de salida es 80 y se especifica <ph id="ph1">`SPC(90)`</ph>, la próxima impresión comenzará en la posición 34 (posición de impresión actual + el resto de 90/80).</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>If the difference between the current print position and the output line width is less than <ph id="ph1">`Count`</ph> (or <ph id="ph2">`Count`</ph> <ph id="ph3">`Mod`</ph> <bpt id="p1">*</bpt>width<ept id="p1">*</ept>), the <ph id="ph4">`SPC`</ph> function skips to the start of the next line and generates spaces equal to <ph id="ph5">`Count`</ph> – (<bpt id="p2">*</bpt>width<ept id="p2">*</ept> – <bpt id="p3">*</bpt>currentprintposition<ept id="p3">*</ept>).</source>
          <target state="translated">Si la diferencia entre la actual posición de impresión y el ancho de línea de salida es menor que <ph id="ph1">`Count`</ph> (o <ph id="ph2">`Count`</ph> <ph id="ph3">`Mod`</ph> <bpt id="p1">*</bpt>ancho<ept id="p1">*</ept>), el <ph id="ph4">`SPC`</ph> función salta al principio de la línea siguiente y genera espacios igual a <ph id="ph5">`Count`</ph> – (<bpt id="p2">*</bpt>ancho<ept id="p2">*</ept> : <bpt id="p3">*</bpt>posiciónDeImpresiónActual<ept id="p3">*</ept>).</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>Make sure your tabular columns are wide enough to allow for wide letters.</source>
          <target state="translated">Asegúrese de que las columnas tabulares sean suficientemente anchas para que quepan letras anchas.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)">
          <source>This example uses the <ph id="ph1">`SPC`</ph> function to position output in a file and in the <bpt id="p1">**</bpt>Output<ept id="p1">**</ept> window.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`SPC`</ph> función para colocar el resultado en un archivo y en la <bpt id="p1">**</bpt>salida<ept id="p1">**</ept> ventana.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> functions to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar el resultado.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> functions to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar el resultado.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> functions to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar el resultado.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>If the current print position on the current line is larger than <ph id="ph1">`Column`</ph>, <ph id="ph2">`TAB`</ph> skips to the column value equal to <ph id="ph3">`Column`</ph> on the next output line.</source>
          <target state="translated">Si la actual posición de impresión en la línea actual es mayor que <ph id="ph1">`Column`</ph>, <ph id="ph2">`TAB`</ph> saltará al valor de columna igual a <ph id="ph3">`Column`</ph> en la siguiente línea de salida.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>If <ph id="ph1">`Column`</ph> is less than 1, <ph id="ph2">`TAB`</ph> moves the print position to column 1.</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es menor que 1, <ph id="ph2">`TAB`</ph> mueve la posición de impresión a la columna 1.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>If <ph id="ph1">`Column`</ph> is larger than the output line width, <ph id="ph2">`TAB`</ph> calculates the next print position using the formula:</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es mayor que el ancho de línea de salida, <ph id="ph2">`TAB`</ph> calcula la siguiente posición de impresión mediante la fórmula:</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>Column Mod width</source>
          <target state="translated">Mod ancho de columna</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>For example, if <bpt id="p1">*</bpt>width<ept id="p1">*</ept> is 80 and you specify <ph id="ph1">`TAB(90)`</ph>, the next print will start at column 10 (the remainder of 90/80).</source>
          <target state="translated">Por ejemplo, si <bpt id="p1">*</bpt>ancho<ept id="p1">*</ept> es 80 y se especifica <ph id="ph1">`TAB(90)`</ph>, la próxima impresión comenzará en la columna 10 (el resto de 90/80).</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>If <ph id="ph1">`Column`</ph> is less than the current print position, printing starts on the next line at the calculated print position.</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</source>
          <target state="translated">Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comenzará en la posición de impresión en la misma línea.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>The leftmost print position on an output line is always 1.</source>
          <target state="translated">La posición de impresión más a la izquierda en una línea de salida es siempre 1.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>When you use the <ph id="ph1">`Print`</ph> or <ph id="ph2">`PrintLine`</ph> functions to print to files, the rightmost print position is the current width of the output file, which you can set using the <ph id="ph3">`FileWidth`</ph> function.</source>
          <target state="translated">Cuando se usa el <ph id="ph1">`Print`</ph> o <ph id="ph2">`PrintLine`</ph> funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el <ph id="ph3">`FileWidth`</ph> función.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>The <ph id="ph1">`TAB`</ph> function can also be used with the <ph id="ph2">`WriteLine`</ph> function.</source>
          <target state="translated">El <ph id="ph1">`TAB`</ph> función también puede utilizarse con el <ph id="ph2">`WriteLine`</ph> función.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>It cannot be used with <ph id="ph1">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No se puede usar con <ph id="ph1">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>Make sure your tabular columns are wide enough to contain wide letters.</source>
          <target state="translated">Asegúrese de que las columnas tabulares sean lo suficientemente ancha para contener letras anchas.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB">
          <source>This example uses the <ph id="ph1">`TAB`</ph> function to position output in a file and in the <bpt id="p1">**</bpt>Output<ept id="p1">**</ept> window.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`TAB`</ph> función para colocar el resultado en un archivo y en la <bpt id="p1">**</bpt>salida<ept id="p1">**</ept> ventana.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>The column number moved to before displaying or printing the next expression in a list.</source>
          <target state="translated">Número de columna a la que se realiza el desplazamiento antes de mostrar o imprimir la siguiente expresión en una lista.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If omitted, <ph id="ph1">&lt;see langword="TAB" /&gt;</ph> moves the insertion point to the start of the next print zone.</source>
          <target state="translated">Si se omite, <ph id="ph1">&lt;see langword="TAB" /&gt;</ph> mueve el punto de inserción al principio de la siguiente zona de impresión.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> functions to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar el resultado.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>Used with the <ph id="ph1">&lt;see langword="Print" /&gt;</ph> or <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> functions to position output.</source>
          <target state="translated">Se utiliza con la función <ph id="ph1">&lt;see langword="Print" /&gt;</ph> o <ph id="ph2">&lt;see langword="PrintLine" /&gt;</ph> para colocar el resultado.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If the current print position on the current line is greater than <ph id="ph1">`Column`</ph>, <ph id="ph2">`TAB`</ph> skips to the column value equal to <ph id="ph3">`Column`</ph> on the next output line.</source>
          <target state="translated">Si la actual posición de impresión en la línea actual es mayor que <ph id="ph1">`Column`</ph>, <ph id="ph2">`TAB`</ph> saltará al valor de columna igual a <ph id="ph3">`Column`</ph> en la siguiente línea de salida.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If <ph id="ph1">`Column`</ph> is less than 1, <ph id="ph2">`TAB`</ph> moves the print position to column 1.</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es menor que 1, <ph id="ph2">`TAB`</ph> mueve la posición de impresión a la columna 1.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If <ph id="ph1">`Column`</ph> is greater than the output line width, <ph id="ph2">`TAB`</ph> calculates the next print position using the formula:</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es mayor que el ancho de línea de salida, <ph id="ph2">`TAB`</ph> calcula la siguiente posición de impresión mediante la fórmula:</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>Column Mod width</source>
          <target state="translated">Mod ancho de columna</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>For example, if <bpt id="p1">*</bpt>width<ept id="p1">*</ept> is 80 and you specify <ph id="ph1">`TAB(90)`</ph>, the next print will start at column 10 (the remainder of 90/80).</source>
          <target state="translated">Por ejemplo, si <bpt id="p1">*</bpt>ancho<ept id="p1">*</ept> es 80 y se especifica <ph id="ph1">`TAB(90)`</ph>, la próxima impresión comenzará en la columna 10 (el resto de 90/80).</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If <ph id="ph1">`Column`</ph> is less than the current print position, printing starts on the next line at the calculated print position.</source>
          <target state="translated">Si <ph id="ph1">`Column`</ph> es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</source>
          <target state="translated">Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comenzará en la posición de impresión en la misma línea.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>The leftmost print position on an output line is always 1.</source>
          <target state="translated">La posición de impresión más a la izquierda en una línea de salida es siempre 1.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>When you use the <ph id="ph1">`Print`</ph> or <ph id="ph2">`PrintLine`</ph> functions to print to files, the rightmost print position is the current width of the output file, which you can set using the <ph id="ph3">`FileWidth`</ph> function.</source>
          <target state="translated">Cuando se usa el <ph id="ph1">`Print`</ph> o <ph id="ph2">`PrintLine`</ph> funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el <ph id="ph3">`FileWidth`</ph> función.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>The <ph id="ph1">`TAB`</ph> function can also be used with the <ph id="ph2">`WriteLine`</ph> function.</source>
          <target state="translated">El <ph id="ph1">`TAB`</ph> función también puede utilizarse con el <ph id="ph2">`WriteLine`</ph> función.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>It cannot be used with <ph id="ph1">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">No se puede usar con <ph id="ph1">&lt;xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType&gt;</ph> o <ph id="ph2">&lt;xref:System.Console.WriteLine%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>Make sure your tabular columns are wide enough to contain wide letters.</source>
          <target state="translated">Asegúrese de que las columnas tabulares sean lo suficientemente ancha para contener letras anchas.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)">
          <source>This example uses the <ph id="ph1">`TAB`</ph> function to position output in a file and in the <bpt id="p1">**</bpt>Output<ept id="p1">**</ept> window.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`TAB`</ph> función para colocar el resultado en un archivo y en la <bpt id="p1">**</bpt>salida<ept id="p1">**</ept> ventana.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="T:Microsoft.VisualBasic.FileSystem">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>Number of the only record or byte to lock or unlock</source>
          <target state="translated">Número del único registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Any valid file number.</source>
          <target state="translated">Cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Number of the first record or byte to lock or unlock.</source>
          <target state="translated">Número del primer registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Number of the last record or byte to lock or unlock.</source>
          <target state="translated">Número del último registro o byte que se va a bloquear o desbloquear.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>Controls access by other processes to all or part of a file opened by using the <ph id="ph1">&lt;see langword="Open" /&gt;</ph> function.</source>
          <target state="translated">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <ph id="ph1">&lt;see langword="Open" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">&lt;see langword="My" /&gt;</ph> feature gives you better productivity and performance in file I/O operations than <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> and <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph>.</source>
          <target state="translated">La característica <ph id="ph1">&lt;see langword="My" /&gt;</ph> proporciona más productividad y rendimiento que <ph id="ph2">&lt;see langword="Lock" /&gt;</ph> y <ph id="ph3">&lt;see langword="Unlock" /&gt;</ph> en las operaciones de E/S con archivos.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>For more information, see <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>The <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are used in environments where several processes might need access to the same file.</source>
          <target state="translated">El <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source><ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions are always used in pairs.</source>
          <target state="translated"><ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones se usan siempre en pares.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>The arguments to <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> must be identical.</source>
          <target state="translated">Los argumentos de <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> deben ser idénticos.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph>, or <ph id="ph2">`FromRecord`</ph> and <ph id="ph3">`ToRecord`</ph> are not supplied, the lock will be for the whole file.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph>, o <ph id="ph2">`FromRecord`</ph> y <ph id="ph3">`ToRecord`</ph> no son se proporciona, será el bloqueo para todo el archivo.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>If <ph id="ph1">`Record`</ph> alone is specified the single record will be locked/unlocked.</source>
          <target state="translated">Si <ph id="ph1">`Record`</ph> por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>If the file has been opened for sequential input or output, <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> affect the whole file, regardless of the range specified by <ph id="ph3">`FromRecord`</ph> and<ph id="ph4">`ToRecord`</ph>.</source>
          <target state="translated">Si el archivo se ha abierto para entradas o salidas, secuenciales <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> afectan a todo el archivo, sin tener en cuenta el intervalo especificado por <ph id="ph3">`FromRecord`</ph> y<ph id="ph4">`ToRecord`</ph>.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>This example illustrates the use of the <ph id="ph1">`Lock`</ph> and <ph id="ph2">`Unlock`</ph> functions.</source>
          <target state="translated">Este ejemplo muestra el uso de la <ph id="ph1">`Lock`</ph> y <ph id="ph2">`Unlock`</ph> funciones.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>This example assumes that <ph id="ph1">`People.txt`</ph> is a file that contains records of the structure <ph id="ph2">`Person`</ph>.</source>
          <target state="translated">En este ejemplo se da por supuesto que <ph id="ph1">`People.txt`</ph> es un archivo que contiene registros de la estructura <ph id="ph2">`Person`</ph>.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> expression that contains any valid file number.</source>
          <target state="translated">Expresión <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>One or more comma-delimited expressions to write to a file.</source>
          <target state="translated">Una o más expresiones delimitadas por comas para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Writes data to a sequential file.</source>
          <target state="translated">Escribe datos en un archivo secuencial.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Data written with <ph id="ph1">&lt;see langword="Write" /&gt;</ph> is usually read from a file by using <ph id="ph2">&lt;see langword="Input" /&gt;</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">&lt;see langword="Write" /&gt;</ph> normalmente se leen desde un archivo mediante <ph id="ph2">&lt;see langword="Input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Write`</ph> and <ph id="ph2">`WriteLine`</ph> functions are provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Write`</ph> y <ph id="ph2">`WriteLine`</ph> funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>If you omit <ph id="ph1">`Output`</ph>, a blank line is printed to the file.</source>
          <target state="translated">Si se omite <ph id="ph1">`Output`</ph>, se imprime una línea en blanco en el archivo.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Multiple expressions can be separated with a comma.</source>
          <target state="translated">Pueden separar varias expresiones con una coma.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Unlike the <ph id="ph1">`Print`</ph> function, the <ph id="ph2">`Write`</ph> function inserts commas between items and quotation marks around strings as they are written to the file.</source>
          <target state="translated">A diferencia de la <ph id="ph1">`Print`</ph> función, el <ph id="ph2">`Write`</ph> función inserta comas entre los elementos y las cadenas entre comillas, tal y como se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>You do not have to put explicit delimiters in the list.</source>
          <target state="translated">No es necesario colocar delimitadores explícitos en la lista.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>When <ph id="ph1">`Write`</ph> is used to write data to a file, only numeric, <ph id="ph2">`Boolean`</ph>, date, null, and <ph id="ph3">`Error`</ph> data formats are supported.</source>
          <target state="translated">Cuando <ph id="ph1">`Write`</ph> se usa para escribir datos en un archivo, solo numérico, <ph id="ph2">`Boolean`</ph>, fecha, null, y <ph id="ph3">`Error`</ph> se admiten formatos de datos.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>The following universal assumptions are followed so the data can always be read and correctly interpreted using <ph id="ph1">`Input`</ph>, regardless of locale:</source>
          <target state="translated">Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretación correctamente mediante <ph id="ph1">`Input`</ph>, independientemente de la configuración regional:</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Numeric data is always written using the period as the decimal separator.</source>
          <target state="translated">Datos numéricos siempre se escriben utilizando la coma como separador decimal.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Boolean`</ph> data, either <ph id="ph2">`#TRUE#`</ph> or <ph id="ph3">`#FALSE#`</ph> is printed.</source>
          <target state="translated">Para <ph id="ph1">`Boolean`</ph> datos, ya sea <ph id="ph2">`#TRUE#`</ph> o <ph id="ph3">`#FALSE#`</ph> se imprime.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`True`</ph> and <ph id="ph2">`False`</ph> keywords are not translated, regardless of locale.</source>
          <target state="translated">El <ph id="ph1">`True`</ph> y <ph id="ph2">`False`</ph> palabras clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Date data is written to the file using the universal date format.</source>
          <target state="translated">Datos de fecha se escriben en el archivo con el formato de fecha universal.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>When either the date or the time component is missing or zero, only the part provided is written to the file.</source>
          <target state="translated">Cuando la fecha o el componente de hora falta o es cero, solo la parte siempre se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Nothing is written to the file if <ph id="ph1">`Output`</ph> data is empty.</source>
          <target state="translated">Se escribirá nada en el archivo si <ph id="ph1">`Output`</ph> datos están vacíos.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>However, for null data, <ph id="ph1">`#NULL#`</ph> is written.</source>
          <target state="translated">Sin embargo, para datos nulos, <ph id="ph1">`#NULL#`</ph> se escribe.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Error`</ph> data, the output appears as <ph id="ph2">`#ERROR errorcode#`</ph>.</source>
          <target state="translated">Para <ph id="ph1">`Error`</ph> aparece de la salida de datos, como <ph id="ph2">`#ERROR errorcode#`</ph>.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Error`</ph> keyword is not translated, regardless of locale.</source>
          <target state="translated">El <ph id="ph1">`Error`</ph> palabra clave no está traducida, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source><ph id="ph1">`WriteLine`</ph> inserts a newline character (that is, a carriage return/line feed, or <ph id="ph2">`Chr(13) + Chr(10)`</ph>), after it has written the final character in <ph id="ph3">`Output`</ph> to the file.</source>
          <target state="translated"><ph id="ph1">`WriteLine`</ph> Inserta un carácter de nueva línea (es decir, un retorno de carro/línea fuente, o <ph id="ph2">`Chr(13) + Chr(10)`</ph>), una vez se ha escrito el último carácter de <ph id="ph3">`Output`</ph> al archivo.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>You can embed quotation marks in a string by using double quotation marks, or "".</source>
          <target state="translated">Puede incrustar comillas en una cadena mediante el uso de comillas dobles o "".</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>returns a string with the value of <ph id="ph1">`Double quotation marks aren't "difficult" to handle`</ph>.</source>
          <target state="translated">Devuelve una cadena con el valor de <ph id="ph1">`Double quotation marks aren't "difficult" to handle`</ph>.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>Writing to a file by using the <ph id="ph1">`Write`</ph> or <ph id="ph2">`WriteLine`</ph> functions requires <ph id="ph3">`Append`</ph> access from the <ph id="ph4">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`Write`</ph> o <ph id="ph2">`WriteLine`</ph> funciones requiere <ph id="ph3">`Append`</ph> acceder desde el <ph id="ph4">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>This example uses the <ph id="ph1">`Write`</ph> function to write raw data to a sequential file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Write`</ph> función para escribir datos sin procesar en un archivo secuencial.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])">
          <source>File mode is invalid.</source>
          <target state="translated">El modo de archivo no es válido.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Required.</source>
          <target state="translated">Obligatorio.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>An <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> expression that contains any valid file number.</source>
          <target state="translated">Expresión <ph id="ph1">&lt;see langword="Integer" /&gt;</ph> que contiene cualquier número de archivo válido.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Optional.</source>
          <target state="translated">Opcional.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>One or more comma-delimited expressions to write to a file.</source>
          <target state="translated">Una o más expresiones delimitadas por comas para escribir en un archivo.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Writes data to a sequential file.</source>
          <target state="translated">Escribe datos en un archivo secuencial.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Data written with <ph id="ph1">&lt;see langword="Write" /&gt;</ph> is usually read from a file by using <ph id="ph2">&lt;see langword="Input" /&gt;</ph>.</source>
          <target state="translated">Los datos escritos con <ph id="ph1">&lt;see langword="Write" /&gt;</ph> normalmente se leen desde un archivo mediante <ph id="ph2">&lt;see langword="Input" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Write`</ph> and <ph id="ph2">`WriteLine`</ph> functions are provided for backward compatibility and may affect performance.</source>
          <target state="translated">El <ph id="ph1">`Write`</ph> y <ph id="ph2">`WriteLine`</ph> funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For non-legacy applications, the <ph id="ph1">`My.Computer.FileSystem`</ph> object provides better performance.</source>
          <target state="translated">Aplicaciones no heredadas, el <ph id="ph1">`My.Computer.FileSystem`</ph> objeto proporciona un mejor rendimiento.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For more information, see <bpt id="p1">[</bpt>File Access with Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</source>
          <target state="translated">Para obtener más información, consulte <bpt id="p1">[</bpt>acceso a archivos con Visual Basic<ept id="p1">](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>If you omit <ph id="ph1">`Output`</ph>, a blank line is printed to the file.</source>
          <target state="translated">Si se omite <ph id="ph1">`Output`</ph>, se imprime una línea en blanco en el archivo.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Multiple expressions can be separated with a comma.</source>
          <target state="translated">Pueden separar varias expresiones con una coma.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Unlike the <ph id="ph1">`Print`</ph> function, the <ph id="ph2">`Write`</ph> function inserts commas between items and quotation marks around strings as they are written to the file.</source>
          <target state="translated">A diferencia de la <ph id="ph1">`Print`</ph> función, el <ph id="ph2">`Write`</ph> función inserta comas entre los elementos y las cadenas entre comillas, tal y como se escriben en el archivo.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>You do not have to put explicit delimiters in the list.</source>
          <target state="translated">No es necesario colocar delimitadores explícitos en la lista.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>When <ph id="ph1">`Write`</ph> is used to write data to a file, only numeric, <ph id="ph2">`Boolean`</ph>, date, null, and <ph id="ph3">`Error`</ph> data formats are supported.</source>
          <target state="translated">Cuando <ph id="ph1">`Write`</ph> se usa para escribir datos en un archivo, solo numérico, <ph id="ph2">`Boolean`</ph>, fecha, null, y <ph id="ph3">`Error`</ph> se admiten formatos de datos.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>The following universal assumptions are followed so the data can always be read and correctly interpreted using <ph id="ph1">`Input`</ph>, regardless of locale:</source>
          <target state="translated">Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretación correctamente mediante <ph id="ph1">`Input`</ph>, independientemente de la configuración regional:</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Numeric data is always written using the period as the decimal separator.</source>
          <target state="translated">Datos numéricos siempre se escriben utilizando la coma como separador decimal.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Boolean`</ph> data, either <ph id="ph2">`#TRUE#`</ph> or <ph id="ph3">`#FALSE#`</ph> is printed.</source>
          <target state="translated">Para <ph id="ph1">`Boolean`</ph> datos, ya sea <ph id="ph2">`#TRUE#`</ph> o <ph id="ph3">`#FALSE#`</ph> se imprime.</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`True`</ph> and <ph id="ph2">`False`</ph> keywords are not translated, regardless of locale.</source>
          <target state="translated">El <ph id="ph1">`True`</ph> y <ph id="ph2">`False`</ph> palabras clave no se traduce, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Date data is written to the file using the universal date format.</source>
          <target state="translated">Datos de fecha se escriben en el archivo con el formato de fecha universal.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>When either the date or the time component is missing or zero, only the part provided is written to the file.</source>
          <target state="translated">Cuando la fecha o el componente de hora falta o es cero, solo la parte siempre se escribe en el archivo.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Nothing is written to the file if <ph id="ph1">`Output`</ph> data is empty.</source>
          <target state="translated">Se escribirá nada en el archivo si <ph id="ph1">`Output`</ph> datos están vacíos.</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>However, for null data, <ph id="ph1">`#NULL#`</ph> is written.</source>
          <target state="translated">Sin embargo, para datos nulos, <ph id="ph1">`#NULL#`</ph> se escribe.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For <ph id="ph1">`Error`</ph> data, the output appears as <ph id="ph2">`#ERROR errorcode#`</ph>.</source>
          <target state="translated">Para <ph id="ph1">`Error`</ph> aparece de la salida de datos, como <ph id="ph2">`#ERROR errorcode#`</ph>.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>The <ph id="ph1">`Error`</ph> keyword is not translated, regardless of locale.</source>
          <target state="translated">El <ph id="ph1">`Error`</ph> palabra clave no está traducida, independientemente de la configuración regional.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source><ph id="ph1">`WriteLine`</ph> inserts a newline character (that is, a carriage return/line feed, or <ph id="ph2">`Chr(13) + Chr(10)`</ph>), after it has written the final character in <ph id="ph3">`Output`</ph> to the file.</source>
          <target state="translated"><ph id="ph1">`WriteLine`</ph> Inserta un carácter de nueva línea (es decir, un retorno de carro/línea fuente, o <ph id="ph2">`Chr(13) + Chr(10)`</ph>), una vez se ha escrito el último carácter de <ph id="ph3">`Output`</ph> al archivo.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>You can embed quotation marks in a string by using double quotation marks, or "".</source>
          <target state="translated">Puede incrustar comillas en una cadena mediante el uso de comillas dobles o "".</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For example,</source>
          <target state="translated">Por ejemplo,</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>returns a string with the value of <ph id="ph1">`Double quotation marks aren't "difficult" to handle`</ph>.</source>
          <target state="translated">Devuelve una cadena con el valor de <ph id="ph1">`Double quotation marks aren't "difficult" to handle`</ph>.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>Writing to a file by using the <ph id="ph1">`Write`</ph> or <ph id="ph2">`WriteLine`</ph> functions requires <ph id="ph3">`Append`</ph> access from the <ph id="ph4">`FileIOPermissionAccess`</ph> enumeration.</source>
          <target state="translated">Escribir en un archivo mediante el uso de la <ph id="ph1">`Write`</ph> o <ph id="ph2">`WriteLine`</ph> funciones requiere <ph id="ph3">`Append`</ph> acceder desde el <ph id="ph4">`FileIOPermissionAccess`</ph> enumeración.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph> .</source>
          <target state="translated">Para obtener más información, vea <ph id="ph1">&lt;xref:System.Security.Permissions.FileIOPermissionAccess&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])">
          <source>This example uses the <ph id="ph1">`Write`</ph> function to write raw data to a sequential file.</source>
          <target state="translated">Este ejemplo se utiliza la <ph id="ph1">`Write`</ph> función para escribir datos sin procesar en un archivo secuencial.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>