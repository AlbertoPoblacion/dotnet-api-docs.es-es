<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="934f06896ded78a1be250bb2062ad8017ce8cb49" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462104" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>El módulo <see langword="FileSystem" /> contiene los procedimientos utilizados para realizar operaciones con archivos, directorios o carpetas y del sistema. La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones de E/S con archivos que el módulo <see langword="FileSystem" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este módulo admite las palabras clave del lenguaje Visual Basic y miembros de la biblioteca de tiempo de ejecución que tienen acceso a archivos y carpetas.  
  
   
  
## Examples  
 Este ejemplo se usa el `GetAttr` función para determinar los atributos de un archivo, directorio o carpeta.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Resumen de archivos y directorios</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Resumen de entrada y salida</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Palabras clave de Visual Basic</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Miembros de la biblioteca de tiempo de ejecución de Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatorio. Expresión de cadena que identifica el directorio o la carpeta que se convierte en el nuevo directorio predeterminado o la nueva carpeta predeterminada. <paramref name="Path" /> puede incluir la unidad. Si no se especifica ninguna unidad, <see langword="ChDir" /> cambia el directorio predeterminado o la carpeta predeterminada en la unidad actual.</param>
        <summary>Cambia el directorio o la carpeta actual. La característica <see langword="My" /> proporciona mayor productividad y rendimiento que la función <see langword="ChDir" /> en las operaciones de E/S con archivos. Para obtener más información, consulta <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ChDir` función cambia el directorio predeterminado, pero no la unidad predeterminada. Por ejemplo, si la unidad predeterminada es C, la instrucción siguiente cambia el directorio predeterminado en la unidad D, pero C sigue siendo la unidad predeterminada:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Puede convertir en relativo es cambios de directorio, escriba dos puntos, como se indica a continuación:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  El `ChDir` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y.  
  
   
  
## Examples  
 Este ejemplo se usa el `ChDir` función puede cambiar el directorio actual o la carpeta.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> está vacía.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Se ha especificado una unidad no válida o la unidad no está disponible.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Cómo: Analizar rutas de acceso a archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Crear, eliminar y mover archivos y directorios en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cambia la unidad actual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Obligatorio. Expresión de cadena que especifica una unidad existente. Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia. Si el argumento <paramref name="Drive" /> es una cadena de varios caracteres, <see langword="ChDrive" /> utiliza sólo la primera letra.</param>
        <summary>Cambia la unidad actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ChDrive` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este ejemplo se usa el `ChDrive` función puede cambiar la unidad actual. La función produce una excepción si la unidad no existe.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha especificado una unidad no válida o la unidad no está disponible.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Obligatorio. Expresión de cadena que especifica una unidad existente. Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia. Si el argumento <paramref name="Drive" /> es una cadena de varios caracteres, <see langword="ChDrive" /> utiliza sólo la primera letra.</param>
        <summary>Cambia la unidad actual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `ChDrive` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este ejemplo se usa el `ChDrive` función puede cambiar la unidad actual. La función produce una excepción si la unidad no existe.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Se ha especificado una unidad no válida o la unidad no está disponible.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una cadena que representa la ruta de acceso actual. El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que representa la ruta de acceso actual. El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Una cadena que representa la ruta de acceso actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se usa el `CurDir` función para devolver la ruta de acceso actual.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Opcional. Expresión de tipo <see langword="Char" /> que especifica una unidad existente. Si no se especifica ninguna unidad o si <paramref name="Drive" /> es una cadena de longitud cero (""), <see langword="CurDir" /> devuelve la ruta de acceso a la unidad actual.</param>
        <summary>Devuelve una cadena que representa la ruta de acceso actual. El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo. Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Una cadena que representa la ruta de acceso actual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se usa el `CurDir` función para devolver la ruta de acceso actual.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad. El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos. Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad. El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos. Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</summary>
        <returns>Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Dir` función admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.  
  
 `VbVolume` Devuelve la etiqueta de volumen para la unidad en lugar de un nombre de archivo específico.  
  
 Debe proporcionar un `PathName` la primera vez que se llama a la `Dir` función. Para recuperar el elemento siguiente, puede realizar las llamadas posteriores a la `Dir` función sin parámetros.  
  
> [!IMPORTANT]
>  Para ejecutar correctamente, el `Dir` función requiere el <xref:System.Security.Permissions.FileIOPermissionAccess.Read> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución. Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 El `Attributes` valores de enumeración del argumento son los siguientes:  
  
|Valor|Constante|Descripción|  
|-|-|-|  
|`Normal`|`vbnormal`|Predeterminado Especifica los archivos sin atributos.|  
|`ReadOnly`|`vbReadOnly`|Especifica los archivos de solo lectura y también los archivos sin atributos.|  
|`Hidden`|`vbHidden`|Especifica los archivos ocultos y también archivos sin atributos.|  
|`System`|`vbSystem`|Especifica los archivos del sistema y también los archivos sin atributos.|  
|`Volume`|`vbVolume`|Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, `vbVolume` se omite.|  
|`Directory`|`vbDirectory`|Especifica los directorios o carpetas y también los archivos sin atributos.|  
|`Archive`|`vbArchive`|El archivo ha cambiado desde que se realizó la última copia de seguridad.|  
|`Alias`|`vbAlias`|El archivo tiene un nombre diferente.|  
  
> [!NOTE]
>  Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden utilizarse en cualquier parte del código en lugar de los valores reales.  
  
   
  
## Examples  
 Este ejemplo se usa el `Dir` función para comprobar si existen determinados archivos y directorios.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcional. Expresión de cadena que especifica un nombre de archivo, directorio o carpeta, o bien, la etiqueta de volumen de la unidad. Si no se encuentra <paramref name="PathName" />, se devuelve una cadena de longitud cero (<see langword="&quot;&quot;" />).</param>
        <param name="Pathname">Opcional. Expresión de cadena que especifica un nombre de archivo, directorio o carpeta, o bien, la etiqueta de volumen de la unidad. Si no se encuentra <paramref name="Pathname" />, se devuelve una cadena de longitud cero (<see langword="&quot;&quot;" />).</param>
        <param name="Attributes">Opcional. Enumeración o expresión numérica cuyo valor especifica los atributos de archivo. Si se omite, <see langword="Dir" /> devuelve archivos que coinciden con <paramref name="Pathname" /> pero que no tienen ningún atributo.</param>
        <summary>Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad. El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos. Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</summary>
        <returns>Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Dir` función admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.  
  
 `VbVolume` Devuelve la etiqueta de volumen para la unidad en lugar de un nombre de archivo específico.  
  
 Debe proporcionar un `PathName` la primera vez que se llama a la `Dir` función. Para recuperar el elemento siguiente, puede realizar las llamadas posteriores a la `Dir` función sin parámetros.  
  
> [!IMPORTANT]
>  Para ejecutar correctamente, el `Dir` función requiere el <xref:System.Security.Permissions.FileIOPermissionAccess.Read> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución. Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 El `Attributes` valores de enumeración del argumento son los siguientes:  
  
|Valor|Constante|Descripción|  
|-|-|-|  
|`Normal`|`vbnormal`|Predeterminado Especifica los archivos que no tienen atributos.|  
|`ReadOnly`|`vbReadOnly`|Especifica los archivos de solo lectura, además de los archivos que no tienen atributos.|  
|`Hidden`|`vbHidden`|Especifica los archivos ocultos, además de los archivos que no tienen atributos.|  
|`System`|`vbSystem`|Especifica los archivos del sistema, además de los archivos que no tienen atributos.|  
|`Volume`|`vbVolume`|Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, `vbVolume` se omite.|  
|`Directory`|`vbDirectory`|Especifica los directorios o carpetas, además de los archivos que no tienen atributos.|  
|`Archive`|`vbArchive`|El archivo ha cambiado desde que se realizó la última copia de seguridad.|  
|`Alias`|`vbAlias`|El archivo tiene un nombre diferente.|  
  
> [!NOTE]
>  Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden utilizarse en cualquier parte del código en lugar de los valores reales.  
  
   
  
## Examples  
 Este ejemplo se usa el `Dir` función para comprobar si existen determinados archivos y directorios.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. <see langword="Integer" /> que contiene cualquier número de archivo válido.</param>
        <summary>Devuelve un valor booleano o <see langword="True" /> cuando se alcanza el final de un archivo abierto para <see langword="Random" /> o <see langword="Input" /> secuencial.</summary>
        <returns>Valor booleano o <see langword="True" /> cuando se alcanza el final de un archivo abierto para <see langword="Random" /> o <see langword="Input" /> secuencial.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `EOF` para evitar el error generado al intentar obtener datos más allá del final de un archivo.  
  
 El `EOF` función devuelve `False` hasta que se alcanzó el final del archivo. Con los archivos abiertos para `Random` o `Binary` acceso, `EOF` devuelve `False` hasta que ejecute la última `FileGet` función no puede leer un registro completo.  
  
 Con los archivos abiertos para `Binary` tener acceso a un intento de leer el archivo mediante el `Input` función hasta `EOF` devuelve `True` genera un error. Utilice la `LOF` y `Loc` funciones en lugar de `EOF` al leer archivos binarios con `Input`, o use `Get` cuando se usa el `EOF` función. Con los archivos abiertos para `Output`, `EOF` siempre devuelve `True`.  
  
   
  
## Examples  
 Este ejemplo se usa el `EOF` función para detectar el final de un archivo. En este ejemplo se da por supuesto que `Testfile` es un archivo de texto que contiene varias líneas de texto.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. <see langword="Integer" />. Cualquier número de archivo válido.</param>
        <summary>Devuelve una enumeración que representa el modo de archivo de los archivos abiertos mediante la función <see langword="FileOpen" />. El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="FileAttr" /> en las operaciones de E/S con archivos. Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> para obtener más información.</summary>
        <returns>Los siguientes valores de enumeración indican el modo de acceso al archivo: 
 <list type="table"><item><term> Valor 
 </term><description> Modo 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta función devuelve una enumeración que representa el modo de archivo para los archivos abiertos con el `FileOpen` función.  
  
   
  
## Examples  
 Este ejemplo se usa el `FileAttr` función para devolver el modo de archivo de un archivo abierto.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Opcional. Matriz de parámetros de 0 o más canales que se van a cerrar.</param>
        <summary>Concluye las operaciones de entrada/salida (E/S) en un archivo abierto con la función <see langword="FileOpen" />. El objeto <see langword="My" /> proporciona más productividad y rendimiento en las operaciones de E/S de archivo. Vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> para obtener más información.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileClose` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, vea [Cómo: Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [Cómo: Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), y [Tutorial: Manipular archivos y directorios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Si se omite `FileNumbers`, todos los archivos activos abiertos por el `FileOpen` función están cerrados.  
  
 Al cerrar los archivos que se abrieron para `Output` o `Append`, el último búfer de salida se escribe en el búfer del sistema operativo de ese archivo. Todos los asociados cerrado de espacio en búfer se libera el archivo.  
  
 Cuando el `FileClose` se ejecuta la función, la asociación de un archivo con su archivo de número de extremos.  
  
   
  
## Examples  
 Este ejemplo se usa el `FileClose` función para cerrar un archivo abierto para `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> no existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End (Instrucción)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop (Instrucción, Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Obligatorio. Expresión de cadena que especifica el nombre del archivo que se va a copiar. <paramref name="Source" /> puede incluir el directorio o la carpeta así como la unidad del archivo de origen.</param>
        <param name="Destination">Obligatorio. Expresión de cadena que especifica el nombre del archivo de destino. <paramref name="Destination" /> puede incluir el directorio o la carpeta así como la unidad del archivo de destino.</param>
        <summary>Copia un archivo. El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="FileCopy" /> en las operaciones de E/S de archivo. Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> para obtener más información.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si intenta usar el `FileCopy` funcionan en un archivo abierto actualmente, se produce un error.  
  
 `FileCopy` requiere plena confianza para que funcione en la unidad local.  
  
   
  
## Examples  
 Este ejemplo se usa el `FileCopy` función para copiar un archivo a otro. Para fines de este ejemplo, suponga que `SrcFile` es un archivo que contiene los datos.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> o <paramref name="Destination" /> no son válidos o no se especifican.</exception>
        <exception cref="T:System.IO.IOException">El archivo ya está abierto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No existe el archivo.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Cómo: Crear una copia de un archivo en un directorio diferente en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Cómo: Crear una copia de un archivo en el mismo directorio en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Cómo: Copiar un directorio en otro directorio en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. Expresión de cadena que especifica un nombre de archivo. <paramref name="PathName" /> puede incluir el directorio o carpeta y la unidad.</param>
        <summary>Devuelve un valor de tipo <see langword="Date" /> que indica la fecha y hora en que se escribió un archivo. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileDateTime" />. Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>Valor de tipo <see langword="Date" /> que indica la fecha y hora de creación o de la última modificación de un archivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se usa el `FileDateTime` función para determinar la fecha y la hora de un archivo se creó o modificó por última vez. El formato de fecha y hora que se muestra se basa en la configuración regional del sistema.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> no es válido o contiene caracteres comodín.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de destino no existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la`FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor. El tamaño y los límites de la matriz que se pasó a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función,`FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la`FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <param name="StringIsFixedLength">Opcional. Se aplica sólo al escribir una cadena. Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud. De manera predeterminada, es <see langword="False" />.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <param name="ArrayIsDynamic">Opcional. Sólo se aplica al escribir una matriz. Especifica si la matriz debe tratarse como una matriz dinámica y si es necesario un descriptor que describa el tamaño y los límites de la matriz.</param>
        <param name="StringIsFixedLength">Opcional. Se aplica sólo al escribir una cadena. Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud. De manera predeterminada, es <see langword="False" />.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del registro siguiente se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz. Si se escribió con el descriptor, debe leer el descriptor. Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.  
  
     El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     Los bytes 218 se distribuyen como sigue:  
  
    -   18 bytes para el descriptor de: (2 + 8 * 2)  
  
    -   200 bytes para los datos: (5 * 10 * 4).  
  
-   Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.  
  
-   `FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales. Esto incluye las matrices y sus descriptores. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos. No se lee ningún descriptor.  
  
-   `FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
    > [!IMPORTANT]
    >  Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre de variable válido en la que se leen los datos.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</param>
        <summary>Lee datos de un archivo de disco abierto en una variable.  La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGetObject" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileGetObject` función se utiliza en lugar de `FileGet` para evitar ambigüedades en tiempo de compilación si tipo `Object` se devuelve en lugar de otro tipo, como `Integer`, `Long`, `Short`, y así sucesivamente.  
  
 Si va a escribir el `Variant` tipo, `FileGetObject` es necesario. En caso de duda, si está utilizando un objeto para el segundo parámetro, se recomienda siempre que utilice `FilePutObject` y `FileGetObject`.  
  
 `FileGetObject` solo es válido en `Random` y `Binary` modo.  
  
 Los datos leídos con `FileGetObject` normalmente se escriben con `FilePutObject`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, `FileGetObject` lee el registro o byte después del último `FileGetObject` o `FilePutObject` función (o apunta a la última `Seek` función).  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGetObject` leerá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el principio del siguiente registro se rellena con el contenido existente del búfer del archivo. Dado que no se puede determinar con exactitud la cantidad de datos de relleno, es una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.  
  
-   Si la variable que se está leyendo es una cadena, de forma predeterminada `FileGetObject` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes. Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija y cuando se leen en un archivo, el descriptor de longitud no se escribe. Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se va a leer en es una matriz y, a continuación, la longitud de registro especificado por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 * NumberOfDimensions.  
  
     Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Los bytes 218 se distribuyen como sigue: 18 bytes para el descriptor (2 + 8 * 2) y 100 bytes para los datos (5 * 10 * 4).  
  
-   `FileGetObject` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos. En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePutObject`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 * NumberOfDimensions. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales, incluidas las matrices y sus descriptores. La <xref:Microsoft.VisualBasic.VBFixedStringAttribute> clase puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, todos los `Random` reglas se aplican, con las siguientes excepciones:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FileGetObject` lee todas las variables desde el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FileGetObject` lee sólo los datos. No se lee ningún descriptor.  
  
 `FileGetObject` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes. El número de bytes leídos es igual al número de caracteres de la cadena.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
   
  
## Examples  
 El ejemplo siguiente lee un registro en un archivo de prueba y, a continuación, lo recupera.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. Expresión de cadena que especifica un archivo. <paramref name="PathName" /> puede incluir el directorio o carpeta y la unidad.</param>
        <summary>Devuelve un valor que especifica la longitud de un archivo en bytes. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileLen" />. Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Longitud de un archivo en bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el archivo especificado está abierto cuando el `FileLen` se llama a la función, el valor devuelto representa el tamaño del archivo en el momento en que se abrió.  
  
> [!NOTE]
>  Para obtener la longitud actual de un archivo abierto, use el `LOF` función.  
  
   
  
## Examples  
 Este ejemplo se usa el `FileLen` función para devolver la longitud de un archivo en bytes. Para fines de este ejemplo, suponga que `TestFile` es un archivo que contiene algunos datos.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">No existe el archivo.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido. Utilice la función <see langword="FreeFile" /> para obtener el siguiente número de archivo disponible.</param>
        <param name="FileName">Obligatorio. Expresión de cadena que especifica un nombre de archivo y que puede incluir el directorio o la carpeta, y la unidad.</param>
        <param name="Mode">Obligatorio. Enumeración que especifica el modo de archivo: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> o <see langword="Random" />. Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Opcional. Enumeración que especifica las operaciones permitidas en el archivo abierto: <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />. Tiene como valor predeterminado <see langword="ReadWrite" />. Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Opcional. Enumeración que especifica las operaciones no permitidas en el archivo abierto por otros procesos: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> y <see langword="Lock Read Write" />. Tiene como valor predeterminado <see langword="Lock Read Write" />. Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Opcional. Número menor o igual que 32.767 (bytes). En el caso de los archivos abiertos para el acceso aleatorio, este valor es la longitud de registro. En el caso de los archivos secuenciales, este valor es el número de caracteres almacenados en búfer.</param>
        <summary>Abre un archivo para operaciones de entrada o salida. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileOpen" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FileOpen` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Debe abrir un archivo antes de poder realizar cualquier operación de E/S en él. `FileOpen` asigna un búfer de E/S al archivo y determina el modo de acceso para usar con el búfer.  
  
> [!IMPORTANT]
>  Al escribir en un archivo, puede tener una aplicación crear un archivo, si no existe el archivo al que está intentando escribir. Para ello, necesita permiso para el directorio en el que se creará el archivo. Sin embargo, si el archivo especificado por `FileName` existe, la aplicación necesita `Write` permiso solo para el propio archivo. Siempre que sea posible, para ayudar a mejorar la seguridad, crear el archivo durante la implementación y conceder `Write` permiso a dicho archivo únicamente, en lugar de a todo el directorio. Para ayudar a mejorar la seguridad, escribir datos en los directorios de usuario en lugar de en el directorio raíz o el directorio de archivos de programa.  
  
 Puede encontrar el canal para abrir mediante el `FreeFile()` función.  
  
> [!IMPORTANT]
>  El `FileOpen` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración, que puede afectar a su ejecución en situaciones de confianza parcial. Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 En este ejemplo se muestra varios usos de la `FileOpen` función para habilitar la entrada y salida a un archivo.  
  
 El código siguiente abre el archivo `TestFile` en `Input` modo.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Este ejemplo abre el archivo en `Binary` modo para solo operaciones de escritura.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 El ejemplo siguiente abre el archivo en `Random` modo. El archivo contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Este ejemplo de código abre el archivo en `Output` modo; cualquier proceso puede leer o escribir en el archivo.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Este ejemplo de código abre el archivo en `Binary` modo para lectura; otros procesos no pueden leer el archivo.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longitud del registro es negativa (y no es igual a ‑1).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> ya está abierto o <paramref name="FileName" /> no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea la clase <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el`VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el`RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <param name="StringIsFixedLength">Opcional. Se aplica sólo al escribir una cadena. Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo. De manera predeterminada, es <see langword="False" />.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <param name="ArrayIsDynamic">Opcional. Sólo se aplica al escribir una matriz. Especifica si la matriz se va a tratar como una matriz dinámica y si se va a escribir un descriptor de matriz para la cadena que describe la longitud.</param>
        <param name="StringIsFixedLength">Opcional. Se aplica sólo al escribir una cadena. Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo. De manera predeterminada, es <see langword="False" />.</param>
        <summary>Escribe los datos de una variable en un archivo de disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePut` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.  
  
-   Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable. Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no. Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo. De forma predeterminada, Visual Basic 2005 no escribe el descriptor. Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`. Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions). La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable. La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.  
  
-   `FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos. El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.  
  
    > [!NOTE]
    >  Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,  
  
## <a name="binary-mode"></a>Modo binario  
 De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones. Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
-   Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos. No se escribe ningún descriptor.  
  
-   `FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes. El número de bytes escritos es igual al número de caracteres de la cadena. Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePut` función para escribir datos en un archivo. Cinco registros de la estructura `Person` se escriben en el archivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</exception>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Nombre válido de variable que contiene los datos escritos en disco.</param>
        <param name="RecordNumber">Opcional. Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</param>
        <summary>Escribe los datos de una variable en un archivo de disco.  La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePutObject" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `FilePutObject` función se utiliza en lugar de `FilePut` para evitar ambigüedades en tiempo de compilación si tipo `Object` se pasa en lugar de otro tipo, como `Integer`, `Long`, `Short`, y así sucesivamente.  
  
 `FilePutObject` escribe y lee descriptores que describen el objeto. Si va a escribir el `Variant` tipo, `FilePutObject` es necesario. En caso de duda, si está utilizando un objeto para el segundo parámetro, se recomienda usar siempre `FilePutObject` y `FileGetObject`.  
  
 `FilePutObject` solo es válido en `Random` y `Binary` modo.  
  
 Los datos escritos con `FilePutObject` normalmente se leen desde un archivo mediante `FileGetObject`.  
  
 El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente. Si se omite `RecordNumber`, `FilePutObject` escribe el siguiente registro o byte después del último `FileGetObject` o `FilePutObject` función (o el registro o byte señalado por la última `Seek` función).  
  
 El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable. `FilePutObject` no escribe el descriptor de longitud cuando el argumento es `True`. Si usas `StringIsFixedLength`  =  `True` con `FilePutObject`, tendrá que hacer lo mismo con `FileGetObject`, y también debe asegurarse de que la cadena se inicializa con la longitud esperada.  
  
## <a name="random-mode"></a>Modo aleatorio  
 De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:  
  
-   Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePutObject` escribirá los registros posteriores en los límites de longitud de registro. El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo. Como no se puede determinar con exactitud la cantidad de datos de relleno, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir. Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se produce una excepción.  
  
-   Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePutObject` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable. Por ejemplo, al escribir un objeto que contiene un entero, `FilePutObject` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.  
  
-   Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePutObject` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena. La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes. Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.  
  
-   Si la variable que se escribe es una matriz y, a continuación, la longitud de registro especificado por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz. El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango. Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Modo binario  
 De archivos abiertos en `Binary` modo, todas las `Random` se aplican las reglas de modo, excepto:  
  
-   El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto. `FilePutObject` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.  
  
   
  
## Examples  
 Este ejemplo se usa el `FilePutObject` función para escribir una cadena en un archivo.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="RecordWidth">Obligatorio. Expresión numérica del 0 al 255, inclusive, que indica el número de caracteres que aparecen en una línea antes de que se inicie una nueva línea. Si el valor de <paramref name="RecordWidth" /> es 0, la longitud de línea no tiene límite. El valor predeterminado para <paramref name="RecordWidth" /> es 0.</param>
        <summary>Asigna un ancho de línea de salida a un archivo abierto mediante la función <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este ejemplo se usa el `FileWidth` función para establecer el ancho de línea de salida de un archivo.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor de tipo <see langword="Integer" /> que representa el siguiente número de archivo disponible para la función <see langword="FileOpen" />.</summary>
        <returns>Valor entero que representa el siguiente número de archivo disponible para la función <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `FreeFile` para proporcionar un número de archivo que ya no se usa.  
  
   
  
## Examples  
 Este ejemplo se usa el `FreeFile` función para devolver el siguiente número de archivo disponibles. Se abren cinco archivos de salida dentro del bucle, y algunos datos de ejemplo se escriben en cada uno.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Hay más de 255 archivos en uso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. Expresión de cadena que especifica un nombre de archivo, directorio o carpeta. <paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</param>
        <summary>Devuelve un valor de <see langword="FileAttribute" /> que representa los atributos de un archivo, un directorio o una carpeta. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileAttribute" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>El valor devuelto por <see langword="GetAttr" /> es la suma de los siguientes valores de enumeración: 
 <list type="table"><item><term> Valor 
 </term><description> Constante 
 </description><description> Descripción 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Sólo lectura.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Oculto.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Archivo de sistema.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Directorio o carpeta.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> El archivo ha cambiado desde que se realizó la última copia de seguridad.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> El archivo tiene un nombre diferente.  
  
 </description></item></list><block subset="none" type="note"><para>  
 El lenguaje de Visual Basic especifica estas enumeraciones. Se pueden utilizar los nombres en cualquier lugar del código en vez de los valores reales.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar qué atributos se establecen, utilice el `And` operador para realizar una comparación bit a bit del valor devuelto por la `GetAttr` función y el valor del atributo de archivo individuales que desee. Si el resultado no es cero, ese atributo se establece para el archivo con nombre. Por ejemplo, el valor devuelto de los siguientes `And` expresión es cero si el `Archive` no se establece el atributo:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Se devuelve un valor distinto de cero si el `Archive` está establecido.  
  
   
  
## Examples  
 Este ejemplo se usa el `GetAttr` función para determinar los atributos de un archivo, directorio o carpeta.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> no es válido o contiene caracteres comodín.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo de destino no existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And (Operador, Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene algunas líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene algunas líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, dado que se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Value">Obligatorio. Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</param>
        <summary>Lee los datos de un archivo secuencial abierto y los asigna a variables.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.  
  
 Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación. En la tabla siguiente se muestra cómo se tratan otros datos de entrada.  
  
|Datos|Valor asignado a la variable|  
|-|-|  
|Delimitadores de coma o línea en blanco|Empty|  
|NULL #|`DBNull`|  
|# TRUE o FALSE #|`True` o `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|La fecha y hora representadas por la expresión|  
|#ERROR `errornumber`#|`errornumber` (la variable es un objeto etiquetado como error)|  
  
 Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.  
  
> [!NOTE]
>  El `Input` función no está localizada. Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables. En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="CharCount">Obligatorio. Cualquier expresión numérica válida que especifique el número de caracteres que se van a leer.</param>
        <summary>Devuelve un valor de tipo <see langword="String" /> que contiene los caracteres de un archivo abierto en modo <see langword="Input" /> o <see langword="Binary" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="InputString" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Cadena que contiene los caracteres de un archivo abierto en modo <see langword="Input" /> o <see langword="Binary" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `InputString` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con el `InputString` función normalmente se escribe en un archivo mediante el uso de `Print` o `FilePut`. Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.  
  
 A diferencia de la `Input` función, el `InputString` función devuelve todos los caracteres que lee. Esto incluye comas, retornos de carro, saltos de línea, las comillas y espacios iniciales.  
  
 Con los archivos abiertos para `Binary` tener acceso a un intento de leer el archivo mediante el uso de la `InputString` función hasta `EOF` devuelve `True` genera un error. Utilice la `LOF` y `Loc` funciones en lugar de `EOF` al leer archivos binarios mediante `InputString`, o use `FileGet` cuando se usa el `EOF` función.  
  
> [!NOTE]
>  Al leer de archivos, no tomar decisiones de seguridad sobre el contenido del archivo basándose en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
   
  
## Examples  
 Este ejemplo se usa el `InputString` función para leer un carácter de un archivo al mismo tiempo y para imprimir el `Output` ventana. En este ejemplo se da por supuesto que `MyFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> no existe.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> &lt; 0 o &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. Expresión de cadena que especifica uno o varios nombres de archivo que se van a eliminar. <paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</param>
        <summary>Elimina archivos de un disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Kill" />. Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.  
  
 **Nota de seguridad** para poder ejecutarse, el `Kill` función requiere `Read` y `PathDiscovery` marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución. Para obtener más información, consulte <xref:System.Security.SecurityException> [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Este ejemplo se usa el `Kill` función para eliminar un archivo desde un disco.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El archivo o los archivos de destino están abiertos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">No se encuentra el archivo o los archivos de destino.</exception>
        <exception cref="T:System.Security.SecurityException">Permiso denegado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <summary>Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <see langword="String" />.</summary>
        <returns>Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `LineInput` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Los datos leídos con `LineInput` se escriben normalmente en un archivo mediante el uso de `Print`.  
  
> [!IMPORTANT]
>  Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo. Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.  
  
 El `LineInput` función lee un carácter de un archivo a la vez hasta que encuentra un retorno de carro (`Chr(13)`) o retorno de carro/línea fuente (`Chr(13) + Chr(10)`) secuencia. Carro retorno estas secuencias se omiten en lugar de anexar a la cadena de caracteres.  
  
> [!IMPORTANT]
>  Leer un archivo mediante el uso de la `LineInput` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.  
  
   
  
## Examples  
 Este ejemplo se usa el `LineInput` función para leer una línea de un archivo secuencial y asignarlo a una variable. En este ejemplo se da por supuesto que `TestFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Se ha llegado al final del archivo.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> no existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido de tipo <see langword="Integer" />.</param>
        <summary>Devuelve un valor que especifica la actual posición de lectura y escritura en un archivo abierto.</summary>
        <returns>Posición de lectura o escritura actual en un archivo abierto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Loc` función está basado en cero; se utiliza para recuperar el primer byte de un archivo, devuelve 0.  
  
 El `Loc` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 El siguiente describe el valor devuelto para cada modo de acceso de archivo:  
  
|Modo|Valor devuelto|  
|-|-|  
|`Random`|Número del último registro leído o escrito en el archivo.|  
|`Sequential`|Posición de byte actual en el archivo dividido entre 128. Sin embargo, la información devuelta por `Loc` para archivos secuenciales no se utiliza ni necesario.|  
|`Binary`|Posición del último byte leído o escrito.|  
  
   
  
## Examples  
 Este ejemplo se usa el `Loc` función para devolver la posición de lectura/escritura actual en un archivo abierto. En este ejemplo se da por supuesto que `MyFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Record">Opcional. Número del único registro o byte que se va a bloquear o desbloquear.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="FromRecord">Opcional. Número del primer registro o byte que se va a bloquear o desbloquear.</param>
        <param name="ToRecord">Opcional. Número del último registro o byte que se va a bloquear o desbloquear.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Número entero que contiene un número de archivo válido.</param>
        <summary>Devuelve el tamaño, en bytes, de un archivo abierto mediante la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="LOF" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Tamaño, en bytes, de un archivo abierto mediante la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use el `FileLen` función para obtener la longitud de un archivo que no está abierto.  
  
   
  
## Examples  
 Este ejemplo se usa el `LOF` función para determinar el tamaño de un archivo abierto. En este ejemplo se da por supuesto que `TestFile` es un archivo de texto que contiene datos de ejemplo.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatorio. Expresión de cadena que identifica el directorio que se va a crear. <paramref name="Path" /> puede incluir la unidad. Si no hay ninguna unidad especificada, <see langword="MkDir" /> crea el nuevo directorio en la unidad actual.</param>
        <summary>Crea un directorio nuevo. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="MkDir" />. Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta función crea un nuevo directorio.  
  
   
  
## Examples  
 Este ejemplo se usa el `MkDir` función para crear un directorio. Si no se especifica la unidad, se crea el nuevo directorio en la unidad actual.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> no se ha especificado o está vacío.</exception>
        <exception cref="T:System.Security.SecurityException">Permiso denegado.</exception>
        <exception cref="T:System.IO.IOException">El directorio ya existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Cómo: Crear un directorio en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Output">Opcional. Cero o más expresiones delimitadas por comas para escribir en un archivo.  
  
La configuración del argumento <paramref name="Output" /> es: 
 <see langword="T:System.IO.IOException" />: El modo de archivo no es válido.  
  
 <see langword="T:System.IO.IOException" />:<paramref name="FileNumber" /> no existe.</param>
        <summary>Escribe los datos con formato de presentación en un archivo secuencial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Print` y `PrintLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` no incluye una avance de línea al final de una línea; Sin embargo, `PrintLine` incluyen un avance de línea.  
  
 Los datos escritos con `Print` normalmente se leen desde un archivo mediante el uso de `LineInput` o `Input`.  
  
 Si se omite `Output` para `PrintLine`, se imprime una línea en blanco en el archivo; para `Print`, nada es de salida. Varias expresiones separadas por comas se alineará en los límites de tabulación, pero la combinación de comas y `TAB` puede causar resultados incoherentes.  
  
 Para `Boolean` datos, ya sea `True` o `False` se imprime. El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.  
  
 Los datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema. Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.  
  
 Si se escribirá nada en el archivo `Output` datos están vacíos. Sin embargo, si `Output` datos de la lista están `DBNull`, `Null` se escribe en el archivo.  
  
 Para `Error` la salida de datos, aparece como `Error errorcode`. El `Error` palabra clave no se traduce, independientemente de la configuración regional.  
  
 Todos los datos escritos en el archivo mediante el uso de `Print` son internacionales; es decir, los datos tiene el formato correcto con el separador decimal adecuado. Si el usuario desea generar datos para su uso en varias configuraciones regionales, `Write` debe usarse.  
  
 Escribir en un archivo mediante el uso de la `Print` o `PrintLine` functions requiere `Write` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Print` y `PrintLine` funciones para escribir datos en un archivo.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Output">Opcional. Cero o más expresiones delimitadas por comas para escribir en un archivo.  
  
La configuración del argumento <paramref name="Output" /> es: 
 <see langword="T:System.IO.IOException" />: El modo de archivo no es válido.  
  
 <see langword="T:System.IO.IOException" />:<paramref name="FileNumber" /> no existe.</param>
        <summary>Escribe los datos con formato de presentación en un archivo secuencial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Print` y `PrintLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` no incluye una avance de línea al final de una línea; Sin embargo,`PrintLine` incluyen un avance de línea.  
  
 Los datos escritos con `Print` normalmente se leen desde un archivo mediante el uso de `LineInput` o `Input`.  
  
 Si se omite `Output` para `PrintLine`, se imprime una línea en blanco en el archivo; para `Print`, nada es de salida. Varias expresiones separadas por comas se alineará en los límites de tabulación, pero la combinación de comas y `TAB` puede causar resultados incoherentes.  
  
 Para `Boolean` datos, ya sea `True` o `False` se imprime. El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.  
  
 Los datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema. Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.  
  
 Si se escribirá nada en el archivo `Output` datos están vacíos. Sin embargo, si `Output` datos de la lista están `DBNull`, `Null` se escribe en el archivo.  
  
 Para `Error` la salida de datos, aparece como `Error errorcode`. El `Error` palabra clave no se traduce, independientemente de la configuración regional.  
  
 Todos los datos escritos en el archivo mediante el uso de `Print` son internacionales; es decir, los datos tiene el formato correcto con el separador decimal adecuado. Si el usuario desea generar datos para su uso en varias configuraciones regionales, `Write` debe usarse.  
  
 Escribir en un archivo mediante el uso de la `Print` o `PrintLine` functions requiere `Write` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Print` y `PrintLine` funciones para escribir datos en un archivo.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Obligatorio. Expresión de cadena que especifica el nombre y la ubicación de archivo existentes. <paramref name="OldPath" /> puede incluir el directorio y la unidad del archivo.</param>
        <param name="NewPath">Obligatorio. Expresión de cadena que especifica el nombre y la ubicación de archivo nuevos. <paramref name="NewPath" /> puede incluir el directorio y la unidad de la ubicación de destino. El nombre de archivo especificado por <paramref name="NewPath" /> no puede existir.</param>
        <summary>Cambia el nombre de un archivo o directorio ubicado en el disco. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Rename" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El`Rename` función cambia el nombre de un archivo y lo mueve a un directorio diferente, si es necesario. El `Rename` función puede mover un archivo a través de unidades, pero solo puede cambiar el nombre un directorio existente cuando ambos `NewPath` y `OldPath` se encuentran en la misma unidad. `Rename` no se puede crear un nuevo archivo o directorio.  
  
 Mediante el `Rename` función en un archivo abierto genera un error. Debe cerrar un archivo abierto antes de cambiarle el nombre. `Rename` argumentos no pueden incluir varios caracteres (*) y comodines de carácter único (?).  
  
> [!IMPORTANT]
>  Cuando se usa `Rename` para copiar un archivo desde una ubicación no protegida en una ubicación protegida, el archivo conserva los derechos menos restringidos. Compruebe para asegurarse de que no presentan un posible riesgo de seguridad.  
  
   
  
## Examples  
 Este ejemplo se usa el `Rename` función para cambiar el nombre de un archivo. Para fines de este ejemplo, suponga que los directorios especificados ya existen.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La ruta de acceso no es válida.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El archivo <paramref name="OldPath" /> no existe.</exception>
        <exception cref="T:System.IO.IOException">No se puede cambiar el nombre en un dispositivo diferente.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Cómo: Cambiar el nombre de un archivo en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cierra todos los archivos ubicados en el disco que se han abierto mediante la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Reset" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Reset` función cierra todos los archivos activos abiertos por el `FileOpen` de función y tiene la misma función que `FileClose()` sin ningún parámetro.  
  
   
  
## Examples  
 Este ejemplo se usa el `Reset` función para cerrar todos los archivos abiertos y escribir el contenido de todos los búferes de archivo en el disco. Tenga en cuenta el uso de la `Object` variable `FileNumber` como una cadena y un número.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End (Instrucción)</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Obligatorio. Expresión de cadena que identifica el directorio o la carpeta que se va a quitar. <paramref name="Path" /> puede incluir la unidad. Si no hay ninguna unidad especificada, <see langword="RmDir" /> quita el directorio de la unidad actual.</param>
        <summary>Quita un directorio existente. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="RmDir" />. Para obtener más información, vea <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se produce un error si intenta usar `RmDir` en un directorio que contiene los archivos. Use el `Kill` función para eliminar todos los archivos antes de intentar quitar un directorio.  
  
   
  
## Examples  
 Este ejemplo se usa el `RmDir` function para quitar un directorio existente.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> no se ha especificado o está vacío.</exception>
        <exception cref="T:System.IO.IOException">El directorio de destino contiene archivos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">El directorio no existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. <see langword="Integer" /> que contiene un número de archivo válido.</param>
        <summary>Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 - 1), ambos inclusive.  
  
 El siguiente describe los valores devueltos para cada modo de acceso de archivo:  
  
|Modo|Valor devuelto|  
|-|-|  
|`Random`|Número del siguiente registro leídos o escritos|  
|`Binary`, `Input`, `Output`, `Append`|Posición del byte en el que se produce la siguiente operación. Es el primer byte de un archivo en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.|  
  
   
  
## Examples  
 Este ejemplo se usa el `Seek` función para devolver la posición actual del archivo. En el ejemplo se da por supuesto `TestFile` es un archivo que contiene registros de la estructura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 De los archivos abiertos en `Random` modo, `Seek` devuelve el número de registro siguiente.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Para los archivos abiertos en modos distintos de `Random` modo, `Seek` devuelve la posición de byte en el que se produce la siguiente operación. Suponga `TestFile` es un archivo que contiene varias líneas de texto.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Este ejemplo se usa el `Seek` función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.  
  
 Para los archivos abiertos en modos distintos de `Random` modo, `Seek` establece la posición de byte en el que se produce la siguiente operación. Suponga `TestFile` es un archivo que contiene varias líneas de texto.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. <see langword="Integer" /> que contiene un número de archivo válido.</param>
        <param name="Position">Obligatorio. Número del 1 al 2.147.483.647, incluido, que indica dónde debe llevarse a cabo la siguiente operación de lectura o escritura.</param>
        <summary>Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 - 1), ambos inclusive.  
  
 El siguiente describe los valores devueltos para cada modo de acceso de archivo:  
  
|Modo|Valor devuelto|  
|-|-|  
|`Random`|Número del siguiente registro leídos o escritos|  
|`Binary`, `Input`, `Output`, `Append`|Posición del byte en el que se produce la siguiente operación. Es el primer byte de un archivo en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.|  
  
   
  
## Examples  
 Este ejemplo se usa el `Seek` función para devolver la posición actual del archivo. En el ejemplo se da por supuesto `TestFile` es un archivo que contiene registros de la estructura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 De los archivos abiertos en `Random` modo, `Seek` devuelve el número de registro siguiente.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Para los archivos abiertos en modos distintos de `Random` modo, `Seek` devuelve la posición de byte en el que se produce la siguiente operación. Suponga `TestFile` es un archivo que contiene varias líneas de texto.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Este ejemplo se usa el `Seek` función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.  
  
 Para los archivos abiertos en modos distintos de `Random` modo, `Seek` establece la posición de byte en el que se produce la siguiente operación. Suponga `TestFile` es un archivo que contiene varias líneas de texto.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Leer archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Escribir en archivos en Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Obligatorio. Expresión de cadena que especifica un nombre de archivo. <paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</param>
        <param name="Attributes">Obligatorio. Constante o expresión numérica, cuya suma especifica los atributos de un archivo.</param>
        <summary>Establece la información de atributos de un archivo. La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="SetAttr" />. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se produce un error de tiempo de ejecución si se intenta establecer los atributos de un archivo abierto.  
  
 El `Attributes` valores de enumeración del argumento son los siguientes:  
  
|Valor|Constante|Descripción|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (predeterminado).|  
|`ReadOnly`|`vbReadOnly`|Sólo lectura.|  
|`Hidden`|`vbHidden`|Oculto.|  
|`System`|`vbSystem`|Archivo de sistema.|  
|`Volume`|`vbVolume`|Etiqueta de volumen|  
|`Directory`|`vbDirectory`|Directorio o carpeta.|  
|`Archive`|`vbArchive`|El archivo ha cambiado desde que se realizó la última copia de seguridad.|  
|`Alias`|`vbAlias`|El archivo tiene un nombre diferente.|  
  
> [!NOTE]
>  El lenguaje de Visual Basic especifica estas enumeraciones. Los nombres se pueden usar en cualquier parte del código en lugar de los valores reales.  
  
   
  
## Examples  
 Este ejemplo se usa el `SetAttr` función para establecer los atributos de un archivo.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">El tipo de <paramref name="Attribute" /> no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Obligatorio. Número de espacios que se van a insertar antes de mostrar o imprimir la siguiente expresión en una lista.</param>
        <summary>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar la salida.</summary>
        <returns>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar la salida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `Count` es menor que el ancho de línea de salida, la siguiente posición de impresión inmediatamente sigue el número de espacios impresos. Si`Count` es mayor que el ancho de línea de salida, `SPC` calcula la siguiente posición de impresión mediante la fórmula:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Por ejemplo, si la posición de impresión actual es 24, el ancho de línea de salida es 80 y se especifica `SPC(90)`, la próxima impresión comenzará en la posición 34 (posición de impresión actual + el resto de 90/80). Si la diferencia entre la actual posición de impresión y el ancho de línea de salida es menor que `Count` (o `Count` `Mod` *ancho*), el `SPC` función salta al principio de la línea siguiente y genera espacios que equivalen a `Count` -(*ancho* - *posiciónDeImpresiónActual*).  
  
> [!NOTE]
>  Asegúrese de que las columnas tabulares sean lo suficientemente ancha para permitir letras anchas.  
  
   
  
## Examples  
 Este ejemplo se usa el `SPC` para colocar el resultado en un archivo y, en función de la **salida** ventana.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod (Operador, Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</summary>
        <returns>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es mayor que la actual posición de impresión en la línea actual `Column`, `TAB` salta al igual que el valor de la columna `Column` en la siguiente línea de salida. Si `Column` es menor que 1, `TAB` mueve la posición de impresión a la columna 1. Si `Column` es mayor que el ancho de línea de salida, `TAB` calcula la siguiente posición de impresión mediante la fórmula:  
  
 Mod ancho de columna  
  
 Por ejemplo, si *ancho* es 80 y se especifica `TAB(90)`, se iniciará la próxima impresión en la columna 10 (el resto de 90/80). Si `Column` es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada. Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comienza en la posición de impresión en la misma línea.  
  
 La posición de impresión más a la izquierda en una línea de salida es siempre 1. Cuando se usa el `Print` o `PrintLine` funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el `FileWidth` función.  
  
 El `TAB` función también se puede usar con el `WriteLine` función. No se puede usar con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Asegúrese de que las columnas tabulares sean lo suficientemente amplio para contener letras anchas.  
  
   
  
## Examples  
 Este ejemplo se usa el `TAB` para colocar el resultado en un archivo y, en función de la **salida** ventana.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod (Operador, Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Opcional. Número de columna a la que se realiza el desplazamiento antes de mostrar o imprimir la siguiente expresión en una lista. Si se omite, <see langword="TAB" /> mueve el punto de inserción al principio de la siguiente zona de impresión.</param>
        <summary>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</summary>
        <returns>Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si es mayor que la actual posición de impresión en la línea actual `Column`, `TAB` salta al igual que el valor de la columna `Column` en la siguiente línea de salida. Si `Column` es menor que 1, `TAB` mueve la posición de impresión a la columna 1. Si `Column` es mayor que el ancho de línea de salida, `TAB` calcula la siguiente posición de impresión mediante la fórmula:  
  
 Mod ancho de columna  
  
 Por ejemplo, si *ancho* es 80 y se especifica `TAB(90)`, se iniciará la próxima impresión en la columna 10 (el resto de 90/80). Si `Column` es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada. Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comienza en la posición de impresión en la misma línea.  
  
 La posición de impresión más a la izquierda en una línea de salida es siempre 1. Cuando se usa el `Print` o `PrintLine` funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el `FileWidth` función.  
  
 El `TAB` función también se puede usar con el `WriteLine` función. No se puede usar con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Asegúrese de que las columnas tabulares sean lo suficientemente amplio para contener letras anchas.  
  
   
  
## Examples  
 Este ejemplo se usa el `TAB` para colocar el resultado en un archivo y, en función de la **salida** ventana.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod (Operador, Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="Record">Opcional. Número del único registro o byte que se va a bloquear o desbloquear.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Cualquier número de archivo válido.</param>
        <param name="FromRecord">Opcional. Número del primer registro o byte que se va a bloquear o desbloquear.</param>
        <param name="ToRecord">Opcional. Número del último registro o byte que se va a bloquear o desbloquear.</param>
        <summary>Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />. La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos. Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.  
  
 `Lock` y `Unlock` funciones se usan siempre en pares. Los argumentos de `Lock` y `Unlock` deben ser idénticos.  
  
 Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo. Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.  
  
 Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.  
  
   
  
## Examples  
 En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones. En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Expresión <see langword="Integer" /> que contiene cualquier número de archivo válido.</param>
        <param name="Output">Opcional. Una o más expresiones delimitadas por comas para escribir en un archivo.</param>
        <summary>Escribe datos en un archivo secuencial. Los datos escritos con <see langword="Write" /> normalmente se leen desde un archivo mediante <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Write` y `WriteLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si se omite `Output`, se imprime una línea en blanco en el archivo. Varias expresiones se pueden separar con comas.  
  
 A diferencia de la `Print` función, el `Write` función inserta comas entre los elementos y las cadenas entre comillas, tal como se escriben en el archivo. No es necesario colocar delimitadores explícitos en la lista. Cuando `Write` se usa para escribir datos en un archivo, solo numérico, `Boolean`, fecha, null, y `Error` se admiten los formatos de datos. Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretan correctamente mediante `Input`, independientemente de la configuración regional:  
  
-   Datos numéricos siempre se escriben con el punto como separador decimal.  
  
-   Para `Boolean` datos, ya sea `#TRUE#` o `#FALSE#` se imprime. El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.  
  
-   Datos de fecha se escriben en el archivo con el formato de fecha universal. Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.  
  
-   Si se escribirá nada en el archivo `Output` datos están vacíos. Sin embargo, para datos nulos, `#NULL#` se escribe.  
  
-   Para `Error` la salida de datos, aparece como `#ERROR errorcode#`. El `Error` palabra clave no se traduce, independientemente de la configuración regional.  
  
 `WriteLine` Inserta un carácter de nueva línea (es decir, un retorno de carro/línea de fuente, o `Chr(13) + Chr(10)`), una vez que se ha escrito el último carácter `Output` al archivo.  
  
 Puede insertar comillas en una cadena mediante el uso de comillas dobles, o "". Por ejemplo,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Devuelve una cadena con el valor de `Double quotation marks aren't "difficult" to handle`.  
  
 Escribir en un archivo mediante el uso de la `Write` o `WriteLine` functions requiere `Append` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Write` función para escribir datos sin procesar en un archivo secuencial.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">El modo de archivo no es válido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Obligatorio. Expresión <see langword="Integer" /> que contiene cualquier número de archivo válido.</param>
        <param name="Output">Opcional. Una o más expresiones delimitadas por comas para escribir en un archivo.</param>
        <summary>Escribe datos en un archivo secuencial. Los datos escritos con <see langword="Write" /> normalmente se leen desde un archivo mediante <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `Write` y `WriteLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento. Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento. Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Si se omite `Output`, se imprime una línea en blanco en el archivo. Varias expresiones se pueden separar con comas.  
  
 A diferencia de la `Print` función, el `Write` función inserta comas entre los elementos y las cadenas entre comillas, tal como se escriben en el archivo. No es necesario colocar delimitadores explícitos en la lista. Cuando `Write` se usa para escribir datos en un archivo, solo numérico, `Boolean`, fecha, null, y `Error` se admiten los formatos de datos. Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretan correctamente mediante `Input`, independientemente de la configuración regional:  
  
-   Datos numéricos siempre se escriben con el punto como separador decimal.  
  
-   Para `Boolean` datos, ya sea `#TRUE#` o `#FALSE#` se imprime. El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.  
  
-   Datos de fecha se escriben en el archivo con el formato de fecha universal. Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.  
  
-   Si se escribirá nada en el archivo `Output` datos están vacíos. Sin embargo, para datos nulos, `#NULL#` se escribe.  
  
-   Para `Error` la salida de datos, aparece como `#ERROR errorcode#`. El `Error` palabra clave no se traduce, independientemente de la configuración regional.  
  
 `WriteLine` Inserta un carácter de nueva línea (es decir, un retorno de carro/línea de fuente, o `Chr(13) + Chr(10)`), una vez que se ha escrito el último carácter `Output` al archivo.  
  
 Puede insertar comillas en una cadena mediante el uso de comillas dobles, o "". Por ejemplo,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Devuelve una cadena con el valor de `Double quotation marks aren't "difficult" to handle`.  
  
 Escribir en un archivo mediante el uso de la `Write` o `WriteLine` functions requiere `Append` acceso desde el `FileIOPermissionAccess` enumeración. Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este ejemplo se usa el `Write` función para escribir datos sin procesar en un archivo secuencial.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Acceso a archivos con Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Cómo: Escribir texto en archivos en Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>