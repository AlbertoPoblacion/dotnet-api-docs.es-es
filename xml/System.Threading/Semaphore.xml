<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfd4af5a6146da7c3a1e0bf3e9198f1ae1ef7404" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52214176" /></Metadata><TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Semaphore&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Semaphore sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Semaphore = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limita el número de subprocesos que pueden tener acceso a un recurso o grupo de recursos simultáneamente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use la <xref:System.Threading.Semaphore> clase para controlar el acceso a un grupo de recursos. Subprocesos entran el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método, que se hereda de la <xref:System.Threading.WaitHandle> clase y liberar el semáforo mediante una llamada a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 El recuento de un semáforo es disminuye cada vez que un subproceso entra en el semáforo y se incrementa cuando un subproceso libera el semáforo. Cuando el recuento es cero, las solicitudes posteriores se bloquean hasta que otros subprocesos liberan el semáforo. Cuando todos los subprocesos han liberado el semáforo, el recuento es el valor máximo especificado cuando se creó el semáforo.  
  
 No hay ningún orden garantizado, como FIFO, LIFO, en el que los subprocesos bloqueados entren en el semáforo.  
  
 Un subproceso puede entrar varias veces, en el semáforo mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método varias veces. Para liberar algunas o todas estas entradas, el subproceso puede llamar a sin parámetros <xref:System.Threading.Semaphore.Release> sobrecarga del método puede llamar varias veces, o bien el <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método que especifica el número de entradas que se liberan.  
  
 El <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso en las llamadas a <xref:System.Threading.WaitHandle.WaitOne%2A> o <xref:System.Threading.Semaphore.Release%2A>. Es responsabilidad del programador asegurarse de que los subprocesos no liberan el semáforo demasiadas veces. Por ejemplo, supongamos que un semáforo tiene un recuento máximo de dos y que los subprocesos A y B entran el semáforo. Si un error de programación en el subproceso B hace que llame a <xref:System.Threading.Semaphore.Release%2A> dos veces, ambas llamadas tendrán éxito. El recuento del semáforo está lleno y cuando el subproceso A finalmente llama a <xref:System.Threading.Semaphore.Release%2A>, se genera <xref:System.Threading.SemaphoreFullException>.  
  
 Son semáforos de dos tipos: semáforos locales y semáforos de sistema con nombre. Si creas un <xref:System.Threading.Semaphore> objeto utilizando un constructor que acepta un nombre, está asociado con un semáforo de sistema operativo de ese nombre. Los semáforos son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos de sistema con nombre. Puede crear varios <xref:System.Threading.Semaphore> objetos que representan el mismo nombre semáforo del sistema, y puede usar el <xref:System.Threading.Semaphore.OpenExisting%2A> método para abrir una existente denominado semáforo del sistema.  
  
 Existe un semáforo local solo dentro del proceso. La puede usar cualquier subproceso del proceso que tenga una referencia al objeto <xref:System.Threading.Semaphore> local. Cada <xref:System.Threading.Semaphore> objeto es un semáforo local independiente.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. En el ejemplo se inicia cinco subprocesos, que bloquear la espera para el semáforo. El subproceso principal utiliza el <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, las llamadas a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo. Cada vez que se libere el semáforo, se muestra el recuento del semáforo anterior. Uso de semáforo pista de la consola mensajes. El intervalo de trabajo simulado aumenta ligeramente para que cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo es seguro para la ejecución de subprocesos.</threadsafe>
    <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
    <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <param name="maximumCount">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un semáforo sin nombre. Todos los subprocesos que usan una instancia de este tipo de semáforo deben tener referencias a la instancia.  
  
 Si `initialCount` es menor que `maximumCount`, el efecto es el mismo que si hubiera llamado el subproceso actual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces. Si no desea reservar entradas para el subproceso que crea el semáforo, use el mismo número de `maximumCount` y `initialCount`.  
  
   
  
## Examples  
 El ejemplo siguiente crea un semáforo con un número máximo de tres y un recuento inicial de cero. En el ejemplo se inicia cinco subprocesos, que bloquear la espera para el semáforo. El subproceso principal utiliza el <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, las llamadas a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo. Cada vez que se libere el semáforo, se muestra el recuento del semáforo anterior. Uso de semáforo pista de la consola mensajes. El intervalo de trabajo simulado aumenta ligeramente para que cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> es menor que 1.  
  
O bien 
 <paramref name="initialCount" /> es menor que 0.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <param name="maximumCount">Número máximo de solicitudes del semáforo que se pueden conceder simultáneamente.</param>
        <param name="name">Nombre de un objeto de semáforo del sistema con nombre.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Semaphore" />, que especifica el número inicial de entradas y el número máximo de entradas simultáneas, y especificando de forma opcional el nombre de un objeto semáforo de sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> objetos que representan el mismo nombre semáforo del sistema.  
  
 Si el semáforo del sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo del sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos también generar excepciones. Si necesita determinar si se creó un semáforo del sistema con nombre, use la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga de constructor en su lugar.  
  
> [!IMPORTANT]
>  Cuando utilice esta sobrecarga del constructor, el método recomendado es especificar el mismo número de `initialCount` y `maximumCount`. Si `initialCount` es menor que `maximumCount`y se crea un semáforo de sistema con nombre, el efecto es el mismo que si hubiera llamado el subproceso actual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces. Sin embargo, con esta sobrecarga del constructor no hay ninguna manera de determinar si se creó un semáforo de sistema con nombre.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si hubiera llamado a la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, se puede usar para coordinar el uso de recursos a través de los límites del proceso.  
  
 Si desea averiguar si existe un semáforo de sistema con nombre, use la <xref:System.Threading.Semaphore.OpenExisting%2A> método. El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente y produce una excepción si el semáforo de sistema no existe.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el comportamiento entre procesos de un semáforo con nombre. En el ejemplo se crea un semáforo con nombre con un número máximo de cinco y un recuento inicial de cinco. El programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método. Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> es menor que 1.  
  
O bien 
 <paramref name="initialCount" /> es menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
        <param name="maximumCount">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
        <param name="name">Nombre de un objeto de semáforo del sistema con nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un semáforo local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema y especificando una variable que recibe un valor que indica si se creó un semáforo del sistema nuevo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> objetos que representan el mismo nombre semáforo del sistema.  
  
 Si el semáforo del sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo del sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos también generar excepciones. Use `createdNew` para determinar si se creó el semáforo del sistema.  
  
 Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si hubiera llamado el subproceso actual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si hubiera llamado a la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor. En este caso, `createdNew` siempre `true`.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, se puede usar para coordinar el uso de recursos a través de los límites del proceso.  
  
   
  
## Examples  
 El ejemplo de código siguiente muestra el comportamiento entre procesos de un semáforo con nombre. En el ejemplo se crea un semáforo con nombre con un número máximo de cinco y un recuento inicial de dos. Es decir, reserva tres entradas para el subproceso que llama al constructor. Si `createNew` es `false`, el programa realiza tres llamadas a la <xref:System.Threading.WaitHandle.WaitOne%2A> método. Por lo tanto, si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia se bloqueará en la tercera llamada a <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar una o más entradas en la primera copia del programa para desbloquear a la segunda.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> es menor que 1.  
  
O bien 
 <paramref name="initialCount" /> es menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Semaphore(int initialCount, int maximumCount, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Semaphore : int * int * string *  * System.Security.AccessControl.SemaphoreSecurity -&gt; System.Threading.Semaphore" Usage="new System.Threading.Semaphore (initialCount, maximumCount, name, createdNew, semaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">Número inicial de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
        <param name="maximumCount">Número máximo de solicitudes para el semáforo que se puede satisfacer simultáneamente.</param>
        <param name="name">Nombre de un objeto de semáforo del sistema con nombre.</param>
        <param name="createdNew">Cuando este método devuelve un resultado, contiene <see langword="true" /> si se creó un semáforo local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó el semáforo del sistema con nombre especificado; es <see langword="false" /> si el semáforo del sistema con nombre especificado ya existía. Este parámetro se pasa sin inicializar.</param>
        <param name="semaphoreSecurity">Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso que se aplicará al semáforo de sistema con nombre.</param>
        <summary>Inicializa una instancia nueva de la clase <see cref="T:System.Threading.Semaphore" />, especificando el número inicial de entradas y el número máximo de entradas simultáneas, especificando de forma opcional el nombre de un objeto semáforo de sistema, especificando una variable que recibe un valor que indica si se creó un semáforo del sistema y especificando la seguridad de control de acceso para el semáforo del sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice este constructor para aplicar la seguridad de control de acceso a un semáforo del sistema con nombre cuando se crea, impide que otro código tome el control del semáforo.  
  
 Este constructor inicializa un <xref:System.Threading.Semaphore> objeto que representa un semáforo de sistema con nombre. Puede crear varias <xref:System.Threading.Semaphore> objetos que representan el mismo nombre semáforo del sistema.  
  
 Si el semáforo del sistema con nombre no existe, se crea con la seguridad de control de acceso especificada. Si el semáforo con nombre existe, se omite la seguridad de control de acceso especificada.  
  
> [!NOTE]
>  El llamador tiene control total sobre el recién creado <xref:System.Threading.Semaphore> objeto incluso si `semaphoreSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual. Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Semaphore> representar el mismo semáforo con nombre, ya sea mediante un constructor de objeto o el <xref:System.Threading.Semaphore.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.  
  
 Si el semáforo del sistema con nombre no existe, se crea con el recuento inicial y el número máximo especificado por `initialCount` y `maximumCount`. Si el semáforo del sistema con nombre ya existe, `initialCount` y `maximumCount` no se usan, aunque los valores no válidos también generar excepciones. Use el `createdNew` parámetro para determinar si este constructor creó el semáforo del sistema.  
  
 Si `initialCount` es menor que `maximumCount`, y `createdNew` es `true`, el efecto es el mismo que si hubiera llamado el subproceso actual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) veces.  
  
 Si especifica `null` o una cadena vacía para `name`, se crea un semáforo local, como si hubiera llamado a la <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga del constructor. En este caso, `createdNew` siempre `true`.  
  
 Dado que los semáforos con nombre son visibles en todo el sistema operativo, se puede usar para coordinar el uso de recursos a través de los límites del proceso.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un semáforo con nombre. Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a usar el semáforo pero concede el derecho para leer y cambiar permisos en el semáforo. Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre el semáforo con los derechos necesarios para escribir y versión. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="initialCount" /> es mayor que <paramref name="maximumCount" />.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maximumCount" /> es menor que 1.  
  
O bien 
 <paramref name="initialCount" /> es menor que 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe y tiene seguridad de control de acceso, y el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">No se puede crear el semáforo con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As SemaphoreSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::SemaphoreSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.SemaphoreSecurity" Usage="semaphore.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene la seguridad de control de acceso para un semáforo de sistema con nombre.</summary>
        <returns>Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso para el semáforo de sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Semaphore.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados con la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.  
  
 El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions?displayProperty=nameWithType> derechos.  
  
 En un semáforo local, la seguridad de control de acceso es irrelevante. Si el <xref:System.Threading.Semaphore> objeto no representa un semáforo de sistema con nombre, este método devuelve un <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos los derechos a cualquier usuario.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a usar el semáforo, pero se concede el derecho para leer y cambiar permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos. La seguridad de control de acceso para el semáforo del sistema se obtiene mediante la <xref:System.Threading.Semaphore.GetAccessControl%2A> método.  
  
 Después de cambian los permisos, se abre el semáforo con los derechos necesarios para escribir y versión. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">El objeto <see cref="T:System.Threading.Semaphore" /> actual representa un semáforo del sistema con nombre y el usuario no tiene derechos de <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.  
  
O bien 
El objeto <see cref="T:System.Threading.Semaphore" /> actual representa un semáforo del sistema con nombre y no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">No se admite para Windows 98 o Windows Millennium Edition.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un semáforo con nombre especificado, si ya existe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
        <summary>Abre el semáforo con nombre especificado, si ya existe.</summary>
        <returns>Objeto que representa el semáforo del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir el semáforo con nombre especificado. Si el semáforo de sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema. Para crear el semáforo del sistema cuando no existe, use uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Semaphore> objeto, aunque los objetos que se devuelven representan el mismo semáforo con nombre del sistema.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.  
  
 Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso en el semáforo y especificando el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a usar el semáforo, pero que concede el derecho para leer y cambiar permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El semáforo con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para abrir un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As SemaphoreRights) As Semaphore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Semaphore ^ OpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.SemaphoreRights -&gt; System.Threading.Semaphore" Usage="System.Threading.Semaphore.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <summary>Abre el semáforo con nombre especificado, si ya existe, con el acceso de seguridad deseado.</summary>
        <returns>Objeto que representa el semáforo del sistema con nombre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El `rights` debe incluir el parámetro el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 El <xref:System.Threading.Semaphore.OpenExisting%2A> método intenta abrir un semáforo con nombre existente. Si el semáforo de sistema no existe, este método produce una excepción en lugar de crear el semáforo del sistema. Para crear el semáforo del sistema cuando no existe, use uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Semaphore> objeto, aunque los objetos que se devuelven representan el mismo semáforo con nombre del sistema.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a usar el semáforo, pero se concede el derecho para leer y cambiar permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, se abre el semáforo con los derechos necesarios para escribir y liberarlo. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">El semáforo con nombre no existe.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene los derechos de acceso de seguridad deseados.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para llamar a código no administrado para crear un semáforo de sistema con nombre. Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Release">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sale del semáforo.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberSignature Language="VB.NET" Value="Public Function Release () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release();" />
      <MemberSignature Language="F#" Value="member this.Release : unit -&gt; int" Usage="semaphore.Release " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sale del semáforo y devuelve el recuento anterior.</summary>
        <returns>Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los subprocesos normalmente utilizan el <xref:System.Threading.WaitHandle.WaitOne%2A> método para introducir el semáforo y se suele utilizar esta sobrecarga del método para salir.  
  
 Si un <xref:System.Threading.SemaphoreFullException> produce el <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso de llamada. Ese subproceso salga del semáforo más veces que se escribió haya provocado un error de programación en otro subproceso.  
  
 Si el actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. En el ejemplo se inicia cinco subprocesos, que bloquear la espera para el semáforo. El subproceso principal utiliza el <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, las llamadas a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.  
  
 Cada vez que se libere el semáforo, se muestra el recuento del semáforo anterior. Uso de semáforo pista de la consola mensajes. El intervalo de trabajo simulado aumenta ligeramente para que cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">El recuento del semáforo ya está en el valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32 con un semáforo con nombre.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
O bien 
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Release (releaseCount As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Release(int releaseCount);" />
      <MemberSignature Language="F#" Value="member this.Release : int -&gt; int" Usage="semaphore.Release releaseCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">Número de veces que se abandona el semáforo.</param>
        <summary>Sale del semáforo un número especificado de veces y devuelve el recuento anterior.</summary>
        <returns>Recuento en el semáforo antes de la llamada al método <see cref="Overload:System.Threading.Semaphore.Release" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un subproceso ha entrado en el semáforo varias veces, esta sobrecarga del método permite el recuento del semáforo todo restaurarse con una llamada.  
  
 Si un <xref:System.Threading.SemaphoreFullException> produce el <xref:System.Threading.Semaphore.Release%2A> método, no indica necesariamente un problema con el subproceso de llamada. Ese subproceso salga del semáforo más veces que se escribió haya provocado un error de programación en otro subproceso.  
  
 Si el actual <xref:System.Threading.Semaphore> objeto representa un semáforo de sistema con nombre, el usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se crea un semáforo con un número máximo de tres y un recuento inicial de cero. En el ejemplo se inicia cinco subprocesos, que bloquear la espera para el semáforo. El subproceso principal utiliza el <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga del método para aumentar el recuento del semáforo a su máximo, lo que permite tres subprocesos en el semáforo. Cada subproceso utiliza el <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para esperar un segundo, para simular el trabajo y, a continuación, las llamadas a la <xref:System.Threading.Semaphore.Release> sobrecarga del método para liberar el semáforo.  
  
 Cada vez que se libere el semáforo, se muestra el recuento del semáforo anterior. Uso de semáforo pista de la consola mensajes. El intervalo de trabajo simulado aumenta ligeramente para que cada subproceso, para facilitar la lectura de la salida.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="releaseCount" /> es menor que 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">El recuento del semáforo ya está en el valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32 con un semáforo con nombre.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo actual representa un semáforo de sistema con nombre, pero el usuario no tiene derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
O bien 
El semáforo actual representa un semáforo de sistema con nombre, pero no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::SemaphoreSecurity ^ semaphoreSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.SemaphoreSecurity -&gt; unit" Usage="semaphore.SetAccessControl semaphoreSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Objeto <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> que representa la seguridad de control de acceso que se aplicará al semáforo de sistema con nombre.</param>
        <summary>Establece la seguridad de control de acceso para un semáforo de sistema con nombre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sólo puede establecer la seguridad de control de acceso en <xref:System.Threading.Semaphore> objetos que representan los semáforos con nombre del sistema.  
  
 El usuario debe tener <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y el semáforo deben haberse abiertos con <xref:System.Security.AccessControl.SemaphoreRights.ChangePermissions?displayProperty=nameWithType> derechos.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra el comportamiento entre procesos de un semáforo con nombre con seguridad de control de acceso. El ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de un semáforo con nombre.  
  
 Si el semáforo no existe, se crea con un recuento máximo de dos y con seguridad de control de acceso que impide que el usuario actual el derecho a usar el semáforo pero concede el derecho para leer y cambiar permisos en el semáforo.  
  
 Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método para abrir el semáforo con los derechos necesarios para leer y cambiar los permisos.  
  
 Después de cambian los permisos, mediante el <xref:System.Threading.Semaphore.SetAccessControl%2A> método, el semáforo se abre con los derechos necesarios para escribir y versión. Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="semaphoreSecurity" /> es <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El usuario no tiene los derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.  
  
O bien 
El semáforo no se abrió con derechos <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">El objeto <see cref="T:System.Threading.Semaphore" /> actual no representa un semáforo de sistema con nombre.</exception>
        <related type="Article" href="~/docs/standard/threading/index.md">Subprocesamiento administrado</related>
        <related type="Article" href="~/docs/standard/threading/semaphore-and-semaphoreslim.md">Semaphore</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre un semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre el semáforo con nombre especificado, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns><see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el semáforo con nombre no existe, este método no la crea. Para crear el semáforo del sistema cuando no existe, use uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si el semáforo no existe.  
  
 Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga del método y especificando <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit. Especificar el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso en el semáforo y especificando el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As SemaphoreRights, ByRef result As Semaphore) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::SemaphoreRights rights, [Runtime::InteropServices::Out] System::Threading::Semaphore ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.SemaphoreRights *  -&gt; bool" Usage="System.Threading.Semaphore.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del semáforo del sistema que se va a abrir.</param>
        <param name="rights">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</param>
        <param name="result">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Semaphore" /> que representa el semáforo con nombre si la llamada se realizó correctamente o <see langword="null" /> si se produjo un error en la misma. Este parámetro se trata como sin inicializar.</param>
        <summary>Abre el semáforo con nombre especificado, si ya existe, con el acceso de seguridad deseado, y devuelve un valor que indica si la operación se realizó correctamente.</summary>
        <returns><see langword="true" /> si el semáforo con nombre se abrió correctamente; si no, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si el semáforo con nombre no existe, este método no la crea. Para crear el semáforo del sistema cuando no existe, use uno de los <xref:System.Threading.Semaphore.%23ctor%2A> constructores que tiene un `name` parámetro.  
  
 Si no está seguro de si existe un semáforo con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga del método que produce una excepción si el semáforo no existe.  
  
 El `rights` debe incluir el parámetro el <xref:System.Security.AccessControl.SemaphoreRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos en el semáforo y el <xref:System.Security.AccessControl.SemaphoreRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Semaphore.Release%2A> método.  
  
 Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Semaphore> objeto, aunque los objetos que se devuelven representan el mismo semáforo con nombre del sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> es una cadena vacía.  
  
O bien 
 <paramref name="name" /> tiene más de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Error de Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">El semáforo con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarlo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>